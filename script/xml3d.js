(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.1
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
// END HEADER

exports.glMatrix = require("./gl-matrix/common.js");
exports.mat2 = require("./gl-matrix/mat2.js");
exports.mat2d = require("./gl-matrix/mat2d.js");
exports.mat3 = require("./gl-matrix/mat3.js");
exports.mat4 = require("./gl-matrix/mat4.js");
exports.quat = require("./gl-matrix/quat.js");
exports.vec2 = require("./gl-matrix/vec2.js");
exports.vec3 = require("./gl-matrix/vec3.js");
exports.vec4 = require("./gl-matrix/vec4.js");
},{"./gl-matrix/common.js":2,"./gl-matrix/mat2.js":3,"./gl-matrix/mat2d.js":4,"./gl-matrix/mat3.js":5,"./gl-matrix/mat4.js":6,"./gl-matrix/quat.js":7,"./gl-matrix/vec2.js":8,"./gl-matrix/vec3.js":9,"./gl-matrix/vec4.js":10}],2:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

/**
 * @class Common utilities
 * @name glMatrix
 */
var glMatrix = {};

// Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    GLMAT_ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

module.exports = glMatrix;

},{}],3:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x2 Matrix
 * @name mat2
 */
var mat2 = {};

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
mat2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
mat2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
mat2.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a1 = a[1];
        out[1] = a[2];
        out[2] = a1;
    } else {
        out[0] = a[0];
        out[1] = a[2];
        out[2] = a[1];
        out[3] = a[3];
    }
    
    return out;
};

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

        // Calculate the determinant
        det = a0 * a3 - a2 * a1;

    if (!det) {
        return null;
    }
    det = 1.0 / det;
    
    out[0] =  a3 * det;
    out[1] = -a1 * det;
    out[2] = -a2 * det;
    out[3] =  a0 * det;

    return out;
};

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
mat2.adjoint = function(out, a) {
    // Caching this value is nessecary if out == a
    var a0 = a[0];
    out[0] =  a[3];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] =  a0;

    return out;
};

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
mat2.determinant = function (a) {
    return a[0] * a[3] - a[2] * a[1];
};

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
mat2.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    return out;
};

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
mat2.mul = mat2.multiply;

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    return out;
};

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
mat2.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
mat2.fromRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
mat2.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2.str = function (a) {
    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))
};

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix 
 * @param {mat2} D the diagonal matrix 
 * @param {mat2} U the upper triangular matrix 
 * @param {mat2} a the input matrix to factorize
 */

mat2.LDU = function (L, D, U, a) { 
    L[2] = a[2]/a[0]; 
    U[0] = a[0]; 
    U[1] = a[1]; 
    U[3] = a[3] - L[2] * U[1]; 
    return [L, D, U];       
}; 


module.exports = mat2;

},{"./common.js":2}],4:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2x3 Matrix
 * @name mat2d
 * 
 * @description 
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */
var mat2d = {};

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.create = function() {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
mat2d.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(6);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    return out;
};

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
mat2d.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = 0;
    out[5] = 0;
    return out;
};

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
mat2d.invert = function(out, a) {
    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
        atx = a[4], aty = a[5];

    var det = aa * ad - ab * ac;
    if(!det){
        return null;
    }
    det = 1.0 / det;

    out[0] = ad * det;
    out[1] = -ab * det;
    out[2] = -ac * det;
    out[3] = aa * det;
    out[4] = (ac * aty - ad * atx) * det;
    out[5] = (ab * atx - aa * aty) * det;
    return out;
};

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
mat2d.determinant = function (a) {
    return a[0] * a[3] - a[1] * a[2];
};

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
mat2d.multiply = function (out, a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];
    out[0] = a0 * b0 + a2 * b1;
    out[1] = a1 * b0 + a3 * b1;
    out[2] = a0 * b2 + a2 * b3;
    out[3] = a1 * b2 + a3 * b3;
    out[4] = a0 * b4 + a2 * b5 + a4;
    out[5] = a1 * b4 + a3 * b5 + a5;
    return out;
};

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
mat2d.mul = mat2d.multiply;

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.rotate = function (out, a, rad) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        s = Math.sin(rad),
        c = Math.cos(rad);
    out[0] = a0 *  c + a2 * s;
    out[1] = a1 *  c + a3 * s;
    out[2] = a0 * -s + a2 * c;
    out[3] = a1 * -s + a3 * c;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
mat2d.scale = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0 * v0;
    out[1] = a1 * v0;
    out[2] = a2 * v1;
    out[3] = a3 * v1;
    out[4] = a4;
    out[5] = a5;
    return out;
};

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
mat2d.translate = function(out, a, v) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],
        v0 = v[0], v1 = v[1];
    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;
    out[4] = a0 * v0 + a2 * v1 + a4;
    out[5] = a1 * v0 + a3 * v1 + a5;
    return out;
};

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
mat2d.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = -s;
    out[3] = c;
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
mat2d.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = v[1];
    out[4] = 0;
    out[5] = 0;
    return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
mat2d.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    out[4] = v[0];
    out[5] = v[1];
    return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat2d.str = function (a) {
    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
};

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat2d.frob = function (a) { 
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))
}; 

module.exports = mat2d;

},{"./common.js":2}],5:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3x3 Matrix
 * @name mat3
 */
var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }
    
    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + 
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + 
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};


module.exports = mat3;

},{"./common.js":2}],6:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;
    
    if (Math.abs(len) < glMatrix.EPSILON) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    
    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);
    
    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,
      
      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];
      
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;
        
  return out;
};

mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};


module.exports = mat4;

},{"./common.js":2}],7:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");
var mat3 = require("./mat3.js");
var vec3 = require("./vec3.js");
var vec4 = require("./vec4.js");

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = quat;

},{"./common.js":2,"./mat3.js":5,"./vec3.js":9,"./vec4.js":10}],8:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 2 Dimensional Vector
 * @name vec2
 */
var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

module.exports = vec2;

},{"./common.js":2}],9:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0){
        return 0;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

module.exports = vec3;

},{"./common.js":2}],10:[function(require,module,exports){
/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */

var glMatrix = require("./common.js");

/**
 * @class 4 Dimensional Vector
 * @name vec4
 */
var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} vec vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

module.exports = vec4;

},{"./common.js":2}],11:[function(require,module,exports){
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

// when used in node, this will actually load the util module we depend on
// versus loading the builtin util module as happens otherwise
// this is a bug in node module loading as far as I am concerned
var util = require('util/');

var pSlice = Array.prototype.slice;
var hasOwn = Object.prototype.hasOwnProperty;

// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  }
  else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = stackStartFunction.name;
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function replacer(key, value) {
  if (util.isUndefined(value)) {
    return '' + value;
  }
  if (util.isNumber(value) && !isFinite(value)) {
    return value.toString();
  }
  if (util.isFunction(value) || util.isRegExp(value)) {
    return value.toString();
  }
  return value;
}

function truncate(s, n) {
  if (util.isString(s)) {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function getMessage(self) {
  return truncate(JSON.stringify(self.actual, replacer), 128) + ' ' +
         self.operator + ' ' +
         truncate(JSON.stringify(self.expected, replacer), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

function _deepEqual(actual, expected) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (util.isBuffer(actual) && util.isBuffer(expected)) {
    if (actual.length != expected.length) return false;

    for (var i = 0; i < actual.length; i++) {
      if (actual[i] !== expected[i]) return false;
    }

    return true;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!util.isObject(actual) && !util.isObject(expected)) {
    return actual == expected;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b) {
  if (util.isNullOrUndefined(a) || util.isNullOrUndefined(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b)) {
    return a === b;
  }
  var aIsArgs = isArguments(a),
      bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b);
  }
  var ka = objectKeys(a),
      kb = objectKeys(b),
      key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key])) return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  } else if (actual instanceof expected) {
    return true;
  } else if (expected.call({}, actual) === true) {
    return true;
  }

  return false;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (util.isString(expected)) {
    message = expected;
    expected = null;
  }

  try {
    block();
  } catch (e) {
    actual = e;
  }

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  if (!shouldThrow && expectedException(actual, expected)) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws.apply(this, [true].concat(pSlice.call(arguments)));
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/message) {
  _throws.apply(this, [false].concat(pSlice.call(arguments)));
};

assert.ifError = function(err) { if (err) {throw err;}};

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

},{"util/":16}],12:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],13:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],14:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],15:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],16:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./support/isBuffer":15,"_process":14,"inherits":13}],17:[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseAssign = require('lodash._baseassign'),
    createAssigner = require('lodash._createassigner'),
    keys = require('lodash.keys');

/**
 * A specialized version of `_.assign` for customizing assigned values without
 * support for argument juggling, multiple sources, and `this` binding `customizer`
 * functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 */
function assignWith(object, source, customizer) {
  var index = -1,
      props = keys(source),
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? (result !== value) : (value === value)) ||
        (value === undefined && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object. Subsequent sources overwrite property assignments of previous sources.
 * If `customizer` is provided it is invoked to produce the assigned values.
 * The `customizer` is bound to `thisArg` and invoked with five arguments:
 * (objectValue, sourceValue, key, object, source).
 *
 * **Note:** This method mutates `object` and is based on
 * [`Object.assign`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign).
 *
 * @static
 * @memberOf _
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
 * // => { 'user': 'fred', 'age': 40 }
 *
 * // using a customizer callback
 * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return _.isUndefined(value) ? other : value;
 * });
 *
 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var assign = createAssigner(function(object, source, customizer) {
  return customizer
    ? assignWith(object, source, customizer)
    : baseAssign(object, source);
});

module.exports = assign;

},{"lodash._baseassign":18,"lodash._createassigner":20,"lodash.keys":24}],18:[function(require,module,exports){
/**
 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseCopy = require('lodash._basecopy'),
    keys = require('lodash.keys');

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return source == null
    ? object
    : baseCopy(source, keys(source), object);
}

module.exports = baseAssign;

},{"lodash._basecopy":19,"lodash.keys":24}],19:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, props, object) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],20:[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var bindCallback = require('lodash._bindcallback'),
    isIterateeCall = require('lodash._isiterateecall'),
    restParam = require('lodash.restparam');

/**
 * Creates a function that assigns properties of source object(s) to a given
 * destination object.
 *
 * **Note:** This function is used to create `_.assign`, `_.defaults`, and `_.merge`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return restParam(function(object, sources) {
    var index = -1,
        length = object == null ? 0 : sources.length,
        customizer = length > 2 ? sources[length - 2] : undefined,
        guard = length > 2 ? sources[2] : undefined,
        thisArg = length > 1 ? sources[length - 1] : undefined;

    if (typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = typeof thisArg == 'function' ? thisArg : undefined;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"lodash._bindcallback":21,"lodash._isiterateecall":22,"lodash.restparam":23}],21:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],22:[function(require,module,exports){
/**
 * lodash 3.0.9 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isIterateeCall;

},{}],23:[function(require,module,exports){
/**
 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],24:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash._getnative":25,"lodash.isarguments":26,"lodash.isarray":27}],25:[function(require,module,exports){
/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;

},{}],26:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) &&
    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
}

module.exports = isArguments;

},{}],27:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;

},{}],28:[function(require,module,exports){
/**
 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseAssign = require('lodash._baseassign'),
    baseCreate = require('lodash._basecreate'),
    isIterateeCall = require('lodash._isiterateecall');

/**
 * Creates an object that inherits from the given `prototype` object. If a
 * `properties` object is provided its own enumerable properties are assigned
 * to the created object.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0;
 *   this.y = 0;
 * }
 *
 * function Circle() {
 *   Shape.call(this);
 * }
 *
 * Circle.prototype = _.create(Shape.prototype, {
 *   'constructor': Circle
 * });
 *
 * var circle = new Circle;
 * circle instanceof Circle;
 * // => true
 *
 * circle instanceof Shape;
 * // => true
 */
function create(prototype, properties, guard) {
  var result = baseCreate(prototype);
  if (guard && isIterateeCall(prototype, properties, guard)) {
    properties = undefined;
  }
  return properties ? baseAssign(result, properties) : result;
}

module.exports = create;

},{"lodash._baseassign":29,"lodash._basecreate":35,"lodash._isiterateecall":36}],29:[function(require,module,exports){
arguments[4][18][0].apply(exports,arguments)
},{"dup":18,"lodash._basecopy":30,"lodash.keys":31}],30:[function(require,module,exports){
arguments[4][19][0].apply(exports,arguments)
},{"dup":19}],31:[function(require,module,exports){
arguments[4][24][0].apply(exports,arguments)
},{"dup":24,"lodash._getnative":32,"lodash.isarguments":33,"lodash.isarray":34}],32:[function(require,module,exports){
arguments[4][25][0].apply(exports,arguments)
},{"dup":25}],33:[function(require,module,exports){
arguments[4][26][0].apply(exports,arguments)
},{"dup":26}],34:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],35:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(prototype) {
    if (isObject(prototype)) {
      object.prototype = prototype;
      var result = new object;
      object.prototype = undefined;
    }
    return result || {};
  };
}());

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseCreate;

},{}],36:[function(require,module,exports){
arguments[4][22][0].apply(exports,arguments)
},{"dup":22}],37:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var assign = require('lodash.assign'),
    restParam = require('lodash.restparam');

/**
 * Used by `_.defaults` to customize its `_.assign` use.
 *
 * @private
 * @param {*} objectValue The destination object property value.
 * @param {*} sourceValue The source object property value.
 * @returns {*} Returns the value to assign to the destination object.
 */
function assignDefaults(objectValue, sourceValue) {
  return objectValue === undefined ? sourceValue : objectValue;
}

/**
 * Creates a `_.defaults` or `_.defaultsDeep` function.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Function} Returns the new defaults function.
 */
function createDefaults(assigner, customizer) {
  return restParam(function(args) {
    var object = args[0];
    if (object == null) {
      return object;
    }
    args.push(customizer);
    return assigner.apply(undefined, args);
  });
}

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object for all destination properties that resolve to `undefined`. Once a
 * property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var defaults = createDefaults(assign, assignDefaults);

module.exports = defaults;

},{"lodash.assign":17,"lodash.restparam":38}],38:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"dup":23}],39:[function(require,module,exports){
module.exports = require( './lib/' );

},{"./lib/":40}],40:[function(require,module,exports){
module.exports = function () {

    var now = require("performance-now");

    function find(arr, predicate) {
            if (arr == null) {
                throw new TypeError('Array.prototype.find called on null or undefined');
            }
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var list = Object(arr);
            var length = list.length >>> 0;
            var value;

            for (var i = 0; i < length; i++) {
                value = list[i];
                if (predicate.call(null, value, i, list)) {
                    return value;
                }
            }
            return undefined;
    };

    var SimpleTextureManager = function (opt) {
        opt = opt || {};
        this._units = [];
        for (var i = 0; i < (opt.units || 8); i++) {
            this._units[i] = {slot: i, use: 0};
        }
    };

    SimpleTextureManager.NOT_FOUND = -1;
    SimpleTextureManager.FULL = -2;

    SimpleTextureManager.prototype = {

        _set: function (slot, newEntry) {
            var oldEntry = this._units[slot];
            if (oldEntry.dispose) {
                oldEntry.dispose(oldEntry, this);
            }
            if (newEntry) {
                this._units[slot] = newEntry;
                this._units[slot].slot = slot;
            } else {
                this._units[slot] = {slot: slot, use: 0};
            }
        },

        bind: function (id, opt) {
            opt = opt || {};
            var fixed = !!opt.fixed;
            var dispose = typeof opt.dispose == "function" ? opt.dispose : null;

            // Check if texture is already bound
            var result = this.get(id);
            if (result !== SimpleTextureManager.NOT_FOUND) {
                return result;
            }

            var candidates = this._units.filter(function (unit) {
                return !unit.fixed;
            });
            //console.log("Candidates,", candidates, candidates.length);

            if (!candidates.length) {
                return SimpleTextureManager.FULL;
            }

            var selected = candidates.reduce(function (prev, curr) {
                return prev ? (curr.use < prev.use ? curr : prev) : curr;
            }, null);
            //console.log("Selected entry", selected);

            var slot = selected.slot;
            this._set(slot, {
                fixed: fixed, use: now(), id: id, dispose: dispose
            });
            return slot;

        },

        dispose: function (id) {
            var entry = this.getEntry(id);
            this._set(entry.slot, null);
        },
        /**
         * Returns if the texture of the given id is bound to an unit
         * @param id
         * @returns {boolean}
         */
        has: function (id) {
            return !!this.getEntry(id);
        },
        /**
         * Returns the current texture unit for the id or SimpleTextureManager.NOT_FOUND
         * if the texture is currently not bound
         * @param id
         * @returns {*}
         */
        get: function (id) {
            var result = this.getEntry(id);
            if(result) {
                result.use = now();
                return result.slot;
            }
            return SimpleTextureManager.NOT_FOUND;
        },

        use: function (id) {
            var result = this.getEntry(id);
            if(result) {
                result.use = now();
            }
        },

        getEntry: function (id) {
            return find(this._units, function (entry) {
                return entry.id === id;
            });
        }

    };


    return {
        SimpleTextureManager: SimpleTextureManager
    };
}();

},{"performance-now":41}],41:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.7.1
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

}).call(this,require('_process'))

},{"_process":14}],42:[function(require,module,exports){
var Set = require("../xflow/utils/utils.js").set;
var DataNode = require("../xflow/interface/graph.js").DataNode;

function AssetError(message, node){
    this.message = message;
    this.node = node;
}

var Asset = function(refNode){
    this.name = null;
    this.srcAsset = null;
    this.children = [];
    this.subAssets = [];
    this.pickFilter = null;
    this.parents = [];
    this.listener = [];
    this.loading = false;
    this.refNode = refNode || null;
    this.material = null;
    this.transform = null;

    this.assetResult = null;
    this.loadLevel = 0;
    this.progressLevel = Infinity;
};

Asset.prototype.checkValidity = function(){
    if(this.isSubtreeLoading())
        return;
    checkRecursive(this);
};
function checkRecursive(asset){
    if(asset.srcAsset){
        checkRecursive(asset.srcAsset);
    }
    var localNames = [];
    for(var i = 0; i < asset.children.length; ++i){
        var child = asset.children[i], name = child.name;
        if(name && localNames.indexOf(name) != -1){
            throw new AssetError("Two subdata elements with the same name: '" + name + "'", child.refNode);
        }
        if(name) localNames.push(name);
    }
    for(var i = 0; i < asset.subAssets.length; ++i){
        checkRecursive(asset.subAssets[i]);
    }
}


Asset.prototype.setLoading = function(loading){
    if(loading != this.loading){
        this.loading = loading;
        updateLoadingState(this);
        invalidateAsset(this);

    }
};

Asset.prototype.isSubtreeLoading = function(){
    return this.progressLevel == 0;
};
Asset.prototype.getProgressLevel = function(){
    return this.progressLevel;
};

Asset.prototype.setName = function(name){
    this.name = name;
    invalidateAsset(this);
};

Asset.prototype.setMaterial = function(material){
    this.material = material;
    invalidateAsset(this);
};

Asset.prototype.setTransform = function(transform){
    this.transform = transform;
    if (this.refNode.localName.toLowerCase() !== "model") {
        invalidateAsset(this);
    }
};

Asset.prototype.appendChild = function(child){
    this.children.push(child);
    child.assetParent = this;
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.setPickFilter = function(pickFilterString){
    if(typeof pickFilterString == "string"){
        this.pickFilter = new AssetPickFilter();
        this.pickFilter.parse(pickFilterString);
    }
    else
        this.pickFilter = null;
    invalidateAsset(this);
};

Asset.prototype.appendSubAsset = function(subAsset){
    subAsset._addParent(this);
    this.subAssets.push(subAsset);
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.setSrcAsset = function(asset){
    if(this.srcAsset)
        this.srcAsset._removeParent(this);

    this.srcAsset = asset;

    if(this.srcAsset)
        this.srcAsset._addParent(this);
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype.clearChildren = function(){
    var i = this.children.length;
    while(i--) this.children[i].assetParent = null;
    this.children = [];
    updateLoadingState(this);
    invalidateAsset(this);

};
Asset.prototype.clearSubAssets = function(){
    var i = this.subAssets.length;
    while(i--) {
        this.subAssets[i]._removeParent(this);
    }
    this.subAssets.length = 0;
    updateLoadingState(this);
    invalidateAsset(this);

};

Asset.prototype._addParent = function(asset){
    this.parents.push(asset);
};
Asset.prototype._removeParent = function(asset){
    var idx = this.parents.indexOf(asset);
    if(idx != -1)
        this.parents.splice(idx, 1);
};

Asset.prototype._callLoadListeners = function(newLevel, oldLevel){
    var listeners = this.listener;
    for(var i = 0; i < listeners.length; ++i){
        listeners[i].onAssetLoadChange && listeners[i].onAssetLoadChange(this, newLevel, oldLevel);
    }
};


Asset.prototype.addChangeListener = function(listener){
    Set.add(this.listener, listener);
};
Asset.prototype.removeChangeListener = function(listener){
    Set.remove(this.listener, listener);
};

Asset.prototype.getResult = function(){
    if(!this.assetResult){
        this.assetResult = new AssetResult();
        this.assetResult.construct(this);
    }
    return this.assetResult;
};

function invalidateAsset(asset){
    if(asset.assetResult){
        asset.assetResult = null;
    }
    var listeners = asset.listener;
    for(var i = 0; i < listeners.length; ++i){
        listeners[i].onAssetChange && listeners[i].onAssetChange(this);
    }
    var i = asset.parents.length;
    while(i--){
        invalidateAsset(asset.parents[i]);
    }
}


function updateLoadingState(asset){
    var progressLevel = asset.loading ? asset.loadLevel : Infinity;
    if(progressLevel && asset.srcAsset){
        progressLevel = Math.min(progressLevel, Math.max(asset.srcAsset.loadLevel, asset.srcAsset.progressLevel));
    }
    var i = asset.subAssets.length;
    while(progressLevel && i--){
        progressLevel = Math.min(progressLevel, Math.max(asset.subAssets[i].loadLevel, asset.subAssets[i].progressLevel));
    }
    var i = asset.children.length;
    while(progressLevel && i--){
        progressLevel = Math.min(progressLevel, asset.children[i].progressLevel);
    }
    var oldLevel = asset.progressLevel;
    asset.progressLevel = progressLevel;

    if(oldLevel != asset.progressLevel){
        asset._callLoadListeners(asset.progressLevel, oldLevel);
        for(var i = 0; i < asset.parents.length; ++i)
            updateLoadingState(asset.parents[i]);
    }
}


//----------------------------------------------------------------------------------------------------------------------
// SubData
//----------------------------------------------------------------------------------------------------------------------

var SubData = function(xflowNodeOut, xflowNodeIn, refNode){
    this.xflowNodeOut = xflowNodeOut;
    this.xflowNodeIn = xflowNodeIn;
    this.refNode = refNode || null;
    this.name = null;
    this.matchFilter = null;
    this.classNames = [];
    this.postDataflow = null;
    this.postCompute = null;
    this.postFilter = null;
    this.includes = [];
    this.material = null;
    this.transform = null;
    this.meshType = null;
    this.assetParent = null;
    this.loading = false;
    this.loadLevel = 0;
    this.progressLevel = Infinity;
    xflowNodeIn.addLoadListener(this.onXflowLoadEvent.bind(this));
    this._updateLoadingState();
};

SubData.prototype.setLoading = function(loading){
    if(loading != this.loading){
        this.loading = loading;
        this._updateLoadingState();
        invalidateParent(this);

    }
};

SubData.prototype._updateLoadingState = function(){
    var progressLevel = this.loading ? this.loadLevel : Infinity;
    progressLevel = Math.min(progressLevel, this.xflowNodeIn.getProgressLevel());
    var oldLevel = this.progressLevel;
    this.progressLevel = progressLevel;

    if(oldLevel != this.progressLevel){
        this.assetParent && updateLoadingState(this.assetParent);
        invalidateParent(this);
    }
};
SubData.prototype.onXflowLoadEvent = function(){
    this._updateLoadingState();
};

SubData.prototype.isSubtreeLoading = function(){
    return this.loading;
};

SubData.prototype.isMesh = function(){
    return !!this.meshType;
};

SubData.prototype.setName = function(name){
    this.name = name;
    invalidateParent(this);
};

SubData.prototype.setMatchFilter = function(matchString){
    if(typeof matchString == "string"){
        this.matchFilter = new AssetPickFilter();
        this.matchFilter.parse(matchString);
    }
    else
        this.matchFilter = null;
    invalidateParent(this);
};

SubData.prototype.setClassNames = function(classNames){
    this.classNames = classNames;
    invalidateParent(this);
};
SubData.prototype.setClassNamesString = function(classNamesString){
    if(!classNamesString)
        this.setClassNames([]);
    else{
        var array = classNamesString.split(/\s+/);
        var i = array.length;
        while(i--) array[i] = array[i].trim();
        this.setClassNames(array);
    }
};


SubData.prototype.setPostDataflow = function(postDataflow){
    this.postDataflow = postDataflow;
    invalidateParent(this);
};

SubData.prototype.setPostCompute = function(postCompute){
    this.postCompute = postCompute;
    invalidateParent(this);
};

SubData.prototype.setPostFilter = function(postFilter){
    this.postFilter = postFilter;
    invalidateParent(this);
};

SubData.prototype.setIncludes = function(includes){
    this.includes = includes;
    invalidateParent(this);
};

SubData.prototype.setMaterial = function(material){
    this.material = material;
    invalidateParent(this);
};

SubData.prototype.setTransform = function(transform){
    this.transform = transform;
    invalidateParent(this);
};

SubData.prototype.setMeshType = function(meshType){
    this.meshType = meshType;
    invalidateParent(this);
};

function invalidateParent(subData){
    if(subData.assetParent){
        invalidateAsset(subData.assetParent);
    }
}

//----------------------------------------------------------------------------------------------------------------------
// AssetResult
//----------------------------------------------------------------------------------------------------------------------

var AssetResult = function(){
    this.parentResult = null;
    this.name = null;
    this.namedEntries = {};
    this.allEntries = [];
    this.matchEntries = [];
    this.namedSubResults = {};
    this.allSubResults = [];

    this.material = null;
    this.transform = null;
    this.pickFilter = null;
};

AssetResult.prototype.construct = function(asset){
    constructAssetTable(this, asset);
};

AssetResult.prototype.getDataTree = function(){
    return rec_getDataTree(this);
};


function constructAssetTable(table, asset){
    table.name = asset.name;

    var srcAsset = asset.srcAsset, srcResult = srcAsset && srcAsset.getResult();
    if(srcResult){
        copySrcTable(table, srcAsset.getResult(), asset.pickFilter);
    }
    else
        table.pickFilter = asset.pickFilter;

    if(asset.material) table.material = asset.material;
    if(asset.transform) table.transform = combineTransform(table.transform, asset.transform);


    var subAssets = asset.subAssets;
    var i = subAssets.length;
    while(i--){
        var result = subAssets[i].getResult();
        mergeSubAssetResult(table, result);
    }
    var matchChildren = [];
    var children = asset.children;
    for(var i = 0; i < children.length; ++i){
        var child = children[i];
        var name = child.name;
        var entry;
        if(child.name && child.matchFilter){
            XML3D.debug.logWarning("Asset entry defines both name and match attribute. Match attribute will be ignored", child.refNode);
        }
        if(name){
            if(!table.namedEntries[name]){
                entry = new AssetTableEntry(child);
                applyMatchEntries(entry, table.matchEntries);
                table.namedEntries[name] = entry;
                table.allEntries.push(entry);
            }
            else
                entry = table.namedEntries[name];
        }
        else if(child.matchFilter){
            matchChildren.push(child);
            continue;
        }
        else{
            entry = new AssetTableEntry(child);
            applyMatchEntries(entry, table.matchEntries);
            table.allEntries.push(entry);
        }
        entry.pushPostEntry(child);
    }
    for(var i = 0; i < matchChildren.length; ++i){
        var child = matchChildren[i];
        var matchEntry = {filter: child.matchFilter, subdata: child};
        table.matchEntries.push(matchEntry);
        for(var j = 0; j < table.allEntries.length; ++j){
            applyMatchEntry(table.allEntries[j], matchEntry);
        }
    }
}

function applyMatchEntries(destEntry, matchEntries){
    for(var i = 0; i < matchEntries.length; ++i){
        applyMatchEntry(destEntry, matchEntries[i]);
    }
}

function applyMatchEntry(destEntry, matchEntry){
    var child = matchEntry.subdata;
    if(child.isMesh() == destEntry.isMesh() && matchEntry.filter.check(destEntry)){
        destEntry.pushPostEntry(child);
    }
}


function copySrcTable(table, srcTable, pickFilter){

    if(srcTable.matchEntries.length > 0){
        var i = table.allEntries.length;
        while(i--){
            var entry = table.allEntries[i];
            if(!entry.name || !srcTable.namedEntries[entry.name]){
                applyMatchEntries(entry, srcTable.matchEntries);
            }
        }
    }

    var i = srcTable.allEntries.length;
    while(i--){
        var srcEntry = srcTable.allEntries[i];
        var destEntry, newlyCreated = false;
        if(srcEntry.name && table.namedEntries[srcEntry.name]){
            destEntry = table.namedEntries[srcEntry.name];
        }
        else{
            destEntry = new AssetTableEntry();
            newlyCreated = true;
            table.allEntries.push(destEntry);
        }
        destEntry.pushTableEntry(srcEntry);
        if(newlyCreated)
            applyMatchEntries(destEntry, table.matchEntries);

        if(destEntry.name) table.namedEntries[destEntry.name] = destEntry;
    }

    table.matchEntries.push.apply(table.matchEntries, srcTable.matchEntries);


    var i = srcTable.allSubResults.length;
    while(i--){
        mergeSubAssetResult(table, srcTable.allSubResults[i]);
    }

    if(pickFilter && srcTable.pickFilter){
        table.pickFilter = new AssetPickFilter();
        table.pickFilter.intersection(pickFilter, srcTable.pickFilter);
    }
    else{
        table.pickFilter = pickFilter || srcTable.pickFilter;
    }
    if(srcTable.material) table.material = srcTable.material;
    if(srcTable.transform) table.transform = combineTransform(table.transform, srcTable.transform);
}


function mergeSubAssetResult(table, srcSubTable){
    var destSubTable;
    if(srcSubTable.name && table.namedSubResults[srcSubTable.name]){
        destSubTable = table.namedSubResults[srcSubTable.name];
    }
    else{
        destSubTable = new AssetResult();
        destSubTable.parentResult = table;
        destSubTable.name = srcSubTable.name;
        table.allSubResults.push(destSubTable);
        if(destSubTable.name) table.namedSubResults[destSubTable.name] = destSubTable;
    }
    copySrcTable(destSubTable, srcSubTable, destSubTable.pickFilter);
}

function rec_getDataTree(table){
    var node = {
        meshes: [],
        groups: [],
        transform: table.transform,
        material: table.material,
        postTransformXflowNode: null
    };

    for(var i = 0; i < table.allEntries.length; ++i){
        var entry = table.allEntries[i];
        if(entry.meshType && (!table.pickFilter || table.pickFilter.check(entry)) ){
            updateAccumulatedNode(table, entry);
            node.meshes.push({
                xflowNode: entry.accumulatedXflowNode,
                type: entry.meshType,
                material: entry.material,
                transform: entry.transform,
                refNode: entry.refNode
            });
        }
    }
    var postTransformEntry = table.namedEntries["_postTransform"];
    if(postTransformEntry){
        updateAccumulatedNode(table, postTransformEntry);
        node.postTransformXflowNode = postTransformEntry.accumulatedXflowNode;
    }
    for(var i = 0; i < table.allSubResults.length; ++i){
        var subNode = rec_getDataTree(table.allSubResults[i]);
        node.groups.push(subNode);
    }
    return node;
}

function updateAccumulatedNode(table, entry){
    if(!entry.outOfSync)
        return;

    if(entry.accumulatedXflowNode){
        entry.accumulatedXflowNode.clearChildren();
        entry.accumulatedXflowNode.setCompute("");
        entry.accumulatedXflowNode.setFilter("");
        entry.accumulatedXflowNode.dataflowNode = null;
        entry.accumulatedXflowNode.setLoading(false);
    }
    else{
        entry.accumulatedXflowNode = new DataNode(false);
    }

    var dataNode = entry.postQueue.length == 1 ? entry.accumulatedXflowNode : new DataNode(false);
    for(var i = 0; i < entry.postQueue.length; ++i){
        var includes = entry.postQueue[i].includes;
        for(var j = 0; j < includes.length; ++j){
            var addEntry = getIncludeEntry(table, includes[j]);
            dataNode.appendChild(addEntry.accumulatedXflowNode);
        }
        if(entry.postQueue[i].xflowNode)
            dataNode.appendChild(entry.postQueue[i].xflowNode);
    }
    var node = dataNode, parentNode = null;
    for(var i = 0; i < entry.postQueue.length; ++i){
        var postEntry = entry.postQueue[i];
        if(!node) node = (i == entry.postQueue.length - 1 ? entry.accumulatedXflowNode : new DataNode(false));
        node.setCompute(postEntry.compute);
        node.setFilter(postEntry.filter);
        node.dataflowNode = postEntry.dataflow;
        node.setLoading(postEntry.dataflowLoading);
        if(parentNode) node.appendChild(parentNode);
        parentNode = node;
        node = null;
    }
    entry.outOfSync = false;
}


var c_accum_entries = [],
    c_accum_names = [];

function getIncludeEntry(table, includeString){
    var segments = includeString.split(".");
    for(var i = 0; i < segments.length -1; ++i){
        var seg = segments[i];
        if(seg == "parent"){
            if(!table.parentResult)
                throw new Error("Includes entry '" + includeString + "' (token "+ i +") accesses non existent parent.");
            table = table.parentResult;
        }
        else{
            if(!table.namedSubResults[seg])
                throw new Error("Includes entry '" + includeString + "' (token "+ i +") accesses non existent sub result '" + seg + "'");
            table = table.namedSubResults[seg];
        }
    }
    var entryKey = segments[segments.length - 1];
    var entry = table.namedEntries[entryKey];
    if(!entry){
        throw new Error("Includes entry '" + includeString + "' accesses non existent asset entry '" + entryKey + "'" );
    }

    c_accum_names.push(includeString);
    if(c_accum_entries.indexOf(entry) != -1){
        var path = c_accum_names.join(" > ");
        throw new Error("Recursive include dependencies detected: " + path);
    }
    c_accum_entries.push(entry);

    updateAccumulatedNode(table, entry);
    c_accum_entries.pop();
    c_accum_names.pop();
    return entry;
}




function AssetTableEntry (subData){
    this.name = null;
    this.classNames = [];
    this.meshType = null;

    this.postQueue = [];
    this.material = null;
    this.transform = null;

    this.accumulatedXflowNode = null;
    this.outOfSync = true;
    this.refNode = null;
    if(subData){
        this.name = subData.name;
        Set.add(this.classNames, subData.classNames);
    }
}

AssetTableEntry.prototype.isMesh = function(){
    return !!this.meshType;
};

AssetTableEntry.prototype.pushTableEntry = function(srcEntry){
    this.name = srcEntry.name;
    Set.add(this.classNames, srcEntry.classNames);
    if(srcEntry.meshType) this.meshType = srcEntry.meshType;

    if(srcEntry.transform) this.transform = combineTransform(this.transform, srcEntry.transform);
    if(srcEntry.material) this.material = srcEntry.material;

    this.postQueue.push.apply(this.postQueue, srcEntry.postQueue);
};


AssetTableEntry.prototype.pushPostEntry = function(subData){
    this.name = subData.name;
    this.postQueue.push({
        dataflow: subData.postDataflow,
        dataflowLoading: subData.loading,
        compute: subData.postCompute,
        filter: subData.postFilter,
        includes: subData.includes,
        xflowNode: subData.xflowNodeIn
    });
    this.refNode = subData.refNode;
    this.accumulatedXflowNode = subData.xflowNodeOut;
    Set.add(this.classNames, subData.classNames);
    if(subData.meshType) this.meshType = subData.meshType;
    if(subData.material) this.material = subData.material;
    if(subData.transform) this.transform = combineTransform(this.transform, subData.transform);
};


function combineTransform(oldTransform, newTransform){
    // TODO: Better multiply transformations here
    return newTransform;
}


function AssetPickFilter(){
    this.all = false;
    this.names = [];
    this.classNames = [];
}

AssetPickFilter.prototype.parse = function(string){
    var entries = string.split(",");
    var i = entries.length;
    while(i--){
        var entry = entries[i].trim();
        if(entry == "*"){
            this.all = true;
        }
        else if(entry.indexOf(".") == 0){
            var classNames = entry.split(".");
            var j = classNames.length;
            while(j--){
                if(!classNames[j].trim())
                    classNames.splice(j,1);
            }
            this.classNames.push(classNames);
        }
        else{
            Set.add(this.names, entry);
        }
    }
};

AssetPickFilter.prototype.intersection = function(setA, setB){
    Set.intersection(this.names, setA.names, setB.names);
    Set.intersection(this.classNames, setA.classNames, setB.classNames);
};

AssetPickFilter.prototype.check = function(entry){
    if(this.all)
        return true;
    if(entry.classNames.length > 0){
        var i = this.classNames.length;
        while(i--){
            if(Set.isSubset(this.classNames[i], entry.classNames))
                return true;
        }
    }
    return (entry.name && this.names.indexOf(entry.name) != -1);
};

module.exports = {
    Asset: Asset,
    SubData: SubData,
    AssetResult: AssetResult
};

},{"../xflow/interface/graph.js":181,"../xflow/utils/utils.js":230}],43:[function(require,module,exports){
var registerFactory = require("./resourcemanager.js").registerFactory;
var Resource = require("./resourcemanager.js").Resource;
var Events = require("../interface/notification.js");
var config = require("../interface/elements.js").config;

/**
 * A normal adapter that doesn't need to be connected to a DOM node
 * @constructor
 * @param {XML3D.base.AdapterFactory} factory - the factory this adapter was created from
 */
var Adapter = function(factory) {
    this.factory = factory;
};

/**
 * Connect an adapterHandle to a certain key.
 * This will enable the ConnectedAdapterNotifcations for notifyChanged.
 * @param {string} key - the key that will also be provided in connectAdapterChanged callback
 * @param {XML3D.base.AdapterHandle} adapterHandle handle of adapter to be added
 */
Adapter.prototype.connectAdapterHandle = function(key, adapterHandle) {
    if (!this.connectedAdapterHandles) {
        this.connectedAdapterHandles = {};
        this._bindedAdapterHandleCallback = adapterHandleCallback.bind(this);
    }

    this.disconnectAdapterHandle(key);

    if (adapterHandle) {
        this.connectedAdapterHandles[key] = adapterHandle;
        this.connectedAdapterHandles[key].addListener(this._bindedAdapterHandleCallback);
    }
    else
        delete this.connectedAdapterHandles[key];

};

/**
 * Disconnects the adapter handle from the given key.
 * @param {string} key - the key that was provided when this adapter handle was connected
 */
Adapter.prototype.disconnectAdapterHandle = function(key) {
    if (this.connectedAdapterHandles && this.connectedAdapterHandles[key]) {
        this.connectedAdapterHandles[key].removeListener(this._bindedAdapterHandleCallback);
        delete this.connectedAdapterHandles[key];
    }
};

/**
 * Disconnects all adapter handles.
 */
Adapter.prototype.clearAdapterHandles = function() {
    for (var i in this.connectedAdapterHandles) {
        this.connectedAdapterHandles[i].removeListener(this._bindedAdapterHandleCallback);
    }

    this.connectedAdapterHandles = null;
};

/**
 * Get the connected AdapterHandle of a certain key.
 * This will only return AdapterHandles previously added via connectAdapterHandle
 * @param {string} key
 * @return {?AdapterHandle} the adapter of that key, or null if not available
 */
Adapter.prototype.getConnectedAdapterHandle = function(key) {
    return this.connectedAdapterHandles && this.connectedAdapterHandles[key];
};

/**
 * Get the connected adapter of a certain key.
 * This will only return adapters of AdapterHandles previously added via connectAdapter
 * @param {string} key
 * @return {?XML3D.base.Adapter} the adapter of that key, or null if not available
 */
Adapter.prototype.getConnectedAdapter = function(key) {
    var handle = this.getConnectedAdapterHandle(key);
    return handle && handle.getAdapter();
};

/**
 * This function is called, when the adapater is detached from the node.
 * At this point, the adapater should disconnect from any other adapter and prepare to be properly garbage collected
 */
Adapter.prototype.onDispose = function() {
};


/**
 * Internal function that converts an AdapterHandleNotification to a ConnectedAdapterNotification
 * @private
 * @param {Events.AdapterHandleNotification} evt
 */
function adapterHandleCallback(evt) {
    for (var key in this.connectedAdapterHandles) {
        if (this.connectedAdapterHandles[key] == evt.adapterHandle) {
            var subEvent = new Events.ConnectedAdapterNotification(evt, key);
            this.notifyChanged(subEvent);
        }
    }
}


/**
 * An Adapter connected to a DOMNode (possibly of an external document)
 * @constructor
 * @param {AdapterFactory} factory the AdapterFactory this adapter was created from
 * @param {Object} node - DOM node of this Adapter
 */
var NodeAdapter = function(factory, node) {
    Adapter.call(this, factory);
    this.node = node;
};
XML3D.createClass(NodeAdapter, Adapter);

/**
 * called by the factory after adding the adapter to the node
 */
NodeAdapter.prototype.init = function() {
};

/**
 * Notifiction due to a change in DOM, related adapters and so on.
 * @param {Events.Notification} e
 */
NodeAdapter.prototype.notifyChanged = function(e) {

};

/**
 * @param {string|XML3D.URI} uri Uri to referred adapterHandle
 * @param {Object=} aspectType Optional: the type of adapter (use same adapter type by default)
 * @param {number=} canvasId Optional: the canvas id of the adapter (use canvas id of this adapter by default)
 * @returns an AdapterHandle to the referred Adapter of the same aspect and canvasId
 */
NodeAdapter.prototype.getAdapterHandle = function(uri, aspectType, canvasId) {
    canvasId = canvasId === undefined ? this.factory.canvasId : canvasId;
    return Resource.getAdapterHandle(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL,
        uri, aspectType || this.factory.aspect, canvasId, this.node.nodeName);
};
/**
 * notifies all adapter that refer to this adapter through AdapterHandles.
 * @param {number?} type The type of change
 */
NodeAdapter.prototype.notifyOppositeAdapters = function(type) {
    type = type || Events.ADAPTER_HANDLE_CHANGED;
    return Resource.notifyNodeAdapterChange(this.node,
        this.factory.aspect, this.factory.canvasId, type);
};

/**
 * Depth-first traversal over element hierarchy
 * @param {function(NodeAdapter)} callback
 */
NodeAdapter.prototype.traverse = function(callback) {
    callback(this);
    var child = this.node.firstElementChild;
    while (child) {
        var adapter = this.factory.getAdapter(child);
        adapter && adapter.traverse(callback);
        child = child.nextElementSibling;
    }
};


/**
 * @interface
 */
var IFactory = function() {
};

/** @type {string} */
IFactory.prototype.aspect;


/**
 * An adapter factory is responsible for creating adapter from a certain data source.
 * Note that any AdapterFactory is registered with Resource
 * @constructor
 * @implements {IFactory}
 * @param {Object} aspect The aspect this factory serves (e.g. XML3D.data or XML3D.webgl)
 * @param {string|Array.<string>} mimetypes The mimetype this factory is compatible to
 * @param {number} canvasId The id of the corresponding canvas handler. 0, if not dependent on any GLCanvasHandler
 */
var AdapterFactory = function(aspect, mimetypes, canvasId) {
    this.aspect = aspect;
    this.canvasId = canvasId || 0;
    this.mimetypes = typeof mimetypes == "string" ? [ mimetypes] : mimetypes;

    registerFactory(this);
};

 /** Implemented by subclass
 * Create adapter from an object (node in case of an xml, and object in case of json)
 * @param {object} obj
 * @returns {?Adapter} created adapter or null if no adapter can be created
 */
AdapterFactory.prototype.createAdapter = function(obj) {
    return null;
};

/**
 * Checks if the adapter factory supports specified mimetype. Can be overridden by subclass.
 * @param {String} mimetype
 * @return {Boolean} true if the adapter factory supports specified mimetype
 */
AdapterFactory.prototype.supportsMimetype = function(mimetype) {
    return this.mimetypes.indexOf(mimetype) != -1;
};

/**
 * A NodeAdaperFactory is a AdapterFactory, that works specifically for DOM nodes / elements.
 * @constructor
 * @param {Object} aspect The aspect this factory serves (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId The id of the corresponding canvas handler. 0, if not dependent on any GLCanvasHandler
 */
var NodeAdapterFactory = function(aspect, canvasId) {
    AdapterFactory.call(this, aspect, ["text/xml", "application/xml"], canvasId);
};
XML3D.createClass(NodeAdapterFactory, AdapterFactory);

/**
 * This function first checks, if an adapter has been already created for the corresponding node
 * If yes, this adapter is returned, otherwise, a new adapter is created and returned.
 * @param {Object} node
 * @returns {Adapter} The adapter of the node
 */
NodeAdapterFactory.prototype.getAdapter = function(node) {
    if(node && node._configured === undefined)
        config.element(node);
    if (!node || node._configured === undefined)
        return null;

    var elemHandler = node._configured;
    var key = this.aspect + "_" + this.canvasId;
    var adapter = elemHandler.adapters[key];
    if (adapter !== undefined)
        return adapter;

    // No adapter found, try to create one
    adapter = this.createAdapter(node);
    if (adapter) {
        elemHandler.adapters[key] = adapter;
        adapter.init();
    }
    return adapter;
};

XML3D.resource.AdapterFactory = AdapterFactory;

module.exports = {
NodeAdapter : NodeAdapter,
AdapterFactory : AdapterFactory,
NodeAdapterFactory : NodeAdapterFactory
};

},{"../interface/elements.js":69,"../interface/notification.js":71,"./resourcemanager.js":46}],44:[function(require,module,exports){
var Events = require("../interface/notification.js");

"use strict";
/**
 * An adapter handle is a connection piece for an adapter that is referred through a uri (e.g. id reference)
 * AdapterHandles are always fetched from the Resource object
 * @constructor
 */
var AdapterHandle = function(url) {
    this.url = url;
    this.adapter = null;
    this.listeners = [];
    this.status = 0; // STATUS.LOADING
};

/**
 * Enumaeration of states for the adapter handle
 * @enum {number}
 */
AdapterHandle.STATUS = {
    LOADING: 0,
    NOT_FOUND: 1,
    READY: 2
};

/**
 * @returns {Boolean} true iff an adapter is available
 */
AdapterHandle.prototype.hasAdapter = function() {
    return this.adapter != null;
};

/**
 * @returns {?XML3D.base.Adapter} the adapter connected to the handle. Can be null
 */
AdapterHandle.prototype.getAdapter = function() {
    return this.adapter;
};

/**
 * Note: this function should only be called by Resource
 * @param {XML3D.base.Adapter} adapter The adapter connected to the AdapterHandler
 * @param {AdapterHandle.STATUS} status
 */
AdapterHandle.prototype.setAdapter = function(adapter, status) {
    this.adapter = adapter;
    this.status = status;
    this.notifyListeners(Events.ADAPTER_HANDLE_CHANGED);
};

/**
 * This function is called to notify all listeners of this AdapterHandle about some change.
 * @param {number} type A type number with the type of change (usually Events.ADAPTER_HANDLE_CHANGED)
 */
AdapterHandle.prototype.notifyListeners = function(type) {
    var event = new Events.AdapterHandleNotification(this, type);
    var i = this.listeners.length;
    while (i--) {
        this.listeners[i](event);
    }
};

/**
 * Add a listener to the AdapterHandle that is notified about changes.
 * Listeners cannot be inserted twice.
 * @param {Function} listener - Function to be called when something concering the adapter changes
 */
AdapterHandle.prototype.addListener = function(listener) {
    var idx = this.listeners.indexOf(listener);
    if (idx == -1)
        this.listeners.push(listener);
};

/**
 * Remove a listener from the AdapterHandle
 * @param {Function} listener
 */
AdapterHandle.prototype.removeListener = function(listener) {
    var idx = this.listeners.indexOf(listener);
    if (idx != -1)
        this.listeners.splice(idx, 1);
};

module.exports = AdapterHandle;
},{"../interface/notification.js":71}],45:[function(require,module,exports){
var AdapterFactory = require("./adapter.js").AdapterFactory;
var registerFormat = require("./resourcemanager.js").registerFormat;
var config = require("../interface/elements.js").config;

/**
 * A format handler is provide functionality for detecting format of resources
 * and providing format-specific services.
 * FormatHandlers are registered with XML3D.base.registerFormat() function.
 * @constructor
 */
var FormatHandler = function() {
    this.factoryClasses = {}; // a map from an aspect name to a factory class
    this.factoryCache = {}; // maps unique keys (aspect + "_" + canvasId) to the factory instance
};

FormatHandler.prototype.registerFactoryClass = function (factoryClass) {
    if (!factoryClass.prototype.aspect )
        throw new Error("factoryClass must be a subclass of XML3D.base.AdapterFactory");
    this.factoryClasses[factoryClass.prototype.aspect] = factoryClass;
};

FormatHandler.prototype.getFactoryClassByAspect = function (aspect) {
    return this.factoryClasses[aspect];
};

FormatHandler.prototype.getFactory = function (aspect, canvasId) {
    canvasId = canvasId || 0;
    var key = aspect + "_" + canvasId;
    var factory = this.factoryCache[key];
    if (!factory) {
        var factoryClass = this.getFactoryClassByAspect(aspect);
        if (!factoryClass)
            return null;
        factory = new factoryClass(canvasId);
        this.factoryCache[key] = factory;
    }
    return factory;
};

//noinspection JSUnusedLocalSymbols
/**
 * Returns true if response data format is supported.
 * response, responseType, and mimetype values are returned by XMLHttpRequest.
 * Data type of the response is one of ArrayBuffer, Blob, Document, String, Object.
 * responseType is one of "", "arraybuffer", "blob", "document", "json", "text"
 *
 * @override
 * @param {Object} response
 * @param {string} responseType
 * @param {string} mimetype
 * @return {Boolean}
 */
FormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    return false;
};

/**
 * Converts response data to format data.
 * Default implementation returns value of response.
 *
 * @override
 * @param {Object} response
 * @param {string} responseType
 * @param {string} mimetype
 * @param {function} callback
 * @return {Object}
 */
FormatHandler.prototype.getFormatData = function (response, responseType, mimetype, callback) {
    callback(true, response);
};

/**
 * Extracts data for a fragment from document data and fragment reference.
 *
 * @override
 * @param {Object} documentData
 * @param {string} fragment Fragment without pound key which defines the part of the document
 * @return {*}
 */
FormatHandler.prototype.getFragmentData = function (documentData, fragment) {
    if (!fragment)
        return documentData;
    return null;
};

/**
 * XMLFormatHandler supports all XML and HTML-based documents.
 * @constructor
 * @extends FormatHandler
 */
var XMLFormatHandler = function () {
    FormatHandler.call(this);
};
XML3D.createClass(XMLFormatHandler, FormatHandler);

XMLFormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    return response && response.nodeType === 9 && (mimetype.match(/xml/));
};

XMLFormatHandler.prototype.getFormatData = function (response, responseType, mimetype, callback) {
    callback(true, response);
};

XMLFormatHandler.prototype.getFragmentData = function (documentData, fragment) {
    return documentData.querySelectorAll("*[id='" + fragment + "']")[0];
};


/**
 *
 * @constructor
 * @extends FormatHandler
 */
var XML3DFormatHandler = function () {
    XMLFormatHandler.call(this);
};
XML3D.createClass(XML3DFormatHandler, XMLFormatHandler);

XML3DFormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    var xml3ds = [];
    if (response instanceof XMLDocument) {
        xml3ds = response.getElementsByTagName("xml3d");
        if (!xml3ds.length) {
            // Also check cases where the XML3D element may have been fitted with a NS prefix (eg. ns1:xml3d)
            xml3ds = response.getElementsByTagNameNS(XML3D.xml3dNS, "xml3d");
        }
    }
    return xml3ds.length !== 0;
};

XML3DFormatHandler.prototype.getFormatData = function (response, responseType, mimetype, callback) {
    // Configure all xml3d elements:
    var xml3dElements = response.querySelectorAll("xml3d");
    for (var i = 0; i < xml3dElements.length; ++i) {
        config.element(xml3dElements[i]);
    }
    callback(true, response);
};

/**
 * @constructor
 * @extends FormatHandler
 */
var JSONFormatHandler = function () {
    FormatHandler.call(this);
};
XML3D.createClass(JSONFormatHandler, FormatHandler);

JSONFormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    return mimetype === "application/json";
};

var xml3dFormatHandler = new XML3DFormatHandler();
registerFormat(xml3dFormatHandler);
XML3D.xml3dFormatHandler = xml3dFormatHandler;
XML3D.resource.FormatHandler = FormatHandler;
XML3D.resource.JSONFormatHandler = JSONFormatHandler;

module.exports = {
    JSONFormatHandler: JSONFormatHandler,
    XMLFormatHandler: XMLFormatHandler,
    XML3DFormatHandler: XML3DFormatHandler,
    FormatHandler: FormatHandler,
    xml3dFormatHandler: xml3dFormatHandler
};

},{"../interface/elements.js":69,"./adapter.js":43,"./resourcemanager.js":46}],46:[function(require,module,exports){
"use strict";

var AdapterHandle = require("./adapterhandle.js");
var URIResolver = require("../utils/uri.js").URIResolver;
var URI = require("../utils/uri.js").URI;
var Options = require("../utils/options.js");

var OPTION_RESOURCE_CORS = "resource-crossorigin-attribute";
Options.register(OPTION_RESOURCE_CORS, "anonymous");

var c_cachedDocuments = {};
var c_factories = {};
var c_cachedAdapterHandles = {};
var c_canvasIdCounters = {};
var c_formatHandlers = [];

var c_binaryContentTypes = ["application/octet-stream", "text/plain; charset=x-user-defined"];
var c_binaryExtensions = [".bin", ".bson"];

/**
 * Register a factory with the resource manager
 * @param {AdapterFactory} factory - the factory to be registered
 */
var registerFactory = function(factory) {
    var canvasId = factory.canvasId;
    if (!c_factories[canvasId])
        c_factories[canvasId] = [];
    c_factories[canvasId].push(factory);
};

var registerFormat = function(formatHandler) {
    if (formatHandler)
        c_formatHandlers.push(formatHandler);
};

var findFormat = function(response, responseType, mimetype) {
    for (var i = 0; i < c_formatHandlers.length; ++i) {
        var formatHandler = c_formatHandlers[i];
        if (c_formatHandlers[i].isFormatSupported(response, responseType, mimetype)) {
            return formatHandler;
        }
    }
    return null;
};

/**
 * @constructor
 */
var Resource = {};

function getCounterObject(canvasId) {
    return c_canvasIdCounters[canvasId];
}

function getOrCreateCounterObject(canvasId) {
    var counterObject = c_canvasIdCounters[canvasId];
    if (!counterObject) {
        counterObject = {counter: 0, listeners: []};
        c_canvasIdCounters[canvasId] = counterObject;
    }
    return counterObject;
}

function notifyLoadCompleteListeners(counterObject) {
    var listeners = counterObject.listeners;
    //counterObject.listeners = new Array();
    var i = listeners.length;
    while (i--) {
        listeners[i](this);
    }
}

function loadComplete(canvasId) {
    // notify all load complete listeners
    var counterObject = getCounterObject(canvasId);
    if (counterObject) {
        XML3D.debug.assert(counterObject.counter > 0, "counter must be > 0");
        counterObject.counter--;
        if (counterObject.counter == 0) {
            notifyLoadCompleteListeners(counterObject);
        }
    }
}

Resource.isLoadComplete = function(canvasId) {
    var counterObject = getCounterObject(canvasId);
    return !counterObject || counterObject.counter == 0;
};

/*
 * Register listener that will be fired when all resources for specified canvasId are loaded.
 * Listener is fired only once.
 *
 * @param {number} canvasId
 * @param {EventListener} listener
 */
Resource.addLoadCompleteListener = function(canvasId, listener) {
    var counterObject = getOrCreateCounterObject(canvasId);

    /*
    if (counterObject === undefined || counterObject.counter == 0) {
        listener(canvasId);
        return;
    }
    */

    var idx = counterObject.listeners.indexOf(listener);
    if (idx == -1) {
        counterObject.listeners.push(listener);
    }
};

//noinspection JSUnusedGlobalSymbols
/**
 *
 * @param {number} canvasId
 * @param {function} listener
 */
Resource.removeLoadCompleteListener = function(canvasId, listener) {
    var counterObject = getCounterObject(canvasId);
    if (counterObject) {
        var idx = counterObject.listeners.indexOf(listener);
        if (idx != -1)
            counterObject.listeners.splice(idx, 1);
    }
};


function stringEndsWithSuffix(str, suffix) {
    return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

//noinspection JSUnusedGlobalSymbols
Resource.addBinaryContentType = function(type) {
    if (c_binaryContentTypes.indexOf(type) == -1)
        c_binaryContentTypes.push(type);
};

//noinspection JSUnusedGlobalSymbols
Resource.removeBinaryContentType = function(type) {
    var idx = c_binaryContentTypes.indexOf(type);
    if (idx != -1)
        c_binaryContentTypes.splice(idx, 1);
};

function isBinaryContentType(contentType) {
    for (var i in c_binaryContentTypes) {
        if (contentType == c_binaryContentTypes[i]) {
            return true;
        }
    }
    return false;
}

Resource.addBinaryExtension = function(extension) {
    if (c_binaryExtensions.indexOf(extension) == -1)
        c_binaryExtensions.push(extension);
};

//noinspection JSUnusedGlobalSymbols
Resource.removeBinaryExtension = function(extension) {
    var idx = c_binaryExtensions.indexOf(extension);
    if (idx != -1)
        c_binaryExtensions.splice(idx, 1);
};

function isBinaryExtension(url) {
    for (var i in c_binaryExtensions) {
        if (stringEndsWithSuffix(url, c_binaryExtensions[i]))
            return true;
    }
    return false;
}

/**
 * Load a document via XMLHttpRequest
 * @private
 * @param {string} url URL of the document
 * @param {string} acceptType The content type that should be requested for this document
 */
function loadDocument(url, acceptType) {
    var xmlHttp = null;
    try {
        xmlHttp = new XMLHttpRequest();
    } catch (e) {
        xmlHttp = null;
    }
    if (xmlHttp) {
        xmlHttp._url = url;
        xmlHttp._contentChecked = false;
        xmlHttp.open('GET', url, true);
        if (isBinaryExtension(url))
            xmlHttp.responseType = "arraybuffer";

        xmlHttp.setRequestHeader("Accept", acceptType);

        xmlHttp.onreadystatechange = function() {
            if (xmlHttp._aborted) // This check is possibly not needed
                return;
            // check compatibility between content and request mode
            if (!xmlHttp._contentChecked &&
                // 2 - HEADERS_RECEIVED, 3 - LOADING, 4 - DONE
                ((xmlHttp.readyState == 2 || xmlHttp.readyState == 3 || xmlHttp.readyState == 4) &&
                    xmlHttp.status == 200)) {
                xmlHttp._contentChecked = true; // we check only once
                // check if we need to change request mode
                var contentType = xmlHttp.getResponseHeader("content-type");
                if (contentType) {
                    var binaryContent = isBinaryContentType(contentType);
                    var binaryRequest = (xmlHttp.responseType == "arraybuffer");
                    // When content is not the same as request, we need to repeat request
                    if (binaryContent != binaryRequest) {
                        xmlHttp._aborted = true;
                        var cb = xmlHttp.onreadystatechange;
                        xmlHttp.onreadystatechange = null;
                        var url = xmlHttp._url;
                        xmlHttp.abort();

                        // Note: We do not recycle XMLHttpRequest !
                        //       This does work only when responseType is changed to "arraybuffer",
                        //       however the size of the xmlHttp.response buffer is then wrong !
                        //       It does not work at all (at least in Chrome) when we use overrideMimeType
                        //       with "text/plain; charset=x-user-defined" argument.
                        //       The latter mode require creation of the fresh XMLHttpRequest.

                        xmlHttp = new XMLHttpRequest();
                        xmlHttp._url = url;
                        xmlHttp._contentChecked = true;
                        xmlHttp.open('GET', url, true);
                        if (binaryContent)
                            xmlHttp.responseType = "arraybuffer";
                        xmlHttp.onreadystatechange = cb;
                        xmlHttp.send(null);
                        return;
                    }
                }
            }
            // Request mode and content type are compatible here (both binary or both text)
            if (xmlHttp.readyState == 4) {
                if (xmlHttp.status == 200) {
                    XML3D.debug.logDebug("Loaded: " + xmlHttp._url);
                    XML3D.xmlHttpCallback && XML3D.xmlHttpCallback(xmlHttp);
                    processResponse(xmlHttp);
                }
                else {
                    XML3D.debug.logError("Could not load external document '" + xmlHttp._url +
                        "': " + xmlHttp.status + " - " + xmlHttp.statusText);
                    invalidateDocumentHandles(xmlHttp._url);
                }
            }
        };
        xmlHttp.send(null);
    }
}
/**
 * Process response of ajax request from loadDocument()
 * @private
 * @param {XMLHttpRequest} httpRequest
 */
function processResponse(httpRequest) {
    var mimetype = httpRequest.getResponseHeader("content-type");
    if (!mimetype) {
        XML3D.debug.logError("Could not load external document because the server did not provide a content-type header: "+httpRequest._url);
        invalidateDocumentHandles(httpRequest._url);
        return;
    }
    setDocumentData(httpRequest, httpRequest._url, mimetype);
}
/**
 * Initialize data of a received document
 * @private
 * @param {XMLHttpRequest} httpRequest The XMLHttpRequest of the loaded document
 * @param {string} url URL of the loaded document
 * @param {string} mimetype The mimetype of the loaded document
 */
function setDocumentData(httpRequest, url, mimetype) {
    var docCache = c_cachedDocuments[url];
    docCache.mimetype = mimetype;

    var cleanedMimetype = mimetype;

    if (mimetype.indexOf(';') > 0)
        cleanedMimetype = mimetype.substr(0, mimetype.indexOf(';'));

    var response = null;
    if (httpRequest.responseType == "arraybuffer") {
        response = httpRequest.response;
    } else if (cleanedMimetype.match(/json/)) {
        response = JSON.parse(httpRequest.responseText);
    } else if (cleanedMimetype.match(/xml/)) {
        response = httpRequest.responseXML;
        //Workaround for IE "bug" where external documents always report their document.URL as being identical to window.location.href
        response._documentURL = url;
        if (!response) {
            XML3D.debug.logError("Invalid external XML document '" + httpRequest._url +
                "': XML Syntax error");
            return;
        }
    } else if (cleanedMimetype == "application/octet-stream" || mimetype.match(/text\/plain/)) {
        XML3D.debug.logError("Possibly wrong loading of resource " + url + ". Mimetype is " + mimetype + " but response is not an ArrayBuffer");
        response = httpRequest.response;
    } else if (cleanedMimetype == "application/javascript" || mimetype == "text/javascript") {
        response = httpRequest.response;
    }else {
        XML3D.debug.logError("Unidentified response type (response = '" + httpRequest.response + "', responseType = '" + httpRequest.responseType + "')");
        response = httpRequest.response;
    }

    var formatHandler = findFormat(response, httpRequest.responseType, cleanedMimetype);
    if (!formatHandler) {
        XML3D.debug.logError("No format handler for resource (response = '" + response + "', responseType = '" + httpRequest.responseType + "')");
        invalidateDocumentHandles(url);
        return;
    }
    docCache.format = formatHandler;
    formatHandler.getFormatData(response, httpRequest.responseType, cleanedMimetype, function(success, result){
        if(success){
            docCache.response = result;
            updateDocumentHandles(url)
        }
        else{
            invalidateDocumentHandles(url);
        }
    } );

}

/**
 * Update all existing handles of a received document
 * @param {string} url The URL of the document
 */
function updateDocumentHandles(url) {
    var docCache = c_cachedDocuments[url];
    var fragments = docCache.fragments;
    docCache.fragments = [];
    for (var i = 0; i < fragments.length; ++i) {
        updateExternalHandles(url, fragments[i]);
    }
}

/**
 * Invalidate all handles of a document, that could not be loaded.
 * @param {string} url The URL of the document
 */
function invalidateDocumentHandles(url) {
    var docCache = c_cachedDocuments[url];
    var fragments = docCache.fragments;
    docCache.fragments = [];
    for (var i = 0; i < fragments.length; ++i) {
        var fullUrl = url + (fragments[i] ? "#" + fragments[i] : "");
        invalidateHandles(fullUrl);
    }
}

/**
 * Update all handles of a part from an external document
 * @param {string} url The URL of the document
 * @param {string} fragment Fragment without pound key which defines the part of the document
 */
function updateExternalHandles(url, fragment) {

    var response = c_cachedDocuments[url].response;
    var mimetype = c_cachedDocuments[url].mimetype;
    var format = c_cachedDocuments[url].format;

    var fullUrl = url + (fragment ? "#" + fragment : "");
    if (!response) {
        // In the case the loaded document is not supported we still need to decrement counter object
        invalidateHandles(fullUrl);
        return;
    }

    // get part of the resource represented by the fragment
    var data = format.getFragmentData(response, fragment);

    if (data) {
        updateMissingHandles(fullUrl, format, data);
    }
    else {
        invalidateHandles(fullUrl);
    }
}


/**
 * Update all AdapterHandles without adapters of a certain url
 * @param {string} url The complete url + fragment
 * @param {FormatHandler} formatHandler Format handler
 * @param {Object} data Data of the document corresponding to the url. Possibly a DOM element
 * @param {boolean?} localChange If true, then this is about a local id change. do not call loadComplete
 */
function updateMissingHandles(url, formatHandler, data, localChange) {
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            if (!handle.hasAdapter()) {
                updateHandle(handle, adapterType, +canvasId, formatHandler, data);
                if(!localChange) loadComplete(canvasId);
            }
        }
    }
}

/**
 * Invalidate all AdapterHandles without adapters of a certain url
 * @param {string} url The complete url + fragment
 */
function invalidateHandles(url) {
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
            loadComplete(canvasId);
        }
    }
}

/**
 * Update a specific AdapterHandle with the provided data.
 * Internally an adapter will be created with 'data' and added to 'handle'
 * All other argument are required to find the correct factory
 * @param {AdapterHandle} handle The AdapterHandle to be updated
 * @param {Object} adapterType The type / aspect of the adapter (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId Id of corresponding canvas handler. 0 if not dependent of canvas handler
 * @param {FormatHandler} format Format handler of the corresponding document
 * @param {Object} data Data for this handle. Possibly a DOM element
 */
function updateHandle(handle, adapterType, canvasId, format, data) {

    var factory = format.getFactory(adapterType, canvasId);

    if(!factory) {
        XML3D.debug.logError("Format does not support adapterType " + adapterType);
        return;
    }

    var adapter = factory.getAdapter ? factory.getAdapter(data) : factory.createAdapter(data);
    if (adapter) {
        handle.setAdapter(adapter, AdapterHandle.STATUS.READY);
    }


}

/**
 * Remove the adapter of all AdapterHandles corresponding to the given URL.
 * This is called e.g. when a node is remove from the document, or an id changes
 * @param {string} url The URL of all AdapterHandles to be cleared.
 */
function clearHandles(url) {
    for (var adapterType in c_cachedAdapterHandles[url]) {
        for (var canvasId in c_cachedAdapterHandles[url][adapterType]) {
            var handle = c_cachedAdapterHandles[url][adapterType][canvasId];
            if (handle.hasAdapter()) {
                handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
            }
        }
    }
}

/**
 * This methods returns an absolute URI compatible with the resource manager.
 * This means: Any reference from an external document will be absolute and any id reference from the current
 * document will remain an id reference.
 * @param {String} baseURI - the base URI that the uri is relative to
 * @param {URI} uri - The URI used to find the referred AdapterHandle. Can be relative
 * @returns {URI} The (sometimes) absolute URI
 */
Resource.getAbsoluteURI = function(baseURI, uri){
    if (!uri)
        return null;

    if (typeof uri == "string") uri = new URI(uri);
    if (baseURI != document.URL || !uri.isLocal()) {
        uri = uri.getAbsoluteURI(baseURI);
    }
    return uri;
};

/**
 * Get any adapter, internal or external.
 * This function will trigger the loading of documents, if required.
 * An AdapterHandle will be always be returned, expect when an invalid (empty) uri is passed.
 *
 * @param {String} baseURI - the base URI from which to look up the reference
 * @param {URI} uri - The URI used to find the referred AdapterHandle. Can be relative
 * @param {string} nodeName The tag name of the element referencing this adapter handle
 * @param {Object} adapterType The type of adapter required (e.g. XML3D.data or XML3D.webgl)
 * @param {number=} canvasId Id of GLCanvasHandler handler this adapter depends on, 0 if not depending on any GLCanvasHandler
 * @returns {?AdapterHandle} The requested AdapterHandler. Note: might be null
 */
Resource.getAdapterHandle = function(baseURI, uri, adapterType, canvasId, nodeName) {
    canvasId = canvasId || 0;
    uri = Resource.getAbsoluteURI(baseURI, uri);

    if (!uri)
        return null;

    if (!c_cachedAdapterHandles[uri])
        c_cachedAdapterHandles[uri] = {};

    if (!c_cachedAdapterHandles[uri][adapterType]) {
        c_cachedAdapterHandles[uri][adapterType] = {};
    }

    var handle = c_cachedAdapterHandles[uri][adapterType][canvasId];
    if (handle)
        return handle;

    handle = new AdapterHandle(uri);
    c_cachedAdapterHandles[uri][adapterType][canvasId] = handle;

    if (uri.isLocal()) {
        var node = URIResolver.resolveLocal(uri);
        if (node)
            updateHandle(handle, adapterType, canvasId, XML3D.xml3dFormatHandler, node);
        else
            handle.setAdapter(null, AdapterHandle.STATUS.NOT_FOUND);
    }
    else {
        var counterObject = getOrCreateCounterObject(canvasId);
        counterObject.counter++;

        var docURI = uri.toStringWithoutFragment();
        var docData = c_cachedDocuments[docURI];
        if (docData && docData.response) {
            updateExternalHandles(docURI, uri.fragment);
        } else {
            if (!docData) {
                var acceptType = getAcceptTypeForNode(nodeName, docURI);
                loadDocument(docURI, acceptType);
                c_cachedDocuments[docURI] = docData = {
                    fragments: []
                };
            }
            docData.fragments.push(uri.fragment);
        }
    }
    return handle;
};

function getAcceptTypeForNode(nodeName, uri) {
    nodeName = nodeName || "";
    switch(nodeName.toLowerCase()) {
        case "model":
            return "model/vnd.xml3d.model+xml";
        case "mesh":
        case "data":
            if (uri.path && uri.path.match(/\.json/)) {
                return "model/vnd.xml3d.mesh+json";
            } else {
                return "model/vnd.xml3d.mesh+xml";
            }
        default:
            return "model/vnd.xml3d.mesh+xml";
    }
}

/**
 * Get any adapter, internal or external.
 *
 * @param node
 * @param adapterType
 * @param canvasId
 * @return {XML3D.base.Adapter?}
 */
Resource.getAdapter = function(node, adapterType, canvasId) {
    var factory = XML3D.xml3dFormatHandler.getFactory(adapterType, canvasId);
    if (factory) {
        return factory.getAdapter(node);
    }
    return null;
};

/**
 * This function is called when an id of an element changes or if that element is now reachable
 * or not reachable anymore. It will update all AdapterHandles connected to the element.
 * @param {Element} node Element of which id has changed
 * @param {string} previousId Previous id of element
 * @param {string} newId New id of element
 */
Resource.notifyNodeIdChange = function(node, previousId, newId) {
    var parent = node;
    while (parent.parentNode) parent = parent.parentNode;
    if (parent != window.document)
        return;

    // clear cached adapters of previous id"
    if (previousId) {
        clearHandles("#" + previousId);
    }
    if (newId) {
        updateMissingHandles("#" + newId, XML3D.xml3dFormatHandler, node, true);
    }
};

/**
 * This function is called to notify an AdapterHandler about a change (can be triggered through adapters)
 * Note that this function only works with nodes inside window.document
 * @param {Element} element Element of AdapterHandler. Must be from window.document
 * @param {Object} adapterType Type/Aspect of AdapterHandler (e.g. XML3D.data or XML3D.webgl)
 * @param {number} canvasId GLCanvasHandler id of AdapterHandler, 0 if not depending on GLCanvasHandler
 * @param {number} type Type of Notification. Usually Events.ADAPTER_HANDLE_CHANGED
 */
Resource.notifyNodeAdapterChange = function(element, adapterType, canvasId, type) {
    canvasId = canvasId || 0;
    var uri = "#" + element.id;
    if (c_cachedAdapterHandles[uri] && c_cachedAdapterHandles[uri][adapterType] &&
        c_cachedAdapterHandles[uri][adapterType][canvasId]) {
        c_cachedAdapterHandles[uri][adapterType][canvasId].notifyListeners(type);
    }
};


/**
 * Load data via XMLHttpRequest
 * @private
 * @param {string} url URL of the document
 * @param {function(object)} loadListener Gets the response of the XHR
 * @param {function(XMLHttpRequest)} errorListener Get the XHR object for further analysis
 */
Resource.loadData = function(url, loadListener, errorListener) {
    var xmlHttp = null;
    try {
        xmlHttp = new XMLHttpRequest();
    } catch (e) {
        xmlHttp = null;
    }
    if (xmlHttp) {
        xmlHttp._url = url;
        xmlHttp._contentChecked = false;
        xmlHttp.open('GET', url, true);
        if (isBinaryExtension(url))
            xmlHttp.responseType = "arraybuffer";

        xmlHttp.onreadystatechange = function() {
            if (xmlHttp._aborted) // This check is possibly not needed
                return;
            // check compatibility between content and request mode
            if (!xmlHttp._contentChecked &&
                // 2 - HEADERS_RECEIVED, 3 - LOADING, 4 - DONE
                ((xmlHttp.readyState == 2 || xmlHttp.readyState == 3 || xmlHttp.readyState == 4) &&
                    xmlHttp.status == 200)) {
                xmlHttp._contentChecked = true; // we check only once
                // check if we need to change request mode
                var contentType = xmlHttp.getResponseHeader("content-type");
                if (contentType) {
                    var binaryContent = isBinaryContentType(contentType);
                    var binaryRequest = (xmlHttp.responseType == "arraybuffer");
                    // When content is not the same as request, we need to repeat request
                    if (binaryContent != binaryRequest) {
                        xmlHttp._aborted = true;
                        var cb = xmlHttp.onreadystatechange;
                        xmlHttp.onreadystatechange = null;
                        var url = xmlHttp._url;
                        xmlHttp.abort();

                        // Note: We do not recycle XMLHttpRequest !
                        //       This does work only when responseType is changed to "arraybuffer",
                        //       however the size of the xmlHttp.response buffer is then wrong !
                        //       It does not work at all (at least in Chrome) when we use overrideMimeType
                        //       with "text/plain; charset=x-user-defined" argument.
                        //       The latter mode require creation of the fresh XMLHttpRequest.

                        xmlHttp = new XMLHttpRequest();
                        xmlHttp._url = url;
                        xmlHttp._contentChecked = true;
                        xmlHttp.open('GET', url, true);
                        if (binaryContent)
                            xmlHttp.responseType = "arraybuffer";
                        xmlHttp.onreadystatechange = cb;
                        xmlHttp.send(null);
                        return;
                    }
                }
            }
            // Request mode and content type are compatible here (both binary or both text)
            if (xmlHttp.readyState == 4) {
                if (xmlHttp.status == 200) {
                    XML3D.debug.logDebug("Loaded: " + xmlHttp._url);

                    var mimetype = xmlHttp.getResponseHeader("content-type");
                    var response = null;

                    if (xmlHttp.responseType == "arraybuffer") {
                        response = xmlHttp.response;
                    } else if (mimetype == "application/json") {
                        response = JSON.parse(xmlHttp.responseText);
                    } else if (mimetype == "application/xml" || mimetype == "text/xml") {
                        response = xmlHttp.responseXML;
                    } else if (mimetype == "application/octet-stream" || mimetype == "text/plain; charset=x-user-defined") {
                        XML3D.debug.logError("Possibly wrong loading of resource " + url + ". Mimetype is " + mimetype + " but response is not an ArrayBuffer");
                        response = xmlHttp.responseText; // FIXME is this correct ?
                    }
                    if (loadListener)
                        loadListener(response);
                }
                else {
                    XML3D.debug.logError("Could not load external document '" + xmlHttp._url +
                        "': " + xmlHttp.status + " - " + xmlHttp.statusText);
                    if (errorListener)
                        errorListener(xmlHttp);
                }
            }
        };
        xmlHttp.send(null);
    }
};

/**
 * This function is called to load an Image.
 *
 * @param {URI} uri Image URI
 * @param {function(Event, HTMLImageElement)} loadListener Function called when image was successfully loaded.
 *                                It will be called with event as the first and image as the second parameter.
 * @param {function(Event, HTMLImageElement)} errorListener Function called when image could not be loaded.
 *                                 It will be called with event as the first and image as the second parameter.
 * @return {HTMLImageElement}
 */
Resource.getImage = function(uri, loadListener, errorListener) {
    // we use canvasId 0 to represent images loaded in a document
    getOrCreateCounterObject(0).counter++;

    var image = new Image();
    image.onload = function(e) {
        loadListener(e, image);
        loadComplete(0);
    };
    image.onerror = function(e) {
        errorListener(e, image);
        loadComplete(0);
    };
    if(!uri.hasSameOrigin(document.location.href)) {
        image.crossOrigin = Options.getValue(OPTION_RESOURCE_CORS);
        XML3D.debug.logWarning("You are using an cross-origin image as texture. This might cause troubles cause the canvas is 'tainted'.")
    }

    image.src = uri.toString(); // here loading starts
    return image;
};


/**
 * This function is called to load a Video.
 *
 * @param {URI} uri Video URI
 * @param {boolean} autoplay
 * @param {boolean} loop
 * @param {Object} listeners  Dictionary of all listeners to register with video element.
 *                            Listeners will be called with event as the first and video as the second parameter.
 * @return {HTMLVideoElement}
 */
Resource.getVideo = function(uri, autoplay, loop, listeners) {
    // we use canvasId 0 to represent videos loaded in a document
    getOrCreateCounterObject(0).counter++;

    // FIXME: In HTML, we create a configured video, play/pause won't work
    var video = document.createElement("video");

    var loadCompleteCallback = function(event) {
        loadComplete(0);
        video.removeEventListener("canplay", loadCompleteCallback, true);
        video.removeEventListener("error", loadCompleteCallback, true);
    };

    if (!uri.hasSameOrigin(document.location.href)) {
        video.crossOrigin = Options.getValue(OPTION_RESOURCE_CORS);
        XML3D.debug.logWarning("You are using an cross-origin video as texture. This might cause troubles cause the canvas is 'tainted'.", uri)
    }

    video.autoplay = autoplay;
    video.loop = loop;

    function createCallback(listener) {
        return function(event) {
            listener(event, video);
        };
    }

    for (var eventName in listeners) {
        video.addEventListener(eventName, createCallback(listeners[eventName]), true);
    }

    video.addEventListener("canplay", loadCompleteCallback, true);
    video.addEventListener("error", loadCompleteCallback, true);

    video.src = uri.toString(); // here loading starts
    return video;
};

module.exports = {
    registerFactory: registerFactory,
    registerFormat: registerFormat,
    findFormat: findFormat,
    Resource: Resource
};

},{"../utils/options.js":175,"../utils/uri.js":176,"./adapterhandle.js":44}],47:[function(require,module,exports){
/*jslint white: false, onevar: false, undef: true, nomen: true, eqeqeq: true, plusplus: true, bitwise: true, regexp: true, newcap: true, immed: true, sub: true, nomen: false */

/**
* This file contains code that may be under the following license:
*
* SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008)
* Copyright (C) 1991-2000 Silicon Graphics, Inc. All Rights Reserved.
*
* See http://oss.sgi.com/projects/FreeB/ for more information.
*
* All code in this file which is NOT under the SGI FREE SOFTWARE LICENSE B
* is free and unencumbered software released into the public domain.
*
* Anyone is free to copy, modify, publish, use, compile, sell, or
* distribute this software, either in source code form or as a compiled
* binary, for any purpose, commercial or non-commercial, and by any
* means.
*
* In jurisdictions that recognize copyright laws, the author or authors
* of this software dedicate any and all copyright interest in the
* software to the public domain. We make this dedication for the benefit
* of the public at large and to the detriment of our heirs and
* successors. We intend this dedication to be an overt act of
* relinquishment in perpetuity of all present and future rights to this
* software under copyright law.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
* OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*/

var GLU = {};
/**
* Unproject a screen point.
*
* @param {number} winX the window point for the x value.
* @param {number} winY the window point for the y value.
* @param {number} winZ the window point for the z value.
* @param {Array.<number>} model the model-view matrix.
* @param {Array.<number>} proj the projection matrix.
* @param {Array.<number>} view the viewport coordinate array.
* @param {Array.<number>} objPos the model point result.
* @return {boolean} true if the unproject operation was successful, false otherwise.
*/
GLU.unProject = function(winX, winY, winZ, model, proj, view, objPos) {

    /** @type {Array.<number>} */
    var inp = [
        winX,
        winY,
        winZ,
        1.0
    ];

    /** @type {Array.<number>} */
    var finalMatrix = [];

    GLU.multMatrices(model, proj, finalMatrix);
    if (!GLU.invertMatrix(finalMatrix, finalMatrix)) {
        return (false);
    }

    /* Map x and y from window coordinates */
    inp[0] = (inp[0] - view[0]) / view[2];
    inp[1] = (inp[1] - view[1]) / view[3];

    /* Map to range -1 to 1 */
    inp[0] = inp[0] * 2 - 1;
    inp[1] = inp[1] * 2 - 1;
    inp[2] = inp[2] * 2 - 1;

    /** @type {Array.<number>} */
    var out = [];

    GLU.multMatrixVec(finalMatrix, inp, out);

    if (out[3] === 0.0) {
        return false;
    }

    out[0] /= out[3];
    out[1] /= out[3];
    out[2] /= out[3];

    objPos[0] = out[0];
    objPos[1] = out[1];
    objPos[2] = out[2];

    return true;
};

/**
* Multiply the matrix by the specified vector.
*
* @param {Array.<number>} matrix the matrix.
* @param {Array.<number>} inp the vector.
* @param {Array.<number>} out the output.
*/
GLU.multMatrixVec = function(matrix, inp, out) {
    for (var i = 0; i < 4; i = i + 1) {
        out[i] =
            inp[0] * matrix[0 * 4 + i] +
            inp[1] * matrix[1 * 4 + i] +
            inp[2] * matrix[2 * 4 + i] +
            inp[3] * matrix[3 * 4 + i];
    }
};

/**
* Multiply the specified matrices.
*
* @param {Array.<number>} a the first matrix.
* @param {Array.<number>} b the second matrix.
* @param {Array.<number>} r the result.
*/
GLU.multMatrices = function(a, b, r) {
    for (var i = 0; i < 4; i = i + 1) {
        for (var j = 0; j < 4; j = j + 1) {
            r[i * 4 + j] =
                a[i * 4 + 0] * b[0 * 4 + j] +
                a[i * 4 + 1] * b[1 * 4 + j] +
                a[i * 4 + 2] * b[2 * 4 + j] +
                a[i * 4 + 3] * b[3 * 4 + j];
        }
    }
};

/**
* Invert a matrix.
*
* @param {Array.<number>} m the matrix.
* @param {Array.<number>} invOut the inverted output.
* @return {boolean} true if successful, false otherwise.
*/
GLU.invertMatrix = function(m, invOut) {
    /** @type {Array.<number>} */
    var inv = [];

    inv[0] = m[5] * m[10] * m[15] - m[5] * m[11] * m[14] - m[9] * m[6] * m[15] +
        m[9] * m[7] * m[14] + m[13] * m[6] * m[11] - m[13] * m[7] * m[10];
    inv[4] = -m[4] * m[10] * m[15] + m[4] * m[11] * m[14] + m[8] * m[6] * m[15] -
        m[8] * m[7] * m[14] - m[12] * m[6] * m[11] + m[12] * m[7] * m[10];
    inv[8] = m[4] * m[9] * m[15] - m[4] * m[11] * m[13] - m[8] * m[5] * m[15] +
        m[8] * m[7] * m[13] + m[12] * m[5] * m[11] - m[12] * m[7] * m[9];
    inv[12] = -m[4] * m[9] * m[14] + m[4] * m[10] * m[13] + m[8] * m[5] * m[14] -
        m[8] * m[6] * m[13] - m[12] * m[5] * m[10] + m[12] * m[6] * m[9];
    inv[1] = -m[1] * m[10] * m[15] + m[1] * m[11] * m[14] + m[9] * m[2] * m[15] -
        m[9] * m[3] * m[14] - m[13] * m[2] * m[11] + m[13] * m[3] * m[10];
    inv[5] = m[0] * m[10] * m[15] - m[0] * m[11] * m[14] - m[8] * m[2] * m[15] +
        m[8] * m[3] * m[14] + m[12] * m[2] * m[11] - m[12] * m[3] * m[10];
    inv[9] = -m[0] * m[9] * m[15] + m[0] * m[11] * m[13] + m[8] * m[1] * m[15] -
        m[8] * m[3] * m[13] - m[12] * m[1] * m[11] + m[12] * m[3] * m[9];
    inv[13] = m[0] * m[9] * m[14] - m[0] * m[10] * m[13] - m[8] * m[1] * m[14] +
        m[8] * m[2] * m[13] + m[12] * m[1] * m[10] - m[12] * m[2] * m[9];
    inv[2] = m[1] * m[6] * m[15] - m[1] * m[7] * m[14] - m[5] * m[2] * m[15] +
        m[5] * m[3] * m[14] + m[13] * m[2] * m[7] - m[13] * m[3] * m[6];
    inv[6] = -m[0] * m[6] * m[15] + m[0] * m[7] * m[14] + m[4] * m[2] * m[15] -
        m[4] * m[3] * m[14] - m[12] * m[2] * m[7] + m[12] * m[3] * m[6];
    inv[10] = m[0] * m[5] * m[15] - m[0] * m[7] * m[13] - m[4] * m[1] * m[15] +
        m[4] * m[3] * m[13] + m[12] * m[1] * m[7] - m[12] * m[3] * m[5];
    inv[14] = -m[0] * m[5] * m[14] + m[0] * m[6] * m[13] + m[4] * m[1] * m[14] -
        m[4] * m[2] * m[13] - m[12] * m[1] * m[6] + m[12] * m[2] * m[5];
    inv[3] = -m[1] * m[6] * m[11] + m[1] * m[7] * m[10] + m[5] * m[2] * m[11] -
        m[5] * m[3] * m[10] - m[9] * m[2] * m[7] + m[9] * m[3] * m[6];
    inv[7] = m[0] * m[6] * m[11] - m[0] * m[7] * m[10] - m[4] * m[2] * m[11] +
        m[4] * m[3] * m[10] + m[8] * m[2] * m[7] - m[8] * m[3] * m[6];
    inv[11] = -m[0] * m[5] * m[11] + m[0] * m[7] * m[9] + m[4] * m[1] * m[11] -
        m[4] * m[3] * m[9] - m[8] * m[1] * m[7] + m[8] * m[3] * m[5];
    inv[15] = m[0] * m[5] * m[10] - m[0] * m[6] * m[9] - m[4] * m[1] * m[10] +
        m[4] * m[2] * m[9] + m[8] * m[1] * m[6] - m[8] * m[2] * m[5];

    /** @type {number} */
    var det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

    if (det === 0) {
        return false;
    }

    det = 1.0 / det;

    for (var i = 0; i < 16; i = i + 1) {
        invOut[i] = inv[i] * det;
    }

    return true;
};

module.exports = GLU;
},{}],48:[function(require,module,exports){
// Domain Public by Eric Wendelin http://eriwen.com/ (2008)
//                  Luke Smith http://lucassmith.name/ (2008)
//                  Loic Dachary <loic@dachary.org> (2008)
//                  Johan Euphrosine <proppy@aminche.com> (2008)
//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)


/**
 * Main function giving a function stack trace with a forced or passed in
 * Error
 *
 * @cfg {Error} e The error to create a stacktrace from (optional)
 * @cfg {Boolean} guess If we should try to resolve the names of anonymous
 * functions
 * @return {Array} of Strings with functions, lines, files, and arguments
 * where possible
 */
var printStackTrace = function (options) {
    options = options || {
        guess : true
    };
    var ex = options.e || null, guess = !!options.guess;
    var p = new printStackTrace.implementation(), result = p.run(ex);
    return (guess) ? p.guessAnonymousFunctions(result) : result;
};

printStackTrace.implementation = function() {};

printStackTrace.implementation.prototype = {
    /**
     * @param {Error} ex The error to create a stacktrace from (optional)
     * @param {String} mode Forced mode (optional, mostly for unit tests)
     */
    run : function(ex, mode) {
        ex = ex || this.createException();
        // examine exception properties w/o debugger
        // for (var prop in ex) {alert("Ex['" + prop + "']=" + ex[prop]);}
        mode = mode || this.mode(ex);
        if (mode === 'other') {
            return this.other(arguments.callee);
        } else {
            return this[mode](ex);
        }
    },

    createException : function() {
        try {
            this.undef();
        } catch (e) {
            return e;
        }
    },

    /**
     * Mode could differ for different exception, e.g. exceptions in Chrome
     * may or may not have arguments or stack.
     *
     * @return {String} mode of operation for the exception
     */
    mode : function(e) {
        if (e['arguments'] && e.stack) {
            return 'chrome';
        } else if (e.stack && e.sourceURL) {
            return 'safari';
        } else if (typeof e.message === 'string' && typeof window !== 'undefined' && window.opera) {
            // e.message.indexOf("Backtrace:") > -1 -> opera
            // !e.stacktrace -> opera
            if (!e.stacktrace) {
                return 'opera9'; // use e.message
            }
            // 'opera#sourceloc' in e -> opera9, opera10a
            if (e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
                return 'opera9'; // use e.message
            }
            // e.stacktrace && !e.stack -> opera10a
            if (!e.stack) {
                return 'opera10a'; // use e.stacktrace
            }
            // e.stacktrace && e.stack -> opera10b
            if (e.stacktrace.indexOf("called from line") < 0) {
                return 'opera10b'; // use e.stacktrace, format differs from
                                    // 'opera10a'
            }
            // e.stacktrace && e.stack -> opera11
            return 'opera11'; // use e.stacktrace, format differs from
                                // 'opera10a', 'opera10b'
        } else if (e.stack) {
            return 'firefox';
        }
        return 'other';
    },

    /**
     * Given a context, function name, and callback function, overwrite it
     * so that it calls printStackTrace() first with a callback and then
     * runs the rest of the body.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to instrument
     * @param {Function} function to call with a stack trace on invocation
     */
    instrumentFunction : function(context, functionName, callback) {
        context = context || window;
        var original = context[functionName];
        context[functionName] = function instrumented() {
            callback.call(this, printStackTrace().slice(4));
            return context[functionName]._instrumented.apply(this, arguments);
        };
        context[functionName]._instrumented = original;
    },

    /**
     * Given a context and function name of a function that has been
     * instrumented, revert the function to it's original (non-instrumented)
     * state.
     *
     * @param {Object} context of execution (e.g. window)
     * @param {String} functionName to de-instrument
     */
    deinstrumentFunction : function(context, functionName) {
        if (context[functionName].constructor === Function && context[functionName]._instrumented
                && context[functionName]._instrumented.constructor === Function) {
            context[functionName] = context[functionName]._instrumented;
        }
    },

    /**
     * Given an Error object, return a formatted Array based on Chrome's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    chrome : function(e) {
        var stack = (e.stack + '\n').replace(/^\S[^\(]+?[\n$]/gm, '').replace(/^\s+(at eval )?at\s+/gm, '').replace(/^([^\(]+?)([\n$])/gm,
                '{anonymous}()@$1$2').replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}()@$1').split('\n');
        stack.pop();
        return stack;
    },

    /**
     * Given an Error object, return a formatted Array based on Safari's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    safari : function(e) {
        return e.stack.replace(/\[native code\]\n/m, '').replace(/^@/gm, '{anonymous}()@').split('\n');
    },

    /**
     * Given an Error object, return a formatted Array based on Firefox's
     * stack string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    firefox : function(e) {
        return e.stack.replace(/(?:\n@:0)?\s+$/m, '').replace(/^[\(@]/gm, '{anonymous}()@').split('\n');
    },

    opera11 : function(e) {
        var ANON = '{anonymous}', lineRE = /^.*line (\d+), column (\d+)(?: in (.+))? in (\S+):$/;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var location = match[4] + ':' + match[1] + ':' + match[2];
                var fnName = match[3] || "global code";
                fnName = fnName.replace(/<anonymous function: (\S+)>/, "$1").replace(/<anonymous function>/, ANON);
                result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    opera10b : function(e) {
        // "<anonymous function: run>([arguments not
        // available])@file://localhost/G:/js/stacktrace.js:27\n" +
        // "printStackTrace([arguments not
        // available])@file://localhost/G:/js/stacktrace.js:18\n" +
        // "@file://localhost/G:/js/test/functional/testcase1.html:15"
        var lineRE = /^(.*)@(.+):(\d+)$/;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i++) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var fnName = match[1] ? (match[1] + '()') : "global code";
                result.push(fnName + '@' + match[2] + ':' + match[3]);
            }
        }

        return result;
    },

    /**
     * Given an Error object, return a formatted Array based on Opera 10's
     * stacktrace string.
     *
     * @param e - Error object to inspect
     * @return Array<String> of function calls, files and line numbers
     */
    opera10a : function(e) {
        // " Line 27 of linked script
        // file://localhost/G:/js/stacktrace.js\n"
        // " Line 11 of inline#1 script in
        // file://localhost/G:/js/test/functional/testcase1.html: In
        // function foo\n"
        var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
        var lines = e.stacktrace.split('\n'), result = [];

        for ( var i = 0, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                var fnName = match[3] || ANON;
                result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    // Opera 7.x-9.2x only!
    opera9 : function(e) {
        // " Line 43 of linked script
        // file://localhost/G:/js/stacktrace.js\n"
        // " Line 7 of inline#1 script in
        // file://localhost/G:/js/test/functional/testcase1.html\n"
        var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
        var lines = e.message.split('\n'), result = [];

        for ( var i = 2, len = lines.length; i < len; i += 2) {
            var match = lineRE.exec(lines[i]);
            if (match) {
                result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
            }
        }

        return result;
    },

    // Safari 5-, IE 9-, and others
    other : function(curr) {
        var ANON = '{anonymous}', fnRE = /function\s*([\w\-$]+)?\s*\(/i, stack = [], fn, args, maxStackSize = 10;
        while (curr && curr['arguments'] && stack.length < maxStackSize) {
            fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
            args = Array.prototype.slice.call(curr['arguments'] || []);
            stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
            curr = curr.caller;
        }
        return stack;
    },

    /**
     * Given arguments array as a String, subsituting type names for
     * non-string types.
     *
     * @param {Arguments} args
     * @return {Array} of Strings with stringified arguments
     */
    stringifyArguments : function(args) {
        var result = [];
        var slice = Array.prototype.slice;
        for ( var i = 0; i < args.length; ++i) {
            var arg = args[i];
            if (arg === undefined) {
                result[i] = 'undefined';
            } else if (arg === null) {
                result[i] = 'null';
            } else if (arg.constructor) {
                if (arg.constructor === Array) {
                    if (arg.length < 3) {
                        result[i] = '[' + this.stringifyArguments(arg) + ']';
                    } else {
                        result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                    }
                } else if (arg.constructor === Object) {
                    result[i] = '#object';
                } else if (arg.constructor === Function) {
                    result[i] = '#function';
                } else if (arg.constructor === String) {
                    result[i] = '"' + arg + '"';
                } else if (arg.constructor === Number) {
                    result[i] = arg;
                }
            }
        }
        return result.join(',');
    },

    sourceCache : {},

    /**
     * @return the text from a given URL
     */
    ajax : function(url) {
        var req = this.createXMLHTTPObject();
        if (req) {
            try {
                req.open('GET', url, false);
                // req.overrideMimeType('text/plain');
                // req.overrideMimeType('text/javascript');
                req.send(null);
                // return req.status == 200 ? req.responseText : '';
                return req.responseText;
            } catch (e) {
            }
        }
        return '';
    },

    /**
     * Try XHR methods in order and store XHR factory.
     *
     * @return <Function> XHR function or equivalent
     */
    createXMLHTTPObject : function() {
        var xmlhttp, XMLHttpFactories = [ function() {
            return new XMLHttpRequest();
        }, function() {
            return new ActiveXObject('Msxml2.XMLHTTP');
        }, function() {
            return new ActiveXObject('Msxml3.XMLHTTP');
        }, function() {
            return new ActiveXObject('Microsoft.XMLHTTP');
        } ];
        for ( var i = 0; i < XMLHttpFactories.length; i++) {
            try {
                xmlhttp = XMLHttpFactories[i]();
                // Use memoization to cache the factory
                this.createXMLHTTPObject = XMLHttpFactories[i];
                return xmlhttp;
            } catch (e) {
            }
        }
    },

    /**
     * Given a URL, check if it is in the same domain (so we can get the
     * source via Ajax).
     *
     * @param url <String> source url
     * @return False if we need a cross-domain request
     */
    isSameDomain : function(url) {
        return typeof location !== "undefined" && url.indexOf(location.hostname) !== -1; // location
                                                                                            // may
                                                                                            // not
                                                                                            // be
                                                                                            // defined,
                                                                                            // e.g.
                                                                                            // when
                                                                                            // running
                                                                                            // from
                                                                                            // nodejs.
    },

    /**
     * Get source code from given URL if in the same domain.
     *
     * @param url <String> JS source URL
     * @return <Array> Array of source code lines
     */
    getSource : function(url) {
        // TODO reuse source from script tags?
        if (!(url in this.sourceCache)) {
            this.sourceCache[url] = this.ajax(url).split('\n');
        }
        return this.sourceCache[url];
    },

    guessAnonymousFunctions : function(stack) {
        for ( var i = 0; i < stack.length; ++i) {
            var reStack = /\{anonymous\}\(.*\)@(.*)/, reRef = /^(.*?)(?::(\d+))(?::(\d+))?(?: -- .+)?$/, frame = stack[i], ref = reStack.exec(frame);

            if (ref) {
                var m = reRef.exec(ref[1]);
                if (m) { // If falsey, we did not get any file/line
                            // information
                    var file = m[1], lineno = m[2], charno = m[3] || 0;
                    if (file && this.isSameDomain(file) && lineno) {
                        var functionName = this.guessAnonymousFunction(file, lineno, charno);
                        stack[i] = frame.replace('{anonymous}', functionName);
                    }
                }
            }
        }
        return stack;
    },

    guessAnonymousFunction : function(url, lineNo, charNo) {
        var ret;
        try {
            ret = this.findFunctionName(this.getSource(url), lineNo);
        } catch (e) {
            ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
        }
        return ret;
    },

    findFunctionName : function(source, lineNo) {
        // FIXME findFunctionName fails for compressed source
        // (more than one function on the same line)
        // TODO use captured args
        // function {name}({args}) m[1]=name m[2]=args
        var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
        // {name} = function ({args}) TODO args capture
        // /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
        var reFunctionExpression = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function\b/;
        // {name} = eval()
        var reFunctionEvaluation = /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
        // Walk backwards in the source lines until we find
        // the line which matches one of the patterns above
        var code = "", line, maxLines = Math.min(lineNo, 20), m, commentPos;
        for ( var i = 0; i < maxLines; ++i) {
            // lineNo is 1-based, source[] is 0-based
            line = source[lineNo - i - 1];
            commentPos = line.indexOf('//');
            if (commentPos >= 0) {
                line = line.substr(0, commentPos);
            }
            // TODO check other types of comments? Commented code may lead to false positive
            if (line) {
                code = line + code;
                m = reFunctionExpression.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
                m = reFunctionDeclaration.exec(code);
                if (m && m[1]) {
                    //return m[1] + "(" + (m[2] || "") + ")";
                    return m[1];
                }
                m = reFunctionEvaluation.exec(code);
                if (m && m[1]) {
                    return m[1];
                }
            }
        }
        return '(?)';
    }
};

module.exports = printStackTrace;
},{}],49:[function(require,module,exports){

var StateMachine = {

    //---------------------------------------------------------------------------

    VERSION: "2.2.0",

    //---------------------------------------------------------------------------

    Result: {
      SUCCEEDED:    1, // the event transitioned successfully from one state to another
      NOTRANSITION: 2, // the event was successfull but no state transition was necessary
      CANCELLED:    3, // the event was cancelled by the caller in a beforeEvent callback
      ASYNC:        4 // the event is asynchronous and the caller is in control of when the transition occurs
    },

    Error: {
      INVALID_TRANSITION: 100, // caller tried to fire an event that was innapropriate in the current state
      PENDING_TRANSITION: 200, // caller tried to fire an event while an async transition was still pending
      INVALID_CALLBACK:   300 // caller provided callback function threw an exception
    },

    WILDCARD: '*',
    ASYNC: 'async',

    //---------------------------------------------------------------------------

    create: function(cfg, target) {

      var initial   = (typeof cfg.initial == 'string') ? { state: cfg.initial } : cfg.initial; // allow for a simple string, or an object with { state: 'foo', event: 'setup', defer: true|false }
      var fsm       = target || cfg.target  || {};
      var events    = cfg.events || [];
      var callbacks = cfg.callbacks || {};
      var map       = {};

      var add = function(e) {
        var from = (e.from instanceof Array) ? e.from : (e.from ? [e.from] : [StateMachine.WILDCARD]); // allow 'wildcard' transition if 'from' is not specified
        map[e.name] = map[e.name] || {};
        for (var n = 0 ; n < from.length ; n++)
          map[e.name][from[n]] = e.to || from[n]; // allow no-op transition if 'to' is not specified
      };

      if (initial) {
        initial.event = initial.event || 'startup';
        add({ name: initial.event, from: 'none', to: initial.state });
      }

      for(var n = 0 ; n < events.length ; n++)
        add(events[n]);

      for(var name in map) {
        if (map.hasOwnProperty(name))
          fsm[name] = StateMachine.buildEvent(name, map[name]);
      }

      for(var name in callbacks) {
        if (callbacks.hasOwnProperty(name))
          fsm[name] = callbacks[name]
      }

      fsm.current = 'none';
      fsm.is      = function(state) { return this.current == state; };
      fsm.can     = function(event) { return !this.transition && (map[event].hasOwnProperty(this.current) || map[event].hasOwnProperty(StateMachine.WILDCARD)); }
      fsm.cannot  = function(event) { return !this.can(event); };
      fsm.error   = cfg.error || function(name, from, to, args, error, msg, e) { throw e || msg; }; // default behavior when something unexpected happens is to throw an exception, but caller can override this behavior if desired (see github issue #3 and #17)

      if (initial && !initial.defer)
        fsm[initial.event]();

      return fsm;

    },

    //===========================================================================

    doCallback: function(fsm, func, name, from, to, args) {
      if (func) {
        try {
          return func.apply(fsm, [name, from, to].concat(args));
        }
        catch(e) {
          return fsm.error(name, from, to, args, StateMachine.Error.INVALID_CALLBACK, "an exception occurred in a caller-provided callback function", e);
        }
      }
    },

    beforeEvent: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onbefore' + name],                     name, from, to, args); },
    afterEvent:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onafter'  + name] || fsm['on' + name], name, from, to, args); },
    leaveState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onleave'  + from],                     name, from, to, args); },
    enterState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onenter'  + to]   || fsm['on' + to],   name, from, to, args); },
    changeState: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onchangestate'],                       name, from, to, args); },


    buildEvent: function(name, map) {
      return function() {

        var from  = this.current;
        var to    = map[from] || map[StateMachine.WILDCARD] || from;
        var args  = Array.prototype.slice.call(arguments); // turn arguments into pure array

        if (this.transition)
          return this.error(name, from, to, args, StateMachine.Error.PENDING_TRANSITION, "event " + name + " inappropriate because previous transition did not complete");

        if (this.cannot(name))
          return this.error(name, from, to, args, StateMachine.Error.INVALID_TRANSITION, "event " + name + " inappropriate in current state " + this.current);

        if (false === StateMachine.beforeEvent(this, name, from, to, args))
          return StateMachine.Result.CANCELLED;

        if (from === to) {
          StateMachine.afterEvent(this, name, from, to, args);
          return StateMachine.Result.NOTRANSITION;
        }

        // prepare a transition method for use EITHER lower down, or by caller if they want an async transition (indicated by an ASYNC return value from leaveState)
        var fsm = this;
        this.transition = function() {
          fsm.transition = null; // this method should only ever be called once
          fsm.current = to;
          StateMachine.enterState( fsm, name, from, to, args);
          StateMachine.changeState(fsm, name, from, to, args);
          StateMachine.afterEvent( fsm, name, from, to, args);
        };
        this.transition.cancel = function() { // provide a way for caller to cancel async transition if desired (issue #22)
          fsm.transition = null;
          StateMachine.afterEvent(fsm, name, from, to, args);
        };

        var leave = StateMachine.leaveState(this, name, from, to, args);
        if (false === leave) {
          this.transition = null;
          return StateMachine.Result.CANCELLED;
        }
        else if ("async" === leave) {
          return StateMachine.Result.ASYNC;
        }
        else {
          if (this.transition)
            this.transition(); // in case user manually called transition() but forgot to return ASYNC
          return StateMachine.Result.SUCCEEDED;
        }

      };
    }

}; // StateMachine

//===========================================================================

/*if ("function" === typeof define) {
define(function(require) { return StateMachine; });
}
else {*/
window.StateMachine = StateMachine;
/*}*/

module.exports = StateMachine;


},{}],50:[function(require,module,exports){
var DOMTransformFetcher = require("../transform-fetcher.js");
var DataAdapter = require("./data.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var getComputeDataflowUrl = require("../../xflow/interface/graph.js").getComputeDataflowUrl;
var Asset = require("../../asset/asset.js").Asset;
var SubData = require("../../asset/asset.js").SubData;
var Events = require("../../interface/notification.js");
var dispatchCustomEvent = require("../../utils/misc.js").dispatchCustomEvent;
var Resource = require("../../base/resourcemanager.js").Resource;

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;
var AdapterHandle = require("../../base/adapterhandle.js");


var AssetAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);

    /**
     *  @type Asset
     **/
    this.asset = new Asset(this.node);
    if (node.localName.toLowerCase() !== "model") {
        this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
    }
};

createClass(AssetAdapter, NodeAdapter);

AssetAdapter.prototype.init = function () {
    this.asset.addChangeListener(this);
    this.asset.setName(this.node.getAttribute("name"));
    updateAdapterHandle(this, "src", this.node.getAttribute("src"));
    updatePickFilter(this);
    updateChildren(this);
    setMaterialUrl(this, this.asset);
    this.transformFetcher && this.transformFetcher.update();
};

AssetAdapter.prototype.onAssetLoadChange = function (asset, newLevel, oldLevel) {
    if (newLevel == Infinity) {
        dispatchCustomEvent(this.node, 'load', false, true, null);
    } else if (newLevel > oldLevel) {
        dispatchCustomEvent(this.node, 'progress', false, true, null);
    }
};

AssetAdapter.prototype.getAssetComplete = function () {
    return this.asset.getProgressLevel() == Infinity;
};
AssetAdapter.prototype.getAssetProgressLevel = function () {
    return this.asset.getProgressLevel();
};

AssetAdapter.prototype.getAsset = function () {
    return this.asset;
};

function updateChildren(adapter) {
    adapter.asset.clearChildren();
    adapter.asset.clearSubAssets();
    for (var child = adapter.node.firstElementChild; child !== null; child = child.nextElementSibling) {
        var subadapter = adapter.factory.getAdapter(child);
        if (subadapter && subadapter.getAsset) {
            adapter.asset.appendSubAsset(subadapter.getAsset());
        }
        if (subadapter && subadapter.assetEntry) {
            adapter.asset.appendChild(subadapter.assetEntry);
        }
    }
}

function updateAdapterHandle(adapter, key, url) {
    var adapterHandle = adapter.getAdapterHandle(url), status = (adapterHandle && adapterHandle.status);

    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, adapter.node);
    }
    adapter.connectAdapterHandle(key, adapterHandle);
    adapter.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
}

function updateAssetLoadState(dataAdapter) {
    var loading = false, handle;

    handle = dataAdapter.getConnectedAdapterHandle("src");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }
    dataAdapter.asset.setLoading(loading);
}

function updatePickFilter(adapter) {
    if (!adapter.node.hasAttribute("pick"))
        adapter.asset.setPickFilter(null); else {
        var value = adapter.node.getAttribute("pick");
        adapter.asset.setPickFilter(value);
    }
}

AssetAdapter.prototype.connectedAdapterChanged = function (attributeName, adapter) {
    if (attributeName == "src")
        this.asset.setSrcAsset(adapter && adapter.getAsset() || null);
    updateAssetLoadState(this);
};

AssetAdapter.prototype.onTransformChange = function (attrName, matrix) {
    this.asset.setTransform(matrix);
};

AssetAdapter.prototype.attributeChangedCallback = function(name, oldValue, newValue) {
        switch (name) {
            case "name":
                this.asset.setName(newValue);
                break;
            case "material":
                setMaterialUrl(this, this.asset);
                break;
            case "style":
            case "transform":
                this.transformFetcher && this.transformFetcher.update();
                break;
            case "src":
                updateAdapterHandle(this, "src", newValue);
                break;
            case "pick":
                updatePickFilter(this);
                break;
        }
};


AssetAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type == Events.ADAPTER_HANDLE_CHANGED) {
        this.connectedAdapterChanged(evt.key, evt.adapter);
        if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find <asset> element of url '" + evt.url + "' for " + evt.key);
        }
    } else if (evt.type == Events.NODE_INSERTED) {
        updateChildren(this);

    } else if (evt.type == Events.NODE_REMOVED) {
        updateChildren(this);

    }  else if (evt.type == Events.THIS_REMOVED) {
        this.clearAdapterHandles();
    }
};

var AssetDataAdapter = function (factory, node) {
    this.assetData = true;
    DataAdapter.call(this, factory, node);

    // Node handles for src and proto
    this.assetEntry = null;
    this.outputXflowNode = null;
};
createClass(AssetDataAdapter, DataAdapter);

AssetDataAdapter.prototype.init = function () {
    DataAdapter.prototype.init.call(this);
    this.outputXflowNode = new DataNode(false);
    this.assetEntry = new SubData(this.outputXflowNode, this.getXflowNode(), this.node);
    this.assetEntry.setName(this.node.getAttribute("name"));
    updateClassNames(this);
    updatePostCompute(this);
    this.assetEntry.setPostFilter(this.node.getAttribute("filter"));
    updateIncludes(this.assetEntry, this.node.getAttribute("includes"));
};

AssetDataAdapter.prototype.connectedAdapterChanged = function (attributeName, adapter) {
    if (attributeName == "postDataflow") {
        this.assetEntry.setPostDataflow(adapter && adapter.getXflowNode() || null);
        updateSubDataLoadState(this);
    } else {
        DataAdapter.prototype.connectedAdapterChanged.call(this, attributeName, adapter);
    }
};

AssetDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
    DataAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
    switch (name) {
        case "name":
            this.assetEntry.setName(newValue);
            break;
        case "compute":
            updatePostCompute(this);
            break;
        case "class":
            updateClassNames(this);
            break;
        case "filter":
            this.assetEntry.setPostFilter(newValue);
            break;
        case "includes":
            updateIncludes(newValue);
            break;
    }
};

AssetDataAdapter.prototype.notifyChanged = function (evt) {
    DataAdapter.prototype.notifyChanged.call(this, evt);

};

AssetDataAdapter.prototype.onTransformChange = function (attrName, matrix) {
    this.assetEntry.setTransform(matrix);
};

function updateIncludes(assetEntry, includeString) {
    if (!includeString)
        assetEntry.setIncludes([]); else
        assetEntry.setIncludes(includeString.trim().split(/\s*,\s*/));
}

function updateClassNames(adapter) {
    var classNames = adapter.node.getAttribute("class");
    adapter.assetEntry.setClassNamesString(classNames)
}

function updatePostCompute(adapter) {
    var computeString = adapter.node.getAttribute("compute");
    var dataflowUrl = getComputeDataflowUrl(computeString);
    if (dataflowUrl) {
        updateAdapterHandle(adapter, "postDataflow", dataflowUrl);
    } else {
        adapter.disconnectAdapterHandle("postDataflow");
        updateSubDataLoadState(adapter);
    }
    adapter.assetEntry.setPostCompute(computeString);
}

function updateSubDataLoadState(dataAdapter) {
    var loading = false, handle;

    handle = dataAdapter.getConnectedAdapterHandle("postDataflow");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }
    dataAdapter.assetEntry.setLoading(loading);
}


/**
 *
 * @param adapter
 * @param {Asset} dest
 */
function setMaterialUrl(adapter, dest) {
    var node = adapter.node;
    var materialURL = node.getAttribute("material");
    if (materialURL) {
        var materialAbsoluteURL = Resource.getAbsoluteURI(node.ownerDocument._documentURL || node.ownerDocument.URL, materialURL);
        dest.setMaterial(materialAbsoluteURL.toString());
    } else {
        dest.setMaterial(null);
    }
}

var AssetMeshAdapter = function (factory, node) {
    AssetDataAdapter.call(this, factory, node);
    this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
};
createClass(AssetMeshAdapter, AssetDataAdapter, {

    init: function () {
        AssetDataAdapter.prototype.init.call(this);
        setMaterialUrl(this, this.assetEntry);
        this.assetEntry.setMeshType(this.node.getAttribute("type") || "triangles");
        this.assetEntry.setMatchFilter(this.node.getAttribute("match"));
        this.transformFetcher.update();
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        AssetDataAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
        switch (name) {
            case "material":
                setMaterialUrl(this, this.assetEntry);
                break;
            case "match":
                this.assetEntry.setMatchFilter(newValue);
                break;
            case "style":
            case "transform":
                this.transformFetcher.update();
                break;
            case "type":
                this.assetEntry.setMeshType(newValue || "triangles")
        }
    },

    notifyChanged: function (evt) {
        AssetDataAdapter.prototype.notifyChanged.call(this, evt);
    }
});

module.exports = {
    AssetAdapter: AssetAdapter, AssetMeshAdapter: AssetMeshAdapter, AssetDataAdapter: AssetDataAdapter
};

},{"../../asset/asset.js":42,"../../base/adapter.js":43,"../../base/adapterhandle.js":44,"../../base/resourcemanager.js":46,"../../interface/notification.js":71,"../../utils/misc.js":174,"../../xflow/interface/graph.js":181,"../transform-fetcher.js":63,"./data.js":53}],51:[function(require,module,exports){
var ComputeRequest = require("../../xflow/interface/request.js").ComputeRequest;
var setShaderConstant = require("../../xflow/processing/vs-connect.js").setShaderConstant;
var registerErrorCallback = require("../../xflow/base.js").registerErrorCallback;
var XC = require("../../xflow/interface/constants.js");
var URI = require("../../utils/uri.js").URI;

var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;

/**
 * @extends NodeAdapter
 * @abstract
 *
 * @param factory
 * @param node
 */
var BaseDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.xflowDataNode = null;
};
createClass(BaseDataAdapter, NodeAdapter);


BaseDataAdapter.prototype.getXflowNode = function () {
    return this.xflowDataNode;
};

BaseDataAdapter.prototype.getComputeRequest = function (filter, callback) {
    return new ComputeRequest(this.xflowDataNode, filter, callback);
};

BaseDataAdapter.prototype.getComputeResult = function (filter) {
    return this.xflowDataNode._getResult(XC.RESULT_TYPE.COMPUTE, filter);
};

BaseDataAdapter.prototype.getOutputNames = function () {
    return this.xflowDataNode.getOutputNames();
};

BaseDataAdapter.prototype.getOutputChannelInfo = function (name) {
    return this.xflowDataNode.getOutputChannelInfo(name);
};

setShaderConstant(XC.SHADER_CONSTANT_KEY.OBJECT_ID, "objectID");
setShaderConstant(XC.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM, "modelViewProjectionMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL, "modelViewProjectionNormalMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.VIEW_TRANSFORM, "modelViewMatrix");
setShaderConstant(XC.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL, "modelViewMatrixN");
setShaderConstant(XC.SHADER_CONSTANT_KEY.WORLD_TRANSFORM, "modelMatrix");
registerErrorCallback(function(message, xflowNode){
    message = "Xflow: " + message;
    var userData = xflowNode ? xflowNode.userData : null;
    if (userData && userData.ownerDocument) {
        if (userData.ownerDocument === document) {
            XML3D.debug.logError(message, userData);
        }
        else if (userData.id) {
            var uri = new URI("#" + userData.id);
            uri = uri.getAbsoluteURI(userData.ownerDocument._documentURL || userData.ownerDocument.URL);
            XML3D.debug.logError(message, "External Node: " + uri);
        }
        else {
            XML3D.debug.logError(message, "External Document: " + userData.ownerDocument.URL);
        }
    }
    else if (typeof userData == "string") {
        XML3D.debug.logError(message, userData);
    }
    else {
        XML3D.debug.logError(message);
    }
});

module.exports = BaseDataAdapter;

},{"../../base/adapter.js":43,"../../utils/uri.js":176,"../../xflow/base.js":178,"../../xflow/interface/constants.js":179,"../../xflow/interface/request.js":182,"../../xflow/processing/vs-connect.js":229}],52:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

/**
 * DataAdapter handling a <compute> element
 * @param {AdapterFactory} factory
 * @param {Element} node
 * @constructor
 */
var ComputeDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};
XML3D.createClass(ComputeDataAdapter, NodeAdapter);

ComputeDataAdapter.prototype.getComputeCode = function () {
    return this.node.value;
};

/**
 * @param evt notification of type XML3D.Notification
 */
ComputeDataAdapter.prototype.notifyChanged = function (evt) {
    switch (evt.type) {
        case Events.VALUE_MODIFIED:
        case Events.NODE_INSERTED:
        case Events.NODE_REMOVED:
            var parent = this.node.parentNode;
            if (parent) {
                var parentAdapter = this.factory.getAdapter(parent);
                parentAdapter && parentAdapter.updateXflowNode();
            }
    }
};

module.exports = ComputeDataAdapter;

},{"../../base/adapter.js":43,"../../interface/notification.js":71}],53:[function(require,module,exports){
var BaseDataAdapter = require("./base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var dispatchCustomEvent = require("../../utils/misc.js").dispatchCustomEvent;
var AdapterHandle = require("../../base/adapterhandle.js");

/**
 * The DataAdapter implements the
 * DataCollector concept and serves as basis of all DataAdapter classes. In
 * general, a DataAdapter is associated with an element node which uses
 * generic data and should be instantiated via
 * XML3DDataAdapterFactory to ensure proper functionality.
 *
 * @extends Adapter
 * @constructor
 *
 * @param factory
 * @param node
 */
var DataAdapter = function (factory, node) {
    BaseDataAdapter.call(this, factory, node);
    // Node handles for src and proto
    this.xflowDataNode = null;
    this.externalScripts = {};
};
XML3D.createClass(DataAdapter, BaseDataAdapter);

DataAdapter.prototype.init = function () {
    this.xflowDataNode = new DataNode(false);
    this.xflowDataNode.addLoadListener(this.onXflowLoadEvent.bind(this));
    this.xflowDataNode.userData = this.node;

    // Setting platform and node type information for a data sequence
    this.xflowDataNode.setPlatform(this.node.getAttribute("platform"));

    this.updateAdapterHandle("src", this.node.getAttribute("src"));
    if(!this.assetData){
        this.xflowDataNode.setFilter(this.node.getAttribute("filter"));
        updateCompute(this);
    }
    recursiveDataAdapterConstruction(this);
};

DataAdapter.prototype.updateAdapterHandle = function(key, url) {
    var oldAdapterHandle = this.getConnectedAdapterHandle(key);

    var adapterHandle = this.getAdapterHandle(url),
        status = (adapterHandle && adapterHandle.status);

    if(oldAdapterHandle == adapterHandle)
        return;
    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, this.node);
    }
    this.connectAdapterHandle(key, adapterHandle);
    this.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
};

DataAdapter.prototype.onXflowLoadEvent = function(node, newLevel, oldLevel){
    if(newLevel == Infinity){
        dispatchCustomEvent(this.node, 'load', false, true, null);
    }
    else if(newLevel > oldLevel){
        dispatchCustomEvent(this.node, 'progress', false, true, null);
    }
};
DataAdapter.prototype.getDataComplete = function(){
    return this.xflowDataNode.getProgressLevel() == Infinity;
};
DataAdapter.prototype.getDataProgressLevel = function(){
    return this.xflowDataNode.getProgressLevel();
};

    /** Recursively passing platform information to children of a data node
     *  Requires that the children and the parents of data nodes are defined
     *
     * @param {DataNode} parentNode
     */
function recursiveDataNodeAttrInit(parentNode) {
    var children = parentNode._children, NChildren, i;

    if (children && children.length > 0) {
        NChildren = children.length;

        for (i = NChildren; i--;) {
            if (children[i] instanceof DataNode) {
                children[i].setPlatform(parentNode._platform);
                recursiveDataNodeAttrInit(children[i]);
            }
        }
    }
}

function recursiveDataAdapterConstruction(adapter) {
    for (var child = adapter.node.firstElementChild; child !== null; child = child.nextElementSibling) {
        var subadapter = adapter.factory.getAdapter(child);
        if (subadapter) {
            if (subadapter.getXflowNode) {
                adapter.xflowDataNode.appendChild(subadapter.getXflowNode());
            } else if (subadapter.getScriptType) {
                var scriptId = subadapter.node.name;
                if (!scriptId) {
                    XML3D.debug.logError("Parsing error: Externally referenced operators must have a 'name' attribute matching the name they were registered with. ", subadapter.node);
                    scriptId = "unknown_operator";
                }
                adapter.externalScripts[scriptId] = subadapter;
                if (subadapter.connectedAdapterHandle) {
                    adapter.connectAdapterHandle(scriptId, subadapter.connectedAdapterHandle);
                }
                adapter.xflowDataNode.setLoading(true);
            }
            // Passes _platform values to children nodes starting from the node
            // where these attributes are first defined
            if (adapter.xflowDataNode._platform !== null) {
                recursiveDataNodeAttrInit(adapter.xflowDataNode);
            }
        }
    }
}

/**
 * The notifyChanged() method is called by the XML3D data structure to
 * notify the DataAdapter about data changes (DOM mustation events) in its
 * associating node. When this method is called, all observers of the
 * DataAdapter are notified about data changes via their notifyDataChanged()
 * method.
 *
 * @param evt notification of type XML3D.Notification
 */
DataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type === Events.ADAPTER_HANDLE_CHANGED) {
        this.connectedAdapterChanged(evt.key, evt.adapter, evt.handleStatus);
        if (evt.handleStatus === AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find <data> element of url '" + evt.url + "' for " + evt.key, this.node);
        }

    } else if (evt.type === Events.NODE_INSERTED) {
        var insertedNode = evt.affectedNode;
        var adapter = this.factory.getAdapter(insertedNode);
        if (!adapter) {
            return;
        }

        var insertedXflowNode = adapter.getXflowNode();
        var sibling = insertedNode, followUpAdapter = null;

        do {
            sibling = sibling.nextSibling;
        } while (sibling && !(followUpAdapter = this.factory.getAdapter(sibling)));

        if (followUpAdapter) {
            this.xflowDataNode.insertBefore(insertedXflowNode, followUpAdapter.getXflowNode());
        } else {
            this.xflowDataNode.appendChild(insertedXflowNode);
        }

    } else if (evt.type === Events.NODE_REMOVED) {
        var adapter = this.factory.getAdapter(evt.affectedNode);
        if (!adapter) {
            return;
        }

        var removedXflowNode = adapter.getXflowNode();
        this.xflowDataNode.removeChild(removedXflowNode);

    } else if (evt.type === Events.THIS_REMOVED) {
        this.clearAdapterHandles();
    }
};

DataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
    if (name === "filter" && !this.assetData) {
        this.xflowDataNode.setFilter(newValue);
    } else if (name === "compute" && !this.assetData) {
        updateCompute(this);
    } else if (name === "src") {
        this.updateAdapterHandle(name, newValue);
    } else if (name === "platform") {
        updatePlatform(this);
    }
};

DataAdapter.prototype.connectedAdapterChanged = function (key, adapter /*, status */) {
    if (key === "src") {
        this.xflowDataNode.sourceNode = adapter ? adapter.getXflowNode() : null;
    } else if (key === "dataflow") {
        this.xflowDataNode.dataflowNode = adapter ? adapter.getXflowNode() : null;
    } else if (this.externalScripts[key]) {
        window.eval(adapter.script);
        this.xflowDataNode.notify(XC.RESULT_STATE.CHANGED_STRUCTURE);
    }
    // Cycle the load state to force a load event even if the new sourceNode is cached
    this.xflowDataNode.setLoading(true);
    updateLoadState(this);
};

/**
 * Returns String representation of this DataAdapter
 */
DataAdapter.prototype.toString = function () {
    return "DataAdapter";
};

function updateCompute(dataAdapter) {
    var xflowNode = dataAdapter.xflowDataNode;
    xflowNode.setCompute(dataAdapter.node.getAttribute("compute"));
    if (xflowNode.computeDataflowUrl) {
        dataAdapter.updateAdapterHandle("dataflow", xflowNode.computeDataflowUrl);
    }
    else {
        dataAdapter.disconnectAdapterHandle("dataflow");
        updateLoadState(dataAdapter);
    }
}

function updatePlatform(dataAdapter) {
    var xflowNode = dataAdapter.xflowDataNode;

    xflowNode.setPlatform(dataAdapter.node.getAttribute("platform"));
    recursiveDataNodeAttrInit(xflowNode);
}

function updateLoadState(dataAdpater) {
    var loading = false, handle;

    handle = dataAdpater.getConnectedAdapterHandle("src");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }

    handle = dataAdpater.getConnectedAdapterHandle("dataflow");
    if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
        loading = true;
    }

    for (var name in dataAdpater.externalScripts) {
        handle = dataAdpater.getConnectedAdapterHandle(name);
        if (handle && handle.status === AdapterHandle.STATUS.LOADING) {
            loading = true;
        }
    }

    dataAdpater.xflowDataNode.setLoading(loading);
}


module.exports = DataAdapter;



},{"../../base/adapterhandle.js":44,"../../interface/notification.js":71,"../../utils/misc.js":174,"../../xflow/interface/constants.js":179,"../../xflow/interface/graph.js":181,"./base.js":51}],54:[function(require,module,exports){
var BaseDataAdapter = require("./base.js");
var DataNode = require("../../xflow/interface/graph.js").DataNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var AdapterHandle = require("../../base/adapterhandle.js");

/**
 * DataAdapter handling a <dataflow> element
 * @param factory
 * @param node
 * @constructor
 */
var DataflowDataAdapter = function (factory, node) {
    BaseDataAdapter.call(this, factory, node);
    this.xflowDataNode = null;
    this.externalScripts = {};
};
XML3D.createClass(DataflowDataAdapter, BaseDataAdapter);

DataflowDataAdapter.prototype.init = function () {
    this.xflowDataNode = new DataNode(false);
    this.dataflowRefs = [];
    updateDataflowXflowNode(this, this.node);
};

DataflowDataAdapter.prototype.updateAdapterHandle = function(key, url) {
    var oldAdapterHandle = this.getConnectedAdapterHandle(key);

    var adapterHandle = this.getAdapterHandle(url),
        status = (adapterHandle && adapterHandle.status);

    if(oldAdapterHandle == adapterHandle)
        return;
    if (status === AdapterHandle.STATUS.NOT_FOUND) {
        XML3D.debug.logError("Could not find element of url '" + adapterHandle.url + "' for " + key, this.node);
    }
    this.connectAdapterHandle(key, adapterHandle);
    this.connectedAdapterChanged(key, adapterHandle ? adapterHandle.getAdapter() : null, status);
};


/**
 * @param evt notification of type XML3D.Notification
 */
DataflowDataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type === Events.ADAPTER_HANDLE_CHANGED) {
        //TODO: Handle ADAPTER_HANDLE_CHANGED
        if (this.externalScripts[evt.key]) {
            window.eval(evt.adapter.script);
            setLoadingStateForMatchingXflowNodes(this.xflowDataNode, evt.key, false);
            this.xflowDataNode.notify(XC.RESULT_STATE.CHANGED_STRUCTURE);
        }
    }

    switch (evt.type) {
        case Events.ADAPTER_HANDLE_CHANGED:
            this.connectedAdapterChanged(evt.key, evt.adapter, evt.handleStatus);
            if (evt.handleStatus === AdapterHandle.STATUS.NOT_FOUND) {
                XML3D.debug.logError("Could not find dataflow of url '" + evt.url, this.node);
            }
            break;

        case Events.NODE_INSERTED:
        case Events.NODE_REMOVED:
            updateDataflowXflowNode(this);
            break;

        case Events.VALUE_MODIFIED:
            var attr = evt.mutation.attributeName;
            if (attr === "out") {
                updateDataflowOut(this);
            } else if (attr === "platform") {
                updateDataflowXflowNode(this, this.node);
            }
            break;
    }
};

/**
 * Traverse all subnodes of a dataflow and set the loading state of
 * all nodes with a compute operator that relies on the matching external script name.
 * A compute node will only be executed if its loading state is 'false' and none of its children are 'loading', so
 * this ensures we don't do the compute operations until the external operators have been loaded.
 * @param {DataNode} node the current node to check for instances of the given operator
 * @param {string} name the name of the external operator to check for
 * @param {boolean} loading whether the operator has finished loading or not
 */
function setLoadingStateForMatchingXflowNodes(node, name, loading) {
    if (node._computeOperator === name) {
        node.setLoading(loading);
    }
    if (node._children) {
        var i = node._children.length;
        while (i--) {
            setLoadingStateForMatchingXflowNodes(node._children[i], name, loading);
        }
    }
}

DataflowDataAdapter.prototype.updateXflowNode = function () {
    updateDataflowXflowNode(this, this.node);
};

DataflowDataAdapter.prototype.connectedAdapterChanged = function (key, adapter, status) {
    var xflowNode = this.dataflowRefs[key];
    if (xflowNode) {
        xflowNode.dataflowNode = adapter ? adapter.getXflowNode() : null;
        xflowNode.setLoading(status === AdapterHandle.STATUS.LOADING);
    }
};

function updateDataflowOut(adapter) {
    var out = adapter.node.getAttribute("out");
    if (out) {
        adapter.xflowDataNode.setFilter("keep(" + out + ")");
    } else {
        adapter.xflowDataNode.setFilter("");
    }
}

function updateDataflowXflowNode(adapter, node) {
    // Getting platform and node type information for a Dataflow node
    var platform = node.getAttribute("platform");

    adapter.xflowDataNode.clearChildren();
    adapter.xflowDataNode.setCompute("");
    adapter.clearAdapterHandles();
    adapter.dataflowRefs = [];
    adapter.externalScripts = {};
    updateDataflowOut(adapter);

    var child = node.lastElementChild, firstNode = true, prevNode = null, currentNode = adapter.xflowDataNode, subAdapter, xflowNode;

    do {
        subAdapter = adapter.factory.getAdapter(child);
        if (!subAdapter) {
            continue;
        }

        if (subAdapter.getXflowNode) {
            xflowNode = subAdapter.getXflowNode();

            if (prevNode) {
                currentNode.insertBefore(xflowNode, prevNode);
            } else {
                currentNode.appendChild(xflowNode);
            }
            prevNode = xflowNode;
        } else if (subAdapter.getComputeCode) {
            var statements = subAdapter.getComputeCode().split(";");
            var j = statements.length;

            while (j--) {
                var compute = statements[j].trim();
                if (!compute) {
                    continue;
                }

                if (firstNode) {
                    firstNode = false;
                } else {
                    xflowNode = new DataNode(false);
                    if (prevNode) {
                        currentNode.insertBefore(xflowNode, prevNode);
                    } else {
                        currentNode.appendChild(xflowNode);
                    }
                    currentNode = xflowNode;
                    prevNode = null;
                }
                currentNode.userData = child;

                currentNode.setPlatform(platform);

                currentNode.setCompute(statements[j].trim());

                if (currentNode.computeDataflowUrl) {
                    var idx = adapter.dataflowRefs.length;
                    adapter.dataflowRefs.push(currentNode);
                    adapter.updateAdapterHandle(idx, currentNode.computeDataflowUrl);
                }
            }
        } else if (subAdapter.getScriptType) {
            var scriptId = subAdapter.node.name;
            if (!scriptId) {
                XML3D.debug.logError("Parsing error: Externally referenced operators must have a 'name' attribute matching the name they were registered with. ", subAdapter.node);
                scriptId = "unknown_operator";
            }
            adapter.externalScripts[scriptId] = subAdapter;
            if (subAdapter.connectedAdapterHandle) {
                adapter.connectAdapterHandle(scriptId, subAdapter.connectedAdapterHandle);
            }
        }

    } while (child = child.previousElementSibling);

    for (var name in adapter.externalScripts) {
        // Ensure XFlow doesn't execute any compute nodes that depend on external scripts until they're loaded
        setLoadingStateForMatchingXflowNodes(adapter.xflowDataNode, name, true);
    }
}


module.exports = DataflowDataAdapter;

},{"../../base/adapterhandle.js":44,"../../interface/notification.js":71,"../../xflow/interface/constants.js":179,"../../xflow/interface/graph.js":181,"./base.js":51}],55:[function(require,module,exports){
var NodeAdapterFactory = require("../../base/adapter.js").NodeAdapterFactory;
var Asset = require("./asset.js");
var Misc = require("./misc.js");
var ScriptDataAdapter = require("./script.js");
var TextureDataAdapter = require("./texture.js");
var TransformDataAdapter = require("./transform.js");
var ValueDataAdapter = require("./values.js");
var DataAdapter = require("./data.js");
var ComputeDataAdapter = require("./compute.js");
var DataflowDataAdapter = require("./dataflow.js");
// Register JSON Handler
require("./json/factory.js");
// Register JavaScript Handler (required for external shade.js Javascript resources)
require("./javascript/factory.js");

/**
 * Constructor of XML3DDataAdapterFactory
 * XML3DDataAdapterFactory creates DataAdapter instances for elements using generic data (<mesh>, <data>, <float>,...).
 * Additionally, it manages all DataAdapter instances so that for each node there is always just one DataAdapter. When
 * it creates a DataAdapter, it calls its init method.
 *
 * @constructor
 * @extends AdapterFactory
 */

var XML3DDataAdapterFactory = function () {
    NodeAdapterFactory.call(this, "data");
};
XML3D.createClass(XML3DDataAdapterFactory, NodeAdapterFactory);
XML3DDataAdapterFactory.prototype.aspect = "data";

var reg = {
    'mesh': Misc.SinkDataAdapter,
    'material': Misc.SinkDataAdapter,
    'shader': Misc.SinkDataAdapter, // TODO(ksons): Remove in 5.1
    'light': Misc.SinkDataAdapter,
    'float': ValueDataAdapter,
    'float2': ValueDataAdapter,
    'float3': ValueDataAdapter,
    'float4': ValueDataAdapter,
    'float4x4': ValueDataAdapter,
    'int': ValueDataAdapter,
    'int4': ValueDataAdapter,
    'bool': ValueDataAdapter,
    'byte': ValueDataAdapter,
    'ubyte': ValueDataAdapter,
    'img': Misc.ImgDataAdapter,
    'texture': TextureDataAdapter,
    'data': DataAdapter,
    'proto': DataAdapter,
    'dataflow': DataflowDataAdapter,
    'compute': ComputeDataAdapter,
    'video': Misc.VideoDataAdapter,
    'script': ScriptDataAdapter,
    'transform': TransformDataAdapter,
    'asset': Asset.AssetAdapter,
    'assetdata': Asset.AssetDataAdapter,
    'assetmesh': Asset.AssetMeshAdapter,
    'model': Asset.AssetAdapter
};

/**
 * Creates a DataAdapter associated with the given node.
 *
 * @param node
 *            element node which uses generic data. The supported elements
 *            are listed in the class description above.
 * @returns DataAdapter instance
 */
XML3DDataAdapterFactory.prototype.createAdapter = function (node) {
    //XML3D.debug.logDebug("Creating adapter: " + node.localName);
    var adapterContructor = reg[node.localName];
    if (adapterContructor !== undefined) {
        return new adapterContructor(this, node);
    }
    XML3D.debug.logWarning("Not supported as data element: " + node.localName);
    return null;
};

module.exports =  XML3DDataAdapterFactory;

},{"../../base/adapter.js":43,"./asset.js":50,"./compute.js":52,"./data.js":53,"./dataflow.js":54,"./javascript/factory.js":56,"./json/factory.js":57,"./misc.js":58,"./script.js":59,"./texture.js":60,"./transform.js":61,"./values.js":62}],56:[function(require,module,exports){
var registerFormat = require("../../../base/resourcemanager.js").registerFormat;
var FormatHandler = require("../../../base/formathandler.js").FormatHandler;
var AdapterFactory = require("../../../base/adapter.js").AdapterFactory;

var JavaScriptFormatHandler = function () {
    FormatHandler.call(this);
};
XML3D.createClass(JavaScriptFormatHandler, FormatHandler);

JavaScriptFormatHandler.prototype.isFormatSupported = function (response, responseType, mimetype) {
    return mimetype === "application/javascript" || mimetype === "text/javascript";
};


JavaScriptFormatHandler.prototype.getFormatData = function (response, responseType, mimetype, callback) {
    callback(true, response);
};

var javaScriptFormatHandler = new JavaScriptFormatHandler();
registerFormat(javaScriptFormatHandler);


var ScriptDataAdapter = function (script) {
    this.script = script;
};

ScriptDataAdapter.prototype.getScriptType = function () {
    return "application/javascript";
};

ScriptDataAdapter.prototype.getScript= function () {
    return this.script;
};


var ScriptFactory = function () {
    AdapterFactory.call(this, "data");
};
XML3D.createClass(ScriptFactory, AdapterFactory);


ScriptFactory.prototype.aspect = "data";

ScriptFactory.prototype.createAdapter = function (xflowNode) {
    return new ScriptDataAdapter(xflowNode);
};

javaScriptFormatHandler.registerFactoryClass(ScriptFactory);

},{"../../../base/adapter.js":43,"../../../base/formathandler.js":45,"../../../base/resourcemanager.js":46}],57:[function(require,module,exports){
var XC = require("../../../xflow/interface/constants.js");
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var Resource = require("../../../base/resourcemanager.js").Resource;
var registerFormat = require("../../../base/resourcemanager.js").registerFormat;
var JSONFormatHandler = require("../../../base/formathandler.js").JSONFormatHandler;
var AdapterFactory = require("../../../base/adapter.js").AdapterFactory;

var XML3DJSONFormatHandler = function() {
    JSONFormatHandler.call(this);
};
XML3D.createClass(XML3DJSONFormatHandler, JSONFormatHandler);

XML3DJSONFormatHandler.prototype.isFormatSupported = function(response, responseType, mimetype) {
    return mimetype === "application/json" && response.format == "xml3d-json" && response.version == "0.4.0";
};


XML3DJSONFormatHandler.prototype.getFormatData = function(response, responseType, mimetype, callback) {
    try{
        var xflowNode = createXflowNode(response);
        callback(true, xflowNode);
    } catch (e) {
        XML3D.debug.logException(e, "Failed to process XML3D json file");
        callback(false);
    }

};

var xml3dJSonFormatHandler = new XML3DJSONFormatHandler();
registerFormat(xml3dJSonFormatHandler);


var empty = function() {};

var TYPED_ARRAY_MAP = {
    "int" : Int32Array,
    "int4" : Int32Array,
    "float" : Float32Array,
    "float2" : Float32Array,
    "float3" : Float32Array,
    "float4" : Float32Array,
    "float4x4" : Float32Array,
    "bool" : Uint8Array,
    "byte" : Int8Array,
    "ubyte" : Uint8Array
};

var isLittleEndian = (function () {
    var buf = new ArrayBuffer(4);
    var dv = new DataView(buf);
    var view = new Int32Array(buf);
    view[0] = 0x01020304;
    var littleEndian = (dv.getInt32(0, true) === 0x01020304);
    return function () { return littleEndian; }
})();

function realTypeOf(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1);
}

function createXflowValue(dataNode, dataType, name, key, value) {
    var v = new (TYPED_ARRAY_MAP[dataType])(value);
    var type = XC.DATA_TYPE.fromString(dataType);
    var buffer = new BufferEntry(type, v);

    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    inputNode.key = key;
    dataNode.appendChild(inputNode);
}

function createXflowValueFromBuffer(dataNode, dataType, name, key, arrayBuffer, byteOffset, byteLength) {
    var ArrayType = TYPED_ARRAY_MAP[dataType];
    var v = new (ArrayType)(arrayBuffer, byteOffset, byteLength/ArrayType.BYTES_PER_ELEMENT);
    var type = XC.DATA_TYPE.fromString(dataType);
    var buffer = new BufferEntry(type, v);

    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    inputNode.key = key;
    dataNode.appendChild(inputNode);
}

function createXflowInputs(dataNode, name, jsonData){
    var v = null;

    if (!TYPED_ARRAY_MAP[jsonData.type])
        return;

    for(var i = 0; i < jsonData.seq.length; ++i) {
        var entry = jsonData.seq[i];
        var value = entry.value;
        var key = entry.key;

        if (realTypeOf(value) === 'Object' && value.url) {
            if (!isLittleEndian()) {
                // FIXME add big-endian -> little-endian conversion
                throw new Error("Big-endian binary data are not supported yet");
            }
            Resource.loadData(value.url, function (arrayBuffer) {
                createXflowValueFromBuffer(dataNode, jsonData.type, name, key, arrayBuffer, value.byteOffset, value.byteLength);
            }, null);
        } else {
            createXflowValue(dataNode, jsonData.type, name, key, value);
        }
    }
}

function createXflowNode(jsonData){
    if (jsonData.format != "xml3d-json")
        throw new Error("Unknown JSON format: " + jsonData.format);
    if (jsonData.version != "0.4.0")
        throw new Error("Unknown JSON version: " + jsonData.version);

    var node = new DataNode(false);
    node.userData = "External Json"; // TODO: Try to add document URL here (how to get it?)

    var entries = jsonData.data;
    for(var name in entries) {
        createXflowInputs(node, name, entries[name]);
    }
    return node;
}

/**
 * @implements IDataAdapter
 */
var JSONDataAdapter = function(xflowNode) {
    this.xflowDataNode = xflowNode;
};

JSONDataAdapter.prototype.getXflowNode = function(){
    return this.xflowDataNode;
};

/**
 * @constructor
 * @implements {XML3D.base.IFactory}
 */
var JSONFactory = function()
{
    AdapterFactory.call(this, "data");
};
XML3D.createClass(JSONFactory, AdapterFactory);


JSONFactory.prototype.aspect = "data";

JSONFactory.prototype.createAdapter = function(xflowNode) {
    return new JSONDataAdapter(xflowNode);
};

xml3dJSonFormatHandler.registerFactoryClass(JSONFactory);

},{"../../../base/adapter.js":43,"../../../base/formathandler.js":45,"../../../base/resourcemanager.js":46,"../../../xflow/interface/constants.js":179,"../../../xflow/interface/data.js":180,"../../../xflow/interface/graph.js":181}],58:[function(require,module,exports){
var DataAdapter = require("./data.js");
var Events = require("../../interface/notification.js");
var URI = require("../../utils/uri.js").URI;
var Util = require("../../utils/misc.js");

var Resource = require("../../base/resourcemanager.js").Resource;
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var createClass = XML3D.createClass;

/**
 * SinkDataAdapter represents the sink in the data hierarchy (no parents).
 * @constructor
 * @extends {DataAdapter}
 * @param factory
 * @param node
 */
var SinkDataAdapter = function(factory, node) {
    DataAdapter.call(this, factory, node);
};
createClass(SinkDataAdapter, DataAdapter, {

    /**
     * Indicates whether this DataAdapter is a SinkAdapter (has no parent
     * DataAdapter).
     *
     * @returns true if this DataAdapter is a SinkAdapter, otherwise false.
     */
    isSinkAdapter: function () {
        return true;
    },

    /**
     * Returns String representation of this DataAdapter
     */
    toString: function () {
        return "XML3D.data.SinkDataAdapter";
    }
});


    var ImgDataAdapter = function(factory, node) {
        NodeAdapter.call(this, factory, node);
        this.textureEntry = null;
        this.image = null;
        if (node.src)
            this.createImageFromURL(node.src);
    };
    createClass(ImgDataAdapter, NodeAdapter, {

        /**
         * Creates a new image object
         *
         * @param {string} url
         */
        createImageFromURL: function (url) {
            var that = this;
            var uri = new URI(url).getAbsoluteURI(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL);
            var onload = function (e, image) {
                if (that.textureEntry) {
                    that.textureEntry.setImage(image, true);
                }
            };
            var onerror = function (e, image) {
                XML3D.debug.logError("Could not load image URI=" + image.src);
            };
            this.image = Resource.getImage(uri, onload, onerror);
            if (that.textureEntry) {
                that.textureEntry.setImage(this.image, true);
            }
        },

        /**
         * @param {Xflow.TextureEntry} entry
         */
        setTextureEntry: function (entry) {
            this.textureEntry = entry;
            if (this.image) {
                this.textureEntry.setImage(this.image, true);
            }
        },

        attributeChangedCallback: function (name, oldValue, newValue) {
            if (name == "src") {
                this.createImageFromURL(newValue);
            }
        },

        notifyChanged: function (evt) {
        },

        getValue: function (cb, obj) {
            return this.image;
        },

        getOutputs: function () {
            var result = {};
            result['image'] = this;
            return result;
        },

        resolveScript: function () {
            return null;
        }
    });

    var VideoDataAdapter = function(factory, node) {
        DataAdapter.call(this, factory, node);
        this.textureEntry = null;
        this.video = null;
        this._ticking = false;
        this._boundTick = this._tick.bind(this);
        if (node.src)
            this.createVideoFromURL(node.src);
    };
    createClass(VideoDataAdapter, NodeAdapter);

    /**
     * Creates a new video object
     *
     * @param {string} url
     */
    VideoDataAdapter.prototype.createVideoFromURL = function(url) {
        var that = this;
        var uri = new URI(url).getAbsoluteURI(this.node.ownerDocument._documentURL || this.node.ownerDocument.URL);
        this.video = Resource.getVideo(uri, this.node.autoplay, this.node.loop,
            {
                canplay : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'canplay', true, true, null);
                    that._startVideoRefresh();
                },
                ended : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'ended', true, true, null);
                },
                load : function(event, video) {
                    Util.dispatchEvent(that.node, 'load');
                },
                error : function(event, video) {
                    Util.dispatchCustomEvent(that.node, 'error', true, true, null);
                    XML3D.debug.logError("Could not load video URI="+video.src);
                }
            }
        );
        if (this.textureEntry)
            this.textureEntry.setImage(this.video, true);
    };

    VideoDataAdapter.prototype.play = function() {
        if (this.video)
            this.video.play();
    };

    VideoDataAdapter.prototype.pause = function() {
        if (this.video)
            this.video.pause();
    };

    VideoDataAdapter.prototype._startVideoRefresh = function() {
        if (!this._ticking)
            this._tick();
    };

    VideoDataAdapter.prototype._tick = function() {
        this._ticking = true;
        window.requestAnimationFrame(this._boundTick);
        // FIXME Do this only when currentTime is changed (what about webcam ?)
        if (this.textureEntry) {
            this.textureEntry.setImage(this.video);
        }
    };

    /**
     * @param {Xflow.TextureEntry} entry
     */
    VideoDataAdapter.prototype.setTextureEntry = function(entry) {
        this.textureEntry = entry;
        if (this.video) {
            this.textureEntry.setImage(this.video, true);
        }
    };

    VideoDataAdapter.prototype.notifyChanged = function(evt) {
    };

    VideoDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
        if (name == "src") {
            this.createVideoFromURL(newValue);
        }
    };

    VideoDataAdapter.prototype.getValue = function(cb, obj) {
        return this.video;
    };

    VideoDataAdapter.prototype.getOutputs = function() {
        var result = {};
        result['video'] = this;
        return result;
    };

    // Export
    module.exports = {
        ImgDataAdapter: ImgDataAdapter,
        VideoDataAdapter: VideoDataAdapter,
        SinkDataAdapter: SinkDataAdapter
    };


},{"../../base/adapter.js":43,"../../base/resourcemanager.js":46,"../../interface/notification.js":71,"../../utils/misc.js":174,"../../utils/uri.js":176,"./data.js":53}],59:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var createClass = XML3D.createClass;
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

var ScriptDataAdapter = function(factory, node) {
    NodeAdapter.call(this, factory, node);
    this.connectedAdapterHandle = null;
    if (node.src) {
        this.connectedAdapterHandle = this.getAdapterHandle(node.src);
        this.connectAdapterHandle(node.name, this.connectedAdapterHandle);
    }
};

createClass(ScriptDataAdapter, NodeAdapter, {

    getScriptType: function () {
        return this.node.type;
    },

    getScript: function () {
        if (this.node.src) {
            return this.externalScript;
        } else {
            return this.node.value;
        }
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        this.notifyOppositeAdapters();
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.NODE_INSERTED:
            case Events.NODE_REMOVED:
            case Events.VALUE_MODIFIED:
                this.notifyOppositeAdapters();
                break;

            case Events.ADAPTER_HANDLE_CHANGED:
                this.externalScript = evt.adapter.script;
                this.notifyOppositeAdapters();
                break;
        }
    }
});

module.exports = ScriptDataAdapter;

},{"../../base/adapter.js":43,"../../interface/notification.js":71}],60:[function(require,module,exports){
var TextureEntry = require("../../xflow/interface/data.js").TextureEntry;
var InputNode = require("../../xflow/interface/graph.js").InputNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

var defaults = require('lodash.defaults');
var assign = require('lodash.assign');


var TextureDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};

XML3D.createClass(TextureDataAdapter, NodeAdapter, {

    init: function () {
        this.xflowInputNode = this.createXflowNode();
        this.xflowInputNode.data = this.createTextureEntry();
    },

    createTextureEntry: function () {
        var node = this.node;
        var entry = new TextureEntry(null);
        initTextureSamplingParameters(entry.getSamplerConfig(), node.getAttribute("wrap"), node.getAttribute("filter"), node.getAttribute("anisotropy"));

        var imageAdapter = this.factory.getAdapter(this.node.firstElementChild);
        if (imageAdapter) {
            imageAdapter.setTextureEntry(entry);
        }
        return entry;
    },

    shouldGenerateMipMaps: shouldGenerateMipMaps,

    /**
     *
     * @returns {InputNode}
     */
    createXflowNode: function () {
        var xnode = new InputNode();
        xnode.name = this.node.name;
        xnode.paramName = this.node.param ? this.node.name : null;
        xnode.key = this.node.key;
        return xnode;
    },

    setScriptValue: function () {
        XML3D.debug.logError("Texture currently does not support setScriptValue()");
    },

    getOutputs: function () {
        var result = {};
        result[this.node.name] = this;
        return result;
    },

    getValue: function () {
        return this.value;
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        switch (name) {
            case "name":
                this.xflowInputNode.name = newValue;
                break;
            case "param":
                this.xflowInputNode.paramName = newValue ? this.node.name : null;
                break;
            case "key":
                this.xflowInputNode.key = newValue;
                break;
            case "wrap":
            case "filter":
            case "samples":
                this.xflowInputNode.data = this.createTextureEntry();
                break;
        }
    },

    notifyChanged: function () { /* Nothing to do */
    },

    /**
     * @return {Element}
     */
    getXflowNode: function () {
        return this.xflowInputNode;
    }

});

var wrapToGL = {
    "clamp":  WebGLRenderingContext.CLAMP_TO_EDGE,
    "repeat": WebGLRenderingContext.REPEAT
};

var filterToGL = {
    "nearest": WebGLRenderingContext.NEAREST,
    "linear": WebGLRenderingContext.LINEAR,
    "nearest-mipmap-nearest": WebGLRenderingContext.NEAREST_MIPMAP_NEAREST,
    "linear-mipmap-nearest": WebGLRenderingContext.LINEAR_MIPMAP_NEAREST,
    "nearest-mipmap-linear": WebGLRenderingContext.NEAREST_MIPMAP_LINEAR,
    "linear-mipmap-linear": WebGLRenderingContext.LINEAR_MIPMAP_LINEAR
};

function shouldGenerateMipMaps(minFilter, magFilter) {
    return (minFilter != WebGLRenderingContext.NEAREST && minFilter != WebGLRenderingContext.LINEAR) || (magFilter != WebGLRenderingContext.NEAREST && magFilter != WebGLRenderingContext.LINEAR);
}

function parseTextureSamplingParameters(wrap, filter, anisotropy) {
    var result = {}, args;

    if(wrap) {
        args = wrap.split(/(\s+)/);
        result.wrapS = wrapToGL[args[0]];
        result.wrapT = wrapToGL[args[args.length - 1]];
    }

    if(filter) {
        args = filter.split(/(\s+)/);
        result.minFilter = filterToGL[args[0]];
        result.magFilter = filterToGL[args[args.length - 1]];
    }

    if(anisotropy) {
        var number = parseFloat(anisotropy);
        if (number == Number.NaN) {
            number = anisotropy == "max" ? Infinity : undefined
        } else {
            number = Math.min(1.0, number)
        }
        result.anisotropy = number;
    }

    return result;
}

function initTextureSamplingParameters(config, wrap, filter, samples) {
    var params = parseTextureSamplingParameters(wrap, filter, samples);
    defaults(params, {
        wrapS: WebGLRenderingContext.CLAMP_TO_EDGE,
        wrapT: WebGLRenderingContext.CLAMP_TO_EDGE,
        minFilter: WebGLRenderingContext.LINEAR_MIPMAP_LINEAR,
        magFilter: WebGLRenderingContext.LINEAR,
        textureType: XC.TEX_TYPE.TEXTURE_2D,
        anisotropy: 1
    });
    assign(config, params);
    config.generateMipMap = shouldGenerateMipMaps(config.minFilter, config.magFilter);
}

// Export
module.exports = TextureDataAdapter;

},{"../../base/adapter.js":43,"../../interface/notification.js":71,"../../xflow/interface/constants.js":179,"../../xflow/interface/data.js":180,"../../xflow/interface/graph.js":181,"lodash.assign":17,"lodash.defaults":37}],61:[function(require,module,exports){
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;
var mat4 = require("gl-matrix").mat4;
var vec3 = require("gl-matrix").vec3;

var TransformDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.isValid = true;
    this.needsUpdate = true;
};

XML3D.createClass(TransformDataAdapter, NodeAdapter);

var IDENT_MAT = mat4.create();

TransformDataAdapter.prototype.init = function () {
    // Create all matrices, no valid values yet
    this.matrix = mat4.create();
    this.transform = {
        translate: mat4.create(),
        scale: mat4.create(),
        scaleOrientation: mat4.create(),
        scaleOrientationInv: mat4.create(),
        center: mat4.create(),
        centerInverse: mat4.create(),
        rotation: mat4.create()
    };
    this.needsUpdate = true;
    this.checkForImproperNesting();
};

TransformDataAdapter.prototype.updateMatrix = function () {
    var n = this.node;
    var transform = this.transform;
    var centerVec = n.center.data;
    var so = n.scaleOrientation.data;
    var ro = n.rotation.data;

    mat4.fromRotation(transform.scaleOrientation, so[3], so);
    mat4.fromRotation(transform.rotation, ro[3], ro);

    mat4.translate(transform.translate, IDENT_MAT, n.translation.data);
    mat4.translate(transform.center, IDENT_MAT, centerVec);
    mat4.translate(transform.centerInverse, IDENT_MAT, vec3.negate(centerVec, centerVec));
    mat4.scale(transform.scale, IDENT_MAT, n.scale.data);
    mat4.invert(transform.scaleOrientationInv, transform.scaleOrientation);

    multiplyComponents(transform, this.matrix);
    this.needsUpdate = false;
};

function multiplyComponents(transform, matrix) {
    // M = T * C
    mat4.multiply(matrix, transform.translate, transform.center);
    // M = T * C * R
    mat4.multiply(matrix, matrix, transform.rotation);
    // M = T * C * R * SO
    mat4.multiply(matrix, matrix, transform.scaleOrientation);
    // M = T * C * R * SO * S
    mat4.multiply(matrix, matrix, transform.scale);
    // M = T * C * R * SO * S * -SO
    mat4.multiply(matrix, matrix, transform.scaleOrientationInv);
    // M = T * C * R * SO * S * -SO * -C
    mat4.multiply(matrix, matrix, transform.centerInverse);
}

TransformDataAdapter.prototype.getMatrix = function () {
    this.needsUpdate && this.updateMatrix();
    return this.matrix;
};

TransformDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
   this.needsUpdate = true;
   this.notifyOppositeAdapters(Events.ADAPTER_VALUE_CHANGED);
};

TransformDataAdapter.prototype.notifyChanged = function (e) {
    if (e.type == Events.NODE_REMOVED) {
        this.dispose();
        this.notifyOppositeAdapters(Events.ADAPTER_HANDLE_CHANGED);
    }
};
TransformDataAdapter.prototype.dispose = function () {
    this.isValid = false;
};

TransformDataAdapter.prototype.checkForImproperNesting = function () {
    for (var i = 0; i < this.node.childNodes.length; i++) {
        if (this.node.childNodes[i].localName === "transform") {
            XML3D.debug.logError("Parsing error: Transform elements cannot be nested!", this.node);
        }
    }
};

// Export to XML3D.data namespace
module.exports = TransformDataAdapter;




},{"../../base/adapter.js":43,"../../interface/notification.js":71,"gl-matrix":1}],62:[function(require,module,exports){
var BufferEntry = require("../../xflow/interface/data.js").BufferEntry;
var InputNode = require("../../xflow/interface/graph.js").InputNode;
var XC = require("../../xflow/interface/constants.js");
var Events = require("../../interface/notification.js");
var NodeAdapter = require("../../base/adapter.js").NodeAdapter;

/**
 * Constructor of XML3D.data.ValueDataAdapter
 *
 * @extends XML3D.data.DataAdapter
 * @constructor
 *
 * @param factory
 * @param {Element} node
 */
var ValueDataAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
    this.xflowInputNode = null;
};
XML3D.createClass(ValueDataAdapter, NodeAdapter);

ValueDataAdapter.prototype.init = function()
{
    var config = this.node._configured, value;
    if(this.node.textContent == "[value set by script]"){
        value = config.scriptValue;
    }
    else{
        delete config.scriptValue;
        value = this.node.value;
    }

    var type = XC.DATA_TYPE.fromString(this.node.localName);
    var buffer = new BufferEntry(type, value);

    this.xflowInputNode = new InputNode(null);
    this.xflowInputNode.name = this.node.name;
    this.xflowInputNode.data = buffer;
    this.xflowInputNode.key = this.node.key;
    this.xflowInputNode.paramName = this.node.param ? this.node.name : null;
    this.checkForImproperNesting();
};

ValueDataAdapter.prototype.getXflowNode = function () {
    return this.xflowInputNode;
};

/**
 *
 */
ValueDataAdapter.prototype.notifyChanged = function (evt) {
    if (evt.type == Events.VALUE_MODIFIED) {
        var attr = evt.mutation.attributeName;
        if (!attr) {
            delete this.node._configured.scriptValue;
            this.xflowInputNode.data.setValue(this.node.value);
        }
    }
};

ValueDataAdapter.prototype.attributeChangedCallback = function (name, oldValue, newValue) {
    if (name == "name") {
        this.xflowInputNode.name = newValue;
    } else if (name == "key") {
        this.xflowInputNode.key = newValue;
    } else if (name == "param") {
        this.xflowInputNode.paramName = newValue ? this.node.name : null;
    }
};


ValueDataAdapter.prototype.setScriptValue = function (value) {
    // TODO: Add Type check
    this.xflowInputNode.data.setValue(value);
};

/**
 * Returns String representation of this DataAdapter
 */
ValueDataAdapter.prototype.toString = function () {
    return "XML3D.data.ValueDataAdapter";
};

ValueDataAdapter.prototype.checkForImproperNesting = function() {
    for (var i=0; i < this.node.childNodes.length; i++) {
        if (XC.DATA_TYPE.fromString(this.node.childNodes[i].localName)) {
            XML3D.debug.logError("Parsing error: Value elements cannot be nested!", this.node);
        }
    }
};

// Export
module.exports = ValueDataAdapter;

},{"../../base/adapter.js":43,"../../interface/notification.js":71,"../../xflow/interface/constants.js":179,"../../xflow/interface/data.js":180,"../../xflow/interface/graph.js":181}],63:[function(require,module,exports){
var ComputeRequest = require("../xflow/interface/request.js").ComputeRequest;
var Events = require("../interface/notification.js");
var CSS = require("../utils/css.js");
var mat4 = require("gl-matrix").mat4;

var DOMTransformFetcher = function (owner, attrName, dataName, onlyDataTransform) {
    this.owner = owner;
    this.node = owner.node;
    this.attrName = attrName;
    this.dataName = dataName;
    this.adapterHandle = null;
    this.xflowRequest = null;
    this.onlyDataTransform = onlyDataTransform || false;
    this._bindedCallback = this._onChange.bind(this);
};
DOMTransformFetcher.prototype.clear = function () {
    this.xflowRequest && this.xflowRequest.clear();
    this.xflowRequest = null;
    this.adapterHandle && this.adapterHandle.removeListener(this._bindedCallback)
};

DOMTransformFetcher.prototype.update = function () {
    var newHandle = this.owner.getAdapterHandle(this.node.getAttribute(this.attrName), "data", 0);
    if (newHandle != this.adapterHandle) {
        this.clear();
        this.adapterHandle = newHandle;
        if (newHandle)
            newHandle.addListener(this._bindedCallback)
    }
    this.updateMatrix();
};

DOMTransformFetcher.prototype.updateMatrix = function () {
    this.owner.onTransformChange(this.attrName, this.getMatrix());
};

DOMTransformFetcher.prototype.getMatrix = ( function () {
    var IDENTITY = mat4.create();

    return function () {
        if (!this.onlyDataTransform) {
            var cssMatrix = CSS.getCSSMatrix(this.node);
            if (cssMatrix) {
                return CSS.convertCssToMat4(cssMatrix).data;
            }
        }
        var adapter;
        if (this.adapterHandle && (adapter = this.adapterHandle.getAdapter())) {
            if (adapter.getXflowNode) {
                if (!this.xflowRequest)
                    this.xflowRequest = new ComputeRequest(adapter.getXflowNode(), [this.dataName], this._bindedCallback);
                var dataResult = this.xflowRequest.getResult();
                var transformData = (dataResult.getOutputData(this.dataName) && dataResult.getOutputData(this.dataName).getValue());
                if (transformData)
                    return transformData;
            }
            if (adapter.getMatrix) {
                return adapter.getMatrix();
            }
        }
        return this.onlyDataTransform ? null : IDENTITY;
    };
}());

DOMTransformFetcher.prototype._onChange = function (evt) {
    if (evt.type == Events.ADAPTER_VALUE_CHANGED) {
        this.owner.onTransformChange(this.attrName, evt.adapterHandle.getAdapter().getMatrix());
    } else { // If the adapter changed, we need to re-evaluate the matrix
        this.updateMatrix();
    }
};

module.exports = DOMTransformFetcher;

},{"../interface/notification.js":71,"../utils/css.js":171,"../xflow/interface/request.js":182,"gl-matrix":1}],64:[function(require,module,exports){
var assign = require("lodash.assign");
var create = require("lodash.create");

if (window.XML3D !== undefined) {
    throw new Error("Tried to define the XML3D namespace a second time. Please ensure xml3d.js is only loaded once!");
}
/** @namespace * */
var XML3D = XML3D || {};
var Xflow = Xflow || {};
window.XML3D = XML3D;
window.Xflow = Xflow;

XML3D.version = 'DEVELOPMENT SNAPSHOT (29.07.2015 09:58:03 GMT+0200)';
/** @const */
XML3D.xml3dNS = 'http://www.xml3d.org/2009/xml3d';
/** @const */
XML3D.xhtmlNS = 'http://www.w3.org/1999/xhtml';
/** @const */
XML3D.webglNS = 'http://www.xml3d.org/2009/xml3d/webgl';
XML3D._xml3d = document.createElementNS(XML3D.xml3dNS, "xml3d");
XML3D._parallel = XML3D._parallel != undefined ? XML3D._parallel : false;
XML3D.xhtml = !!(document.doctype && new XMLSerializer().serializeToString(document.doctype).match(/xhtml/i));

XML3D.createElement = function(tagName) {
    return document.createElementNS(XML3D.xml3dNS, tagName);
};

XML3D.extend = assign;

/**
 *
 * @param {Object} obj Constructor
 * @param {Object} parent Parent class
 * @param {Object=} methods Methods to add to the class
 * @return {Object!}
 */
XML3D.createClass = function(obj, parent, methods) {
    if(!parent) {
        assign(obj.prototype, methods);
    } else {
        obj.prototype = create(parent.prototype, methods);
    }
    return obj;
};

XML3D.debug = require("./utils/debug.js");
XML3D.util = require("./utils/misc.js");
XML3D.options = require("./utils/options.js");
XML3D.materials = require("./renderer/webgl/materials/urn/registery.js");
XML3D.resource = require("./base/resourcemanager.js").Resource; //Required for the test library because the RM needs to "belong" to the same document as the XML3D element in order to resolve references correctly
XML3D.resource.registerFormat = require("./base/resourcemanager.js").registerFormat;
//XML3D.resource.FormatHandler
//XML3D.resource.JSONFormatHandler
//XML3D.resource.AdapterFactory
XML3D.webcl = require("./utils/webcl.js").webcl;
XML3D.math = require("gl-matrix");
XML3D.math.bbox = require("./math/bbox.js");
XML3D.math.ray = require("./math/ray.js");
require("./math/math.js")(XML3D.math);

XML3D.Mat2 = require("./types/mat2.js");
XML3D.Mat3 = require("./types/mat3.js");
XML3D.Mat4 = require("./types/mat4.js");
XML3D.Vec2 = require("./types/vec2.js");
XML3D.Vec3 = require("./types/vec3.js");
XML3D.Vec4 = require("./types/vec4.js");
XML3D.AxisAngle = require("./types/axisangle.js");
XML3D.Quat = require("./types/quat.js");
XML3D.Ray = require("./types/ray.js");
XML3D.Box = require("./types/box.js");

XML3D.extend(window, require("./types/data-observer.js"));

Xflow.registerOperator = require("./xflow/operator/operator.js").registerOperator;
Xflow.constants = require("./xflow/interface/constants.js");
XML3D.extend(Xflow, require("./xflow/interface/graph.js"));
XML3D.extend(Xflow, require("./xflow/interface/data.js"));
Xflow.ComputeRequest = require("./xflow/interface/request.js").ComputeRequest;

require("./xflow/operator/default");

module.exports = {
    XML3D : XML3D,
    Xflow : Xflow
};

},{"./base/resourcemanager.js":46,"./math/bbox.js":73,"./math/math.js":74,"./math/ray.js":75,"./renderer/webgl/materials/urn/registery.js":131,"./types/axisangle.js":159,"./types/box.js":160,"./types/data-observer.js":161,"./types/mat2.js":162,"./types/mat3.js":163,"./types/mat4.js":164,"./types/quat.js":165,"./types/ray.js":166,"./types/vec2.js":167,"./types/vec3.js":168,"./types/vec4.js":169,"./utils/debug.js":173,"./utils/misc.js":174,"./utils/options.js":175,"./utils/webcl.js":177,"./xflow/interface/constants.js":179,"./xflow/interface/data.js":180,"./xflow/interface/graph.js":181,"./xflow/interface/request.js":182,"./xflow/operator/default":199,"./xflow/operator/operator.js":219,"gl-matrix":1,"lodash.assign":17,"lodash.create":28}],65:[function(require,module,exports){
var XML3D = require("./global.js").XML3D;
var Config = require("./interface/elements.js").config;
var sendAdapterEvent = require("./utils/misc.js").sendAdapterEvent;
var Options = require("./utils/options.js");
var CSS = require("./utils/css.js");
var ConfigureRenderer = require("./renderer/renderer/configure.js");
var WebglSupported = require("./renderer/webgl/base/utils.js").supported;
require("./interface/dom.js");
require("./utils/debug.js");

(function () {
    if (navigator.userAgent.match(/(iPad|iPhone|iPod touch)/i)) {
        var m = document.createElement("meta");
        m.name = "format-detection";
        m.content = "telephone=no";
        document.head.appendChild(m)
    }
}());

function displayWebGLNotSupportedInfo(xml3dElement){

    if(xml3dElement.hasAttribute("onunsupported")){
        var callback = new Function("event", xml3dElement.getAttribute("onunsupported"));
        xml3dElement.addEventListener('unsupported', callback, false);
    }
    var doDefault = XML3D.util.dispatchCustomEvent(xml3dElement, 'unsupported', false, true, null);
    if(doDefault){
        // Place xml3dElement inside an invisible div
        var hideDiv = document.createElementNS(XML3D.xhtmlNS, 'div');

        xml3dElement.parentNode.insertBefore(hideDiv, xml3dElement);
        hideDiv.appendChild(xml3dElement);
        //hideDiv.style.display = "none";

        var infoDiv = document.createElementNS(XML3D.xhtmlNS, 'div');
        if(xml3dElement.hasAttribute("class")){
            infoDiv.setAttribute("class", xml3dElement.getAttribute("class"));
        }

        infoDiv.setAttribute("style", xml3dElement.getAttribute("style"));
        infoDiv.style.border = "2px solid red";
        infoDiv.style.fontFamily = "verdana,sans-serif";
        infoDiv.style.color = "red";
        infoDiv.style.padding = "10px";
        infoDiv.style.backgroundColor = "rgba(255, 0, 0, 0.3)";

        var width = xml3dElement.getAttribute("width");
        if (width !== null) {
            infoDiv.style.width = width;
        }

        var height = xml3dElement.getAttribute("height");
        if (height !== null) {
            infoDiv.style.height = height;
        }

        var hElement = document.createElement("h3");
        var hTxt = document.createTextNode("Sorry, your browser doesn't appear to support XML3D.");
        hElement.appendChild(hTxt);

        var pElement = document.createElement("p");
        pElement.appendChild(document.createTextNode("Please visit "));
        var link = document.createElement("a");
        link.setAttribute("href", "http://www.xml3d.org/help");
        link.appendChild(document.createTextNode("http://www.xml3d.org/help"));
        pElement.appendChild(link);
        pElement.appendChild(document.createTextNode(" for more information."));
        infoDiv.appendChild(hElement);
        infoDiv.appendChild(pElement);

        hideDiv.parentNode.insertBefore(infoDiv, hideDiv);
    }

}

/*  a list of elements that are currently initialized. More specifically,
 *  they're currently in a call to the method below.
 *
 *  Why?
 *  In webgl we actually reattach the xml3d element in the DOM. Thus, when
 *  we're in the middle of working on a onNodeInserted event, there will probably
 *  come right another event which we actually don't care for.
 *  So we use this list to keep track of which elements are currently initializing.
 */
var curXML3DInitElements = [];

/**
 * @param {Element} xml3dElement
 */
function initXML3DElement(xml3dElement) {
    if(-1 < curXML3DInitElements.indexOf(xml3dElement))
        return;

    curXML3DInitElements.push(xml3dElement);

    var debug = XML3D.debug.setup();

    if (!WebglSupported()) {
        debug && XML3D.debug.logWarning("Could not initialise WebGL, sorry :-(");
        displayWebGLNotSupportedInfo(xml3dElement);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }

    XML3D.debug.logInfo("Configuring", xml3dElement.querySelectorAll("*").length, "elements");

    try {
        Config.configure(xml3dElement);
    } catch (e) {
        debug && XML3D.debug.logException(e);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }
    try {
        ConfigureRenderer(xml3dElement);
    } catch (e) {
        debug && XML3D.debug.logException(e);
        curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
        return;
    }

    // initialize all attached adapters
    sendAdapterEvent(xml3dElement, {onConfigured : []});

    curXML3DInitElements.splice(curXML3DInitElements.indexOf(xml3dElement), 1);
    clearObserver();
}

/**
 * @param {Element} xml3dElement
 */
function destroyXML3DElement(xml3dElement)
{
    if(-1 < curXML3DInitElements.indexOf(xml3dElement))
        return;

    xml3dElement._configured = undefined;

    if(!xml3dElement.parentNode)
        return; // already removed

    var canvas = xml3dElement.parentNode.previousElementSibling;

    var grandParentNode = xml3dElement.parentNode.parentNode;
    if(!grandParentNode)
        return; // subtree containing canvas is not attached, can't remove it

    if(!canvas || canvas.tagName !== "canvas")
        return; // an element we didn't create, skip deletion

    grandParentNode.removeChild(xml3dElement.parentNode);
    grandParentNode.removeChild(canvas);
}

/**
 * @param {Event} evt
 */
function onNodeInserted(evt) {

    if(evt.target.tagName === "xml3d") {
        initXML3DElement(evt.target);
    }
}

/**
 * @param {Event} evt
 */
function onNodeRemoved(evt) {

    if(evt.target.tagName === "xml3d") {
        destroyXML3DElement(evt.target);
    }
}

var observer = null;

function onLoad() {

    Options.setOptionsFromQuery();

    CSS.init();

    var debug = XML3D.debug.setup();
    debug && XML3D.debug.logInfo("xml3d.js version: " + XML3D.version);

    /**
     * Find all the XML3D tags in the document
     * @type {NodeList}
     */
    var xml3ds = document.querySelectorAll("xml3d");

    debug && XML3D.debug.logInfo("Found " + xml3ds.length + " xml3d node(s)");

    for(var i = 0; i < xml3ds.length; i++) {
        initXML3DElement(xml3ds[i]);
    }

    // TODO(ksons): Remove this, no MutationObserver no XML3D
    if(!MutationObserver){
        document.addEventListener('DOMNodeInserted', onNodeInserted, false);
        document.addEventListener('DOMNodeRemoved', onNodeRemoved, false);
    }
    else{
        observer = new MutationObserver(resolveMutations);
        observer.observe(document.documentElement, { childList: true, subtree: true, attributes: true, attributeFilter: [ "class", "id", "style" ] } );
    }
}

function onUnload() {
    if (XML3D.document)
        XML3D.document.onunload();
}



function resolveMutations(mutations){
    for(var i = 0; i < mutations.length; ++i){
        var mutation = mutations[i];
        if(mutation.type == 'childList'){
            var addedNodes = mutation.addedNodes;
            var j = addedNodes.length;
            while(j--){
                if(addedNodes[j].tagName == "xml3d")
                    initXML3DElement(addedNodes[j]);
            }
            var removedNodes = mutation.removedNodes;
            var j = removedNodes.length;
            while(j--) {
                if(removedNodes[j].tagName == "xml3d")
                    destroyXML3DElement(removedNodes[j]);
            }

        } else if (mutation.type == 'attributes') {
            var mutationTarget = mutation.target;
            if (mutation.attributeName === "id" || mutation.attributeName === "class")
                mutationTarget = mutation.target.parentNode;
            var cssTarget = mutationTarget._configured ? mutationTarget : mutationTarget.querySelector("xml3d");
            if(cssTarget && cssTarget._configured) { // xml3d is a child node
                var adaptersNames = Object.keys(cssTarget._configured.adapters).filter(function(a) {
                    return a.indexOf("webgl") == 0;
                });
                adaptersNames.map(function(name){return cssTarget._configured.adapters[name];}).forEach(function(renderAdapter) {
                    renderAdapter.traverse(function(adapter) {
                        adapter.styleChangedCallback();
                    })

                });

            }

        }
    }
}

XML3D.flushCSSChanges = function(){
    if(observer){
        resolveMutations(observer.takeRecords());
    }
}
function clearObserver(){
    if(observer){
        observer.takeRecords();
    }
}


document.addEventListener('DOMContentLoaded', onLoad, false);
window.addEventListener('unload', onUnload, false);
window.addEventListener('reload', onUnload, false);

module.exports = XML3D;


},{"./global.js":64,"./interface/dom.js":68,"./interface/elements.js":69,"./renderer/renderer/configure.js":89,"./renderer/webgl/base/utils.js":116,"./utils/css.js":171,"./utils/debug.js":173,"./utils/misc.js":174,"./utils/options.js":175}],66:[function(require,module,exports){
var Resource = require("../base/resourcemanager.js").Resource;

var string2bool = function(string) {
    if (!string) {
        return false;
    }
    switch (string.toLowerCase()) {
    case "true":
    case "1":
        return true;
    case "false":
    case "0":
        return false;
    default:
        return Boolean(string);
    }
};
var handlers = {};

function getStorage(elem){
    return elem._configured.storage;
}

var AttributeHandler = function(elem) {
};

handlers.IDHandler = function(id) {
    id = id.toLowerCase();
    this.setFromAttribute = function(value, prevValue, elem) {
        Resource.notifyNodeIdChange(elem, prevValue, value);
    };
    this.desc = {
        get : function() {
            return this.getAttribute(id) || "";
        },
        set : function(value) {
            this.setAttribute(id, value);
        }
    };
};

handlers.StringAttributeHandler = function(id) {
    id = id.toLowerCase();
    this.desc = {
        get : function() {
            return this.getAttribute(id) || "";
        },
        set : function(value) {
            this.setAttribute(id, value);
        }
    };
};

handlers.EnumAttributeHandler = function(id, enumObj) {
    AttributeHandler.call(this);
    id = id.toLowerCase();

    this.init = function(elem, storage){
        storage[id] = enumObj.defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };
    this.setFromAttribute = function(v, prevValue, elem, storage) {
        var value = v.toLowerCase();
        storage[id] = (value && enumObj.values[value] !== undefined) ? enumObj.values[value] : enumObj.defaultValue;
        return false;
    };
    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return enumObj.values[storage[id]];
        },
        set : function(v) {
                // Attribute is set to whatever comes in
            this.setAttribute(id, v);
            var storage = getStorage(this);
            var value = typeof v == 'string' ? v.toLowerCase() : undefined;
            if (value && enumObj.values[value] !== undefined)
                storage[id] = enumObj.values[value];
            else
                storage[id] = enumObj.defaultValue;
        }
    };
};
handlers.EnumAttributeHandler.prototype = new AttributeHandler();
handlers.EnumAttributeHandler.prototype.constructor = handlers.EnumAttributeHandler;

handlers.EventAttributeHandler = function(id) {
    AttributeHandler.call(this);
    id = id.toLowerCase();
    var eventType = id.substring(2);

    this.init = function(elem, storage){
        storage[id] = null;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        if(storage[id] != null)
            elem.removeEventListener(eventType, storage[id]);
        if(!value){
            storage[id] = null;
        }
        else{
            storage[id] = eval("crx = function " + id + "(event){\n  " + value + "\n}");
            if (XML3D.xhtml) {
                // only XHTML documents require this polyfill for mouse event attributes
                elem.addEventListener(eventType, storage[id], false);
            }
        }
        return false;
    };
    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            if(XML3D.xhtml && storage[id]) this.removeEventListener(eventType, storage[id]);
            storage[id] = (typeof value == 'function') ? value : undefined;
            if(XML3D.xhtml && storage[id]) this.addEventListener(eventType, storage[id], false);
            return false;
        }
    };
};

handlers.EventAttributeHandler.prototype = new AttributeHandler();
handlers.EventAttributeHandler.prototype.constructor = handlers.EventAttributeHandler;

handlers.IntAttributeHandler = function(id, defaultValue) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var v = value.match(/^\d+/);
        if (!v || isNaN(+v[0])) {
            XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
            elem.setAttribute(id, prevValue);
            storage[id] = defaultValue;
        } else {
            storage[id] =  +v[0];
        }
        if(elem._configured.canvas)
            elem._configured.canvas[id] = storage[id];
        return false;
    };

    this.desc = {
        get : function(){
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            var v = +value;
            if (isNaN(v)) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                storage[id] = defaultValue;
            } else {
                storage[id] =  Math.floor(v);
            }
            this.setAttribute(id, storage[id] + '');
        }
    };
};
handlers.IntAttributeHandler.prototype = new AttributeHandler();
handlers.IntAttributeHandler.prototype.constructor = handlers.IntAttributeHandler;

handlers.FloatAttributeHandler = function(id, defaultValue) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var v = +value;
        if (isNaN(v)) {
            XML3D.debug.logWarning("Invalid attribute value: " + value, elem);
            elem.setAttribute(id, prevValue);
            storage[id] = defaultValue;
        } else {
            storage[id] =  v;
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            var v = +value;
            if (isNaN(v)) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                storage[id] = defaultValue;
            } else {
                storage[id] =  v;
            }
            this.setAttribute(id, storage[id] + '');
        }
    };
};

handlers.BoolAttributeHandler = function(id, defaultValue) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        storage[id] = defaultValue;
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };
    this.setFromAttribute = function(value, prevValue, elem, storage) {
        storage[id] = string2bool(value);
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            return storage[id];
        },
        set : function(value) {
            var storage = getStorage(this);
            storage[id] = Boolean(value);
            this.setAttribute(id, storage[id] + '');
        }
    };
};

handlers.Vec3AttributeHandler = function(id, defaultValue) {
    var that = this;
    id = id.toLowerCase();

    this.init = function(elem, storage){
        storage[id] = null;
    };

    this.setFromAttribute = function(value, prevValue, elem, storage, init) {
        if (!storage[id]) {
            storage[id] = XML3D.math.vec3.create();
        }
        var v = storage[id];
        var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(value);
        if (!m  || isNaN(+m[1]) || isNaN(+m[2]) || isNaN(+m[3])) {
            v[0] = defaultValue[0];
            v[1] = defaultValue[1];
            v[2] = defaultValue[2];
            !init && XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
        } else {
            v[0] = +m[1];
            v[1] = +m[2];
            v[2] = +m[3];
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            return new XML3D.Vec3(storage[id]);
        },
        set : function(value) {
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            var v = storage[id];
            var val = value.data ? value.data : value;
            if (val.length !== 3 || isNaN(val[0]) || isNaN(val[1]) || isNaN(val[2])) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                v = defaultValue;
            } else {
                v[0] = val[0]; v[1] = val[1]; v[2] = val[2];
            }
            this.setAttribute(id, XML3D.math.vec3.toDOMString(v));
        }
    };
};

// Note: All vec4 attributes are considered to be axis-angle, NOT quaternions!
handlers.AxisAngleAttributeHandler = function(id, defaultValue) {
    var that = this;
    id = id.toLowerCase();

    this.init = function(elem, storage){
        storage[id] = null;
    };

    this.setFromAttribute = function(value, prevValue, elem, storage, init) {
        if (!storage[id]) {
            storage[id] = XML3D.math.vec4.create();
        }
        var v = storage[id];
        var m = /^\s*(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s*$/.exec(value);
        if (!m  || isNaN(+m[1]) || isNaN(+m[2]) || isNaN(+m[3]) || isNaN(+m[4])) {
            XML3D.math.vec4.copy(v, defaultValue);
            !init && XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, elem);
        } else {
            XML3D.math.vec4.set(v, +m[1], +m[2], +m[3], +m[4]);
        }
        return false;
    };

    this.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            return new XML3D.AxisAngle(storage[id]);
        },
        set : function(value) {
            var storage = getStorage(this);
            if (!storage[id]) {
                that.setFromAttribute(this.getAttribute(id), null, this, storage, true);
            }
            var v = storage[id];
            var val = value.data ? value.data : value;
            if (val.length !== 4 || isNaN(val[0]) || isNaN(val[1]) || isNaN(val[2]) || isNaN(val[3])) {
                XML3D.debug.logWarning("Invalid attribute ["+id+"] value: " + value, this);
                XML3D.math.vec4.copy(v, defaultValue);
            } else {
                XML3D.math.quat.copy(v, val);
            }
            this.setAttribute(id, XML3D.math.vec4.toDOMString(v));
        }
    };
};

var mixedContent = function(handler) {
    handler.init = function(elem, storage){
        elem._configured.registerMixed();
    };
    handler.desc = {
        get : function() {
            XML3D.flushDOMChanges();
            var storage = getStorage(this);
            if (!storage.value) {
                storage.value = handler.parse(this);
            }
            return storage.value;
        },
        set : function(value) {
            // Throw error?
            throw Error("Can't set " + this.nodeName + "::value: it's readonly");
        }
    };
    handler.resetValue = function(storage) { storage.value = null; };
};

var getContent = function(elem) {
    var str = "";
    var k = elem.firstChild;
    while (k) {
        str += k.nodeType == 3 ? k.textContent : " ";
        k = k.nextSibling;
    }
    return str;
};

handlers.FloatArrayValueHandler = function(id) {
    mixedContent(this);
};

handlers.FloatArrayValueHandler.prototype.parse = function(elem) {
    var exp = /([+\-0-9eE\.]+)/g;
    var str = getContent(elem);
    var m = str.match(exp);
    return m ? new Float32Array(m) : new Float32Array();
};

handlers.Float2ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float3ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float4ArrayValueHandler = handlers.FloatArrayValueHandler;
handlers.Float4x4ArrayValueHandler = handlers.FloatArrayValueHandler;

handlers.IntArrayValueHandler = function(id) {
    mixedContent(this);
};
handlers.IntArrayValueHandler.prototype.parse = function(elem) {
    var exp = /([+\-0-9]+)/g;
    var str = getContent(elem);
    var m = str.match(exp);
    return m ? new Int32Array(m) : new Int32Array();
};

handlers.BoolArrayValueHandler = function(id) {
    mixedContent(this);
};
handlers.BoolArrayValueHandler.prototype.parse = function(elem) {
    var exp = /(true|false|0|1)/ig;
    var str = getContent(elem);
    var m = str.match(exp);
    if (!m)
        return new Uint8Array();
    m = m.map(string2bool);
    return m ? new Uint8Array(m) : new Uint8Array();
};

handlers.StringValueHandler = function(id) {
    mixedContent(this);
};
handlers.StringValueHandler.prototype.parse = function(elem) {
    return elem.textContent;
};

handlers.CanvasStyleHandler = function(id, d) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        elem._configured.canvas.setAttribute(id, value);
    };

    this.desc = {
        get: function() { return this._configured.canvas.style; },
        set: function(value) {}
    };

};

handlers.CanvasClassHandler = function(id) {
    id = id.toLowerCase();
    this.init = function(elem, storage){
        var canvas = elem._configured.canvas;
        canvas.className = "_xml3d"; // Class name always defined for xml3d canvas
        if (elem.hasAttribute(id))
            this.setFromAttribute(elem.getAttribute(id), null, elem, storage);
    };

    this.setFromAttribute = function(value, prevValue, elem, storage) {
        var canvas = elem._configured.canvas;
        canvas.setAttribute(id, value + " _xml3d");
    };

    this.desc = {
        // TODO: Should we not strip the _xml3d class here?
        get: function() { return this._configured.canvas.className; },
        set: function(value) { this._configured.canvas.className = value; }
    };
};

module.exports = handlers;

},{"../base/resourcemanager.js":46}],67:[function(require,module,exports){
var methods = require("./methods.js");
var handlers = require("./attributes.js");
var properties = require("./properties.js");

// MeshTypes
var MeshTypes = {};
MeshTypes["triangles"] = 0;
MeshTypes[0] = "triangles";
MeshTypes["trianglestrips"] = 1;
MeshTypes[1] = "trianglestrips";
MeshTypes["lines"] = 2;
MeshTypes[2] = "lines";
MeshTypes["linestrips"] = 3;
MeshTypes[3] = "linestrips";
MeshTypes["points"] = 4;
MeshTypes[4] = "points";
// TextureTypes
var TextureTypes = {};
TextureTypes["2d"] = 0;
TextureTypes[0] = "2d";
TextureTypes["1d"] = 1;
TextureTypes[1] = "1d";
TextureTypes["3d"] = 2;
TextureTypes[2] = "3d";

// PlatformTypes
var PlatformTypes = {};
PlatformTypes["auto"] = 1;
PlatformTypes[1] = "auto";
PlatformTypes["js"] = 2;
PlatformTypes[2] = "js";
PlatformTypes["gl"] = 3;
PlatformTypes[3] = "gl";
PlatformTypes["cl"] = 4;
PlatformTypes[4] = "cl";
// DataFieldType
var DataFieldType = {};
DataFieldType["float "] = 0;
DataFieldType[0] = "float ";
DataFieldType["float2 "] = 1;
DataFieldType[1] = "float2 ";
DataFieldType["float3"] = 2;
DataFieldType[2] = "float3";
DataFieldType["float4"] = 3;
DataFieldType[3] = "float4";
DataFieldType["float4x4"] = 4;
DataFieldType[4] = "float4x4";
DataFieldType["int"] = 10;
DataFieldType[10] = "int";
DataFieldType["int4"] = 11;
DataFieldType[11] = "int4";
DataFieldType["bool"] = 20;
DataFieldType[20] = "bool";
DataFieldType["texture"] = 30;
DataFieldType[30] = "texture";
// DataChannelOrigin
var DataChannelOrigin = {};
DataChannelOrigin["origin_value "] = 0;
DataChannelOrigin[0] = "origin_value ";
DataChannelOrigin["origin_child"] = 1;
DataChannelOrigin[1] = "origin_child";
DataChannelOrigin["origin_source"] = 2;
DataChannelOrigin[2] = "origin_source";
DataChannelOrigin["origin_compute"] = 3;
DataChannelOrigin[3] = "origin_compute";
DataChannelOrigin["origin_proto"] = 4;
DataChannelOrigin[4] = "origin_proto";

var classInfo = {};

/**
 * Properties and methods for <xml3d>
 **/
classInfo['xml3d'] = {
    id : {a: handlers.IDHandler},
    className : {a: handlers.CanvasClassHandler, id: 'class'},
    style : {a: handlers.CanvasStyleHandler},
    onclick : {a: handlers.EventAttributeHandler},
    ondblclick : {a: handlers.EventAttributeHandler},
    onmousedown : {a: handlers.EventAttributeHandler},
    onmouseup : {a: handlers.EventAttributeHandler},
    onmouseover : {a: handlers.EventAttributeHandler},
    onmousemove : {a: handlers.EventAttributeHandler},
    onmouseout : {a: handlers.EventAttributeHandler},
    onkeypress : {a: handlers.EventAttributeHandler},
    onkeydown : {a: handlers.EventAttributeHandler},
    onkeyup : {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onframedrawn: {a: handlers.EventAttributeHandler},
    complete: {p: properties.xml3dComplete},
    height : {a: handlers.IntAttributeHandler, params: 600},
    width : {a: handlers.IntAttributeHandler, params: 800},
    getElementByPoint : {m: methods.xml3dGetElementByPoint},
    generateRay : {m: methods.xml3dGenerateRay},
    getElementByRay : {m: methods.xml3dGetElementByRay},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    getRenderInterface : {m: methods.xml3dGetRenderInterface},
    activeView : {a: handlers.StringAttributeHandler}
    };

classInfo['compute'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    value: {a: handlers.StringValueHandler}
    };

/**
 * Properties and methods for <data>
 **/
classInfo['data'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    compute: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValues: 1}},
    filter: {a: handlers.StringAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DNestedDataContainerTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DNestedDataContainerTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DNestedDataContainerTypeIsOutputConnected},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <dataflow>
 **/
classInfo['dataflow'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValues: 1}},
    out: {a: handlers.StringAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DNestedDataContainerTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DNestedDataContainerTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DNestedDataContainerTypeIsOutputConnected},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult}
    };
/**
 * Properties and methods for <data>
 **/
classInfo['asset'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.AssetComplete},
    progressLevel: {p: properties.AssetProgressLevel},
    src: {a: handlers.StringAttributeHandler},
    name: {a: handlers.StringAttributeHandler},
    pick: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <defs>
 **/
classInfo['defs'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'}
    };
/**
 * Properties and methods for <group>
 **/
classInfo['group'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getLocalMatrix: {m: methods.groupGetLocalMatrix},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <mesh>
 **/
classInfo['mesh'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    type: {a: handlers.EnumAttributeHandler, params: {values: MeshTypes, defaultValue: 0}},
    compute: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    getOutputNames: {m: methods.meshGetOutputNames},
    getOutputChannelInfo: {m: methods.meshGetOutputChannelInfo},
    getComputeInfo: {m: methods.meshGetComputeInfo},
    getProtoInfo: {m: methods.meshGetProtoInfo},
    isOutputConnected: {m: methods.meshIsOutputConnected},
    getResult: {m: methods.meshGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <model>
 **/
classInfo['model'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.AssetComplete},
    progressLevel: {p: properties.AssetProgressLevel},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    getWorldBoundingBox : {m: methods.getWorldBoundingBox},
    getLocalBoundingBox : {m: methods.getLocalBoundingBox},
    src: {a: handlers.StringAttributeHandler},
    pick: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <transform>
 **/
classInfo['transform'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    translation: {a: handlers.Vec3AttributeHandler, params: [0, 0, 0]},
    scale: {a: handlers.Vec3AttributeHandler, params: [1, 1, 1]},
    rotation: {a: handlers.AxisAngleAttributeHandler, params: [0, 0, 1, 0]},
    center: {a: handlers.Vec3AttributeHandler, params: [0, 0, 0]},
    scaleOrientation: {a: handlers.AxisAngleAttributeHandler, params: [0, 0, 1, 0]}
    };
/**
 * Properties and methods for <material>
 **/
classInfo['material'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DShaderProviderTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DShaderProviderTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DShaderProviderTypeIsOutputConnected},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    script: {a: handlers.StringAttributeHandler},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <light>
 **/
classInfo['light'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    global: {a: handlers.BoolAttributeHandler, params: false},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DShaderProviderTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DShaderProviderTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DShaderProviderTypeIsOutputConnected},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    src: {a: handlers.StringAttributeHandler},
    model: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <lightshader>
 * // TODO(ksons): Remove in XML3D 5.1
 **/
classInfo['lightshader'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onload: {a: handlers.EventAttributeHandler},
    onprogress: {a: handlers.EventAttributeHandler},
    complete: {p: properties.XML3DNestedDataContainerTypeComplete},
    progressLevel: {p: properties.XML3DNestedDataContainerTypeProgressLevel},
    compute: {a: handlers.StringAttributeHandler},
    getOutputNames: {m: methods.XML3DShaderProviderTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DShaderProviderTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DShaderProviderTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DShaderProviderTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DShaderProviderTypeIsOutputConnected},
    getResult: {m: methods.XML3DShaderProviderTypeGetResult},
    script: {a: handlers.StringAttributeHandler},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <script>
 **/
classInfo['script'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    value: {a: handlers.StringValueHandler},
    src: {a: handlers.StringAttributeHandler},
    name: {a: handlers.StringAttributeHandler},
    type: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <assetmesh>
 **/
classInfo['assetmesh'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    match: {a: handlers.StringAttributeHandler},
    type: {a: handlers.EnumAttributeHandler, params: {values: MeshTypes, defaultValue: 0}},
    compute: {a: handlers.StringAttributeHandler},
    filter: {a: handlers.StringAttributeHandler},
    includes: {a: handlers.StringAttributeHandler},
    material: {a: handlers.StringAttributeHandler},
    transform: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValue: 1}},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DNestedDataContainerTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DNestedDataContainerTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DNestedDataContainerTypeIsOutputConnected},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <assetdata>
 **/
classInfo['assetdata'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    compute: {a: handlers.StringAttributeHandler},
    filter: {a: handlers.StringAttributeHandler},
    includes: {a: handlers.StringAttributeHandler},
    platform: {a: handlers.EnumAttributeHandler, params: {values: PlatformTypes, defaultValue: 1}},
    getOutputNames: {m: methods.XML3DNestedDataContainerTypeGetOutputNames},
    getOutputChannelInfo: {m: methods.XML3DNestedDataContainerTypeGetOutputChannelInfo},
    getComputeInfo: {m: methods.XML3DNestedDataContainerTypeGetComputeInfo},
    getProtoInfo: {m: methods.XML3DNestedDataContainerTypeGetProtoInfo},
    isOutputConnected: {m: methods.XML3DNestedDataContainerTypeIsOutputConnected},
    getResult: {m: methods.XML3DNestedDataContainerTypeGetResult},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <float>
 **/
classInfo['float'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.FloatArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float2>
 **/
classInfo['float2'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float2ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float3>
 **/
classInfo['float3'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float3ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float4>
 **/
classInfo['float4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float4ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <float4x4>
 **/
classInfo['float4x4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.Float4x4ArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <int>
 **/
classInfo['int'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.IntArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <int4>
 **/
classInfo['int4'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.IntArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <bool>
 **/
classInfo['bool'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    value: {a: handlers.BoolArrayValueHandler},
    setScriptValue: {m: methods.XML3DDataSourceTypeSetScriptValue}
    };
/**
 * Properties and methods for <texture>
 **/
classInfo['texture'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    name: {a: handlers.StringAttributeHandler},
    param: {a: handlers.BoolAttributeHandler, params: false},
    key: {a: handlers.FloatAttributeHandler, params: 0.0},
    type: {a: handlers.EnumAttributeHandler, params: {values: TextureTypes, defaultValue: 0}},
    filter: {a: handlers.StringAttributeHandler},
    wrap: {a: handlers.StringAttributeHandler},
    anisotropy: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <img>
 **/
classInfo['img'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    src: {a: handlers.StringAttributeHandler}
    };
/**
 * Properties and methods for <video>
 **/
classInfo['video'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    src: {a: handlers.StringAttributeHandler},
    autoplay: {a: handlers.BoolAttributeHandler, params: false},
    play: {m: methods.videoPlay},
    pause: {m: methods.videoPause}
    };
/**
 * Properties and methods for <view>
 **/
classInfo['view'] = {
    id: {a: handlers.IDHandler},
    className: {a: handlers.StringAttributeHandler, id: 'class'},
    onclick: {a: handlers.EventAttributeHandler},
    ondblclick: {a: handlers.EventAttributeHandler},
    onmousedown: {a: handlers.EventAttributeHandler},
    onmouseup: {a: handlers.EventAttributeHandler},
    onmouseover: {a: handlers.EventAttributeHandler},
    onmousemove: {a: handlers.EventAttributeHandler},
    onmouseout: {a: handlers.EventAttributeHandler},
    onkeypress: {a: handlers.EventAttributeHandler},
    onkeydown: {a: handlers.EventAttributeHandler},
    onkeyup: {a: handlers.EventAttributeHandler},
    position: {a: handlers.Vec3AttributeHandler, params: [0, 0, 0]},
    orientation: {a: handlers.AxisAngleAttributeHandler, params: [0, 0, 1, 0]},
    fieldOfView: {a: handlers.FloatAttributeHandler, params: 0.785398},
    getWorldMatrix: {m: methods.XML3DGraphTypeGetWorldMatrix},
    setDirection: {m: methods.viewSetDirection},
    setUpVector: {m: methods.viewSetUpVector},
    lookAt: {m: methods.viewLookAt},
    getDirection: {m: methods.viewGetDirection},
    getUpVector: {m: methods.viewGetUpVector},
    getViewMatrix: {m: methods.viewGetViewMatrix},
    projection: {a: handlers.StringAttributeHandler}
    };

module.exports = {
    classInfo : classInfo,
    MeshTypes : MeshTypes,
    TextureTypes : TextureTypes,
    PlatformTypes : PlatformTypes,
    DataFieldTypes : DataFieldType,
    DataChannelOrigin : DataChannelOrigin
};

},{"./attributes.js":66,"./methods.js":70,"./properties.js":72}],68:[function(require,module,exports){
var config = require("./elements.js").config;
var classInfo = require("./configuration.js").classInfo;

var doc = {};
var nativeGetElementById = document.getElementById;
doc.getElementById = function(id) {
    var elem = nativeGetElementById.call(this, id);
    if (elem) {
        return elem;
    } else {
        var elems = this.getElementsByTagName("*");
        for ( var i = 0; i < elems.length; i++) {
            var node = elems[i];
            if (node.getAttribute("id") === id) {
                return node;
            }
        }
    }
    return null;
};
var nativeCreateElementNS = document.createElementNS;
doc.createElementNS = function(ns, name) {
    var r = nativeCreateElementNS.call(this, ns, name);
    if (ns == XML3D.xml3dNS || classInfo[name.toLowerCase()]) {
        config.element(r);
    }
    return r;
};
var nativeCreateElement = document.createElement;
doc.createElement = function(name) {
    var r = nativeCreateElement.call(this, name);
    if (classInfo[name.toLowerCase()] ) {
        config.element(r);
    }
    return r;
};

XML3D.extend(window.document, doc);

},{"./configuration.js":67,"./elements.js":69}],69:[function(require,module,exports){
var events = require("./notification.js");
var ClassInfo = require("./configuration.js").classInfo;
var Resource = require("../base/resourcemanager.js").Resource;

var MutationObserver = (window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver),
    mutObserver;

if(MutationObserver){
    mutObserver = new MutationObserver(handleMutations);
} else {
    XML3D.debug.logError("XML3D requires MutationObservers, which your browser does not support. Please consider upgrading to a newer version.");
    mutObserver = {
        takeRecords:function(){return []},
        observe: function(a,b) {}
    }
}

XML3D.flushDOMChanges = function(){
    var records = mutObserver.takeRecords();
    records.length && handleMutations(records);
};

function handleMutations(mutations) {
    for(var i = 0; i < mutations.length; ++i){
        var mutationRecord = mutations[i];
        if (mutationRecord.type === 'attributes') {
            handleAttributeChanged(mutationRecord);
        } else if (mutationRecord.type === 'childList') {
            handleChildListChanged(mutationRecord);
        } else if(mutationRecord.type == 'characterData'){
            handleCharacterDataChanged(mutationRecord);
        }
    }
}

function handleCharacterDataChanged(mutation) {
    var target = mutation.target;
    while(!target._configured && target.parentElement) {
        target = target.parentElement;
    }
    var elementHandler = target._configured;
    if (!elementHandler) {
        return;
    }
    var n = new events.NotificationWrapper(mutation, events.VALUE_MODIFIED, target);
    if (elementHandler.handlers.value !== undefined) {
        elementHandler.handlers.value.resetValue(elementHandler.storage);
    }
    elementHandler.notify(n);
}

function handleChildListChanged(mutation) {
    var addedNodes = mutation.addedNodes;
    for (var i = 0; i < addedNodes.length; i++) {
        if (addedNodes[i].nodeType === Node.TEXT_NODE){
            // This may have been the value of eg. a float3 element, we should treat it as a characterDataChanged event
            handleCharacterDataChanged(mutation);
            continue;
        }
        handleNodeInserted(addedNodes[i], mutation);
    }

    var removedNodes = mutation.removedNodes;
    for (var i=0; i < removedNodes.length; i++) {
        if (removedNodes[i].nodeType === Node.TEXT_NODE){
            continue; // characterDataChanged events were already handled in addedNodes
        }
        handleNodeRemoved(removedNodes[i], mutation);
    }
}

function handleNodeInserted(node, mutation) {
    var targetHandler = mutation.target._configured;
    if (!targetHandler) {
        return;
    }
    config.element(node);
    addRecursive(node);
    var n = new events.NotificationWrapper(mutation, events.NODE_INSERTED, node);
    targetHandler.notify(n);
}

function handleNodeRemoved(node, mutation) {
    var targetHandler = mutation.target._configured;
    if (!targetHandler) {
        return;
    }
    var n = new events.NotificationWrapper(mutation, events.NODE_REMOVED, node);
    targetHandler.notify(n);
    if(node._configured) {
        n.type = events.THIS_REMOVED;
        removeRecursive(node, n);
        notifyNodeIdChangeRecursive(node);
    } else if (node.nodeType === Node.TEXT_NODE){
        // This may have been the value of eg. a float3 element, we should also treat it as a characterDataChanged event
        handleCharacterDataChanged(mutation);
    }
}

function notifyNodeIdChangeRecursive(element){
    Resource.notifyNodeIdChange(element, element.id, null);
    var n = element.firstElementChild;
    while(n) {
        notifyNodeIdChangeRecursive(n);
        n = n.nextElementSibling;
    }
}

function removeRecursive(element, evt) {
    if(element._configured) {
        element._configured.notify(evt);
        element._configured.remove(evt);
    }
    var child = element.firstElementChild;
    while(child) {
        removeRecursive(child, evt);
        child = child.nextElementSibling;
    }
}

function addRecursive(element){
    var n = element.firstElementChild;
    while(n) {
        addRecursive(n);
        n = n.nextElementSibling;
    }
    // We call this here in addition to nodeInsertedIntoDocument, since the later is not supported by Firefox
    Resource.notifyNodeIdChange(element, null, element.id);
}

/**
 *
 * @param {MutationRecord} mutation
 */
function handleAttributeChanged(mutation) {
    var target = mutation.target;
    var elementHandler = target._configured;
    if (!elementHandler) {
        return;
    }

    var attributeHandler = elementHandler.handlers[mutation.attributeName] || elementHandler.handlers[mutation.attributeName.toLowerCase()];
    if (attributeHandler && attributeHandler.setFromAttribute) {
        var newValue = target.getAttribute(mutation.attributeName);
        var notified = attributeHandler.setFromAttribute(newValue, mutation.oldValue, target, elementHandler.storage);
        XML3D.debug.assert(!notified, "We assume no attribute handler notifies adapters anymore.");
    }
    elementHandler.attributeChangedCallback(mutation);
}


var ElementHandler = function(elem) {
    if (!elem) {
        return;
    }
    this.element = elem;
    this.handlers = null;
    this.storage = {};
    this.adapters = {};
    mutObserver.observe(elem, { childList: true,  attributes: true, attributeOldValue: true} );

};

ElementHandler.prototype.registerAttributes = function(config) {
    var elem = this.element;

    var isHTML = (elem instanceof HTMLElement);
    var keyPrefix = (isHTML ? "_html" : "_xml");
    var handlerKey = keyPrefix + "handlers",
        protoKey = keyPrefix + "proto";

    var canProto = !!elem.__proto__;

    if(!config._cache) config._cache = {};

    if(!config._cache[handlerKey]){
        // Create handlers and prototype only once per configuration
        var proto;
        if(canProto){
            var F = function () {
            };
            F.prototype = elem.__proto__;
            proto = new F();
        }

        var handlers = {};
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if (config[prop] === undefined) {
                if(proto) delete proto[prop];
            } else {
                if (config[prop].a !== undefined) {
                    var attrName = config[prop].id || prop;
                    var handler = new config[prop].a(attrName, config[prop].params);
                    handlers[attrName.toLowerCase()] = handler;
                    if(proto) {
                        try {
                            Object.defineProperty(proto, prop, handler.desc);
                        } catch (e) {
                            XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                        }
                    }

                } else if (config[prop].m !== undefined) {
                    if(proto) proto[prop] = config[prop].m;
                } else if (config[prop].p !== undefined) {
                    if(proto){
                        try {
                            Object.defineProperty(proto, prop, config[prop].p);
                        } catch (e) {
                            XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                        }
                    }
                }else
                    XML3D.debug.logError("Can't configure " + elem.nodeName + "::" + prop);
            }
        }
        config._cache[handlerKey] = handlers;
        config._cache[protoKey] = proto;
    }
    // Set and initialize handlers for element
    this.handlers = config._cache[handlerKey];
    if(canProto){
        elem.__proto__ = config._cache[protoKey];
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if(config[prop] && config[prop].a !== undefined){
                var attrName = config[prop].id || prop;
                var handler = this.handlers[attrName.toLowerCase()];
                handler.init && handler.init(elem, this.storage);
                delete elem[prop];
            }
        }
    }
    else{
        for ( var prop in config) {
            if(prop =="_cache") continue;
            if (config[prop] === undefined) {
                delete elem[prop];
            }
            else if (config[prop].a !== undefined){
                var attrName = config[prop].id || prop;
                var handler = this.handlers[attrName.toLowerCase()];
                handler.init && handler.init(elem, this.storage);
                try {
                    Object.defineProperty(elem, prop, handler.desc);
                } catch (e) {
                    XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                }
            }else if (config[prop].m !== undefined) {
                elem[prop] = config[prop].m;
            } else if (config[prop].p !== undefined) {
                try {
                    Object.defineProperty(elem, prop, config[prop].p);
                } catch (e) {
                    XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + prop);
                }
            }
        }
    }

    return elem;
};


ElementHandler.prototype.registerMixed = function() {
    mutObserver.observe(this.element, { childList: true,  attributes: true, attributeOldValue: true, characterData: true, subtree: true} );
};

/**
 * @param evt
 */
ElementHandler.prototype.notify =  function(evt) {
    var adapters = this.adapters;
    for(var a in adapters) {
        try {
            adapters[a].notifyChanged(evt);
        } catch (e) {
            XML3D.debug.logException(e);
        }
    }
};

/**
 * @param {MutationRecord} mutation
 */
ElementHandler.prototype.attributeChangedCallback =  function(mutation) {
    var adapters = this.adapters;
    for(var a in adapters) {
        XML3D.debug.assert(adapters[a].attributeChangedCallback, "Adapter implements 'attributeChangedCallback': " + this.element.nodeName + " (" + a + ")");
        try {
            adapters[a].attributeChangedCallback(mutation.attributeName, mutation.oldValue, this.element.getAttribute(mutation.attributeName), mutation.attributeNamespace);
        } catch (e) {
            XML3D.debug.logException(e);
        }
    }
};

/*
 * Get called, if the related node gets removed from the DOM
 */
ElementHandler.prototype.remove = function(evt) {
    for(var h in this.adapters) {
        var adapter = this.adapters[h];
        if(adapter.onDispose)
            adapter.onDispose();
        if(adapter.clearAdapterHandles)
            adapter.clearAdapterHandles();
    }
    this.adapters = {};
    for(var h in this.handlers) {
        var handler = this.handlers[h];
        if(handler.remove)
            handler.remove();
    }

};

ElementHandler.prototype.toString = function() {
    return "ElementHandler ("+this.element.nodeName + ", id: "+this.element.id+")";
};

var delegateProperties = ["clientHeight", "clientLeft", "clientTop", "clientWidth",
    "offsetHeight", "offsetLeft", "offsetTop", "offsetWidth"];
function delegateProp(name, elem, canvas) {
    var desc = {
        get : function() {
            return canvas[name];
        }
    };
    try {
        Object.defineProperty(elem, name, desc);
    } catch (e){
        XML3D.debug.logWarning("Can't configure " + elem.nodeName + "::" + name);
    }
}

var XML3DHandler = function(elem) {
    ElementHandler.call(this, elem);
    var c = document.createElement("canvas");
    c.width = 800;
    c.height = 600;
    this.canvas = c;

    for(var i in delegateProperties) {
        delegateProp(delegateProperties[i], elem, c);
    }

    elem.getBoundingClientRect = function() {
        return c.getBoundingClientRect();
    };
};

XML3D.createClass(XML3DHandler, ElementHandler);


var config = {};

/**
 * @param {Element} element
 * @return {undefined}
 */
config.element = function(element) {
    if (element._configured === undefined ) {
        var classInfo = ClassInfo[element.localName];
        if (classInfo === undefined) {
            XML3D.debug.logInfo("Unrecognised element " + element.localName);
        } else {
            element._configured = element.localName == "xml3d" ?
                new XML3DHandler(element)
                : new ElementHandler(element);
            element._configured.registerAttributes(classInfo);
            // Fix difference in Firefox (undefined) and Chrome (null)
            try{
                if (element.style == undefined)
                    element.style = null;
            }
            catch(e){
                // Firefox throws exception here...
            }

            var n = element.firstElementChild;

            Resource.notifyNodeIdChange(element, null, element.getAttribute("id"));

            while(n) {
                config.element(n);
                n = n.nextElementSibling;
            }
        }
    }
};

/**
 * @param {Element} element
 * @return {undefined}
 */
config.configure = function(element) {
    if (Array.isArray(element)) {
        element.forEach(function(el) {
            config.element(el);
        });
    } else {
        config.element(element);
    }
};


module.exports = {
    ElementHandler : ElementHandler,
    XML3DHandler : XML3DHandler,
    config : config
};

},{"../base/resourcemanager.js":46,"./configuration.js":67,"./notification.js":71}],70:[function(require,module,exports){
var Resource = require("../base/resourcemanager.js").Resource;
var sendAdapterEvent = require("../utils/misc.js").sendAdapterEvent;
var callAdapterFunc = require("../utils/misc.js").callAdapterFunc;
var Vec3 = require("../types/vec3.js");
var Quat = require("../types/quat.js");
var Mat4 = require("../types/mat4.js");
var AxisAngle = require("../types/axisangle.js");
var vec3 = require("gl-matrix").vec3;

var methods = {};

methods.xml3dGetElementByRay = function(ray, hitPoint, hitNormal) {
    XML3D.flushDOMChanges();
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getElementByRay) {
            return adapters[adapter].getElementByRay(ray, hitPoint, hitNormal);
        }
    }
    return null;
};

methods.viewGetDirection = function() {
    var dir = Vec3.fromValues(0,0,-1);
    var orientation = Quat.fromAxisAngle(this.orientation);
    return dir.transformQuat(orientation);
};

methods.viewSetPosition = function(pos) {
    this.position = pos;
};

methods.viewSetDirection = function(direction) {
    direction = direction.normalize();
    var up = Vec3.fromValues(0,1,0);
    var orientation = Quat.fromAxisAngle(this.orientation);
    up = up.transformQuat(orientation).normalize();

    var basisX = new Vec3(direction).cross(up);
    if (!basisX.length()) {
        basisX = Vec3.fromValues(1,0,0).transformQuat(orientation);
    }
    var basisY = basisX.clone().cross(direction);
    var basisZ = new Vec3(direction).negate();

    var q = Quat.fromBasis(basisX, basisY, basisZ);
    this.orientation = AxisAngle.fromQuat(q);
};

methods.viewSetUpVector = function(up) {
    up = up.normalize();
    var orientation = Quat.fromAxisAngle(this.orientation);
    var r = Quat.fromRotationTo([0,1,0], up);
    orientation = orientation.mul(r).normalize();
    this.orientation = AxisAngle.fromQuat(orientation);
};

methods.viewGetUpVector = function() {
    var up = Vec3.fromValues(0, 1, 0);
    var orientation = Quat.fromAxisAngle(this.orientation);
    return up.transformQuat(orientation);
};

methods.viewLookAt = function(point) {
    var dir = new Vec3();
    vec3.sub(dir.data, point.data, this.position.data);
    this.setDirection(dir);
};

methods.viewGetViewMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getViewMatrix) {
            return adapters[adapter].getViewMatrix();
        }
    }
    // Fallback implementation
    var p = this.position;
    var r = Quat.fromAxisAngle(this.orientation);
    return Mat4.fromRotationTranslation(r,p).invert();
};

methods.xml3dGetElementByPoint = function(x, y, hitPoint, hitNormal) {
    XML3D.flushDOMChanges();
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getElementByPoint) {
            return adapters[adapter].getElementByPoint(x, y, hitPoint, hitNormal);
        }
    }
    return null;
};

methods.xml3dGenerateRay = function(x, y) {
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].generateRay) {
            return adapters[adapter].generateRay(x, y);
        }
    }
    return new XML3D.Ray();
};

methods.groupGetLocalMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getLocalMatrix) {
            return adapters[adapter].getLocalMatrix();
        }
    }
    return new Mat4();
};

/**
 * return the bounding box of the owning space in world space
 */
methods.getWorldBoundingBox = function() {
    XML3D.flushDOMChanges();
    // Visibility influences bounding box
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getWorldBoundingBox) {
            return adapters[adapter].getWorldBoundingBox();
        }
    }
    return new XML3D.Box();
};

/**
 * return the bounding box of the owning space in local space (object BB)
 */
methods.getLocalBoundingBox = function() {
    XML3D.flushDOMChanges();
    // Visibility influences bounding box
    XML3D.flushCSSChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getLocalBoundingBox) {
            return adapters[adapter].getLocalBoundingBox();
        }
    }
    return new XML3D.Box();
};

methods.xml3dGetRenderInterface = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for ( var adapter in adapters) {
        if (adapters[adapter].getRenderInterface) {
            return adapters[adapter].getRenderInterface();
        }
    }
    return {};
};


methods.XML3DGraphTypeGetWorldMatrix = function() {
    XML3D.flushDOMChanges();
    var adapters = this._configured.adapters || {};
    for (var adapter in adapters) {
        if (adapters[adapter].getWorldMatrix) {
            return adapters[adapter].getWorldMatrix();
        }
    }
    return new Mat4();
};

methods.videoPlay = function() {
    sendAdapterEvent(this, {play: []});
};

methods.videoPause = function() {
    sendAdapterEvent(this, {pause: []});
};

methods.XML3DNestedDataContainerTypeGetOutputNames =
methods.XML3DShaderProviderTypeGetOutputNames =
methods.meshGetOutputNames = function() {
    XML3D.flushDOMChanges();
    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter){
        return dataAdapter.getOutputNames();
    }
    return null;
};

methods.XML3DNestedDataContainerTypeGetResult =
methods.XML3DShaderProviderTypeGetResult =
methods.meshGetResult = function(filter) {
    XML3D.flushDOMChanges();
    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter){
        var result = dataAdapter.getComputeResult(filter);
        if(!result) return null;
        return new window.XML3DDataResult(result);
    }
    return null;
};

methods.XML3DNestedDataContainerTypeGetOutputChannelInfo =
    methods.XML3DShaderProviderTypeGetOutputChannelInfo =
        methods.meshGetOutputChannelInfo = function (name) {
            XML3D.flushDOMChanges();
            var dataAdapter = Resource.getAdapter(this, "data");
            if (dataAdapter) {
                var result = dataAdapter.getOutputChannelInfo(name);
                if (!result) return null;
                return new window.XML3DDataChannelInfo(result.type, result.origin, result.originalName,
                    result.seqLength, result.seqMinKey, result.seqMaxKey);
            }
            return null;
        };
// TODO: Get rid of these
methods.XML3DNestedDataContainerTypeGetComputeInfo =
    methods.XML3DShaderProviderTypeGetComputeInfo =
        methods.meshGetComputeInfo = function () {
            XML3D.flushDOMChanges();
            XML3D.debug.logError(this.nodeName + "::getComputeInfo is not implemeted yet.");
            return null;
        };

methods.XML3DNestedDataContainerTypeGetProtoInfo =
    methods.XML3DShaderProviderTypeGetProtoInfo =
        methods.meshGetProtoInfo = function () {
            XML3D.flushDOMChanges();
            XML3D.debug.logError(this.nodeName + "::getProtoInfo is not implemeted yet.");
            return null;
        };

methods.XML3DNestedDataContainerTypeIsOutputConnected =
    methods.XML3DShaderProviderTypeIsOutputConnected =
        methods.meshIsOutputConnected = function () {
            XML3D.flushDOMChanges();
            XML3D.debug.logError(this.nodeName + "::isOutputConnected is not implemeted yet.");
            return false;
        };


function createValues(result, names) {
    var values = {};
    for (var i in names) {
        var name = names[i];
        var data = result.getOutputData(name) && result.getOutputData(name).getValue();
        if (data)
            values[name] = data;
    }
    return values;
}

/** Register data listener for data fields specified by names.
 *
 * @param names   single name or array of names that are monitored.
 * @param callback function that is called when selected data are changed.
 * @return {Boolean}
 */
methods.dataAddOutputFieldListener = function(names, callback) {
    XML3D.flushDOMChanges();
    if (!names)
        return false;

    // check if names is a single string, and convert it to array then
    var typeOfNames = Object.prototype.toString.call(names).slice(8, -1);
    if (typeOfNames === "String") {
        names = [names];
    }
    if (names.length == 0)
        return false;

    var request = callAdapterFunc(this, {
        getComputeRequest : [names, function(request, changeType) {
            callback(createValues(request.getResult(), names));
        }
        ]});
    if (request.length == 0)
        return false;
    var result = request[0].getResult();
    var values = createValues(result, names);
    if (Object.keys(values).length)
        callback(values);
    return true;
};

methods.XML3DDataSourceTypeSetScriptValue = function(data){
    var configData = this._configured;

    if(!configData)
        return;

    if(this.textContent != "[value set by script]")
        this.textContent = "[value set by script]";
    XML3D.flushDOMChanges();
    configData.scriptValue = data;

    var dataAdapter = Resource.getAdapter(this, "data");
    if(dataAdapter)
        dataAdapter.setScriptValue(data);

};

module.exports = methods;

},{"../base/resourcemanager.js":46,"../types/axisangle.js":159,"../types/mat4.js":164,"../types/quat.js":165,"../types/vec3.js":168,"../utils/misc.js":174,"gl-matrix":1}],71:[function(require,module,exports){

/**
 * Types of change events
 * @enum {number}
 */
var events = {
      NODE_INSERTED: 0,
      VALUE_MODIFIED:  1,
      NODE_REMOVED: 2,
      THIS_REMOVED: 3,
      ADAPTER_HANDLE_CHANGED: 4,
      ADAPTER_VALUE_CHANGED: 5
};

//-----------------------------------------------------------------------------
//Class Notification
//-----------------------------------------------------------------------------
events.Notification = function(type) {
    this.type = type;
};
events.Notification.prototype.toString = function() {
    return "Notification (type:" + this.type + ")";
};
//-----------------------------------------------------------------------------
events.NotificationWrapper = function(mutation, type, affectedNode) {
    this.mutation = mutation;
    this.type = type;
    this.affectedNode = affectedNode;
};
XML3D.createClass(events.NotificationWrapper, events.Notification);
events.NotificationWrapper.prototype.toString = function() {
    return "NotificationWrapper (type:" + this.type + ", wrapped: "+ this.mutation +")";
};

//-----------------------------------------------------------------------------

/**
 * @param {AdapterHandle} handle
 * @param {int} type
 * @constructor
 */
events.AdapterHandleNotification = function (handle, type) {
    this.adapterHandle = handle;
    this.type = type;
};
XML3D.createClass(events.AdapterHandleNotification, events.Notification);
events.AdapterHandleNotification.prototype.toString = function () {
    return "AdapterHandleNotification (type:" + this.type + ")";
};
//-----------------------------------------------------------------------------

events.ConnectedAdapterNotification = function(adapterHandleNotification, key) {
    this.adapter = adapterHandleNotification.adapterHandle.getAdapter();
    this.key = key;
    this.url = adapterHandleNotification.adapterHandle.url;
    this.type = adapterHandleNotification.type;
    this.handleStatus = adapterHandleNotification.adapterHandle.status;
};
XML3D.createClass(events.ConnectedAdapterNotification, events.Notification);
events.ConnectedAdapterNotification.prototype.toString = function() {
    return "ConnectedAdapterNotification (type:" + this.type + ", key: " + this.key + ")";
};

module.exports = events;
},{}],72:[function(require,module,exports){
var properties = {};

properties.XML3DNestedDataContainerTypeComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getDataComplete) {
                return adapters[adapter].getDataComplete();
            }
        }
        return false;
    },
    set: function(){}
};

properties.XML3DNestedDataContainerTypeProgressLevel = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getDataProgressLevel) {
                return adapters[adapter].getDataProgressLevel();
            }
        }
        return false;
    },
    set: function(){}
};

properties.AssetComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getAssetComplete) {
                return adapters[adapter].getAssetComplete();
            }
        }
        return false;
    },
    set: function(){}
};


properties.AssetProgressLevel = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getAssetProgressLevel) {
                return adapters[adapter].getAssetProgressLevel();
            }
        }
        return false;
    },
    set: function(){}
};

properties.xml3dComplete = {
    get: function(){
        XML3D.flushDOMChanges();
        var adapters = this._configured.adapters || {};
        for (var adapter in adapters) {
            if (adapters[adapter].getComplete) {
                return adapters[adapter].getComplete();
            }
        }
        return false;
    },
    set: function(){}
};

module.exports = properties;

},{}],73:[function(require,module,exports){
(function (module) {

    /**
     * @class An axis aligned bounding box in the style of glMatrix
     * @name bbox
     */
    var bbox = {};

    /**
     * Creates a new, empty bounding box
     *
     * @returns {bbox} a new empty bounding box
     */
    bbox.create = function () {
        var out = new Float32Array(6);
        out[0] = Number.MAX_VALUE;
        out[1] = Number.MAX_VALUE;
        out[2] = Number.MAX_VALUE;
        out[3] = -Number.MAX_VALUE;
        out[4] = -Number.MAX_VALUE;
        out[5] = -Number.MAX_VALUE;
        return out;
    };

    bbox.clone = function (a) {
        var out = new Float32Array(6);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        return out;
    };

    bbox.copy = function (out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        return out;
    };

    bbox.copyMin = function (target, source) {
        target[0] = source[0];
        target[1] = source[1];
        target[2] = source[2];
        return target;
    };

    bbox.copyMax = function (target, source) {
        target[0] = source[3];
        target[1] = source[4];
        target[2] = source[5];
        return target;
    };

    bbox.min = function(box) {
        return box.subarray(0,3);
    };

    bbox.max = function(box) {
        return box.subarray(3,6);
    };

    bbox.extendWithBox = function (target, other) {
        for (var i = 0; i < 3; i++) {
            target[i] = Math.min(other[i], target[i]);
            target[i + 3] = Math.max(other[i + 3], target[i + 3]);
        }
        return target;
    };

    bbox.empty = function (b) {
        b[0] = Number.MAX_VALUE;
        b[1] = Number.MAX_VALUE;
        b[2] = Number.MAX_VALUE;
        b[3] = -Number.MAX_VALUE;
        b[4] = -Number.MAX_VALUE;
        b[5] = -Number.MAX_VALUE;
        return b;
    };

    bbox.isEmpty = function (b) {
        return (b[0] > b[3] || b[1] > b[4] || b[2] > b[5]);
    };

    bbox.center = function (target, b) {
        target[0] = (b[0] + b[3]) * 0.5;
        target[1] = (b[1] + b[4]) * 0.5;
        target[2] = (b[2] + b[5]) * 0.5;
        return target;
    };

    bbox.size = function (target, b) {
        target[0] = Math.max(b[3] - b[0], 0);
        target[1] = Math.max(b[4] - b[1], 0);
        target[2] = Math.max(b[5] - b[2], 0);
        return target;
    };

    bbox.extent = function (target, b) {
        target[0] = Math.max(b[3] - b[0], 0) * 0.5;
        target[1] = Math.max(b[4] - b[1], 0) * 0.5;
        target[2] = Math.max(b[5] - b[2], 0) * 0.5;
        return target;
    };

    bbox.transformAxisAligned = function (out, mat, box) {
        if (bbox.isEmpty(box)) {
            bbox.copy(out, box); // an empty box remains empty
            return;
        }
        if (out === box) {
            //The algorithm breaks if source and dest are the same so create a new instance of the source box
            box = bbox.clone(box);
        }
        if (mat[3] == 0 && mat[7] == 0 && mat[11] == 0 && mat[15] == 1) {

            for (var i = 0; i < 3; i++) {
                out[i] = out[i + 3] = mat[12 + i];

                for (var j = 0; j < 3; j++) {
                    var a, b;

                    a = mat[j * 4 + i] * box[j];
                    b = mat[j * 4 + i] * box[j + 3];

                    if (a < b) {
                        out[i] += a;
                        out[i + 3] += b;
                    }
                    else {
                        out[i] += b;
                        out[i + 3] += a;
                    }
                }
            }
            return out;
        }
        throw new Error("Matrix is not affine");
    };

    bbox.transform = function (out, mat, box) {
        if (bbox.isEmpty(box)) {
            bbox.copy(out, box); // an empty box remains empty
            return;
        }

        XML3D.math.vec3.transformMat4(out, box, mat);
        XML3D.math.vec3.transformMat4(bbox.max(out), bbox.max(box), mat);
        return out;
    };

    bbox.longestSide = function (b) {
        var x = Math.abs(b[3] - b[0]);
        var y = Math.abs(b[4] - b[1]);
        var z = Math.abs(b[5] - b[2]);
        return Math.max(x, Math.max(y, z));
    };

    /**
     * Tests a given ray against a given bounding box and returns true if the ray intersects it, false otherwise.
     * @param bb The axis aligned bounding box to test against
     * @param xml3dRay The ray to test for intersection with
     * @param opt {object} If opt.dist is provided the function will fill it with the distance from the ray origin to
     *                     the hit point on the bounding box, or MAX_VALUE if the ray does not intersect.
     * @returns {boolean}
     */
    bbox.intersects = function(bb, xml3dRay, opt) {
        var origin = XML3D.math.ray.origin(xml3dRay);
        var direction = XML3D.math.ray.direction(xml3dRay);
        var inverseDirX = 1 / direction[0];
        var inverseDirY = 1 / direction[1];
        var inverseDirZ = 1 / direction[2];

        var t1 = (bb[0] - origin[0]) * inverseDirX;
        var t2 = (bb[3] - origin[0]) * inverseDirX;
        var t3 = (bb[1] - origin[1]) * inverseDirY;
        var t4 = (bb[4] - origin[1]) * inverseDirY;
        var t5 = (bb[2] - origin[2]) * inverseDirZ;
        var t6 = (bb[5] - origin[2]) * inverseDirZ;

        var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

        if (opt === undefined || opt.dist === undefined) {
            return tmax > 0 && tmin <= tmax;
        }

        if (tmax < 0) {
            opt.dist = Number.MAX_VALUE;
            return false;
        }

        if (tmin > tmax) {
            opt.dist = Number.MAX_VALUE;
            return false;
        }

        opt.dist = tmin;
        return true;
    };

    bbox.str = function (a) {
        return 'bbox(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
            a[4] + ', ' + a[5] + ')';
    };

    bbox.EMPTY_BOX = bbox.create();

    module.exports = bbox;


}(module));


},{}],74:[function(require,module,exports){
module.exports = function (math) {

// Additional methods in glMatrix style
    math.vec3.reciprocal = function (dest, vec) {
        if (!dest) {
            dest = vec;
        }

        dest[0] = 1 / vec[0];
        dest[1] = 1 / vec[1];
        dest[2] = 1 / vec[2];
        return dest;
    };

    var toDOMString = function(data) {
        return Array.prototype.join.call(data, ' ');
    };

    math.vec2.toDOMString = toDOMString;

    math.vec2.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 2 || isNaN(+s[0]) || isNaN(+s[1])) {
            throw "Could not parse '"+str+"' into a valid vec2 object";
        }
        return math.vec2.fromValues(+s[0], +s[1]);
    };

    math.vec3.toDOMString = toDOMString;

    math.vec3.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 3 || isNaN(+s[0]) || isNaN(+s[1]) || isNaN(+s[2])) {
            throw "Could not parse '"+str+"' into a valid vec3 object";
        }
        return math.vec3.fromValues(+s[0], +s[1], +s[2]);
    };


    math.vec4.toDOMString = toDOMString;

    math.vec4.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 4 || isNaN(+s[0]) || isNaN(+s[1]) || isNaN(+s[2]) || isNaN(+s[3])) {
            throw "Could not parse '"+str+"' into a valid vec4 or quat object";
        }
        return math.vec4.fromValues(+s[0], +s[1], +s[2], +s[3]);
    };

    math.quat.toDOMString = toDOMString;

    math.quat.fromDOMString = math.vec4.fromDOMString;

    math.mat3.toDOMString = toDOMString;

    math.mat3.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 9) {
            throw "Could not parse '"+str+"' into a valid mat3 object";
        }
        var mat = math.mat3.create();
        for (var i=0; i<9; i++) {
            mat[i] = +s[i];
            if (isNaN(mat[i])) {
                throw "Could not parse '"+str+"' into a valid mat3 object";
            }
        }
        return mat;
    };

    math.mat4.toDOMString = toDOMString;

    math.mat4.fromDOMString = function(str) {
        var s = str.split(' ');
        if (s.length !== 16) {
            throw "Could not parse '"+str+"' into a valid mat4 object";
        }
        var mat = math.mat4.create();
        for (var i=0; i<16; i++) {
            mat[i] = +s[i];
            if (isNaN(mat[i])) {
                throw "Could not parse '"+str+"' into a valid mat4 object";
            }
        }
        return mat;
    };


    math.mat4.multiplyOffsetVec3 = function (mat, matOffset, vec, vecOffset, dest) {
        if (!dest) {
            dest = vec;
        }
        if (!vecOffset) {
            vecOffset = 0;
        }

        var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2];

        dest[0] = mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z + mat[matOffset + 12];
        dest[1] = mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z + mat[matOffset + 13];
        dest[2] = mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z + mat[matOffset + 14];

        return dest;
    };


    math.mat4.multiplyOffsetDirection = function (mat, matOffset, vec, vecOffset, dest) {
        if (!dest) {
            dest = vec;
        }
        if (!vecOffset) {
            vecOffset = 0;
        }

        var x = vec[vecOffset + 0], y = vec[vecOffset + 1], z = vec[vecOffset + 2], w;

        dest[0] = mat[matOffset + 0] * x + mat[matOffset + 4] * y + mat[matOffset + 8] * z;
        dest[1] = mat[matOffset + 1] * x + mat[matOffset + 5] * y + mat[matOffset + 9] * z;
        dest[2] = mat[matOffset + 2] * x + mat[matOffset + 6] * y + mat[matOffset + 10] * z;

        return dest;
    };

    math.mat4.multiplyOffset = function (dest, destOffset, mat, offset1, mat2, offset2) {
        var a00 = mat2[offset2 + 0], a01 = mat2[offset2 + 1], a02 = mat2[offset2 + 2], a03 = mat2[offset2 + 3];
        var a10 = mat2[offset2 + 4], a11 = mat2[offset2 + 5], a12 = mat2[offset2 + 6], a13 = mat2[offset2 + 7];
        var a20 = mat2[offset2 + 8], a21 = mat2[offset2 + 9], a22 = mat2[offset2 + 10], a23 = mat2[offset2 + 11];
        var a30 = mat2[offset2 + 12], a31 = mat2[offset2 + 13], a32 = mat2[offset2 + 14], a33 = mat2[offset2 + 15];

        var b00 = mat[offset1 + 0], b01 = mat[offset1 + 1], b02 = mat[offset1 + 2], b03 = mat[offset1 + 3];
        var b10 = mat[offset1 + 4], b11 = mat[offset1 + 5], b12 = mat[offset1 + 6], b13 = mat[offset1 + 7];
        var b20 = mat[offset1 + 8], b21 = mat[offset1 + 9], b22 = mat[offset1 + 10], b23 = mat[offset1 + 11];
        var b30 = mat[offset1 + 12], b31 = mat[offset1 + 13], b32 = mat[offset1 + 14], b33 = mat[offset1 + 15];

        dest[destOffset + 0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[destOffset + 1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[destOffset + 2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[destOffset + 3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[destOffset + 4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[destOffset + 5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[destOffset + 6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[destOffset + 7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[destOffset + 8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[destOffset + 9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[destOffset + 10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[destOffset + 11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[destOffset + 12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[destOffset + 13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[destOffset + 14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[destOffset + 15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;
    };

    math.quat.slerpOffset = function (quat, offset1, quat2, offset2, t, dest, destOffset, shortest) {
        if (!dest) {
            dest = quat;
        }

        var ix1 = offset1, iy1 = offset1 + 1, iz1 = offset1 + 2, iw1 = offset1 + 3;
        var ix2 = offset2, iy2 = offset2 + 1, iz2 = offset2 + 2, iw2 = offset2 + 3;
        var ixd = destOffset, iyd = destOffset + 1, izd = destOffset + 2, iwd = destOffset + 3;

        var cosAngle = quat[ix1] * quat2[ix2] + quat[iy1] * quat2[iy2] + quat[iz1] * quat2[iz2] + quat[iw1] * quat2[iw2];

        var c1, c2;

        // Linear interpolation for close orientations
        if ((1.0 - Math.abs(cosAngle)) < 0.01) {
            c1 = 1.0 - t;
            c2 = t;
        } else {
            // Spherical interpolation
            var angle = Math.acos(Math.abs(cosAngle));
            var sinAngle = Math.sin(angle);
            c1 = Math.sin(angle * (1.0 - t)) / sinAngle;
            c2 = Math.sin(angle * t) / sinAngle;
        }

        // Use the shortest path
        if (shortest && (cosAngle < 0.0))
            c1 = -c1;

        dest[ixd] = c1 * quat[ix1] + c2 * quat2[ix2];
        dest[iyd] = c1 * quat[iy1] + c2 * quat2[iy2];
        dest[izd] = c1 * quat[iz1] + c2 * quat2[iz2];
        dest[iwd] = c1 * quat[iw1] + c2 * quat2[iw2];
    };

    math.quat.fromAxisAngle = function(axis, angle) {
        var q = math.quat.create();
        if (axis.length === 4 && angle === undefined) {
            math.quat.setAxisAngle(q, axis, axis[3]);
        } else {
            math.quat.setAxisAngle(q, axis, angle);
        }
        return math.quat.normalize(q,q);
    };

    /**
     * Transforms the vec3 with a mat4.
     * 4th vector component is implicitly '0'
     *
     * @param {vec3} out the receiving vector
     * @param {vec3} a the vector to transform
     * @param {mat4} m matrix to transform with
     * @returns {vec3} out
     */
    math.vec3.transformDirection = function(out, a, m) {
        var x = a[0], y = a[1], z = a[2];
        out[0] = (m[0] * x + m[4] * y + m[8] * z);
        out[1] = (m[1] * x + m[5] * y + m[9] * z);
        out[2] = (m[2] * x + m[6] * y + m[10] * z);
        return out;
    };

    math.quat.setFromMat3 = function(dest, m) {
        var tr = m[0] + m[4] + m[8];

        if (tr > 0) {
            var s = Math.sqrt(tr + 1.0) * 2; // s=4*dest[3]
            dest[0] = (m[7] - m[5]) / s;
            dest[1] = (m[2] - m[6]) / s;
            dest[2] = (m[3] - m[1]) / s;
            dest[3] = 0.25 * s;
        } else if ((m[0] > m[4]) && (m[0] > m[8])) {
            var s = Math.sqrt(1.0 + m[0] - m[4] - m[8]) * 2; // s=4*qx
            dest[3] = (m[7] - m[5]) / s;
            dest[0] = 0.25 * s;
            dest[1] = (m[1] + m[3]) / s;
            dest[2] = (m[2] + m[6]) / s;
        } else if (m[4] > m[8]) {
            var s = Math.sqrt(1.0 + m[4] - m[0] - m[8]) * 2; // s=4*qy
            dest[3] = (m[2] - m[6]) / s;
            dest[0] = (m[1] + m[3]) / s;
            dest[1] = 0.25 * s;
            dest[2] = (m[5] + m[7]) / s;
        } else {
            var s = Math.sqrt(1.0 + m[8] - m[0] - m[4]) * 2; // s=4*qz
            dest[3] = (m[3] - m[1]) / s;
            dest[0] = (m[2] + m[6]) / s;
            dest[1] = (m[5] + m[7]) / s;
            dest[2] = 0.25 * s;
        }
        return dest;
    };

    math.quat.setFromBasis = function(dest, X,Y,Z) {
        var lx = 1.0 / XML3D.math.vec3.length(X);
        var ly = 1.0 / XML3D.math.vec3.length(Y);
        var lz = 1.0 / XML3D.math.vec3.length(Z);
        var m = XML3D.math.mat3.create();
        m[0] = X[0] * lx;
        m[1] = Y[0] * ly;
        m[2] = Z[0] * lz;
        m[3] = X[1] * lx;
        m[4] = Y[1] * ly;
        m[5] = Z[1] * lz;
        m[6] = X[2] * lx;
        m[7] = Y[2] * ly;
        m[8] = Z[2] * lz;
        return XML3D.math.quat.setFromMat3(dest, m);
    };

    math.vec4.fromQuat = function(q) {
        var dest = XML3D.math.vec4.create();
        if (q[3] > 1) {
            XML3D.math.quat.normalize(q,q);
        }
        var s = Math.sqrt(1-q[3]*q[3]);
        var angle = 2*Math.acos(q[3]);
        if (s < 0.0001) {
            // Axis is practically 0 so we return the identity axis angle
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 1;
            dest[3] = 0;
        } else {
            dest[0] = q[0] / s;
            dest[1] = q[1] / s;
            dest[2] = q[2] / s;
            dest[3] = angle;
        }
        return dest;
    };


};

},{}],75:[function(require,module,exports){
(function (module) {
    /**
     * @class A ray in the style of glMatrix
     * @name ray
     */
    var ray = {};

    /**
     * Creates a new, ray with origin (0,0,0) and direction (0,0,-1)
     *
     * @returns {ray} a new default ray
     */
    ray.create = function () {
        var out = new Float32Array(6);
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        out[4] = 0;
        out[5] = -1;
        return out;
    };

    ray.fromOriginDirection = function(origin, direction) {
        var out = ray.create();
        ray.setOrigin(out, origin);
        ray.setDirection(out, direction);
        return out;
    };

    ray.clone = function (a) {
        var out = new Float32Array(6);
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        return out;
    };

    ray.copy = function (out, a) {
        out[0] = a[0];
        out[1] = a[1];
        out[2] = a[2];
        out[3] = a[3];
        out[4] = a[4];
        out[5] = a[5];
        return out;
    };

    ray.copyOrigin = function (target, source) {
        target[0] = source[0];
        target[1] = source[1];
        target[2] = source[2];
        return target;
    };

    ray.copyDirection = function (target, source) {
        target[3] = source[3];
        target[4] = source[4];
        target[5] = source[5];
        return target;
    };

    ray.origin = function(a) {
        return a.subarray(0,3);
    };

    ray.direction = function(a) {
        return a.subarray(3,6);
    };

    ray.setOrigin = function(ray, origin) {
        ray[0] = origin[0];
        ray[1] = origin[1];
        ray[2] = origin[2];
        return ray;
    };

    ray.setDirection = function(ray, direction) {
        XML3D.math.vec3.normalize(ray.subarray(3,6), direction);
    };

    ray.str = function (a) {
        return 'ray(origin: ' + a[0] + ', ' + a[1] + ', ' + a[2] + ', direction: ' + a[3] + ', ' +
            a[4] + ', ' + a[5] + ')';
    };

    module.exports = ray;

})(module);
},{}],76:[function(require,module,exports){
var NodeAdapter = require("../../../base/adapter.js").NodeAdapter;

var RenderAdapter = function (factory, node) {
    NodeAdapter.call(this, factory, node);
};

XML3D.createClass(RenderAdapter, NodeAdapter, {

    getParentRenderAdapter: function () {
        return this.factory.getAdapter(this.node.parentNode, RenderAdapter);
    },

    /**
     * @param element
     */
    initElement: function (element) {
        this.factory.getAdapter(element);
        this.initChildElements(element);
    },

    /**
     * @param {Element} element
     */
    initChildElements: function (element) {
        var child = element.firstElementChild;
        while (child) {
            this.initElement(child);
            child = child.nextElementSibling;
        }
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
    },

    styleChangedCallback: function () {
    },

    applyTransformMatrix: function (transform) {
        return transform;
    },

    getScene: function () {
        return this.factory.renderer.scene;
    }
});

module.exports = RenderAdapter;

},{"../../../base/adapter.js":43}],77:[function(require,module,exports){
var RenderAdapter = require("./base.js");

//Adapter for <defs>
var DefsRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
};
XML3D.createClass(DefsRenderAdapter, RenderAdapter);

module.exports = DefsRenderAdapter;

},{"./base.js":76}],78:[function(require,module,exports){
var NodeAdapterFactory = require("../../../base/adapter.js").NodeAdapterFactory;
var DataAdapterFactory = require("../../../data/adapter/factory.js");
require("../../../base/formathandler.js").xml3dFormatHandler.registerFactoryClass(DataAdapterFactory);

/**
 * @constructor
 * @implements {XML3D.base.IFactory}
 * @extends XML3D.base.NodeAdapterFactory
 * @param {number} canvasId
 */
var RenderAdapterFactory = function (canvasId) {
    NodeAdapterFactory.call(this, "webgl", canvasId);
    this.type = "RenderAdapterFactory";
};
XML3D.createClass(RenderAdapterFactory, NodeAdapterFactory);
RenderAdapterFactory.prototype.aspect = "webgl";


var registry = {
        xml3d: require("./xml3d.js"),
        view: require("./view.js"),
        defs: require("./defs.js"),
        mesh: require("./mesh.js"),
        model: require("./model.js"),
        material: require("./material.js"),
        shader: require("./material.js"), // TODO(ksons): Remove in 5.1
        group: require("./group.js"),
        light: require("./light.js"),
        lightshader: require("./lightshader.js") // TODO(ksons): Remove in 5.1
    };

/**
 * @param node
 * @return {XML3D.base.Adapter|null}
 */
RenderAdapterFactory.prototype.createAdapter = function (node) {
    var adapterConstructor = registry[node.localName];
    if (adapterConstructor !== undefined) {
        return new adapterConstructor(this, node);
    }
    return null;
};

RenderAdapterFactory.prototype.setScene = function (scene) {
    this.scene = scene;
};

RenderAdapterFactory.prototype.getScene = function () {
    return this.scene;
};

RenderAdapterFactory.prototype.setRenderer = function (renderer) {
    this.renderer = renderer;
};

RenderAdapterFactory.prototype.getRenderer = function () {
    return this.renderer;
};

// Export
module.exports = RenderAdapterFactory;

},{"../../../base/adapter.js":43,"../../../base/formathandler.js":45,"../../../data/adapter/factory.js":55,"./defs.js":77,"./group.js":79,"./light.js":80,"./lightshader.js":81,"./material.js":82,"./mesh.js":83,"./model.js":84,"./view.js":86,"./xml3d.js":87}],79:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var Events = require("../../../interface/notification.js");
var mat4 = require("gl-matrix").mat4;

var GroupRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, true, true);
    this.style = window.getComputedStyle(node);
    this.createRenderNode();
};

XML3D.createClass(GroupRenderAdapter, TransformableAdapter, {

    createRenderNode: function () {
        //TODO: Shouldn't have to go through the renderer...
        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();
        this.renderNode = this.getScene().createRenderGroup({
            parent: parentNode, name: this.node.id
        });
        this.updateLocalMatrix();
        this.updateMaterialHandler();
        var bbox = new XML3D.Box();
        this.renderNode.setWorldSpaceBoundingBox(bbox);
    },

    notifyChanged: function (evt) {
        TransformableAdapter.prototype.notifyChanged.call(this, evt);
        return this.handleConnectedAdapterEvent(evt);
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        TransformableAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
    },

    handleConnectedAdapterEvent: function (evt) {
        switch (evt.type) {
            case Events.NODE_INSERTED:
                // This also initializes the children
                this.initElement(evt.mutation.target);
                break;
            case Events.THIS_REMOVED:
                this.dispose();
                break;
            case Events.ADAPTER_HANDLE_CHANGED:
                break;
            case Events.NODE_REMOVED:
                break;
            default:
                XML3D.debug.logWarning("Unhandled connected adapter event for " + evt.key + " in group adapter");
        }
    },

     styleChangedCallback: function() {
        TransformableAdapter.prototype.styleChangedCallback.call();
        this.updateVisibility();
    },

    updateVisibility: function() {
        var none = this.style.getPropertyValue("display").trim() == "none";
        var hidden  = this.style.getPropertyValue("visibility").trim() == "hidden";
        this.renderNode.setLocalVisible(!(none || hidden));
    },

    dispose: function () {
        // Dispose all children as well
        this.traverse(function (adapter) {
            if (adapter && adapter.destroy)
                adapter.dispose();
        });
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    },

    /* Interface methods */
    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        this.renderNode.getWorldSpaceBoundingBox(bbox);
        return bbox;
    },

    getLocalBoundingBox: (function () {
        var localMat = mat4.create();
        var childBB = new XML3D.Box();

        return function () {
            var bbox = new XML3D.Box();
            Array.prototype.forEach.call(this.node.childNodes, function (c) {
                if (c.getLocalBoundingBox) {
                    childBB = c.getLocalBoundingBox();
                    bbox.extend(childBB);
                }
            });
            this.renderNode.getLocalMatrix(localMat);
            bbox.transformAxisAligned(localMat);
            return bbox;
        }
    })(),

    getLocalMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getLocalMatrix(m.data);
        return m;
    },

    getWorldMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getWorldMatrix(m.data);
        return m;
    }
});

module.exports = GroupRenderAdapter;

},{"../../../interface/notification.js":71,"./transformable.js":85,"gl-matrix":1}],80:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var Events = require("../../../interface/notification.js");
var Resource = require("../../../base/resourcemanager.js").Resource;
var LightConfiguration = require("../scene/light-configuration.js");

var DEFAULT_LIGHT_MODEL = "urn:xml3d:light:directional";
/**
 * Adapter for <light>
 * @constructor
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 */
var LightRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, false, true);
    this.dataAdapter = Resource.getAdapter(node, "data");
    this.style = window.getComputedStyle(node);
    this.createRenderNode();
};

XML3D.createClass(LightRenderAdapter, TransformableAdapter, {

    createRenderNode: function () {
        var parentAdapter = this.getParentRenderAdapter();
        var parentNode = parentAdapter.getRenderNode && parentAdapter.getRenderNode();
        this.renderNode = this.factory.getScene().createRenderLight({
            configuration: this.createLightConfiguration(),
            parent: parentNode
        });
        this.updateVisibility();
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        TransformableAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);

        switch (name) {
            case "intensity": // TODO(ksons): remove in 5.1
                XML3D.debug.logWarning("The <light> attribute intensity is deprecated in XML3D 5.0.", this.node);
                break;
            case "model":
                this.renderNode.remove();
                this.createRenderNode();
                break;
        }
    },

    styleChangedCallback: function () {
        TransformableAdapter.prototype.styleChangedCallback.call();
        this.updateVisibility();
    },

    updateVisibility: function () {
        var none = this.style.getPropertyValue("display").trim() == "none";
        this.renderNode.setLocalVisible(!none);
        this.factory.renderer.requestRedraw("Light visibility changed.");
    },


    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.NODE_REMOVED:
                return;
            case Events.THIS_REMOVED:
                this.dispose();
                return;
        }
    },

    createLightConfiguration: function () {
        var model = this.node.hasAttribute("model") ? this.node.getAttribute("model") : DEFAULT_LIGHT_MODEL;
        var opt = {
            name: this.node.id
        };
        return new LightConfiguration(model, this.dataAdapter.getXflowNode(), opt);
    },

    dispose: function () {
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    },

    /**
     * @return {XML3D.Mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getWorldMatrix(m.data);
        return m;
    }
});

// Export
module.exports = LightRenderAdapter;


},{"../../../base/resourcemanager.js":46,"../../../interface/notification.js":71,"../scene/light-configuration.js":97,"./transformable.js":85}],81:[function(require,module,exports){
var RenderAdapter = require("./base.js");

/**
 * Adapter for <lightshader>
 * TODO(ksons): Remove in 5.1
 * @constructor
 * @param {RenderAdapterFactory} factory
 * @param {Element} node
 * @extends RenderAdapter
 */
var LightShaderRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    XML3D.debug.logWarning("The <lightshader> element is deprecated in XML3D 5.0.", node);
};

// Export
module.exports = LightShaderRenderAdapter;


},{"./base.js":76}],82:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var Events = require("../../../interface/notification.js");
var URI = require("../../../utils/uri.js").URI;
var Resource = require("../../../base/resourcemanager.js").Resource;
var AdapterHandle = require("../../../base/adapterhandle.js");

/**
 * @param factory
 * @param {Element} node
 * @extends RenderAdapter
 * @constructor
 */
var MaterialRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    this._dataAdapter = Resource.getAdapter(node, "data");
    /** @type MaterialConfiguration | null **/
    this._materialConfiguration = null;
    this._materialModel = null;

    this.updateMaterialConfiguration();
};

XML3D.createClass(MaterialRenderAdapter, RenderAdapter,  {

    getMaterialConfiguration: function() {
        return this._materialConfiguration;
    },

    updateMaterialConfiguration: function () {
        // First find the model
        this.updateMaterialModel();
        if (!this._materialModel) {
            this._materialConfiguration = null;
        } else {
            this._materialConfiguration = this.getScene().createMaterialConfiguration(this._materialModel, this._dataAdapter.getXflowNode(), {name: this.node.id});
        }
        this.notifyOppositeAdapters();
    },

    updateMaterialModel: function () {
        this._materialModel = null;

        var uri = this.getMaterialScript();
        if (uri.scheme == "urn") {
            this.disconnectAdapterHandle("script");
            this._materialModel = { "type": "urn", "urn": uri };
            return;
        }

        this.connectAdapterHandle("script", this.getAdapterHandle(uri, "data", 0));
        var adapter = this.getConnectedAdapter('script');
        if (adapter && adapter.getScriptType) {
            this._materialModel = { type: adapter.getScriptType(), script: adapter.getScript() };
        }
    },

    getMaterialScript: function () {
        return new URI(this.node.getAttribute("script"));
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        if (name == "script") {
            this.updateMaterialConfiguration();
        }
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.ADAPTER_HANDLE_CHANGED:
                if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
                    XML3D.debug.logError("Could not find material for url '" + evt.url + "'");

                }
                this.updateMaterialConfiguration();
                break;
        }
    }
});

// Export
module.exports = MaterialRenderAdapter;


},{"../../../base/adapterhandle.js":44,"../../../base/resourcemanager.js":46,"../../../interface/notification.js":71,"../../../utils/uri.js":176,"./base.js":76}],83:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var Events = require("../../../interface/notification.js");
var Resource = require("../../../base/resourcemanager.js").Resource;

/**
 * @constructor
 */
var MeshRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, true, true);
    this.style = window.getComputedStyle(node);
    this.createRenderNode();
};

XML3D.createClass(MeshRenderAdapter, TransformableAdapter, {

    createRenderNode: function () {
        var dataAdapter = Resource.getAdapter(this.node, "data");

        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();

        this.renderNode = this.getScene().createRenderObject({
            parent: parentNode, node: this.node, object: {
                data: dataAdapter.getXflowNode(), type: this.getMeshType()
            }, name: this.node.id
        });
        this.updateVisibility();
        this.updateLocalMatrix();
        this.updateMaterialHandler();
    },

    getMeshType: function () {
        return this.node.hasAttribute("type") ? this.node.getAttribute("type") : "triangles";
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        TransformableAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
        if (name == "type") {
            this.renderNode.setType(newValue);
        }
    },

    styleChangedCallback: function() {
        TransformableAdapter.prototype.styleChangedCallback.call();
        this.updateVisibility();
    },

    updateVisibility: function() {
        var none = this.style.getPropertyValue("display").trim() == "none";
        var hidden  = this.style.getPropertyValue("visibility").trim() == "hidden";
        this.renderNode.setLocalVisible(!(none || hidden));
        this.renderNode.setPickable(!none);
    },

    /**
     * @param {Events.Notification} evt
     */
    notifyChanged: function (evt) {
        TransformableAdapter.prototype.notifyChanged.call(this, evt);
        switch (evt.type) {
            case  Events.NODE_INSERTED:
                return;
            case Events.THIS_REMOVED:
                this.dispose();
                return;
            case Events.NODE_REMOVED:
                // this.createPerObjectData();
                return;
        }
    },

    dispose: function () {
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    },


    // Interface methods

    /**
     * @return {XML3D.Box}
     */
    getLocalBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode && this.renderNode.visible) {
            this.renderNode.getObjectSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {XML3D.Box}
     */
    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode && this.renderNode.visible) {
            this.renderNode.getWorldSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4(), obj = this.renderNode;
        if (obj) {
            obj.getWorldMatrix(m.data);
        }
        return m;
    }
});

// Export
module.exports = MeshRenderAdapter;


},{"../../../base/resourcemanager.js":46,"../../../interface/notification.js":71,"./transformable.js":85}],84:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var Events = require("../../../interface/notification.js");
var Resource = require("../../../base/resourcemanager.js").Resource;
var AdapterHandle = require("../../../base/adapterhandle.js");
var mat4 = require("gl-matrix").mat4;

var ModelRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, false, true);
    this.asset = null;
    this.postTransformXflowRequests = [];
    this.postTransformRenderGroups = [];
    this.style = window.getComputedStyle(node);
    this.createRenderNode();
    this._bindedRequestCallback = this.onXflowRequestChange.bind(this);
    this.transformFetcher.update();
};

var c_IDENTITY = mat4.create();

XML3D.createClass(ModelRenderAdapter, TransformableAdapter, {

    createRenderNode: function () {
        var dataAdapter = Resource.getAdapter(this.node, "data");
        this.asset = dataAdapter.getAsset();

        this.asset.addChangeListener(this);

        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode && parent.getRenderNode();

        this.renderNode = this.getScene().createRenderGroup({
            parent: parentNode, name: this.node.id
        });
        this.renderNode.setLocalMatrix(c_IDENTITY);
        this.createModelRenderNodes();
        this.updateVisibility();

    },

    clearModelRenderNodes: function () {
        this.clearAdapterHandles();
        this._subRenderNodes = [];
        var i = this.postTransformXflowRequests.length;
        while (i--) {
            this.postTransformXflowRequests[i].clear();
        }
        rec_removeRenderNodes(this.renderNode, true);
        this.postTransformXflowRequests.length = 0;
        this.postTransformRenderGroups.length = 0;
    },

    createModelRenderNodes: function () {
        this.clearModelRenderNodes();
        if (!this.asset.isSubtreeLoading()) {
            try {
                this.asset.checkValidity();
                var assetResult = this.asset.getResult();
                var dataTree = assetResult.getDataTree();
                rec_createRenderNodes(this, this.renderNode, dataTree);
            } catch (e) {
                XML3D.debug.logError("Asset Error: " + e.message, e.node || this.node);
                this.clearModelRenderNodes();
            }
        }
    },

    getMaterialConfiguration: function (materialURI, index) {
        var result = null;
        if (materialURI) {
            var adapterHandle = this.getAdapterHandle(materialURI);
            this.connectAdapterHandle("material_" + index, adapterHandle);

            switch (adapterHandle.status) {

                case AdapterHandle.STATUS.NOT_FOUND:
                    XML3D.debug.logError("Could not find <material> of url '" + adapterHandle.url + "' ", this.node);
                    break;
                case AdapterHandle.STATUS.READY:
                    var adapter = adapterHandle.getAdapter();
                    if (adapter && adapter.getMaterialConfiguration) {
                        result = adapter.getMaterialConfiguration();
                    }
                    break;
                case AdapterHandle.STATUS.LOADING:
                    break;
            }

        }
        return result;
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        TransformableAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
    },

    styleChangedCallback: function() {
        TransformableAdapter.prototype.styleChangedCallback.call();
        this.updateVisibility();
    },

    updateVisibility: function() {
        var none = this.style.getPropertyValue("display").trim() == "none";
        var hidden  = this.style.getPropertyValue("visibility").trim() == "hidden";
        var visible = !(none || hidden);
        var propagate = function(node) {
            if (node.setLocalVisible) {
                 node.setLocalVisible(visible)
            }
            if (node.children) {
                node.children.forEach(propagate);
            }
        };
        propagate(this.renderNode);
        // TODO(ksons): this.renderNode.setPickable(!none);
    },


    /**
     * @param evt
     */
    notifyChanged: function (evt) {
        TransformableAdapter.prototype.notifyChanged.call(this, evt);
        switch (evt.type) {
            case  Events.NODE_INSERTED:
                return;
            case Events.THIS_REMOVED:
                this.dispose();
                return;
            case Events.ADAPTER_HANDLE_CHANGED:
                var splits = evt.key.split("_");
                if (splits[0] == "material") {
                    var renderNodeId = +splits[1];
                    // We identify the corresponding rendernode by the handler key
                    // This is a workaround that should be removed if there are
                    // custom callbacks for
                    var renderNode = this._subRenderNodes[renderNodeId];
                    XML3D.debug.assert(renderNode);
                    if (evt.handleStatus == AdapterHandle.STATUS.NOT_FOUND) {
                        renderNode.setMaterial(null);
                    } else {
                        var adapter = evt.adapter;
                        if (adapter && adapter.getMaterialConfiguration) {
                            renderNode.setMaterial(adapter.getMaterialConfiguration());
                        }
                    }
                    this.factory.renderer.requestRedraw("Material model changed.");
                }
        }
    },

    onAssetChange: function () {
         if (!this.renderNode) {
            //This model hasn't even been initialized yet so we defer building the render nodes to that step
            //This can happen for ex. when changing the "src" attribute before the model is appended into the DOM
            return;
        }

        this.createModelRenderNodes();
    },

    onXflowRequestChange: function (request) {
        var index = this.postTransformXflowRequests.indexOf(request);
        if (index != -1) {
            this.updatePostTransform(this.postTransformRenderGroups[index], request);
        }
    },

    updatePostTransform: function (renderNode, xflowRequest) {
        var dataResult = xflowRequest.getResult();
        var transformData = (dataResult.getOutputData("transform") && dataResult.getOutputData("transform").getValue());
        if (!transformData) {
            XML3D.debug.logWarning("Post Transform entry does not contain any 'transform' value.", this.node);
            renderNode.setLocalMatrix(c_IDENTITY);
            return;
        }
        renderNode.setLocalMatrix(transformData);
    },

    dispose: function () {
        this.asset.removeChangeListener(this);
        this.clearModelRenderNodes();
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    }
});

function rec_removeRenderNodes(node, keepCurrentNode) {
    if (!node) {
        return;
    }
    if (!keepCurrentNode)
        node.remove();
    var children = node.getChildren();
    var i = children.length;
    while (i--) {
        rec_removeRenderNodes(children[i], false);
    }
}

function rec_createRenderNodes(adapter, parentNode, dataTreeNode) {

    if (dataTreeNode.postTransformXflowNode) {
        var request = new ComputeRequest(dataTreeNode.postTransformXflowNode, ["transform"], adapter._bindedRequestCallback);
        parentNode = adapter.getScene().createRenderGroup({
            parent: parentNode, visible: true, name: undefined
        });
        adapter.postTransformXflowRequests.push(request);
        adapter.postTransformRenderGroups.push(parentNode);
        adapter.updatePostTransform(parentNode, request);
    }

    var groupNode = adapter.getScene().createRenderGroup({
        parent: parentNode,
        visible: true,
        name: adapter.node.id
    });
    groupNode.setLocalMatrix(dataTreeNode.transform || c_IDENTITY);
    groupNode.setMaterial(adapter.getMaterialConfiguration(dataTreeNode.material, adapter._subRenderNodes.length));
    adapter._subRenderNodes.push(groupNode);

    var meshSets = dataTreeNode.meshes, i;
    for (i = 0; i < meshSets.length; ++i) {
        var renderNode = adapter.getScene().createRenderObject({
            parent: groupNode,
            node: meshSets[i].refNode || adapter.node,
            object: {
                data: meshSets[i].xflowNode, type: meshSets[i].type
            },
            name: adapter.node.id,
            visible: true
        });
        renderNode.setLocalMatrix(meshSets[i].transform || c_IDENTITY);
        renderNode.setMaterial(adapter.getMaterialConfiguration(meshSets[i].material, adapter._subRenderNodes.length));
        adapter._subRenderNodes.push(renderNode);
    }
    var groups = dataTreeNode.groups;
    for (i = 0; i < groups.length; ++i) {
        rec_createRenderNodes(adapter, groupNode, groups[i]);
    }
}


// Interface methods

XML3D.extend(ModelRenderAdapter.prototype, {
    /**
     * @return {XML3D.Box}
     */
    getLocalBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode) {
            this.renderNode.getObjectSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {XML3D.Box}
     */
    getWorldBoundingBox: function () {
        var bbox = new XML3D.Box();
        if (this.renderNode) {
            this.renderNode.getWorldSpaceBoundingBox(bbox);
        }
        return bbox;
    },

    /**
     * @return {mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4(), obj = this.renderNode;
        if (obj) {
            obj.getWorldMatrix(m.data);
        }
        return m;
    }
});

// Export
module.exports = ModelRenderAdapter;


},{"../../../base/adapterhandle.js":44,"../../../base/resourcemanager.js":46,"../../../interface/notification.js":71,"../../../xflow/interface/request.js":182,"./transformable.js":85,"gl-matrix":1}],85:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var DOMTransformFetcher = require("../../../data/transform-fetcher.js");
var Events = require("../../../interface/notification.js");
var AdapterHandle = require("../../../base/adapterhandle.js");

var TransformableAdapter = function (factory, node, handleMaterial, handleTransform) {
    RenderAdapter.call(this, factory, node);
    this.renderNode = null;
    this.materialHandler = null;
    this.handleMaterial = handleMaterial || false;
    if (handleTransform) {
        this.transformFetcher = new DOMTransformFetcher(this, "transform", "transform");
    }

};

XML3D.createClass(TransformableAdapter, RenderAdapter, {

    updateMaterialHandler: function () {
        var materialURI = getMaterialURI(this.node);
        if (!materialURI) {
            this.disconnectAdapterHandle("material");
            this.materialHandler = null;
        } else {
            this.materialHandler = this.getAdapterHandle(materialURI);
            this.connectAdapterHandle("material", this.materialHandler);
        }
        this.referencedMaterialChanged();
    },

    referencedMaterialChanged: function () {
        if (!this.materialHandler) {
            this.getRenderNode().setMaterial(null);
            return;
        }
        var status = this.materialHandler.status;
        if (status === AdapterHandle.STATUS.NOT_FOUND) {
            XML3D.debug.logError("Could not find element of url '" + this.materialHandler.url + "' for material", this.node);
            this.getRenderNode().setMaterial(null);
            return;
        }
        var adapter = this.materialHandler.getAdapter();
        if (adapter && adapter.getMaterialConfiguration) {
            this.getRenderNode().setMaterial(adapter.getMaterialConfiguration());
        } else {
            this.getRenderNode().setMaterial(null);
        }
    },

    onDispose: function () {
        this.transformFetcher && this.transformFetcher.clear();
    },

    onConfigured: function () {
    },

    getRenderNode: function () {
        if (!this.renderNode) {
            this.renderNode = this.createRenderNode ? this.createRenderNode() : null;
            this.updateLocalMatrix();
        }
        return this.renderNode;
    },

    updateLocalMatrix: function () {
        this.transformFetcher && this.transformFetcher.update();
    },

    onTransformChange: function (attrName, matrix) {
        if (attrName == "transform") {
            this.renderNode.setLocalMatrix(matrix);
        }

    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        RenderAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);

        if (name == "transform") {
            this.transformFetcher && this.transformFetcher.update();
        } else if (name == "style") {
            this.transformFetcher && this.transformFetcher.updateMatrix();
        } else if (name == "material" && this.handleMaterial) {
            this.updateMaterialHandler();
            this.factory.renderer.requestRedraw("Transformable material changed.");
        }
    },

    notifyChanged: function (evt) {
     if (evt.type == Events.ADAPTER_HANDLE_CHANGED) {
            var key = evt.key;
            if (key == "material") {
                this.updateMaterialHandler();
                this.factory.renderer.requestRedraw("Material reference changed.");
            }
        }
    }
});

function getMaterialURI(node) {
    var materialURI = node.getAttribute("material");
    if (!materialURI) {
        var styleValue = node.getAttribute('style');
        if (styleValue) {
            var pattern = /material\s*:\s*url\s*\(\s*(\S+)\s*\)/i;
            var result = pattern.exec(styleValue);
            if (result)
                materialURI = result[1];
        }
    }
    return materialURI;
}

module.exports = TransformableAdapter;

},{"../../../base/adapterhandle.js":44,"../../../data/transform-fetcher.js":63,"../../../interface/notification.js":71,"./base.js":76}],86:[function(require,module,exports){
var TransformableAdapter = require("./transformable.js");
var DOMTransformFetcher = require("../../../data/transform-fetcher.js");
var Events = require("../../../interface/notification.js");
var mat4 = require("gl-matrix").mat4;

var ViewRenderAdapter = function (factory, node) {
    TransformableAdapter.call(this, factory, node, false, false);
    this.projectionFetcher = new DOMTransformFetcher(this, "projection", "projection", true);
    this.createRenderNode();
};

XML3D.createClass(ViewRenderAdapter, TransformableAdapter, {

    createRenderNode: function () {
        var parent = this.getParentRenderAdapter();
        var parentNode = parent.getRenderNode ? parent.getRenderNode() : this.factory.renderer.scene.createRootNode();
        var rot = this.node.orientation.data;
        var m = mat4.fromRotation(mat4.create(), rot[3], rot);
        this.renderNode = this.factory.renderer.scene.createRenderView({
            position: this.node.position.data,
            orientation: m,
            fieldOfView: this.node.fieldOfView,
            parent: parentNode
        });
        this.projectionFetcher.update();
    },

    /* Interface method */
    getViewMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getWorldToViewMatrix(m.data);
        return m;
    },

    /**
     * returns view2world matrix
     * @return {mat4}
     */
    getWorldMatrix: function () {
        var m = new XML3D.Mat4();
        this.renderNode.getViewToWorldMatrix(m.data);
        return m;
    },

    attributeChangedCallback: function (name, oldValue, newValue) {
        TransformableAdapter.prototype.attributeChangedCallback.call(this, name, oldValue, newValue);
        switch (name) {
            case "orientation":
                var rot = this.node.orientation.data;
                var m = mat4.fromRotation(mat4.create(), rot[3], rot);
                this.renderNode.updateOrientation(m);
                break;
            case "position":
                this.renderNode.updatePosition(this.node.position.data);
                break;
            case "projection":
                this.projectionFetcher.update();
                break;
            case "fieldofview":
                this.renderNode.updateFieldOfView(this.node.fieldOfView);
                break;
            default:
                XML3D.debug.logWarning("Unhandled value changed event in view adapter for attribute:" + target);
        }
    },

    notifyChanged: function (evt) {
        switch (evt.type) {
            case Events.THIS_REMOVED:
                this.dispose();
                break;
        }
        this.factory.getRenderer().requestRedraw("View changed");
    },

    onTransformChange: function (attrName, matrix) {
        TransformableAdapter.prototype.onTransformChange.call(this, attrName, matrix);
        if (attrName == "projection") {
            this.renderNode.setProjectionOverride(matrix);
        }
    },

    dispose: function () {
        this.projectionFetcher.clear();
        this.getRenderNode().remove();
        this.clearAdapterHandles();
    }
});

// Export
module.exports = ViewRenderAdapter;


},{"../../../data/transform-fetcher.js":63,"../../../interface/notification.js":71,"./transformable.js":85,"gl-matrix":1}],87:[function(require,module,exports){
var RenderAdapter = require("./base.js");
var Utils = require("../utils.js");
var Events = require("../../../interface/notification.js");
var dispatchCustomEvent = require("../../../utils/misc.js").dispatchCustomEvent;
var getOrCreateActiveView = require("../../../utils/misc.js").getOrCreateActiveView;
var Resource = require("../../../base/resourcemanager.js").Resource;

var XML3DRenderAdapter = function (factory, node) {
    RenderAdapter.call(this, factory, node);
    this.fireLoadEventAfterDraw = false;
    this.firstLoadFired = false;
};
XML3D.createClass(XML3DRenderAdapter, RenderAdapter, {
    updateActiveViewAdapter: function () {
        var href = this.node.getAttribute("activeView");
        if (href) {
            this.connectAdapterHandle("activeView", this.getAdapterHandle(href));
        } else {
            this.disconnectAdapterHandle("activeView");
        }
    },

    setViewAdapter: function (adapter) {
        adapter = adapter || this.getConnectedAdapter("activeView");
        if (!(adapter && adapter.getRenderNode)) {
            var viewElement = getOrCreateActiveView(this.node);
            adapter = this.factory.getAdapter(viewElement);
        }
        this.factory.getScene().setActiveView(adapter.getRenderNode());
    },

    attributeChangedCallback: function(name, oldValue, newValue) {
        if(name.toLowerCase() == "activeview") {
            this.updateActiveViewAdapter();
            this.setViewAdapter();
        }
    },

    dispose: function () {
        this.clearAdapterHandles();
    }
});

XML3DRenderAdapter.prototype.notifyChanged = function (evt) {

    switch (evt.type) {
        case Events.ADAPTER_HANDLE_CHANGED:
            this.setViewAdapter(evt.adapter);
            return;
        case Events.NODE_INSERTED:
            // This also initializes the children
            this.initElement(evt.mutation.target);
            return;
        case Events.NODE_REMOVED:
            // Handled in removed node
            return;
    }
};

/* Interface methods */

/*
 * This function is called when scene DOM is loaded and all adapters are attached
 */
XML3DRenderAdapter.prototype.onConfigured = function () {
    this.updateActiveViewAdapter();
    this.setViewAdapter();

    // emit load event when all resources currently loading are completed
    var callback = this.onLoadComplete.bind(this);
    // register callback for canvasId == 0 i.e. global resources
    Resource.addLoadCompleteListener(0, callback);
    // register callback for canvasId of this node
    Resource.addLoadCompleteListener(this.factory.canvasId, callback);
    this.onLoadComplete();
};

XML3DRenderAdapter.prototype.onLoadComplete = function (canvasId) {
    if (Resource.isLoadComplete(0) && Resource.isLoadComplete(this.factory.canvasId)) {
        this.fireLoadEventAfterDraw = true;
    }
};

XML3DRenderAdapter.prototype.onFrameDrawn = function () {
    if (this.fireLoadEventAfterDraw) {
        this.fireLoadEventAfterDraw = false;
        this.firstLoadFired = true;
        dispatchCustomEvent(this.node, 'load', false, true, null);
    }
};


XML3DRenderAdapter.prototype.getComplete = function () {
    if (this.fireLoadEventAfterDraw) return false;
    if (!this.firstLoadFired) return false;
    return Resource.isLoadComplete(0) && Resource.isLoadComplete(this.factory.canvasId);
};

XML3DRenderAdapter.prototype.getWorldBoundingBox = function () {
    var bbox = new XML3D.Box();
    Array.prototype.forEach.call(this.node.childNodes, function (c) {
        if (c.getWorldBoundingBox) {
            bbox.extend(c.getWorldBoundingBox());
        }
    });
    return bbox;
};
//XML3D element is the root with no transform of its own so by definition it's always in world space
XML3DRenderAdapter.prototype.getLocalBoundingBox = XML3DRenderAdapter.prototype.getWorldBoundingBox;

/**
 *
 * @param x number x coordinate in screen space
 * @param y number y coordinate in screen space
 * @param hitPoint? XML3D.Vec3
 * @param hitNormal? XML3D.Vec3
 * @returns {*}
 */
XML3DRenderAdapter.prototype.getElementByPoint = function (x, y, hitPoint, hitNormal) {
    var relativeMousePos = Utils.convertPageCoords(this.node, x, y);

    var relX = relativeMousePos.x;
    var relY = relativeMousePos.y;

    var renderer = this.factory.getRenderer();
    var object = renderer.getRenderObjectFromPickingBuffer(relX, relY);
    if (object) {
        if (hitPoint) {
            var vec = renderer.getWorldSpacePositionByPoint(relX, relY, object);
            XML3D.math.vec3.copy(hitPoint.data, vec);
        }
        if (hitNormal) {
            var vec = renderer.getWorldSpaceNormalByPoint(relX, relY, object);
            XML3D.math.vec3.copy(hitNormal.data, vec);
        }
    } else {
        if (hitPoint) {
            hitPoint.x = NaN;
            hitPoint.y = NaN;
            hitPoint.z = NaN;
        }
        if (hitNormal) {
            hitNormal.x = NaN;
            hitNormal.y = NaN;
            hitNormal.z = NaN;
        }
    }
    return object ? object.node : null;
};

XML3DRenderAdapter.prototype.getRenderInterface = function () {
    return this.factory.getRenderer().getRenderInterface();
};

XML3DRenderAdapter.prototype.generateRay = function (x, y) {
    var relativeMousePos = Utils.convertPageCoords(this.node, x, y);
    return this.factory.getRenderer().generateRay(relativeMousePos.x, relativeMousePos.y);
};

XML3DRenderAdapter.prototype.getElementByRay = (function () {
    var c_viewMat = XML3D.math.mat4.create();
    var c_projMat = XML3D.math.mat4.create();

    return function (xml3dRay, hitPoint, hitNormal) {
        var renderer = this.factory.getRenderer();
        renderer.calculateMatricesForRay(xml3dRay, c_viewMat, c_projMat);
        var hitObject = renderer.getRenderObjectByRay(xml3dRay, c_viewMat, c_projMat);
        if (hitObject !== null && (hitPoint || hitNormal)) {
            if (hitPoint) {
                var vec = renderer.getWorldSpacePositionByRay(xml3dRay, hitObject, c_viewMat, c_projMat);
                XML3D.math.vec3.copy(hitPoint.data, vec);
            }
            if (hitNormal) {
                var vec = renderer.getWorldSpaceNormalByRay(xml3dRay, hitObject, c_viewMat, c_projMat);
                XML3D.math.vec3.copy(hitNormal.data, vec);
            }
        } else {
            if (hitPoint) {
                hitPoint.x = NaN;
                hitPoint.y = NaN;
                hitPoint.z = NaN;
            }
            if (hitNormal) {
                hitNormal.x = NaN;
                hitNormal.y = NaN;
                hitNormal.z = NaN;
            }
        }
        return hitObject !== null ? hitObject.node : null;
    }
})();

module.exports = XML3DRenderAdapter;



},{"../../../base/resourcemanager.js":46,"../../../interface/notification.js":71,"../../../utils/misc.js":174,"../utils.js":109,"./base.js":76}],88:[function(require,module,exports){
var MouseEvents = require("./events/mouse.js");
var TouchEvents = require("./events/touch.js");

var c_globalCanvasId = 0;

/**
 * @param {Element} xml3dElement
 * @constructor
 */
function AbstractCanvasHandler(xml3dElement, canvas) {
    this._xml3dElement = xml3dElement;
    this._canvas = canvas;
    this.id = ++c_globalCanvasId; // global canvas id starts at 1

    this._mouseHandler = new MouseEvents.MouseEventHandler(xml3dElement, this);
    this._registerCanvasListeners(this._mouseHandler, MouseEvents.EVENTS);
    if(this.hasTouchEvents()) {
        this._touchHandler = new TouchEvents.TouchEventHandler(xml3dElement, this);
        this._registerCanvasListeners(this._touchHandler, TouchEvents.EVENTS);
    }
}

/**
 * @returns {boolean}
 */
AbstractCanvasHandler.prototype.hasTouchEvents = function() {
    return 'ontouchstart' in window;
};

AbstractCanvasHandler.prototype.getCanvas = function() {
   return this._canvas;
};

AbstractCanvasHandler.prototype.dispatchEvent = function(event) {
    this._xml3dElement.dispatchEvent(event);
};

AbstractCanvasHandler.prototype._registerCanvasListeners = function (handler, events) {
    var canvas = this._canvas;
    events.forEach(function (name) {
        canvas.addEventListener(name, function (e) {
            handler[name] && handler[name].call(handler, e);
            e.stopPropagation();
        });
    });
};

AbstractCanvasHandler.prototype.dispatchCustomEvent = function(type, detail) {
    detail = detail || null;
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(type, true, true, detail);
    this._xml3dElement.dispatchEvent(event);
};


/**
 * The update event can be used by user to sync actions
 * with rendering
 */
AbstractCanvasHandler.prototype.dispatchUpdateEvent = function () {
    this.dispatchCustomEvent("update");
};


AbstractCanvasHandler.prototype.dispatchResizeEvent = function (dimensions) {
    this.dispatchCustomEvent("resize", dimensions);
};

/**
 * Dispatches a FrameDrawnEvent to listeners
 *
 * @param start
 * @param end
 * @param stats
 * @return
 */
AbstractCanvasHandler.prototype.dispatchFrameDrawnEvent = function (start, end, stats) {
    stats = stats || {
        count: {
            primitives: 0, objects: 0
        }
    };
    var data = {
        timeStart: start, timeEnd: end, renderTimeInMilliseconds: end - start, count: stats.count
    };
    this.dispatchCustomEvent("framedrawn", data);
};

module.exports = AbstractCanvasHandler;

},{"./events/mouse.js":90,"./events/touch.js":91}],89:[function(require,module,exports){
var RenderAdapterFactory = require("./adapter/factory.js");
var xml3dFormatHandler = require("../../base/formathandler.js").xml3dFormatHandler;

xml3dFormatHandler.registerFactoryClass(RenderAdapterFactory);

var factory = require("./renderer-factory.js");

var configure = function(xml3ds) {
    if (!(xml3ds instanceof Array))
        xml3ds = [xml3ds];

    xml3ds.forEach(function(xml3dElement) {
        XML3D.debug.logDebug("Configuring Renderer for", xml3dElement.id);
        var renderer = factory.createRenderer(xml3dElement)

    });
};

module.exports = configure;
},{"../../base/formathandler.js":45,"./adapter/factory.js":78,"./renderer-factory.js":94}],90:[function(require,module,exports){
var Options = require("../../../utils/options.js");

var OPTION_MOUSEMOVE_PICKING = "renderer-mousemove-picking";
var OPTION_MOVEMENT_AWARE_CLICK_HANDLER = "renderer-movement-aware-click-handler";
Options.register(OPTION_MOUSEMOVE_PICKING, true);
Options.register(OPTION_MOVEMENT_AWARE_CLICK_HANDLER, false);

var EVENTS = ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mousemove", "mouseout", "wheel"];

/**
 *
 * @param {Element} defaultTarget
 * @param {AbstractCanvasHandler} canvasHandler
 * @constructor
 */
var MouseEventHandler = function(defaultTarget, canvasHandler) {
    this._defaultTarget = defaultTarget;
    this._canvasHandler = canvasHandler;
    this._lastMousePosition =  {x: 0, y: 0};
};

var supportsEventConstructors = (function() {
    try {
        new MouseEvent("click", {});
        return true;
    } catch (e){
        return false;
    }
})();

MouseEventHandler.prototype =  {

    /**
     * @param {MouseEvent} event  The original event
     * @param {Element} target  target to dispatch on
     * @param {object?}     opt    Options
     */
    dispatchMouseEvent: function (event, target, opt) {
        opt = opt || {};
        target = target || this._defaultTarget;
        var x = opt.x !== undefined ? opt.x : event.clientX;
        var y = opt.y !== undefined ? opt.y : event.clientY;
        var noCopy = opt.noCopy || false;
        // Copy event to avoid DOM dispatch errors (cannot dispatch event more
        // than once)
        if (!noCopy) {
            event = this.copyMouseEvent(event);
        }
        this.initExtendedMouseEvent(event, x, y);

        target.dispatchEvent(event);
    },

    /**
     * @param {MouseEvent|WheelEvent} event the event to copy
     * @return {MouseEvent} the new event
     */
    copyMouseEvent: function (event) {
        var evt;
        if (supportsEventConstructors) {
            if (event.toString() === "[object WheelEvent]") {
                evt = new WheelEvent(event.type, event);
            } else {
                evt = new MouseEvent(event.type, event);
            }
        } else {
            //These event APIs are deprecated but still required by IE, which doesn't support event constructors yet
            if (event.toString() === "[object WheelEvent]") {
                evt = document.createEvent("WheelEvent");
                evt.initWheelEvent(event.type, event.bubbles, event.cancelable, event.view, event.detail,
                    event.screenX, event.screenY, event.clientX, event.clientY, event.button, event.relatedTarget, "",
                    event.deltaX, event.deltaY, event.deltaZ, event.deltaMode);
            } else {
                evt = document.createEvent("MouseEvent");
                evt.initMouseEvent(event.type, event.bubbles, event.cancelable, event.view, event.detail,
                    event.screenX, event.screenY, event.clientX, event.clientY, event.ctrlKey, event.altKey,
                    event.shiftKey, event.metaKey, event.button, event.relatedTarget);
            }
        }
        if (event.dataTransfer)
            evt.data = {url: event.dataTransfer.getData("URL"), text: event.dataTransfer.getData("Text")};
        // override preventDefault to actually prevent the default of the original event
        evt.preventDefault = function () {
            event.preventDefault();
        };
        return evt;
    },

    createMouseEvent: function (type, opts) {
        opts = opts || {};
        var dict = {
            bubbles		: opts.bubbles !== undefined ? opts.bubbles : true,
            cancelable 	: opts.cancelable !== undefined ? opts.cancelable : true,
            view 		: opts.view || window,
            detail 		: opts.detail !== undefined ? opts.detail : 0,
            screenX		: opts.screenX !== undefined ? opts.screenX : 0,
            screenY		: opts.screenY !== undefined ? opts.screenY : 0,
            clientX		: opts.clientX !== undefined ? opts.clientX : 0,
            clientY		: opts.clientY !== undefined ? opts.clientY : 0,
            ctrl 		: opts.ctrl !== undefined ? opts.ctrl : false,
            alt 		: opts.alt !== undefined ? opts.alt : false,
            shift 		: opts.shift !== undefined ? opts.shift : false,
            meta 		: opts.meta !== undefined ? opts.meta : false,
            button 		: opts.button !== undefined ? opts.button : 0,
            relatedTarget : opts.relatedTarget
        };
        if (supportsEventConstructors) {
            return new MouseEvent(type, dict);
        } else {
            var evt = document.createEvent("MouseEvent");
            evt.initMouseEvent(type, dict.bubbles, dict.cancelable, dict.view, dict.detail,
                dict.screenX, dict.screenY, dict.clientX, dict.clientY, dict.ctrlKey, dict.altKey,
                dict.shiftKey, dict.metaKey, dict.button, dict.relatedTarget);
            return evt;
        }
    },

    /**
     * Adds position and normal attributes to the given event.
     *
     * @param {Event} event
     * @param {number} x
     * @param {number} y
     * @return {XML3D.Vec3}
     */
    initExtendedMouseEvent: function (event, x, y) {
        var handler = this._canvasHandler;

        (function () {
            var cachedPosition = undefined;
            var cachedNormal = undefined;

            event.__defineGetter__("normal", function () {
                if (!cachedNormal) {
                    var norm = (handler.getWorldSpaceNormalByPoint(x, y));
                    cachedNormal = norm || null;
                }
                return cachedNormal;
            });
            event.__defineGetter__("position", function () {
                if (!cachedPosition) {
                    var pos = handler.getWorldSpacePositionByPoint(x, y);
                    cachedPosition = pos || null;
                }
                return cachedPosition;
            });
        })();
    },

    /**
     * @param {MouseEvent} evt
     * @param {object?} opt
     */
    dispatchMouseEventOnPickedObject: function (evt, opt) {
        opt = opt || {};
        var pos = this.getMousePosition(evt);

        var picked = null;
        if (!opt.omitUpdate)
            picked = this._canvasHandler.getPickObjectByPoint(pos.x, pos.y);

        this.dispatchMouseEvent(evt, picked && picked.node, pos);
    },

    getMousePosition: function (evt) {
        return this._canvasHandler.getMousePosition(evt)
    },


    /**
     * @param {MouseEvent} evt
     */
    mouseup: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * @param {MouseEvent} evt
     */
    mousedown: function (evt) {
        this._lastMousePosition = this.getMousePosition(evt);
        this.dispatchMouseEventOnPickedObject(evt);
    },


    /**
     * @param {MouseEvent} evt
     */
    click: function (evt) {
        if (Options.getValue("renderer-movement-aware-click-handler") === true) {
            var pos = this.getMousePosition(evt);
            if (Math.abs(pos.x - this._lastMousePosition.x) > 4 || Math.abs(pos.y - this._lastMousePosition.y) > 4)
                return;
        }
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * @param {MouseEvent} evt
     */
    dblclick: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt);
    },

    /**
     * This method is called each time a mouseMove event is triggered on the
     * canvas.
     *
     * This method also triggers mouseover and mouseout events of objects in the
     * scene.
     *
     * @param {MouseEvent} evt
     */
    mousemove: function (evt) {
        var pos = this.getMousePosition(evt);

        var doMouseMovePick = Options.getValue(OPTION_MOUSEMOVE_PICKING);

        this.dispatchMouseEventOnPickedObject(evt, {omitUpdate: !doMouseMovePick});
        if (!doMouseMovePick)
            return;

        var curObj = this._canvasHandler.getPickedObject();

        // trigger mouseover and mouseout
        if (curObj !== this.lastPickObj) {
            if (this.lastPickObj) {
                // The mouse has left the last object
                this.dispatchMouseEvent(this.createMouseEvent("mouseout", {
                    clientX: pos.x, clientY: pos.y, button: evt.button
                }), this.lastPickObj);
                if (!curObj) { // Nothing picked, this means we enter the xml3d canvas
                    this.dispatchMouseEvent(this.createMouseEvent("mouseover", {
                        clientX: pos.x, clientY: pos.y, button: evt.button
                    }), this._defaultTarget);
                }
            }
            if (curObj) {
                // The mouse is now over a different object, so call the new
                // object's mouseover method
                this.dispatchMouseEvent(this.createMouseEvent("mouseover", {
                    clientX: pos.x, clientY: pos.y, button: evt.button
                }), curObj);
                if (!this.lastPickObj) { // Nothing was picked before, this means we leave the xml3d canvas
                    this.dispatchMouseEvent(this.createMouseEvent("mouseout", {
                        clientX: pos.x, clientY: pos.y, button: evt.button
                    }), this._defaultTarget);
                }
            }

            this.lastPickObj = curObj;
        }
    },

    /**
     * @param {MouseEvent} evt
     */
    mouseout: function (evt) {
        var pos = this.getMousePosition(evt);
        this.dispatchMouseEvent(evt, this.lastPickObj, pos);
    },

    /**
     * @param {MouseEvent} evt
     */
    mouseover: function (evt) {
        var doMouseMovePick = Options.getValue(OPTION_MOUSEMOVE_PICKING);
        this.dispatchMouseEventOnPickedObject(evt, {omitUpdate: !doMouseMovePick});
    },

    /**
     * @param {WheelEvent} evt
     */
    wheel: function (evt) {
        this.dispatchMouseEventOnPickedObject(evt, { type: "wheel" });
    }


};

module.exports = {
    EVENTS: EVENTS, MouseEventHandler: MouseEventHandler
};

},{"../../../utils/options.js":175}],91:[function(require,module,exports){
/**
 *
 * @param {Element} defaultTarget
 * @param {AbstractCanvasHandler} canvasHandler
 * @constructor
 */
var TouchEventHandler = function (defaultTarget, canvasHandler) {
    this._defaultTarget = defaultTarget;
    this._canvasHandler = canvasHandler;
};


var EVENTS = ["touchstart", "touchmove", "touchend", "touchcancel"];

TouchEventHandler.prototype = {

    copyTouchEvent: function (event, options) {
        var touchEventData = this.copyTouchEventData(event, options);
        return this.createTouchEvent(touchEventData);
    },


    copyTouchEventData: function (event, options) {
        return {
            type: options.type || event.type,
            timeStamp: Date.now(),
            bubbles: event.bubbles,
            cancelable: event.cancelable,
            detail: event.detail,
            screenX: event.screenX,
            screenY: event.screenY,
            pageX: event.pageX,
            pageY: event.pageY,
            clientX: event.clientX,
            clientY: event.clientY,
            ctrlKey: event.ctrlKey,
            altKey: event.altKey,
            shiftKey: event.shiftKey,
            metaKey: event.metaKey,
            scale: event.scale,
            rotation: event.rotation,
            view: event.view,
            touches: event.touches,
            changedTouches: event.changedTouches,
            targetTouches: event.targetTouches
        };
    },

    createTouchEvent: function (data) {
        var touchEvent;

        try {
            touchEvent = document.createEvent('TouchEvent');
        } catch (e) {
            XML3D.debug.logWarning("Create Touch Event failed, creating UI instead");
            touchEvent = document.createEvent('UIEvent');
        }

        if (touchEvent && touchEvent.initTouchEvent) {
            if (touchEvent.initTouchEvent.length == 0) { //chrome
                touchEvent.initTouchEvent(data.touches, data.targetTouches, data.changedTouches, data.type, data.view, data.screenX, data.screenY, data.clientX, data.clientY);
            } else if (touchEvent.initTouchEvent.length == 12) { //firefox
                touchEvent.initTouchEvent(data.type, data.bubbles, data.cancelable, data.view, data.detail, data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.touches, data.targetTouches, data.changedTouches);
            } else { //iOS length = 18
                touchEvent.initTouchEvent(data.type, data.bubbles, data.cancelable, data.view, data.detail, data.screenX, data.screenY, data.pageX, data.pageY, data.ctrlKey, data.altKey, data.shiftKey, data.metaKey, data.touches, data.targetTouches, data.changedTouches, data.scale, data.rotation);
            }
        }
        return touchEvent;
    },

    /**
     * @param {Event} evt
     * @param {object?} opt
     */
    dispatchTouchEventOnPickedObject: function (evt, opt) {
        opt = opt || {};
        var touchEvent = this.copyTouchEvent(evt, opt);
        touchEvent.preventDefault = function () {
            evt.preventDefault();
        };
        this._defaultTarget.dispatchEvent(touchEvent);
    },

    touchstart: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchend: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchmove: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    },

    touchcancel: function (evt) {
        this.dispatchTouchEventOnPickedObject(evt);
    }

};


module.exports = {
    EVENTS: EVENTS, TouchEventHandler: TouchEventHandler
};

},{}],92:[function(require,module,exports){
function LightManager() {
    this._lights = [];
    this._models = {};

    /**
     * Updating light parameters can lead to updating the (lazy) scene structure, which
     * in turn updates the lights. If we are in updating the lights, flag is set to true.
     * @type {boolean}
     * @private
     */
    this._inUpdate = false;
}

LightManager.prototype = {
    add: function (light) {
        this._lights.push(light);
        this._addModel(light.model);
    },

    remove: function (light) {
        var index = this._lights.indexOf(light);
        if (index != -1) {
            this._lights.splice(index, 1);
        }
        this._removeModel(light.model);
    },

    fillGlobalParameters: function (globals, force) {
        for (var id in this._models) {
            var entry = this._models[id];
            /* Fill globals only if this was not already done before */
            if (entry.changed || force) {
                var prefix = id + "Light";
                for (var param in entry.parameters) {
                    var name = prefix + param.charAt(0).toUpperCase() + param.slice(1);
                    globals[name] = entry.parameters[param];
                }
                entry.changed = false;
            }
        }
    },

    lightValueChanged: function (light) {
        if (this._inUpdate)
            return;
        this._inUpdate = true;

        var lights = light ? [light] : this._lights;
        var that = this;

        lights.forEach(function(light) {
            var model = light.model;
            var entry = that.getModelEntry(model.id);
            var offset = entry.lightModels.indexOf(model);
            XML3D.debug.assert(offset != -1, "Light values changed for a light that is not managed by this LightManager");
            model.fillLightParameters(entry.parameters, offset);
            model.getLightData(entry.parameters, offset);
            entry.changed = true;
        });
        this._inUpdate = false;
    },

    getModelEntry: function (id) {
        return this._models[id];
    },

    getModels: function (id) {
        return Object.keys(this._models);
    },

    getModelCount: function (id) {
        var model = this.getModelEntry(id);
        return model ? model.lightModels.length : 0;
    },

    _addModel: function (model) {
        var entry = this._models[model.id];
        if (!entry) {
            entry = this._models[model.id] = {lightModels: [], parameters: {}};
        }
        entry.lightModels.push(model);
        this._lightStructureChanged(entry);
    },

    _removeModel: function (model) {
        var entry = this.getModelEntry(model.id);
        var index = entry.lightModels.indexOf(model);
        if (index != -1) {
            entry.lightModels.splice(index, 1);
        }
        this._lightStructureChanged(entry);
    },

    _lightStructureChanged: function (entry) {
        this._inUpdate = true;
        var length = entry.lightModels.length;
        if (!length) {
            entry.parameters = {};
            return;
        }
        var model = entry.lightModels[0];
        entry.parameters = model.allocateParameterArray(length);
        entry.lightModels.forEach(function (lightModel, offset) {
            lightModel.fillLightParameters(entry.parameters, offset)
            lightModel.getLightData(entry.parameters, offset);
        });
        entry.changed = true;
        this._inUpdate = false;

    }
};

module.exports = LightManager;

},{}],93:[function(require,module,exports){
var Frustum = require("../tools/frustum.js").Frustum;
var XC = require("../../../xflow/interface/constants.js");
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var mat4 = require("gl-matrix").mat4;
var vec3 = require("gl-matrix").vec3;
var quat = require("gl-matrix").quat;

var PointLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "attenuation": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 1]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]},
    "nearFar": {type: XC.DATA_TYPE.FLOAT2, 'default': [1.0, 100.0]}
};

var SpotLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "attenuation": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 1]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "falloffAngle": {type: XC.DATA_TYPE.FLOAT, 'default': [Math.PI / 4]},
    "softness": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]}
};

var DirectionalLightData = {
    "intensity": {type: XC.DATA_TYPE.FLOAT3, 'default': [1, 1, 1]},
    "direction": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, -1]},
    "shadowBias": {type: XC.DATA_TYPE.FLOAT, 'default': [0.0001]},
    "position": {type: XC.DATA_TYPE.FLOAT3, 'default': [0, 0, 0]},
    "castShadow": {type: XC.DATA_TYPE.BOOL, 'default': [false]},
    "on": {type: XC.DATA_TYPE.BOOL, 'default': [true]},
    "matrix": {type: XC.DATA_TYPE.FLOAT4X4, 'default': [1, 0, 0, 0,   0, 1, 0, 0,    0, 0, 1, 0,  0, 0, 0, 1]}
};


function createXflowData(config) {
    var data = new DataNode();
    for (var name in config) {
        var entry = config[name];
        createXflowValue(data, name, entry.type, entry['default']);
    }
    return data;
}

function createXflowValue(dataNode, name, type, value) {
    var buffer = new BufferEntry(type, new XC.TYPED_ARRAY_MAP[type](value));
    var inputNode = new InputNode();
    inputNode.data = buffer;
    inputNode.name = name;
    dataNode.appendChild(inputNode);
}

/**
 * Base class for light models
 * @param {string} id Unique id that identifies the light model
 * @param {RenderLight} light
 * @param {DataNode} dataNode
 * @param {Object} config Configuration that contains the light model's parameters and default values
 * @constructor
 */
var LightModel = function (id, light, dataNode, config) {
    this.id = id;
    this.light = light;
    this.configuration = config;
    this.parameters = Object.keys(config);
    /**
     * If the light has not data, just use the default parameters
     */
    if (dataNode) {
        var data = new DataNode();
        data.insertBefore(createXflowData(config), null);
        data.insertBefore(dataNode, null);
        this.dataNode = data;
    } else {
        this.dataNode = createXflowData(config);
    }

    // Horizontal opening angle of the light camera. Derived from falloffAngle in case of spot light
    this.fovy =  Math.PI/2.0;

    this.lightParameterRequest = new ComputeRequest(this.dataNode, this.parameters, this.lightParametersChanged.bind(this));
    this.lightParametersChanged(this.lightParameterRequest, null);
};

LightModel.prototype = {
    /**
     * Copies the light parameters in an array of the same size
     * @param {Object} target Name to typed array map containing the data
     * @param {number} offset Slot in the array to be filled
     */
    fillLightParameters: function (target, offset) {
        var result = this.lightParameterRequest.getResult();
        this.parameters.forEach(function (name) {
            var entry = result.getOutputData(name);
            var size = XC.DATA_TYPE_TUPLE_SIZE[entry.type];
            var value = entry.getValue();
            target[name].set(value.subarray(0, size), offset * size);
        });
        this.transformParameters(target, offset);
    },

    allocateParameterArray: function (size) {
        var parameterArrays = {};
        var config = this.configuration;
        this.parameters.forEach(function (name) {
            var type = config[name].type;
            var tupleSize = XC.DATA_TYPE_TUPLE_SIZE[type];
            parameterArrays[name] = new XC.TYPED_ARRAY_MAP[type](tupleSize * size);
        });
        return parameterArrays;
    },

    getParameter: function(name) {
        if(name in this.configuration) {
            // No other checks required because parameters are always defined
            return this.lightParameterRequest.getResult().getOutputData(name).getValue();
        }
        return null;
    },

    lightParametersChanged: function (request, changeType) {
        if (changeType) {
            this.light.lightValueChanged();
        }
    },

    _expandNearFar:function(nfobject){
        var expand = Math.max((nfobject.far - nfobject.near) * 0.30, 0.05);
        nfobject.near -= expand;
        nfobject.far  += expand;
    },

    getLightData: function (target, offset) {
        var matrix = target["matrix"].subarray(offset * 16, offset * 16 + 16);
        this.getLightViewProjectionMatrix(matrix);
    },

    getLightViewProjectionMatrix: function (target) {
        var LVM = mat4.create();
        var LPM = mat4.create();
        this.getLightViewMatrix(LVM);
        this.getLightProjectionMatrix(LPM);
        XML3D.math.mat4.multiply(target, LPM, LVM);
    },

    getLightProjectionMatrix: function (target) {
        this.light.getFrustum(1).getProjectionMatrix(target);
    },

    getLightViewMatrix: (function() {
        var tmp = mat4.create();

        return function (mat) {
            var p_dir = this.getParameter("direction");
            var p_pos = this.getParameter("position");

            // Get the world matrix from the light in the transformation hierarchy
            // world => light
            this.light.getWorldMatrix(mat);

            // Derive rotation from the direction and standard direction (-z => no rotation)
            var q_rot = XML3D.math.quat.rotationTo(quat.create(),c_standardDirection, p_dir);
            // Create matrix from rotation and translation
            mat4.fromRotationTranslation(tmp, q_rot, p_pos);
            // Add to world matrix\
            mat4.mul(mat, mat, tmp);

            // Invert:  light => world
            mat4.invert(mat, mat);
        }
    })()

};

var c_tmpWorldMatrix = mat4.create();
var c_standardDirection = vec3.fromValues(0,0,-1);


function transformPose(light, position, direction) {
    light.getWorldMatrix(c_tmpWorldMatrix);
    if (position) {
        vec3.transformMat4(position, position, c_tmpWorldMatrix);
    }
    if (direction) {
        XML3D.math.vec3.transformDirection(direction, direction, c_tmpWorldMatrix);
        vec3.normalize(direction, direction);
    }
}

function transformDefault(target, offset, light) {
    target["on"][offset] = light.visible;
}


/**
 * Implement XML3D's predefined point light model urn:xml3d:light:point
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var PointLightModel = function (dataNode, light) {
    LightModel.call(this, "point", light, dataNode, PointLightData);
};

XML3D.createClass(PointLightModel, LightModel, {
    getFrustum: function (aspect, sceneBoundingBox) {
        var orthogonal = false;
        var entry = this.light.scene.lights.getModelEntry(this.id);

        if (sceneBoundingBox.isEmpty()) {
            entry.parameters["nearFar"][0] = 1.0;
            entry.parameters["nearFar"][1] = 110.0;
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, orthogonal)
        }


        var t_mat = mat4.create();
        this.getLightViewMatrix(t_mat);
        sceneBoundingBox.transformAxisAligned(t_mat);

        var nf = {
            near: -sceneBoundingBox.max.z, far: -sceneBoundingBox.min.z
        };
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        entry.parameters["nearFar"][0] = 1.0;
        entry.parameters["nearFar"][1] = nf.far;

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, orthogonal);
    },

    transformParameters: function (target, offset) {
        var position = target["position"].subarray(offset * 3, offset * 3 + 3);
        transformPose(this.light, position, null);
        transformDefault(target, offset, this.light);
    }
});




/**
 * Implement XML3D's predefined spot light model urn:xml3d:light:spot
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var SpotLightModel = function (dataNode, light) {
    LightModel.call(this, "spot", light, dataNode, SpotLightData);
};


XML3D.createClass(SpotLightModel, LightModel, {
    getFrustum: function (aspect, sceneBoundingBox) {

        if (sceneBoundingBox.isEmpty()) {
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, false)
        }

        var t_mat = mat4.create();
        this.getLightViewMatrix(t_mat);
        sceneBoundingBox.transformAxisAligned(t_mat);

        var nf = {
            near: -sceneBoundingBox.max.z, far: -sceneBoundingBox.min.z
        };
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, false);
    },

    transformParameters: function (target, offset) {
        var position = target["position"].subarray(offset * 3, offset * 3 + 3);
        var direction = target["direction"].subarray(offset * 3, offset * 3 + 3);
        // Transform position and direction from object to world space
        transformPose(this.light, position, direction);
        transformDefault(target, offset, this.light);
    },

    lightParametersChanged: function (request, changeType) {
        this.fovy = this.getParameter("falloffAngle")[0] * 2;
        LightModel.prototype.lightParametersChanged.call(this, request, changeType);
    }
});




/**
 * Implement XML3D's predefined spot light model urn:xml3d:light:directional
 * @param {DataNode} dataNode
 * @param {RenderLight} light
 * @extends LightModel
 * @constructor
 */
var DirectionalLightModel = function (dataNode, light) {
    LightModel.call(this, "directional", light, dataNode, DirectionalLightData);
};

XML3D.createClass(DirectionalLightModel, LightModel, {
    getFrustum: function(aspect, sceneBoundingBox) {
        var orthogonal = true;

        if (sceneBoundingBox.isEmpty()) {
            return new Frustum(1.0, 110.0, 0, this.fovy, aspect, orthogonal)
        }

        var t_mat = mat4.create();
        this.getLightViewMatrix(t_mat);
        sceneBoundingBox.transformAxisAligned(t_mat);

        var nf = {  near: -sceneBoundingBox.max.z,
                    far:  -sceneBoundingBox.min.z};
        // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
        this._expandNearFar(nf);

        return new Frustum(1.0, nf.far, 0, this.fovy, aspect, orthogonal);
    },

    transformParameters: function (target, offset) {
        var direction = target["direction"].subarray(offset * 3, offset * 3 + 3);
        transformPose(this.light, null, direction);
        transformDefault(target, offset, this.light);
    },



    getLightViewMatrix: function (mat) {
        var manager = this.light.scene.lights;
        var entry = manager.getModelEntry(this.id);
        var p_dir = entry.parameters["direction"];
        var p_pos = entry.parameters["position"];

        var bb = new XML3D.Box();
        this.light.scene.getBoundingBox(bb);
        var off = vec3.create();
        var bbCenter = bb.center();
        var bbSize = bb.size();
        var d = bbSize.length(); //diameter of bounding sphere of the scene
        vec3.scale(off, p_dir, -0.55 * d); //enlarge a bit on the radius of the scene
        p_pos = vec3.add(p_pos, bbCenter.data, off);
        entry.parameters["position"] = p_pos;


        //create new transformation matrix depending on the updated parameters
        mat4.identity(mat);
        var lookat_mat = mat4.create();
        var top_vec = vec3.fromValues(0.0, 1.0, 0.0);
        if ((p_dir[0] == 0.0) && (p_dir[2] == 0.0)) //check if top_vec colinear with direction
            top_vec = vec3.fromValues(0.0, 0.0, 1.0);
        var up_vec = vec3.create();
        var dir_len = vec3.len(p_dir);
        vec3.scale(up_vec, p_dir, -vec3.dot(top_vec, p_dir) / (dir_len * dir_len));
        vec3.add(up_vec, up_vec, top_vec);
        vec3.normalize(up_vec, up_vec);
        mat4.lookAt(lookat_mat, vec3.fromValues(0.0, 0.0, 0.0), p_dir, up_vec);
        mat4.invert(lookat_mat, lookat_mat);
        mat4.translate(mat, mat, p_pos);
        mat4.multiply(mat, mat, lookat_mat);

        bb = new XML3D.Box();
        this.light.scene.getBoundingBox(bb);
        bb.transformAxisAligned(mat);
        bbSize = bb.size().data;
        var max = (bbSize[0] > bbSize[1]) ? bbSize[0] : bbSize[1];
        max = 0.55 * (max);//enlarge 10percent to make sure nothing gets cut off
        this.fovy = max <= 0 ? Math.PI : Math.atan(max)*2.0;

        entry.parameters["direction"] = p_dir;
        entry.parameters["position"]  = p_pos;

        mat4.invert(mat, mat);
    }

});

module.exports = {
    PointLightModel: PointLightModel, SpotLightModel: SpotLightModel, DirectionalLightModel: DirectionalLightModel

};

},{"../../../xflow/interface/constants.js":179,"../../../xflow/interface/data.js":180,"../../../xflow/interface/graph.js":181,"../../../xflow/interface/request.js":182,"../tools/frustum.js":107,"gl-matrix":1}],94:[function(require,module,exports){
var GLRenderer = require("../webgl/renderer.js");
var GLCanvasHandler = require("../webgl/canvas-handler.js");

var RendererFactory = function () {
    this.createRenderer = function (xml3dElement) {
        var canvas = xml3dElement._configured.canvas;
        var canvasHandler = new GLCanvasHandler(xml3dElement, canvas);
        var renderer = new GLRenderer(xml3dElement, canvasHandler);
        canvasHandler.setRenderer(renderer);
        window.requestAnimationFrame(canvasHandler.tick);
        return renderer;
    }
};
module.exports = new RendererFactory();








},{"../webgl/canvas-handler.js":117,"../webgl/renderer.js":150}],95:[function(require,module,exports){
module.exports = {
    NODE_TYPE: {
        GROUP: "group", OBJECT: "object", LIGHT: "light", VIEW: "view"
    },

    EVENT_TYPE: {
        VIEW_CHANGED: "view_changed",
        LIGHT_STRUCTURE_CHANGED: "light_structure_changed",
        LIGHT_VALUE_CHANGED: "light_value_changed",
        SCENE_SHAPE_CHANGED: "scene_shape_changed",
        SCENE_STRUCTURE_CHANGED: "scene_structure_changed",
        DRAWABLE_STATE_CHANGED: "drawable_state_changed"

    }
};

},{}],96:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;

var DrawableClosure = function (context, type) {
    EventEmitter.call(this);
    this.context = context;
    this._type = type;
    this._valid = false;
    // Do not limit the number of listeners
    this.setMaxListeners(0);
};

DrawableClosure.TYPES = {
    MESH: "mesh", VOLUME: "volume"
};

DrawableClosure.READY_STATE = {
    COMPLETE: "complete", INCOMPLETE: "incomplete"
};

XML3D.createClass(DrawableClosure, EventEmitter, {
    getType: function () {
        return this._type;
    }, isValid: function () {
        return this._valid;
    }, setShaderComposer: function (shaderComposer) {
        // implemented by subclass
    }, update: function (scene) {
        // implemented by subclass
    }
});

module.exports = DrawableClosure;


},{"events":12}],97:[function(require,module,exports){
var uniqueObjectId = require("../../webgl/base/utils.js").getUniqueCounter();
/**
 * Connects a light model with a data node containing light paramters
 * and a render light to evaluate the world position of the light.
 * The LightConfiguration is immutable
 *
 * @param model The light model
 * @param {Xflow.DataNode} dataNode  The light parameters of this node
 * @param {RenderLight} light  The light in the transformation hierarchy
 * @param {{}} opt
 * @constructor
 */
var LightConfiguration = function(model, dataNode, opt) {
    opt = opt || {};

    this.id = uniqueObjectId();

    /**
     * @type {{type: string}}
     */
    this.model = model;

    /**
     * Data Node of the renderObject
     * @type {Xflow.DataNode}
     */
    this.dataNode = dataNode;

    /**
     * A name for debug purposes
     * @type {string|null}
     */
    this.name = opt.name || null;
};

module.exports = LightConfiguration;

},{"../../webgl/base/utils.js":116}],98:[function(require,module,exports){
var uniqueObjectId = require("../../webgl/base/utils.js").getUniqueCounter();
/**
 * Connects a material model with a set of default parameters defined by
 * an Xflow DataNode. The MaterialConfiguration is immutable
 *
 * @param model The material model
 * @param {Xflow.DataNode} dataNode  The material parameters of this node
 * @param {{}} opt
 * @constructor
 */
var MaterialConfiguration = function(model, dataNode, opt) {
    opt = opt || {};

    this.id = uniqueObjectId();

    /**
     * @type {{type: string}}
     */
    this.model = model;

    /**
     * Data Node of the renderObject
     * @type {Xflow.DataNode}
     */
    this.dataNode = dataNode;

    /**
     * A name for debug purposes
     * @type {string|null}
     */
    this.name = opt.name || null;
};

module.exports = MaterialConfiguration;

},{"../../webgl/base/utils.js":116}],99:[function(require,module,exports){
var DEFAULT_PAGE_SIZE = 1 << 12;

/**
 * @constructor
 */
var Pager = function (opt) {
    opt = opt || {};

    this.pageSize = opt.pageSize || DEFAULT_PAGE_SIZE;

    /** @type Array<Float32Array> */
    this.pages = [];
    /** @type number */
    this.nextOffset = 0;
    /** @type Array<*> */
    this.freeEntries = [];
    // Add a first page
    this.addPage();
};

XML3D.extend(Pager.prototype, {
    addPage: function () {
        var page = new Float32Array(this.pageSize);
        this.pages.push(page);
        this.nextOffset = 0;
        XML3D.debug.logInfo("Adding page", this.pages.length, "(", this.pageSize * Float32Array.BYTES_PER_ELEMENT * this.pages.length / 1024, "kB)");
    },

    getPageEntry: function (size) {
        if (!size)
            throw new Error("No size given for page entry");
        return this.reusePageEntry(size) || this.createPageEntry(size);
    },

    /**
     * @param {number} size Requested size in number of floats
     * @returns {{ page: Float32Array, offset: number, size: number }}
     */
    reusePageEntry: function (size) {
        var sameSizeEntries = this.freeEntries[size];
        if (sameSizeEntries && sameSizeEntries.length) {
            return sameSizeEntries.pop();
        }
        return null;
    },

    /**
     * @param {number} size  Size in number of floats
     * @returns {{ page: Float32Array, offset: number, size: number }}
     */
    createPageEntry: function (size) {
        if (this.nextOffset + size > this.pageSize) {
            this.addPage();
            return this.getPageEntry(size);
        }
        var page = this.pages[this.pages.length - 1];
        var localOffset = this.nextOffset;
        this.nextOffset += size;
        return {page: page, offset: localOffset, size: size};
    },

    /**
     *
     * @param {{ page: Float32Array, offset: number, size: number }} entryInfo
     */
    freePageEntry: function (entryInfo) {
        var sameSizeEntries = this.freeEntries[entryInfo.size];
        if (!sameSizeEntries) {
            sameSizeEntries = this.freeEntries[entryInfo.size] = [];
        }
        sameSizeEntries.push(entryInfo);
    }
});

module.exports = Pager;


},{}],100:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

/** @const */
var WORLD_MATRIX_OFFSET = 0;
/** @const */
var LOCAL_MATRIX_OFFSET = WORLD_MATRIX_OFFSET + 16;
/** @const */
var WORLD_BB_OFFSET = LOCAL_MATRIX_OFFSET + 16;
/** @const */
var ENTRY_SIZE = WORLD_BB_OFFSET + 6;

/**
 *
 * @constructor
 * @extends {RenderNode}
 */
var RenderGroup = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.GROUP, scene, pageEntry, opt);
    opt = opt || {};

    /**
     * The material attached to this group
     * @type {MaterialConfiguration|null}
     */
    this._material = opt.material || null;
    this.boundingBoxDirty = false;
    this.setWorldSpaceBoundingBox(XML3D.Box.EMPTY_BOX);
};
RenderGroup.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderGroup, RenderNode);

XML3D.extend(RenderGroup.prototype, {
    getLocalMatrix: function (dest) {
        this.getMat4FromPage(dest, LOCAL_MATRIX_OFFSET);
    },

    setLocalMatrix: function (sourceMat4) {
        this.setMat4InPage(sourceMat4, LOCAL_MATRIX_OFFSET);
        this.setTransformDirty();
        this.setBoundingBoxDirty();
    },

    getWorldSpaceBoundingBox: function (bbox) {
        if (this.boundingBoxDirty) {
            this.updateWorldSpaceBoundingBox();
        }
        var o = this.offset + WORLD_BB_OFFSET;
        bbox.data[0] = this.page[o];
        bbox.data[1] = this.page[o + 1];
        bbox.data[2] = this.page[o + 2];
        bbox.data[3] = this.page[o + 3];
        bbox.data[4] = this.page[o + 4];
        bbox.data[5] = this.page[o + 5];
    },

    setWorldSpaceBoundingBox: function (bbox) {
        var o = this.offset + WORLD_BB_OFFSET;
        this.page[o] = bbox.data[0];
        this.page[o + 1] = bbox.data[1];
        this.page[o + 2] = bbox.data[2];
        this.page[o + 3] = bbox.data[3];
        this.page[o + 4] = bbox.data[4];
        this.page[o + 5] = bbox.data[5];
    },


    updateWorldSpaceBoundingBox: (function () {
        var childBB = new XML3D.Box();

        return function () {
            var localBB = new XML3D.Box();

            for (var i = 0, j = this.children.length; i < j; i++) {
                var obj = this.children[i];
                obj.getWorldSpaceBoundingBox(childBB);
                localBB.extend(childBB);
            }
            this.setWorldSpaceBoundingBox(localBB);
            this.boundingBoxDirty = false;
        }
    })(),

    addChild: function (child) {
        this.children.push(child);
        this.setBoundingBoxDirty();
        this.scene.emit(EVENT_TYPE.SCENE_STRUCTURE_CHANGED, child, false);
    },

    removeChild: function (child) {
        var index = this.children.indexOf(child);
        if (index != -1) {
            this.children.splice(index, 1);
        }
        this.scene.emit(EVENT_TYPE.SCENE_STRUCTURE_CHANGED, child, true);
    },

    getChildren: function () {
        return this.children;
    },

    updateWorldMatrix: function (sourceMat4) {
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + WORLD_MATRIX_OFFSET, page, offset + LOCAL_MATRIX_OFFSET, sourceMat4, 0);
        this.transformDirty = false;
    },

    setTransformDirty: function () {
        if (this.transformDirty) {
            //We can be sure all child nodes are already set to transformDirty from here
            return;
        }
        this.transformDirty = true;
        var children = this.children;
        for(var i = 0, l = children.length; i < l; i++) {
            children[i].setTransformDirty();
        }
    },

    /**
     * @param {MaterialConfiguration|null} material
     */
    setMaterial: function (material) {
        if(this._material === material)
            return;
        this._material = material;
        this.children.forEach(function (obj) {
            obj.parentMaterialChanged && obj.parentMaterialChanged();
        });
    },

    parentMaterialChanged: function () {
        if (this._material) {
            // Local material overrides anything coming from upstream
            return;
        }
        this.children.forEach(function (obj) {
            obj.parentMaterialChanged && obj.parentMaterialChanged();
        });
    },

    /**
     * @returns {MaterialConfiguration}
     */
    getMaterial: function () {
        return this._material || this.parent.getMaterial();
    },

    /**
     * A group propagates its visibility
     */
    visibilityChanged: function () {
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
            children[i].evaluateVisibility();
        }
    },



    setBoundingBoxDirty: function () {
        this.boundingBoxDirty = true;
        if (this.parent) {
            this.parent.setBoundingBoxDirty();
        }
    },

    findRayIntersections: (function () {
        var bbox = new XML3D.Box();

        return function (ray, intersections) {
            this.getWorldSpaceBoundingBox(bbox);
            if (ray.intersects(bbox)) {
                for (var i = 0; i < this.children.length; i++) {
                    this.children[i].findRayIntersections(ray, intersections);
                }
            }
        }
    })()

});

// Export
module.exports = RenderGroup;


},{"./constants.js":95,"./rendernode.js":102}],101:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");
var LightModels = require("../lights/light-models.js");

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

var tmp_worldMatrix = XML3D.math.mat4.create();

var SHADOWMAP_OFFSET_MATRIX = new Float32Array([0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0]);

/** @const */
var CLIPPLANE_NEAR_MIN = 1.0;

/** @const */
var ENTRY_SIZE = 16;

var c_BoundingBox = new XML3D.Box();


function createLightModel(type, data, light) {
    switch (type) {
        case "urn:xml3d:light:point":
            return new LightModels.PointLightModel(data, light);
        case "urn:xml3d:light:spot":
            return new LightModels.SpotLightModel(data, light);
        case "urn:xml3d:light:directional":
            return new LightModels.DirectionalLightModel(data, light);
        default:
            XML3D.debug.logWarning("Unknown light model: ", type, ". Using directional instead.");
            return new LightModels.DirectionalLightModel(data, light);
    }
}

/**
 * @constructor
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 * @extends {RenderNode}
 */
var RenderLight = function (scene, pageEntry, opt) {
    RenderNode.call(this, NODE_TYPE.LIGHT, scene, pageEntry, opt);
    opt = opt || {};
    var configuration = opt.configuration || {};
    this.setLightType(configuration.model, configuration.dataNode);
};
RenderLight.ENTRY_SIZE = ENTRY_SIZE;

XML3D.createClass(RenderLight, RenderNode);
XML3D.extend(RenderLight.prototype, {

    setLightType: function (modelId, data) {
        if (this.model) {
            if (this.model.id == modelId) {
                return; // Nothing changed
            }
            this.scene.lights.remove(this);
            this.lightStructureChanged(true);
        }
        this.model = createLightModel(modelId, data, this);
        this.scene.lights.add(this);
        this.lightStructureChanged(false);
    },

    setLocalMatrix: function (source) {
        XML3D.debug.logError("RenderLight::setLocalMatrix not implemented");
    },


    getFrustum: function (aspect) {
        this.scene.getBoundingBox(c_BoundingBox);
        return this.model.getFrustum(aspect, c_BoundingBox);
    },

    lightValueChanged: function () {
        if (this.model) { // FIXME: Complex dependency
            this.scene.emit(EVENT_TYPE.LIGHT_VALUE_CHANGED, this);
        }
    },

    lightStructureChanged: function (removed) {
        this.scene.emit(EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, this, removed);
    },

    updateWorldMatrix: function () {
        if (this.parent) {
            this.parent.getWorldMatrix(tmp_worldMatrix);
            this.setWorldMatrix(tmp_worldMatrix);
            // We change position / direction of the light
            this.lightValueChanged();
        }
    },

    visibilityChanged: function (newVal) {
        // Visibility is a light parameter
        this.lightValueChanged();
    },

    setTransformDirty: function () {
        this.updateWorldMatrix();
    },


    remove: function () {
        this.parent.removeChild(this);
        this.scene.lights.remove(this);
        this.lightStructureChanged(true);
    },


    getWorldSpaceBoundingBox: function (bbox) {
        bbox.setEmpty();
    }
});

module.exports = RenderLight;



},{"../lights/light-models.js":93,"./constants.js":95,"./rendernode.js":102}],102:[function(require,module,exports){
/** @const */
var WORLD_MATRIX_OFFSET = 0;

/**
 * @constructor
 * @param type
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 */
var RenderNode = function (type, scene, pageEntry, opt) {
    opt = opt || {};

    this.scene = scene;
    this.type = type;
    this.name = opt.name || "";
    this.page = pageEntry.page;
    this.offset = pageEntry.offset;
    this.entrySize = pageEntry.size;
    this.transformDirty = true;
    this.children = [];
    this.parent = null;

    this.setParent(opt.parent || scene.rootNode);

    this.localVisible = true;
    // The global visibility depends on visibility of parents
    this.visible = true;
    this.evaluateVisibility();
};

XML3D.extend(RenderNode.prototype, {

    getChildren: function () {
        return this.children;
    },

    evaluateVisibility: function() {
        var oldVisible = this.visible;
        if(this.parent && !this.parent.visible) {
            this.visible = false;
        } else {
            this.visible = this.localVisible;
        }
        if(oldVisible !== this.visible) {
            this.visibilityChanged();
            this.scene.requestRedraw && this.scene.requestRedraw("Visibility changed.");
        }
    },

    setLocalVisible: function(newVisible) {
        if (this.localVisible === newVisible) {
            return;
        }
        this.localVisible = newVisible;
        this.evaluateVisibility();
    },

    // Needs to be overwritten
    visibilityChanged: function() {},

    getParent: function () {
        return this.parent;
    },

    setParent: function (parent) {
        this.parent = parent;
        if (parent && parent.addChild) {
            parent.addChild(this);
        }
        // Reevaluate visibility, which might change due to
        // invisibility of parent
        this.evaluateVisibility();
    },

    traverse: function (callback) {
        callback(this);
        this.children.forEach(function (child) {
            child.traverse(callback);
        })
    },

    /**
     * @param {Mat4} source
     * @param {number} offset
     */
    setMat4InPage: function(source, offset) {
        var o = this.offset + offset;
        for(var i = 0; i < 16; i++, o++) {
            this.page[o] = source[i];
        }
    },

    /**
     * @param {Mat4} dest
     * @param {number} offset
     */
    getMat4FromPage: function(dest, offset) {
        var o = this.offset + offset;
        for(var i = 0; i < 16; i++, o++) {
            dest[i] = this.page[o];
        }
    },

    getWorldMatrix: function (dest) {
        if (this.transformDirty) {
            this.parent.getWorldMatrix(dest);
            this.updateWorldMatrix(dest);
        }
        this.getMat4FromPage(dest, WORLD_MATRIX_OFFSET);
    },

    setWorldMatrix: function (source) {
        this.setMat4InPage(source, WORLD_MATRIX_OFFSET);
        this.transformDirty = false;
        if (this.setBoundingBoxDirty) {
            this.setBoundingBoxDirty();
        }
    },

    setTransformDirty: function () {
        this.transformDirty = true;
    },

    remove: function () {
        this.parent.removeChild(this);
        this.scene.pager.freePageEntry({page: this.page, offset: this.offset, size: this.entrySize});
    },

    findRayIntersections: function (/* ray, closestIntersection*/) {
        //This function is overridden by groups and drawables
    }

});

module.exports = RenderNode;

},{}],103:[function(require,module,exports){
var SystemNotifier = require("../../webgl/system/system-notifier.js");
var RenderNode = require("./rendernode.js");
var DrawableClosure= require("./drawableclosure.js");
var C = require("./constants.js");
var Scene= require("./scene.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var mat4 = require("gl-matrix").mat4;

// Entry:
/** @const */
var WORLD_MATRIX_OFFSET = 0;
/** @const */
var LOCAL_MATRIX_OFFSET = WORLD_MATRIX_OFFSET + 16;
/** @const */
var OBJECT_BB_OFFSET = LOCAL_MATRIX_OFFSET + 16;
/** @const */
var WORLD_BB_OFFSET = OBJECT_BB_OFFSET + 6;
/** @const */
var MODELVIEW_MATRIX_OFFSET = WORLD_BB_OFFSET + 6;
/** @const */
var MODELVIEWPROJECTION_MATRIX_OFFSET = MODELVIEW_MATRIX_OFFSET + 16;
/** @const */
var MODEL_MATRIX_N_OFFSET = MODELVIEWPROJECTION_MATRIX_OFFSET + 16;
/** @const */
var MODELVIEW_MATRIX_N_OFFSET = MODEL_MATRIX_N_OFFSET + 16;
/** @const */
var ENTRY_SIZE = MODELVIEW_MATRIX_N_OFFSET + 16;

//noinspection JSClosureCompilerSyntax,JSClosureCompilerSyntax
/**
 * Represents a renderable object in the scene.
 * The RenderObject has these responsibilities:
 *  1. Keep track of the transformation hierarchy and bounding boxes
 *  2. Connect the DrawableClosure with the ShaderClosure
 *
 *  The {@link DrawableClosure} is a DrawableObject plus it's data
 *  The {@link ShaderClosure} is a ProgramObject plus it's data
 *  The concrete ShaderClosure can vary per DrawableObject and change
 *  due to scene or object changes. Thus we have to keep track of the
 *  related {@link IShaderComposer}.
 *
 * @constructor
 * @implements {IRenderObject}
 * @param {Scene} scene
 * @param {Object} pageEntry
 * @param {Object} opt
 */
var RenderObject = function (scene, pageEntry, opt) {
    RenderNode.call(this, C.NODE_TYPE.OBJECT, scene, pageEntry, opt);
    opt = opt || {};

    /**
     * Keep reference to DOM Element need e.g. for picking
     * @type {Element}
     */
    this.node = opt.node;

    /**
     * Object related data
     * @type {{data: DataNode|null, type: string}}
     */
    this.object = opt.object || {data: null, type: "triangles"};

    /**
     * Can we rely on current WorldMatrix?
     * @type {boolean}
     */
    this.transformDirty = true;

    /**
     * Can we rely on current Bounding Boxes?
     * @type {boolean}
     */
    this.boundingBoxDirty = true;

    this.transformDataRequest = this.createTransformRequest();

    /**
     * The drawable closure transforms object data and type into
     * a drawable entity
     * @type {DrawableClosure}
     */
    this.drawable = this.createDrawable();

    this._material = opt.material || null;
    this._actualMaterial = null;
    this.initMaterial();

    /** {Object?} **/
    this.override = null;

    this.pickable = true;
};
RenderObject.ENTRY_SIZE = ENTRY_SIZE;

RenderObject.IDENTITY_MATRIX = mat4.create();

XML3D.createClass(RenderObject, RenderNode, {
    createTransformRequest: function () {
        if (!this.object.data)
            return null;
        return new ComputeRequest(this.object.data, ["meshTransform"], this.onTransformDataChange.bind(this));
    },

    createDrawable: function () {
        var result = this.scene.createDrawable(this);
        if (result) {
            var that = this;
            result.on(C.EVENT_TYPE.DRAWABLE_STATE_CHANGED, function (newState, oldState) {
                if (newState === DrawableClosure.READY_STATE.COMPLETE) {
                    that.scene.moveFromQueueToReady(that);
                } else if (newState === DrawableClosure.READY_STATE.INCOMPLETE && oldState === DrawableClosure.READY_STATE.COMPLETE) {
                    that.scene.moveFromReadyToQueue(that);
                }
            });
            result.updateTypeRequest();
            result.calculateBoundingBox();
            result.on(C.EVENT_TYPE.SCENE_SHAPE_CHANGED, function (evt) {
                that.scene.emit(C.EVENT_TYPE.SCENE_SHAPE_CHANGED)
            })
        }
        return result;
    },

    setType: function (type) {
        this.object.type = type;
        // TODO: this.typeChangedEvent
    },

    getType: function () {
        return this.object.type;
    },

    getDataNode: function () {
        return this.object ? this.object.data : null;
    },

    getLocalMatrix: function (dest) {
        this.getMat4FromPage(dest, LOCAL_MATRIX_OFFSET);
    },

    setLocalMatrix: function (source) {
        this.setMat4InPage(source, LOCAL_MATRIX_OFFSET);
        this.setTransformDirty();
        this.setBoundingBoxDirty();
    },

    dispose: function () {
        this.transformDataRequest && this.transformDataRequest.clear();
        this.scene.remove(this);
    },

    onTransformDataChange: function () {
        this.setTransformDirty();
    },

    getModelViewMatrix: function (dest) {
        this.getMat4FromPage(dest, MODELVIEW_MATRIX_OFFSET);
    },

    getModelMatrixN: function (dest) {
        var o = this.offset + MODEL_MATRIX_N_OFFSET;
        dest[0] = this.page[o];
        dest[1] = this.page[o + 1];
        dest[2] = this.page[o + 2];
        dest[3] = this.page[o + 4];
        dest[4] = this.page[o + 5];
        dest[5] = this.page[o + 6];
        dest[6] = this.page[o + 8];
        dest[7] = this.page[o + 9];
        dest[8] = this.page[o + 10];
    },

    getModelViewMatrixN: function (dest) {
        var o = this.offset + MODELVIEW_MATRIX_N_OFFSET;
        dest[0] = this.page[o];
        dest[1] = this.page[o + 1];
        dest[2] = this.page[o + 2];
        dest[3] = this.page[o + 4];
        dest[4] = this.page[o + 5];
        dest[5] = this.page[o + 6];
        dest[6] = this.page[o + 8];
        dest[7] = this.page[o + 9];
        dest[8] = this.page[o + 10];
    },


    getModelViewProjectionMatrix: function (dest) {
        this.getMat4FromPage(dest, MODELVIEWPROJECTION_MATRIX_OFFSET);
    },

    updateWorldSpaceMatrices: function (view, projection) {
        if (this.transformDirty) {
            this.updateWorldMatrix();
        }
        this.updateModelViewMatrix(view);
        this.updateModelMatrixN();
        this.updateModelViewMatrixN();
        this.updateModelViewProjectionMatrix(projection);
    },

    updateWorldMatrix: (function () {
        var tmp_mat = mat4.create();
        return function () {
            this.parent.getWorldMatrix(tmp_mat);
            var page = this.page;
            var offset = this.offset;
            XML3D.math.mat4.multiplyOffset(tmp_mat, 0, page, offset + LOCAL_MATRIX_OFFSET, tmp_mat, 0);
            if (this.transformDataRequest) {
                var result = this.transformDataRequest.getResult();
                var transformData = result.getOutputData("meshTransform");
                if (transformData && transformData.getValue()) {
                    XML3D.math.mat4.multiply(tmp_mat, tmp_mat, transformData.getValue());
                }
            }
            this.setWorldMatrix(tmp_mat);
            this.boundingBoxDirty = true;
            this.transformDirty = false;
        }
    })(),

    /** Relies on an up-to-date transform matrix **/
    updateModelViewMatrix: function (view) {
        if (this.transformDirty) {
            this.updateWorldMatrix();
        }
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + MODELVIEW_MATRIX_OFFSET, page, offset + WORLD_MATRIX_OFFSET, view, 0);
    },

    updateModelMatrixN: (function () {
        var c_tmpMatrix = mat4.create();
        return function () {
            this.getWorldMatrix(c_tmpMatrix);
            mat4.invert(c_tmpMatrix, c_tmpMatrix);
            var normalMatrix = c_tmpMatrix ? mat4.transpose(c_tmpMatrix, c_tmpMatrix) : RenderObject.IDENTITY_MATRIX;
            this.setMat4InPage(normalMatrix, MODEL_MATRIX_N_OFFSET);
        }
    })(),

    /** Relies on an up-to-date view matrix **/
    updateModelViewMatrixN: (function () {
        var c_tmpMatrix = mat4.create();
        return function () {
            this.getModelViewMatrix(c_tmpMatrix);
            mat4.invert(c_tmpMatrix, c_tmpMatrix);
            var normalMatrix = c_tmpMatrix ? mat4.transpose(c_tmpMatrix, c_tmpMatrix) : RenderObject.IDENTITY_MATRIX;
            this.setMat4InPage(normalMatrix, MODELVIEW_MATRIX_N_OFFSET);
        }
    })(),


    /** Relies on an up-to-date view matrix **/
    updateModelViewProjectionMatrix: function (projection) {
        var page = this.page;
        var offset = this.offset;
        XML3D.math.mat4.multiplyOffset(page, offset + MODELVIEWPROJECTION_MATRIX_OFFSET, page, offset + MODELVIEW_MATRIX_OFFSET, projection, 0);
    },

    setTransformDirty: function () {
        this.transformDirty = true;
        this.setBoundingBoxDirty();
        this.scene.emit(C.EVENT_TYPE.SCENE_SHAPE_CHANGED);
        this.scene.requestRedraw("Transformation changed");
    },

    setObjectSpaceBoundingBox: function (box) {
        var o = this.offset + OBJECT_BB_OFFSET;
        this.page[o] = box.data[0];
        this.page[o + 1] = box.data[1];
        this.page[o + 2] = box.data[2];
        this.page[o + 3] = box.data[3];
        this.page[o + 4] = box.data[4];
        this.page[o + 5] = box.data[5];
        this.setBoundingBoxDirty();
    },

    getObjectSpaceBoundingBox: function (box) {
        var o = this.offset + OBJECT_BB_OFFSET;
        box.data[0] = this.page[o];
        box.data[1] = this.page[o + 1];
        box.data[2] = this.page[o + 2];
        box.data[3] = this.page[o + 3];
        box.data[4] = this.page[o + 4];
        box.data[5] = this.page[o + 5];
    },

    setBoundingBoxDirty: function () {
        this.boundingBoxDirty = true;
        this.parent.setBoundingBoxDirty();
    },

    setWorldSpaceBoundingBox: function (bbox) {
        var o = this.offset + WORLD_BB_OFFSET;
        this.page[o] = bbox.data[0];
        this.page[o + 1] = bbox.data[1];
        this.page[o + 2] = bbox.data[2];
        this.page[o + 3] = bbox.data[3];
        this.page[o + 4] = bbox.data[4];
        this.page[o + 5] = bbox.data[5];
    },

    getWorldSpaceBoundingBox: function (bbox) {
        if (this.boundingBoxDirty) {
            this.updateWorldSpaceBoundingBox();
        }
        var o = this.offset + WORLD_BB_OFFSET;
        bbox.data[0] = this.page[o];
        bbox.data[1] = this.page[o + 1];
        bbox.data[2] = this.page[o + 2];
        bbox.data[3] = this.page[o + 3];
        bbox.data[4] = this.page[o + 4];
        bbox.data[5] = this.page[o + 5];

    },

    updateWorldSpaceBoundingBox: (function () {
        var c_box = new XML3D.Box();
        var c_trans = mat4.create();

        return function () {
            if(!this.visible) {
                c_box.setEmpty();
            } else {
                this.getObjectSpaceBoundingBox(c_box);
                this.getWorldMatrix(c_trans);
                c_box.transformAxisAligned(c_trans);
            }
            this.setWorldSpaceBoundingBox(c_box);
            this.boundingBoxDirty = false;
        }
    })(),

    visibilityChanged: function () {
        this.setBoundingBoxDirty();
    },

    setPickable: function (value) {
        if (this.pickable == value)
            return;
        this.pickable = value;
    },


    getProgram: function () {
        return this.drawable.getProgram();
    },

    hasTransparency: function () {
        var program = this.getProgram();
        return program ? program.hasTransparency() : false;
    },

    updateForRendering: function () {
        SystemNotifier.setNode(this.node);
        try {
            this.drawable && this.drawable.update(this.scene);
        } catch (e) {
            XML3D.debug.logError("Mesh Error: " + e.message, this.node);
        }
        SystemNotifier.setNode(null);
    },

    findRayIntersections: (function () {
        var bbox = new XML3D.Box();
        var opt = {dist: 0};

        return function (ray, intersections) {
            this.getWorldSpaceBoundingBox(bbox);
            if (ray.intersects(bbox, opt)) {
                intersections.push(this);
            }
        }
    })(),

        /**
     * @param {MaterialConfiguration|null} material
     */
    setMaterial: function (material) {
        if(this._material === material) {
            return;
        }
        this._material = material;
        if (material) {
            this._actualMaterial = material;
        } else {
            this._actualMaterial = this.parent.getMaterial();
        }
        this.materialChanged();
    },

    parentMaterialChanged: function () {
        if (this._material) {
            // Local material overrides the change from above
            return;
        }
        this.initMaterial();
    },

    initMaterial: function () {
        if (this._material) {
            this._actualMaterial = this._material;
        } else {
            this._actualMaterial = this.parent.getMaterial();
        }
        this.materialChanged();
    },

    materialChanged: function() {
        XML3D.debug.logDebug("material changed", this._actualMaterial);
        if (this.drawable) {
            var composer = this.scene.shaderFactory.createComposerFromMaterialConfiguration(this._actualMaterial);
            this.drawable.setShaderComposer(composer);
        }
    }

});


// Export
module.exports = RenderObject;


},{"../../../xflow/interface/request.js":182,"../../webgl/system/system-notifier.js":156,"./constants.js":95,"./drawableclosure.js":96,"./rendernode.js":102,"./scene.js":105,"gl-matrix":1}],104:[function(require,module,exports){
var RenderNode = require("./rendernode.js");
var Constants = require("./constants.js");
var Frustum = require("../tools/frustum.js").Frustum;
var vec3 = require("gl-matrix").vec3;
var mat4 = require("gl-matrix").mat4;

var NODE_TYPE = Constants.NODE_TYPE;
var EVENT_TYPE = Constants.EVENT_TYPE;

    /** @const */
    var VIEW_TO_WORLD_MATRIX_OFFSET = 0;
    /** @const */
    var WORLD_TO_VIEW_MATRIX_OFFSET = 16;
    /** @const */
    var PROJECTION_MATRIX_OFFSET = 32;
    /** @const */
    var ENTRY_SIZE = PROJECTION_MATRIX_OFFSET + 16;

    /** @const */
    var CLIPPLANE_NEAR_MIN = 0.01;

    /** @const */
    var DEFAULT_FIELDOFVIEW = 45 / 180 * Math.PI;

    /**
     *
     * @constructor
     * @extends {RenderNode}
     */
    var RenderView = function(scene, pageEntry, opt) {
        RenderNode.call(this, NODE_TYPE.VIEW, scene, pageEntry, opt);
        opt = opt || {};
        this.position = opt.position || vec3.create();
        this.orientation = opt.orientation || mat4.create();
        this.fieldOfView = opt.fieldOfView !== undefined ? opt.fieldOfView : DEFAULT_FIELDOFVIEW;
        this.worldSpacePosition = vec3.create();
        this.projectionOverride = opt.projectionOverride;
        this.viewDirty = true;
        this.projectionDirty = true;
        this.frustum = new Frustum(1, 100000, 0, this.fieldOfView, 1);
        this.lastAspectRatio = 1;
    };
    RenderView.ENTRY_SIZE = ENTRY_SIZE;

    XML3D.createClass(RenderView, RenderNode);

    XML3D.extend(RenderView.prototype, {
        getFrustum: function() {
            return this.frustum;
        },

        updateViewMatrix: (function() {
            var tmp_mat4 = mat4.create();
            var tmp_parent = mat4.create();

            return function () {
                mat4.identity(tmp_mat4);
                tmp_mat4[12] = this.position[0];
                tmp_mat4[13] = this.position[1];
                tmp_mat4[14] = this.position[2];
                // tmp = T * O
                mat4.multiply(tmp_mat4, tmp_mat4, this.orientation);
                this.parent.getWorldMatrix(tmp_parent);
                mat4.multiply(tmp_mat4, tmp_parent, tmp_mat4);
                vec3.set(this.worldSpacePosition, tmp_mat4[12], tmp_mat4[13], tmp_mat4[14]);
                this.setViewToWorldMatrix(tmp_mat4);
                mat4.invert(tmp_mat4, tmp_mat4);
                this.setWorldToViewMatrix(tmp_mat4);
                this.viewDirty = false;
            }
        })(),

        updateProjectionMatrix: (function() {
            var tmp = mat4.create();

            return function(aspect) {
                if (this.projectionOverride) {
                    this.setProjectionMatrix(this.projectionOverride);
                    // TODO: Correctly compute frustrum from projection matrix (if possible)
                    this.frustum.setFrustum(1, 100000, 0, this.fieldOfView, 1);
                    return;
                }

                var clipPlane = this.getClippingPlanes(),
                    near = clipPlane.near,
                    far = clipPlane.far,
                    fovy = this.fieldOfView;

                // Calculate perspective projectionMatrix
                mat4.perspective(tmp, fovy, aspect, near, far);
                // Set projectionMatrix
                this.setProjectionMatrix(tmp);
                // Update Frustum
                this.frustum.setFrustum(near, far, 0, fovy, aspect);

                this.lastAspectRatio = aspect;
            }
        })(),

        getClippingPlanes: (function() {
            var t_mat = mat4.create();
            var bb = new XML3D.Box();

            return function() {
                this.scene.getBoundingBox(bb);
                if (bb.isEmpty()) {
                    return { near: 1, far: 10 };
                }
                this.getWorldToViewMatrix(t_mat);
                bb.transformAxisAligned(t_mat);

                var near = -bb.max.z,
                    far = -bb.min.z,
                    expand = Math.max((far - near) * 0.005, 0.05);

                // Expand the view frustum a bit to ensure 2D objects parallel to the camera are rendered
                far += expand;
                near -= expand;

                return {near: Math.max(near, expand, CLIPPLANE_NEAR_MIN), far: far};
            }
        })(),

        setWorldToViewMatrix: function(source) {
            this.setMat4InPage(source, WORLD_TO_VIEW_MATRIX_OFFSET);
        },

        setViewToWorldMatrix: function(source) {
            this.setMat4InPage(source, VIEW_TO_WORLD_MATRIX_OFFSET);
        },

        setProjectionMatrix: function(source) {
            this.setMat4InPage(source, PROJECTION_MATRIX_OFFSET);
            this.projectionDirty = false;
        },

        setProjectionOverride: function(projAdapter) {
            this.projectionOverride = projAdapter;
            this.setProjectionDirty();
            this.scene.requestRedraw("Projection changed");
        },

        setTransformDirty: function() {
            this.viewDirty = true;
            this.setProjectionDirty();
            this.scene.requestRedraw("Transformation changed");
        },

        setProjectionDirty: function() {
            this.projectionDirty = true;
        },

        updatePosition: function(newPos) {
            this.setTransformDirty();
            vec3.copy(this.position, newPos);
        },

        updateOrientation: function(newOrientation) {
            this.setTransformDirty();
            mat4.copy(this.orientation, newOrientation);
        },

        updateFieldOfView: function(newFov) {
            this.setTransformDirty();
            this.fieldOfView = newFov;
        },

        getViewToWorldMatrix: function (dest) {
            if (this.viewDirty) {
                this.updateViewMatrix();
            }
            this.getMat4FromPage(dest, VIEW_TO_WORLD_MATRIX_OFFSET);
        },

        getWorldToViewMatrix: function (dest) {
            if (this.viewDirty) {
                this.updateViewMatrix();
            }
            this.getMat4FromPage(dest, WORLD_TO_VIEW_MATRIX_OFFSET);
        },

        getProjectionMatrix: function(dest, aspect) {
            if (this.projectionDirty || aspect != this.lastAspectRatio) {
                this.updateProjectionMatrix(aspect);
            }
            this.getMat4FromPage(dest, PROJECTION_MATRIX_OFFSET);
        },

        getWorldSpacePosition: function() {
            return this.worldSpacePosition;
        },

        getWorldSpaceBoundingBox: function(bbox) {
            bbox.setEmpty();
        }
    });

    // Export
    module.exports = RenderView;


},{"../tools/frustum.js":107,"./constants.js":95,"./rendernode.js":102,"gl-matrix":1}],105:[function(require,module,exports){
var Pager = require("./pager.js");
var RenderObject = require("./renderobject.js");
var RenderView = require("./renderview.js");
var RenderGroup = require("./rendergroup.js");
var RenderLight = require("./renderlight.js");
var MaterialConfiguration = require("./material-configuration.js");
var LightManager = require("../lights/light-manager.js");
var C = require("./constants.js");
var InputNode = require("../../../xflow/interface/graph.js").InputNode;
var DataNode = require("../../../xflow/interface/graph.js").DataNode;
var BufferEntry = require("../../../xflow/interface/data.js").BufferEntry;
var XC = require("../../../xflow/interface/constants.js");
var URI = require("../../../utils/uri.js").URI;
var EventEmitter = require('events').EventEmitter;
var mat4 = require("gl-matrix").mat4;

/**
 * @extends {EventEmitter}
 * @constructor
 */
var Scene = function () {
    EventEmitter.call(this);
    this.boundingBox = new XML3D.Box();
    this.lights = new LightManager();
    this.pager = new Pager();

    /** @type RenderView */
    this.activeView = null;

    /** @type MaterialConfiguration */
    this._defaultMaterial = null;

    this.rootNode = this.createRootNode();
};

XML3D.createClass(Scene, EventEmitter, {
    /**
     * @returns {RenderView}
     */
    getActiveView: function () {
        return this.activeView;
    }, /**
     * @param {RenderView} view
     */
    setActiveView: function (view) {
        if (view != this.activeView) {
            if (!view)
                throw new Error("Active view must not be null");
            this.activeView = view;
            this.emit(C.EVENT_TYPE.VIEW_CHANGED, this.activeView);
        }
    },
    /**
     * @param {object?} opt
     * @returns {RenderObject}
     */
    createRenderObject: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderObject.ENTRY_SIZE);
        return new RenderObject(this, pageEntry, opt);
    },

    createRenderGroup: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderGroup.ENTRY_SIZE);
        return new RenderGroup(this, pageEntry, opt);
    },

    createRenderView: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderView.ENTRY_SIZE);
        return new RenderView(this, pageEntry, opt);
    },

    createRenderLight: function (opt) {
        var pageEntry = this.pager.getPageEntry(RenderLight.ENTRY_SIZE);
        return new RenderLight(this, pageEntry, opt);
    },

    createMaterialConfiguration: function(model, data, opt) {
        return new MaterialConfiguration(model, data, opt);
    },

    createRootNode: function () {
        var pageEntry = this.pager.getPageEntry(RenderGroup.ENTRY_SIZE);
        var root = new RenderGroup(this, pageEntry, {
            material: this.getDefaultMaterial(), name: "@scene"
        });
        root.setWorldMatrix(mat4.create());
        root.setLocalMatrix(mat4.create());
        root.transformDirty = false;
        return root;
    },

    updateBoundingBox: function () {
        if (this.rootNode.boundingBoxDirty) {
            // TODO: There should always be an active view
            this.activeView && this.activeView.setProjectionDirty();
        }
        this.rootNode.getWorldSpaceBoundingBox(this.boundingBox);
    },

    getBoundingBox: function (bb) {
        this.updateBoundingBox();
        bb.copy(this.boundingBox);
    },

    createDrawable: function (/*obj*/) {
        throw new Error("Scene::createDrawable not implemented");
    },

    requestRedraw: function (/*reason*/) {
        throw new Error("Scene::requestRedraw not implemented");
    },

    traverse: function (callback) {
        this.rootNode.traverse(callback);
    },

    /**
     * Returns all objects intersected by the given ray, based on their bounding boxes
     * @param ray
     * @returns {Array} An array of RenderObjects that were hit by this ray
     */
    findRayIntersections: function (ray) {
        var intersections = [];
        this.rootNode.findRayIntersections(ray, intersections);
        return intersections;
    },

    getDefaultMaterial: function() {
        if(!this._defaultMaterial) {
            var inputNode = new InputNode();
            inputNode.data = new BufferEntry(XC.DATA_TYPE.FLOAT3, new Float32Array([1, 0, 0]));
            inputNode.name = "diffuseColor";

            var data = new DataNode(false);
            data.appendChild(inputNode);

            this._defaultMaterial = this.createMaterialConfiguration(
                {"type": "urn", "urn": new URI("urn:xml3d:material:matte")},
                data,
                {name: "default"}
            );
        }
        return this._defaultMaterial;
    }



});

module.exports = Scene;

},{"../../../utils/uri.js":176,"../../../xflow/interface/constants.js":179,"../../../xflow/interface/data.js":180,"../../../xflow/interface/graph.js":181,"../lights/light-manager.js":92,"./constants.js":95,"./material-configuration.js":98,"./pager.js":99,"./rendergroup.js":100,"./renderlight.js":101,"./renderobject.js":103,"./renderview.js":104,"events":12,"gl-matrix":1}],106:[function(require,module,exports){
var DataChangeNotifier = require("../../../xflow/interface/data.js").DataChangeNotifier;

/**
 *
 * @constructor
 */
var DataChangeListener = function () {
    DataChangeNotifier.addListener(this.dataEntryChanged);
};

/**
 *
 * @param {Xflow.DataEntry} entry
 * @param {Xflow.DATA_ENTRY_STATE} notification
 */
DataChangeListener.prototype.dataEntryChanged = function (entry, notification) {
    if (entry.userData.webglData) {
        for (var i in entry.userData.webglData) {
            var oldChanged = entry.userData.webglData[i].changed;
            entry.userData.webglData[i].changed = Math.max(oldChanged, notification);
        }
    }
};

module.exports = DataChangeListener;

},{"../../../xflow/interface/data.js":180}],107:[function(require,module,exports){
var vec3 = require("gl-matrix").vec3;
var tmp1 = vec3.create();
var tmp2 = vec3.create();


/**
 *
 * @param {number} nearPlane
 * @param {number} farPlane
 * @param {number} fovx
 * @param {number} fovy
 * @param {number} aspect
 * @param {boolean} orthographic
 * @constructor
 */
var Frustum = function (nearPlane, farPlane, fovx, fovy, aspect, orthographic) {
    /**
     *
     * @type {boolean}
     */
    if (typeof(orthographic) === "undefined")
        this.orthographic = false; else
        this.orthographic = orthographic;
    this.setFrustum(nearPlane, farPlane, fovx, fovy, aspect, this.orthographic);
};

XML3D.extend(Frustum.prototype, {
    setFrustum: function (nearPlane, farPlane, fovx, fovy, aspect, orthographic) {
        if (fovx && fovy)
            throw new Error("fovx and fovy cannot both be non-zero.");

        if (fovx) {
            this.right = nearPlane * Math.tan(fovx / 2);
            this.left = -this.right;
            this.top = ((this.right - this.left) / aspect) / 2;
            this.bottom = -this.top;
        } else {
            this.top = nearPlane * Math.tan(0.5 * fovy);
            this.bottom = -this.top;
            this.right = (this.top - this.bottom) * aspect / 2;
            this.left = -this.right;
        }
        this.nearPlane = nearPlane;
        this.farPlane = farPlane;

        if (typeof(orthographic) === "undefined")
            this.orthographic = false; else
            this.orthographic = orthographic;

    },

    getProjectionMatrix: function (matrix) {
        var limitMax = Number.MAX_VALUE;
        var rightPlusLeft = this.right + this.left;
        var rightMinusLeft = this.right - this.left;

        var topPlusBottom = this.top + this.bottom;
        var topMinusBottom = this.top - this.bottom;

        var farPlusNear = this.farPlane + this.nearPlane;
        var farMinusNear = this.farPlane - this.nearPlane;

        if ((Math.abs(rightMinusLeft) < 1 && Math.abs(rightPlusLeft) > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && Math.abs(topPlusBottom) > limitMax * Math.abs(topMinusBottom)) || (Math.abs(farMinusNear) < 1 && Math.abs(farPlusNear) > limitMax * Math.abs(farMinusNear))) {
            throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
        }

        var A, B, C, D, E, F;
        var m = matrix.data ? matrix.data : matrix;

        if (this.orthographic) {
            var tx = -rightPlusLeft / rightMinusLeft;
            var ty = -topPlusBottom / topMinusBottom;
            var tz = -farPlusNear / farMinusNear;

            if ((Math.abs(rightMinusLeft) < 1 && 2 > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && 2 > limitMax * Math.abs(topMinusBottom)) || (Math.abs(farMinusNear) < 1 && 2 > limitMax * Math.abs(farMinusNear))) {
                throw new Error("Bad viewing frustum:  projection matrix cannot be computed.");
            }

            A = 2 / rightMinusLeft;
            B = 2 / topMinusBottom;
            C = -2 / farMinusNear;

            XML3D.math.mat4.identity(m);
            m[0] = A;
            m[5] = B;
            m[10] = C;
            m[12] = tx;
            m[13] = ty;
            m[14] = tz;
            m[15] = 1.0;
        } else {
            A = rightPlusLeft / rightMinusLeft;
            B = topPlusBottom / topMinusBottom;
            C = -farPlusNear / farMinusNear;

            var farTimesNear = -2 * this.farPlane * this.nearPlane;
            if (Math.abs(farMinusNear) < 1 && Math.abs(farTimesNear) > limitMax * Math.abs(farMinusNear)) {
                throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
            }

            D = farTimesNear / farMinusNear;

            var twoTimesNear = 2 * this.nearPlane;

            if ((Math.abs(rightMinusLeft) < 1 && Math.abs(twoTimesNear) > limitMax * Math.abs(rightMinusLeft)) || (Math.abs(topMinusBottom) < 1 && Math.abs(twoTimesNear) > limitMax * Math.abs(topMinusBottom))) {
                throw new Error("Bad viewing frustum: projection matrix cannot be computed.");
            }

            E = twoTimesNear / rightMinusLeft;
            F = twoTimesNear / topMinusBottom;

            XML3D.math.mat4.identity(m);
            m[0] = E;
            m[5] = F;
            m[8] = A;
            m[9] = B;
            m[10] = C;
            m[11] = -1;
            m[14] = D;
            m[15] = 0;
        }
    },

    getPlanes: (function () {

        var c_a = vec3.create();
        var c_b = vec3.create();
        var c_c = vec3.create();
        var c_d = vec3.create();

        var c_e = vec3.create();
        var c_f = vec3.create();
        var c_g = vec3.create();
        var c_o = vec3.create();


        return function (planes, M) {
            vec3.transformMat4(c_a, [this.left, this.bottom, -this.nearPlane], M);
            vec3.transformMat4(c_b, [this.left, this.top, -this.nearPlane], M);
            vec3.transformMat4(c_c, [this.right, this.top, -this.nearPlane], M);
            vec3.transformMat4(c_d, [this.right, this.bottom, -this.nearPlane], M);
            if (!this.orthographic) {
                var s = this.farPlane / this.nearPlane;
                var farLeft = s * this.left;
                var farRight = s * this.right;
                var farTop = s * this.top;
                var farBottom = s * this.bottom;
                vec3.transformMat4(c_e, [farLeft, farBottom, -this.farPlane], M);
                vec3.transformMat4(c_f, [farLeft, farTop, -this.farPlane], M);
                vec3.transformMat4(c_g, [farRight, farTop, -this.farPlane], M);
                vec3.transformMat4(c_o, [0, 0, 0], M);
                planes[0].setFromPoints(c_o, c_c, c_b);
                planes[1].setFromPoints(c_o, c_d, c_c);
                planes[2].setFromPoints(c_o, c_a, c_d);
                planes[3].setFromPoints(c_o, c_b, c_a);
                planes[4].setFromPoints(c_a, c_d, c_c);
                planes[5].setFromPoints(c_e, c_f, c_g);
            } else {
                vec3.transformMat4(c_e, [this.left, this.bottom, -this.farPlane], M);
                vec3.transformMat4(c_f, [this.left, this.top, -this.farPlane], M);
                vec3.transformMat4(c_g, [this.right, this.top, -this.farPlane], M);
                vec3.transformMat4(c_o, [this.right, this.bottom, -this.farPlane], M);
                planes[0].setFromPoints(c_c, c_g, c_f);
                planes[1].setFromPoints(c_d, c_o, c_g);
                planes[2].setFromPoints(c_a, c_e, c_o);
                planes[3].setFromPoints(c_b, c_f, c_e);
                planes[4].setFromPoints(c_a, c_d, c_c);
                planes[5].setFromPoints(c_e, c_f, c_g);
            }
        };
    }())


});


var Plane = function () {
    this.distance = 0;
    this.normal = vec3.create();
};

XML3D.extend(Plane.prototype, {
    setFromPoints: function (point1, point2, point3) {
        vec3.cross(this.normal, vec3.sub(tmp2, point3, point1), vec3.sub(tmp1, point2, point1));
        vec3.normalize(this.normal, this.normal);
        this.distance = -vec3.dot(this.normal, point1);
    },

    set: function (x, y, z, distance) {
        vec3.set(this.normal, x, y, z);
        vec3.normalize(this.normal, this.normal);
        this.distance = distance;
    }
});

var FrustumTest = function (frustum, cameraMatrix) {
    this.frustumPlanes = [new Plane(), new Plane(), new Plane(), new Plane(), new Plane(), new Plane()];
    if (frustum && cameraMatrix) {
        this.set(frustum, cameraMatrix);
    }
};


XML3D.extend(FrustumTest.prototype, {
    /**
     *
     * @param {Frustum} frustum
     * @param {mat4} matrix
     */
    set: function (frustum, matrix) {
        frustum.getPlanes(this.frustumPlanes, matrix);

    }, /**
     * @param bbox
     * @returns {boolean}
     */
    isBoxVisible: (function () {

        return function (bbox) {
            if (bbox.isEmpty())
                return false;


            for (var i = 0; i < this.frustumPlanes.length; i++) {
                var plane = this.frustumPlanes[i];
                var normal = plane.normal;
                var bbx = normal.x >= 0.0 ? bbox.max.x : bbox.min.x;
                var bby = normal.y >= 0.0 ? bbox.max.y : bbox.min.y;
                var bbz = normal.z >= 0.0 ? bbox.max.z : bbox.min.z;

                // Compute the distance
                var distance = bbx * normal.x + bby * normal.y + bbz * normal.z + plane.distance;

                // if highest point is below plane then all below.
                if (distance < 0.0) {
                    return false;
                }
            }
            return true;
        }
    }())

});

module.exports = {
    Plane: Plane,
    Frustum: Frustum,
    FrustumTest: FrustumTest
};

},{"gl-matrix":1}],108:[function(require,module,exports){
var vec3 = require("gl-matrix").vec3;

/**
 *
 * @constructor
 */
var ObjectSorter = function () {

};

var c_bbox = new XML3D.Box();
var c_center = vec3.create();

XML3D.extend(ObjectSorter.prototype, {
    /**
     * @param {GLScene} scene
     * @param {XML3D.Mat4?} viewMatrix Matrix to apply to objects world space extend before sorting
     */
    sortScene: function (scene, viewMatrix) {
        var sourceObjectArray = scene.ready, opaque = {}, transparent = [];

        var transparentArray = [], obj;
        for (var i = 0, l = sourceObjectArray.length; i < l; i++) {
            obj = sourceObjectArray[i];
            if (obj.inFrustum === false) {
                continue;
            }
            if (obj.hasTransparency()) {
                transparentArray.push(obj);
            } else {
                var program = obj.getProgram();
                opaque[program.id] = opaque[program.id] || [];
                opaque[program.id].push(obj);
            }
        }

        // Sort opaque objects from front to back in order
        // to have earlier z-fails
        for (var progId in opaque) {
            var withinShader = opaque[progId];
            var sortedArray = new Array(withinShader.length);
            for (i = 0; i < withinShader.length; i++) {
                obj = withinShader[i];
                obj.getWorldSpaceBoundingBox(c_bbox);
                c_bbox.center(c_center);
                viewMatrix && vec3.transformMat4(c_center, c_center, viewMatrix);
                sortedArray[i] = {
                    obj: obj, depth: c_center.z
                };
            }
            sortedArray.sort(function (a, b) {
                return b.depth - a.depth;
            });
            opaque[progId] = sortedArray.map(function(e) { return e.obj; });
        }

        //Sort transparent objects from back to front
        var tlength = transparentArray.length;
        if (tlength > 1) {
            for (i = 0; i < tlength; i++) {
                obj = transparentArray[i];
                obj.getWorldSpaceBoundingBox(c_bbox);
                c_bbox.center(c_center);
                viewMatrix && vec3.transformMat4(c_center, c_center, viewMatrix);
                transparentArray[i] = [obj, c_center.z];
            }

            transparentArray.sort(function (a, b) {
                return a[1] - b[1];
            });

            for (i = 0; i < tlength; i++) {
                transparent[i] = transparentArray[i][0];
            }
        } else if (tlength == 1) {
            transparent[0] = transparentArray[0];
        }
        return {
            opaque: opaque, transparent: transparent
        }
    }

});


module.exports = ObjectSorter;



},{"gl-matrix":1}],109:[function(require,module,exports){
/** Calculate the offset of the given element and return it.
 *
 *  @param {Object} element
 *  @return {{top:number, left:number}} the offset
 *
 *  This code is taken from http://javascript.info/tutorial/coordinates .
 *  We don't want to do it with the offsetParent way, because the xml3d
 *  element is actually invisible and thus offsetParent will return null
 *  at least in WebKit. Also it's slow. So we use getBoundingClientRect().
 *  However it returns the box relative to the window, not the document.
 *  Thus, we need to incorporate the scroll factor. And because IE is so
 *  awesome some workarounds have to be done and the code gets complicated.
 */
function calculateOffset(element) {
    var box = element.getBoundingClientRect();
    var body = document.body;
    var docElem = document.documentElement;

    // get scroll factor (every browser except IE supports page offsets)
    var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;

    // the document (`html` or `body`) can be shifted from left-upper corner in IE. Get the shift.
    var clientTop = docElem.clientTop || body.clientTop || 0;
    var clientLeft = docElem.clientLeft || body.clientLeft || 0;

    var top = box.top + scrollTop - clientTop;
    var left = box.left + scrollLeft - clientLeft;

    // for Firefox an additional rounding is sometimes required
    return {top: Math.round(top), left: Math.round(left)};
}


module.exports = {

    /** Convert a given mouse page position to be relative to the given target element.
     *  Most probably the page position are the MouseEvent's pageX and pageY attributes.
     *
     *  @param {!Object} xml3dEl the xml3d element to which the coords need to be translated
     *  @param {!number} pageX the x-coordinate relative to the page
     *  @param {!number} pageY the y-coordinate relative to the page
     *  @return {{x: number, y: number}} the converted coordinates
     */
    convertPageCoords: function (xml3dEl, pageX, pageY) {
        var off = calculateOffset(xml3dEl);

        return {x: pageX - off.left, y: pageY - off.top};
    }
};

},{}],110:[function(require,module,exports){
var TextureManager = require("texture-manager").SimpleTextureManager;
var GLTexture = require("./texture.js").GLTexture;
var GLCubeMap = require("./texture.js").GLCubeMap;
var GLCanvasTarget = require("./rendertarget.js").GLCanvasTarget;
var ProgramFactory = require("./../shader/programfactory.js");
var XC = require("../../../xflow/interface/constants.js");

var CONTEXT_OPTIONS = {
    alpha: true, premultipliedAlpha: false, antialias: true, stencil: true, preserveDrawingBuffer: true
};

/**
 * @param {HTMLCanvasElement!} canvas
 */
function getContextForCanvas(canvas) {
    try {
        return canvas.getContext('experimental-webgl', CONTEXT_OPTIONS);
    } catch (e) {
        return null;
    }
}

/**
 * Context that includes all GL related resources / handlers
 * @param {HTMLCanvasElement!} canvas
 * @param {number} id
 * @constructor
 */
var GLContext = function (canvas, id) {
    this.gl = getContextForCanvas(canvas);
    this.id = id;
    this.canvasTarget = new GLCanvasTarget(this, canvas.clientWidth, canvas.clientHeight);
    this.programFactory = new ProgramFactory(this);
    this.textureManager = new TextureManager({ units: this.gl.getParameter(WebGLRenderingContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS )});
    this.stats = {
        materials: 0, meshes: 0
    };
    this.extensions = populateExtensions(this.gl);

};

var EXTENSIONS = GLContext.EXTENSIONS = {};
EXTENSIONS.STANDARD_DERIVATES = 'OES_standard_derivatives';
EXTENSIONS.MULTIPLE_RENDER_TARGETS = 'WEBGL_draw_buffers';
EXTENSIONS.DEPTH_TEXTURE = 'WEBGL_depth_texture';
EXTENSIONS.FLOAT_COLOR_BUFFER = 'WEBGL_color_buffer_float';
EXTENSIONS.FLOAT_TEXTURES = 'OES_texture_float';
EXTENSIONS.UINT32_INDICES = 'OES_element_index_uint'; //Also defined in xflow/utils/utils.js

XML3D.extend(GLContext.prototype, {
    getXflowEntryWebGlData: function (entry) {
        return getXflowEntryWebGlData(entry, this.id);
    },

    requestRedraw: function (reason) {
        //handler.redraw(reason, forcePicking);
    },

    handleResizeEvent: function (width, height) {
        this.canvasTarget = new GLCanvasTarget(this, width, height);
    },

    getStatistics: function () {
        return this.stats;
    },

    getExtensionByName: function (name) {
        return this.extensions[name];
    } ,

    createTexture: function() {
        return new GLTexture(this);
    } ,
    createCubeMap: function() {
        return new GLCubeMap(this);
    }
});


function getXflowEntryWebGlData(entry, canvasId){
    if(!entry) return null;
    if(!entry.userData.webglData)
        entry.userData.webglData = {};
    if(!entry.userData.webglData[canvasId])
        entry.userData.webglData[canvasId] = {
            changed : XC.DATA_ENTRY_STATE.CHANGED_NEW
        };
    return entry.userData.webglData[canvasId];
}

/**
 * @param {WebGLRenderingContext} gl
 * @returns {{}}
 */
function populateExtensions(gl) {
    var result = {};
    for (var name in EXTENSIONS) {
        var extensionName = EXTENSIONS[name];
        var ext = gl.getExtension(extensionName);
        if (!ext) {
            XML3D.debug.logInfo(extensionName, "is not supported on your graphics card");
        } else {
            result[extensionName] = ext;
        }
    }
    return result;
}

module.exports = GLContext;



},{"../../../xflow/interface/constants.js":179,"./../shader/programfactory.js":154,"./rendertarget.js":114,"./texture.js":115,"texture-manager":39}],111:[function(require,module,exports){
var FullscreenQuad = function (context) {
    this.gl = context.gl;
    this.createGLAssets();
};

XML3D.extend(FullscreenQuad.prototype, {

    createGLAssets: function () {
        var gl = this.gl;
        this.posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0]), gl.STATIC_DRAW);
    },

    draw: function (program) {
        var gl = this.gl;
        var posAttr = program.attributes["position"];
        gl.enableVertexAttribArray(posAttr.location);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.posBuffer);
        gl.vertexAttribPointer(posAttr.location, 3, gl.FLOAT, false, 0, 0);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        gl.disableVertexAttribArray(posAttr.location);
    }

});

module.exports = FullscreenQuad;


},{}],112:[function(require,module,exports){


/**
 *
 * @param context
 * @param type
 * @constructor
 */
var GLMesh = function (context, type) {
    this.context = context;
    this.glType = getGLTypeFromString(type);
    this.buffers = {};
    this.uniformOverride = {};
    this.minIndex = 0;
    this.maxIndex = 0;
    this.isIndexed = false;
    this.vertexCount = null;
    this.minAttributeCount = -1;
    this.context.getStatistics().meshes++;
    this.multiDraw = (this.glType == WebGLRenderingContext.LINE_STRIP || this.glType == WebGLRenderingContext.TRIANGLE_STRIP);
};

XML3D.extend(GLMesh.prototype, {
    setIndexRange: function (minIndex, maxIndex) {
        this.minIndex = minIndex;
        this.maxIndex = maxIndex;
    },

    checkBufferCompatible: function (name, xflowDataBuffer) {
        var cnt = xflowDataBuffer.getIterateCount();
        this.minAttributeCount = (this.minAttributeCount == -1 ? cnt : Math.min(this.minAttributeCount, cnt));

        if (this.isIndexed) {
            if (cnt <= this.maxIndex) {
                throw new Error("Index range of [" + this.minIndex + ", " + this.maxIndex + "] " + " goes beyond element count " + cnt + " of attribute '" + name + "'");
            }
        } else if (this.vertexCount !== null) {
            if (cnt < this.vertexCount)
                throw new Error("VertexCount " + this.vertexCount + " is larger than element count " + cnt + " of attribute '" + name + "'");
        }
    },

    removeBuffer: function (name) {
        delete this.buffers[name];
    },

    setBuffer: function (name, buffer) {
        this.buffers[name] = buffer;
        this.isIndexed = this.isIndexed || name == "index";
    },

    clear: function () {
        this.buffers = {};
        this.uniformOverride = {};
        this.minIndex = this.maxIndex = 0;
        this.isIndexed = false;
        this.minAttributeCount = -1;
    },

    setUniformOverride: function (name, value) {
        if (value === undefined)
            delete this.uniformOverride[name];
        this.uniformOverride[name] = value;
    },

    setVertexCount: function (vertexCount) {
        this.vertexCount = vertexCount;
    },

    isReadyToRender: function () {
        return this.minAttributeCount > 0;
    },

    /**
     * @returns {number}
     */
    getElementCount: function () {
        try {
            return this.buffers.index.length;
        } catch (e) {
            //XML3D.debug.logError("Could not calculate element count.", e);
            return 0;
        }
    }, /**
     * @returns {number}
     */
    getVertexCount: function () {
        try {
            return (this.vertexCount != null ? this.vertexCount : this.minAttributeCount );
        } catch (e) {
            //XML3D.debug.logError("Could not calculate vertex count.", e);
            return 0;
        }
    },

    /**
     * @param {AbstractShaderClosure} program
     * @private
     */
    _bindVertexBuffers: function(program) {
        var gl = this.context.gl, sAttributes = program.attributes, buffers = this.buffers, i, name;

        var keys = Object.keys(sAttributes);
        var keyLength = keys.length;

        for (i = 0; i < keyLength; i++) {
            name = keys[i];
            var buffer = buffers[name];
            var location = sAttributes[name].location;

            if (!buffer) {
                continue;
            }
            gl.enableVertexAttribArray(location);
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(location, buffer.tupleSize, buffer.glType, false, 0, 0);
        }
    },

    _unbindVertexBuffers: function (program) {
        var gl = this.context.gl, sAttributes = program.attributes;
        for (var name in sAttributes) {
            var shaderAttribute = sAttributes[name];
            gl.disableVertexAttribArray(shaderAttribute.location);
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    },

    /**
     * @param {AbstractShaderClosure} program
     * @returns {number}
     */
    draw: function (program) {
        var gl = this.context.gl, sAttributes = program.attributes, buffers = this.buffers, triCount = 0, offset, j;

        //Bind vertex buffers
        this._bindVertexBuffers(program);

        //Draw the object
        if (this.isIndexed) {
            var indexBuffer = buffers.index;
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);

            if (this.multiDraw && this.vertexCount) {
                offset = 0;
                for (j = 0; j < this.vertexCount.length; j++) {
                    var count = this.vertexCount[j];
                    gl.drawElements(this.glType, count, indexBuffer.glType, offset * indexBuffer.bytesPerElement);
                    offset += count;
                }
            } else {
                gl.drawElements(this.glType, this.getElementCount(), indexBuffer.glType, 0);
            }
            triCount = this.getElementCount() / 3;
        } else { // not indexed
            if (this.multiDraw && this.vertexCount) {
                offset = 0;
                for (j = 0; j < this.vertexCount.length; j++) {
                    var count = this.vertexCount[j];
                    gl.drawArrays(this.glType, offset, count);
                    offset += count;
                }
            } else {
                gl.drawArrays(this.glType, 0, this.getVertexCount());
                triCount = this.getVertexCount();
            }
        }

        //Unbind vertex buffers
        this._unbindVertexBuffers(program);


        if (program.undoUniformVariableOverride)
            program.undoUniformVariableOverride(this.uniformOverride);

        return triCount;
    }


});

/**
 * @param {string} typeName
 */
var getGLTypeFromString = function (typeName) {
    var GL = window.WebGLRenderingContext;
    if (typeName && typeName.toLoweGLase)
        typeName = typeName.toLowerCase();
    switch (typeName) {
        case "triangles":
            return GL.TRIANGLES;
        case "tristrips":
            return GL.TRIANGLE_STRIP;
        case "points":
            return GL.POINTS;
        case "lines":
            return GL.LINES;
        case "linestrips":
            return GL.LINE_STRIP;
        default:
            throw new Error("Unknown primitive type: " + typeName);
    }
};

module.exports = GLMesh;

},{}],113:[function(require,module,exports){

var utils = require("./utils.js");
var SystemNotifier = require("../system/system-notifier.js");

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param {Number} type
 * @param {string} shaderSource
 * @return {WebGLShader}
 */
var createWebGLShaderFromSource = function (gl, type, shaderSource) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, shaderSource);
    gl.compileShader(shader);

    if (gl.getShaderParameter(shader, WebGLRenderingContext.COMPILE_STATUS) == 0) {
        var message = gl.getShaderInfoLog(shader);
        var errorString = "";
        if (type == WebGLRenderingContext.VERTEX_SHADER)
            errorString = "Vertex shader failed to compile: \n"; else
            errorString = "Fragment shader failed to compile: \n";

        errorString += message + "\n--------\n";
        errorString += "Shader Source:\n--------\n";
        errorString += XML3D.debug.formatSourceCode(shaderSource);
        gl.getError();
        SystemNotifier.sendEvent('glsl', {
                glslType: "compile_error",
                shaderType: type == WebGLRenderingContext.VERTEX_SHADER ? "vertex" : "fragment",
                code: shaderSource,
                message: message
            });

        throw new Error(errorString)
    }
    return shader;
};

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param vertexSources
 * @param fragmentSources
 * @returns {WebGLProgram}
 */
var createProgramFromSources = function (gl, vertexSources, fragmentSources) {
    var shd, s, src;
    var shaders = [];
    for (s in vertexSources) {
        src = vertexSources[s];
        shd = createWebGLShaderFromSource(gl, WebGLRenderingContext.VERTEX_SHADER, src);
        shaders.push(shd);
    }
    for (s in fragmentSources) {
        src = fragmentSources[s];
        shd = createWebGLShaderFromSource(gl, WebGLRenderingContext.FRAGMENT_SHADER, src);
        shaders.push(shd);
    }
    return createProgramFromShaders(gl, shaders);
};

//noinspection JSValidateJSDoc
/**
 * @param {WebGLRenderingContext} gl
 * @param {Object} shaders
 * @return {WebGLProgram}
 */
var createProgramFromShaders = function (gl, shaders) {
    var program = gl.createProgram();
    for (var s in shaders) {
        var shader = shaders[s];
        gl.attachShader(program, shader);
    }
    gl.linkProgram(program);
    if (gl.getProgramParameter(program, WebGLRenderingContext.LINK_STATUS) == 0) {
        var message = gl.getProgramInfoLog(program);
        var errorString = "Shader linking failed: \n";
        errorString += message;
        errorString += "\n--------\n";
        gl.getError();
        SystemNotifier.sendEvent('glsl', {glslType: "link_error", message: message});
        throw new Error(errorString);
    }
    return program;
};

var tally = function (gl, handle, programObject) {
    var i;
    // Tally shader attributes
    var numAttributes = gl.getProgramParameter(handle, gl.ACTIVE_ATTRIBUTES);
    for (i = 0; i < numAttributes; i++) {
        var att = gl.getActiveAttrib(handle, i);
        if (!att)
            continue;
        var attInfo = {};
        attInfo.name = att.name;
        attInfo.size = att.size;
        attInfo.glType = att.type;
        attInfo.location = gl.getAttribLocation(handle, att.name);
        programObject.attributes[att.name] = attInfo;
    }


    // Tally shader uniforms and samplers
    var numUniforms = gl.getProgramParameter(handle, gl.ACTIVE_UNIFORMS);
    for (i = 0; i < numUniforms; i++) {
        var uni = gl.getActiveUniform(handle, i);
        if (!uni)
            continue;
        var uniInfo = {};
        uniInfo.name = uni.name;
        uniInfo.size = uni.size;
        uniInfo.glType = uni.type;
        uniInfo.location = gl.getUniformLocation(handle, uni.name);

        var name = uniInfo.name;

        // Remove array identifier from name, this is handled by size
        if (name.substring(name.length - 3) == "[0]") {
            name = name.substring(0, name.length - 3); // Remove [0]
        }

        if (uni.type == gl.SAMPLER_2D || uni.type == gl.SAMPLER_CUBE) {
            // Set all texture units to 0, needs to be Int32Array
            uniInfo.cachedUnits = new Int32Array(uniInfo.size);
            uniInfo.textures = [];
            // Caches this information
            utils.setUniform(gl, uniInfo, uniInfo.cachedUnits);

            programObject.samplers[name] = uniInfo;
        } else
            programObject.uniforms[name] = uniInfo;
    }

};

var uniqueObjectId = utils.getUniqueCounter();

/**
 * @constructor
 * @param {WebGLRenderingContext} gl
 * @param {{ fragment: string, vertex: string }} sources
 */
var ProgramObject = function (gl, sources) {
    this.gl = gl;
    this.sources = sources;

    this.id = uniqueObjectId();
    this.attributes = {};
    this.uniforms = {};
    this.samplers = {};
    this.handle = null;

    this.create();
};

XML3D.extend(ProgramObject.prototype, {
    create: function () {
        XML3D.debug.logDebug("Create shader program: ", this.id);
        this.handle = createProgramFromSources(this.gl, [this.sources.vertex], [this.sources.fragment]);
        if (!this.handle)
            return;
        SystemNotifier.sendEvent('glsl', {glslType: "success"});
        this.bind();
        tally(this.gl, this.handle, this);
    },

    bind: function () {
        if (!this.handle) {
            XML3D.debug.logError("Trying to bind invalid GLProgram.");
        }
        this.gl.useProgram(this.handle);

        /**
         * Some of the dependent textures may have changed their texture units
         */
        for (var name in this.samplers) {
            var sampler = this.samplers[name];
            if(sampler.textures.length) {
                this.setSamplerFromTextures(sampler);
            }
        }
    },

    unbind: function () {
    }, isValid: function () {
        return !!this.handle;
    }, setUniformVariables: function (envNames, sysNames, inputCollection) {
        var i, base, override, name;
        if (envNames && inputCollection.envBase) {
            i = envNames.length;
            base = inputCollection.envBase;
            override = inputCollection.envOverride;
            while (i--) {
                name = envNames[i];
                this.setUniformVariable(name, override && override[name] !== undefined ? override[name] : base[name]);
            }
        }
        if (sysNames && inputCollection.sysBase) {
            i = sysNames.length;
            base = inputCollection.sysBase;
            while (i--) {
                name = sysNames[i];
                this.setUniformVariable(name, base[name]);
            }
        }
    }, setUniformVariable: function (name, value) {
        if (value === undefined) return;
        if (this.uniforms[name]) {
            utils.setUniform(this.gl, this.uniforms[name], value);
        } else if (this.samplers[name]) {
            this.setUniformSampler(this.samplers[name], value);
        }
    },

    /**
     * Sets the texture units from the textures associated with the sampler
     * @param sampler
     * @returns {boolean}
     */
    setSamplerFromTextures: function (sampler) {
        var textures = sampler.textures;
        var cachedUnits = sampler.cachedUnits;
        var textureUnitsChanged = false;

        for (var i = 0, ii = textures.length; i < ii; i++) {
            var unit = textures[i].unit;

            // If texture is not bound to a texture unit (-1), bind it now
            if (unit == -1) {
                unit = textures[i]._bind();
            }
            if (unit != cachedUnits[i]) {
                cachedUnits[i] = unit;
                textureUnitsChanged = true;
            }
        }
        if (true) {
            XML3D.debug.logDebug("Setting new texture units:", sampler.name, cachedUnits);
            utils.setUniform(this.gl, sampler, cachedUnits);
        }
    },

    setSamplerFromArray: function(sampler, arr) {
        var cachedUnits = sampler.cachedUnits;
        var textureUnitsChanged = false;

       for (var i = 0, ii = arr.length; i < ii; i++) {
            var unit = arr[i];
            if (unit != cachedUnits[i]) {
                cachedUnits[i] = unit;
                textureUnitsChanged = true;
            }
        }
        if (true) {
            utils.setUniform(this.gl, sampler, cachedUnits);
            XML3D.debug.logDebug("Setting global texture units:", sampler.name, cachedUnits, this.id);
        }
    },

    /**
     *
     * @param {Object} sampler
     * @param {Array.<GLTexture>|Int32Array} value
     */
    setUniformSampler: function (sampler, value) {
        XML3D.debug.assert(value && sampler);
        // Textures are always an array value
        XML3D.debug.assert(Array.isArray(value), "Program::setUniformSampler: Unexpected value.");
        // We have at least one entry
        XML3D.debug.assert(value.length, "Program::setUniformSampler: No entry in value.");

        /**
         * Value can either be an array of GLTextures that know their current texture unit,
         * otherwise a typed array containing the texture units we have to bind.
         * @type {boolean}
         */
        var hasTextures = value[0].unit != undefined;

        if(hasTextures) {
            sampler.textures = value;
            this.setSamplerFromTextures(sampler);
        } else {
            this.setSamplerFromArray(sampler, value);
        }
    }
});

module.exports = ProgramObject;


},{"../system/system-notifier.js":156,"./utils.js":116}],114:[function(require,module,exports){
/**
 * @interface
 */
var IRenderTarget = function () {
};
IRenderTarget.prototype.bind = function () {
};
IRenderTarget.prototype.unbind = function () {
};
IRenderTarget.prototype.getWidth = function () {
};
IRenderTarget.prototype.getHeight = function () {
};
IRenderTarget.prototype.getScale = function () {
};
IRenderTarget.prototype.resize = function (width, height) {
};

/**
 * Wrapper to handle screen context as render target
 * @constructor
 * @param {GLContext} context
 * @param {Number} width
 * @param {Number} height
 * @implements IRenderTarget
 */
var GLCanvasTarget = function (context, width, height) {
    this.context = context;
    this.width = width;
    this.height = height;
};

var empty = function () {
};

XML3D.extend(GLCanvasTarget.prototype, {
    getWidth: function () {
        return this.width;
    }, getHeight: function () {
        return this.height;
    }, getScale: function () {
        return 1;
    }, bind: function() {
        this.context.gl.viewport(0, 0, this.width, this.height);
    }, unbind: empty, resize: empty
});

/**
 * @param context
 * @param opt
 * @constructor
 * @implements IRenderTarget
 */
var GLRenderTarget = function (context, opt) {
    this.context = context;
    this.width = opt.width || 800;
    this.height = opt.height || 600;
    this.scale = opt.scale || 1;
    this.opt = this.fillOptions(opt);
    this.handle = null;
    this.colorTarget = {handle: null, isTexture: false};
    this.depthTarget = {handle: null, isTexture: false};
    this.stencilTarget = {handle: null, isTexture: false};
    this.valid = false;
};

XML3D.extend(GLRenderTarget.prototype, {
    getWidth: function () {
        return this.width;
    }, getHeight: function () {
        return this.height;
    }, getScale: function () {
        return this.scale;
    }, bind: function () {
        if (!this.handle) {
            this.createFrameBuffer(this.opt.colorFormat, this.opt.depthFormat, this.opt.stencilFormat);
        }
        if (this.valid) {
            var gl = this.context.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
            gl.viewport(0, 0, this.width, this.height);
        }
    }, unbind: function () {
        var gl = this.context.gl;
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }, resize: function (width, height) {
        this.dispose();
        this.width = width;
        this.height = height;
        this.bind();
    }, createFrameBuffer: function (colorFormat, depthFormat, stencilFormat) {
        var gl = this.context.gl;

        this.handle = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
        colorFormat && this.createColorTarget(colorFormat);
        depthFormat && this.createDepthTarget(depthFormat);
        stencilFormat && this.createStencilTarget(stencilFormat);
        this.checkStatus();
    }, createColorTarget: function (colorFormat) {
        var gl = this.context.gl;
        if (this.opt.colorAsRenderbuffer) {
            var ct = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, ct);
            gl.renderbufferStorage(gl.RENDERBUFFER, colorFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, ct);

            this.colorTarget = {
                handle: ct, isTexture: false
            };
        } else {
            //opt.generateMipmap = opt.generateColorsMipmap;
            var ctex = this.context.createTexture();
            ctex.createTex2DFromData(colorFormat, this.width, this.height, gl.RGBA, this.opt.colorType || gl.UNSIGNED_BYTE, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, ctex.handle, 0);
            this.colorTarget = {
                handle: ctex, isTexture: true
            };
        }
    }, createDepthTarget: function (depthFormat) {
        var gl = this.context.gl;
        this.opt.isDepth = true;
        if (this.opt.depthAsRenderbuffer) {
            var dt = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, dt);
            gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, dt);

            this.depthTarget = {
                handle: dt, isTexture: false
            }
        } else {
            //opt.generateMipmap = opt.generateDepthMipmap;
            var dtex = this.context.createTexture();
            dtex.createTex2DFromData(depthFormat, this.width, this.height, gl.DEPTH_COMPONENT, gl.FLOAT, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, dtex.handle, 0);

            this.depthTarget = {
                handle: dtex, isTexture: true
            }
        }
    }, createStencilTarget: function (stencilFormat) {
        var gl = this.context.gl;
        if (this.opt.stencilAsRenderbuffer) {
            var st = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, st);
            gl.renderbufferStorage(gl.RENDERBUFFER, stencilFormat, this.width, this.height);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, st);

            this.stencilTarget = {
                handle: st, isTexture: false
            }
        } else {
            //opt.generateMipmap = opt.generateStencilMipmap;
            var stex = this.context.createTexture();
            stex.createTex2DFromData(stencilFormat, this.width, this.height, gl.STENCIL_COMPONENT, gl.UNSIGNED_BYTE, this.opt);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.TEXTURE_2D, stex.handle, 0);

            this.stencilTarget = {
                handle: stex, isTexture: true
            }
        }
    }, checkStatus: function () {
        var gl = this.context.gl;

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.handle);
        //Finalize framebuffer creation
        var fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

        switch (fbStatus) {
            case gl.FRAMEBUFFER_COMPLETE:
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                break;
            case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                break;
            case gl.FRAMEBUFFER_UNSUPPORTED:
                XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                break;
            default:
                XML3D.debug.logError("Incomplete framebuffer: " + fbStatus);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        this.valid = (fbStatus == gl.FRAMEBUFFER_COMPLETE);
        return this.valid;
    }, fillOptions: function (options) {
        var gl = this.context.gl;
        var opt = {
            wrapS: gl.CLAMP_TO_EDGE,
            wrapT: gl.CLAMP_TO_EDGE,
            minFilter: gl.NEAREST,
            magFilter: gl.NEAREST,
            depthMode: gl.LUMINANCE,
            depthCompareMode: gl.COMPARE_R_TO_TEXTURE,
            depthCompareFunc: gl.LEQUAL,
            colorsAsRenderbuffer: false,
            depthAsRenderbuffer: false,
            stencilAsRenderbuffer: false,
            isDepth: false
        };

        for (var item in options) {
            opt[item] = options[item];
        }
        return opt;
    }, dispose: function () {
        if (!this.handle)
            return;

        var gl = this.context.gl;
        gl.deleteFramebuffer(this.handle);

        if (this.colorTarget !== null) {
            if (this.colorTarget.isTexture)
                this.colorTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.colorTarget.handle);
        }
        if (this.depthTarget !== null) {
            if (this.depthTarget.isTexture)
                this.depthTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.depthTarget.handle);
        }
        if (this.stencilTarget !== null) {
            if (this.stencilTarget.isTexture)
                this.stencilTarget.handle.dispose(); else
                gl.deleteRenderBuffer(this.stencilTarget.handle);
        }
    }
});

var GLScaledRenderTarget = function (context, maxDimension, opt) {
    GLRenderTarget.call(this, context, opt);
    this.scaleToMaxDimension(maxDimension);
};

XML3D.createClass(GLScaledRenderTarget, GLRenderTarget);
XML3D.extend(GLScaledRenderTarget.prototype, {
    scaleToMaxDimension: function (maxDimension) {
        var hDiff = this.height - maxDimension;
        var wDiff = this.width - maxDimension;

        if (hDiff > 0 || wDiff > 0) {
            var scale;
            if (hDiff > wDiff) {
                scale = maxDimension / this.height;
            } else {
                scale = maxDimension / this.width;
            }
            this.width = Math.floor(this.width * scale);
            this.height = Math.floor(this.height * scale);
            this.scale = scale;
        }
    }
});


    /**
     * @param context
     * @param opt
     * @constructor
     * @implements IRenderTarget
     */
    var GLCubeMapRenderTarget = function (context, opt) {
        var gl = context.gl;
        this.context = context;
        this.width = opt.width || 800;
        this.height = this.width;
        this.scale = opt.scale || 1;
        this.opt = this.fillOptions(opt);
        this.handle = null;
        this.ctex = null;
        this.dtex = null;
        this.stex = null;
        this.colorTarget = null;
        this.depthTarget =  null;
        this.stencilTarget = null;
        this.valid = false;
        this.glSides = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                        gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                        gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];
        this.framebuffers = [];
    };

    XML3D.extend(GLCubeMapRenderTarget.prototype, {
        getWidth: function() {
            return this.width;
        },
        getHeight: function() {
            return this.height;
        },
        getScale: function() {
            return this.scale;
        },
        bind: function (side) {
            if (this.framebuffers.length <= 0) {
                this.createFrameBuffers(this.opt.colorFormat, this.opt.depthFormat, this.opt.stencilFormat);
            }
            if (this.valid) {
                var gl = this.context.gl;
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[side]);
                gl.viewport(0, 0, this.width, this.height);
            }
        },
        unbind: function () {
            var gl = this.context.gl;
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        },
        resize: function(width, height) {
            this.dispose();
            this.width = width;
            this.height = height;
            this.bind();
        },
        createFrameBuffers: function (colorFormat, depthFormat, stencilFormat) {
            var gl = this.context.gl;

            if(colorFormat) { //TODO check if renderbuffers instead of textures...
                this.ctex = this.context.createCubeMap();
                this.ctex.createTex2DFromData(colorFormat, this.width, this.height, gl.RGBA, this.opt.colorType || gl.UNSIGNED_BYTE, this.opt);
                this.colorTarget = { handle: this.ctex,  isTexture: true};
            }
            if(depthFormat) {
                this.opt.isDepth = true;

                if (this.opt.depthAsRenderbuffer) {
                } else {
                    this.dtex = this.context.createCubeMap();
                    this.dtex.createTex2DFromData(depthFormat, this.width, this.height, gl.DEPTH_COMPONENT, gl.FLOAT, this.opt);
                    this.depthTarget = { handle: this.dtex,  isTexture: true};
                }
            }
            if(stencilFormat) {
                this.stex = this.context.createCubeMap();
                this.stex.createTex2DFromData(stencilFormat, this.width, this.height, gl.STENCIL_COMPONENT, gl.UNSIGNED_BYTE, this.opt);
                this.stencilTarget = { handle: this.stex, isTexture: true};
            }

            for(var i = 0; i < this.glSides.length; ++i) {
                this.framebuffers[i] = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[i]);
                colorFormat && this.createColorTarget(colorFormat, i);
                depthFormat && this.createDepthTarget(depthFormat, i);
                stencilFormat && this.createStencilTarget(stencilFormat, i);
                this.checkStatus(i);
            }
        },
        createColorTarget: function (colorFormat, side) {
            var gl = this.context.gl;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, this.glSides[side], this.ctex.handle, 0);
        },
        createDepthTarget: function (depthFormat, side) {
            var gl = this.context.gl;

            if (this.opt.depthAsRenderbuffer) {
                if (!this.dtex) this.dtex = [];
                this.dtex[side] = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, this.dtex[side]);
                gl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, this.width, this.height);
                gl.bindRenderbuffer(gl.RENDERBUFFER, null);

                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.dtex[side]);
                if (!this.depthTarget) this.depthTarget = [];
                this.depthTarget[side] = {
                    handle: this.dtex[side],
                    isTexture: false
                }
            }
            else
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT0, this.glSides[side], this.dtex.handle, 0);
        },
        createStencilTarget: function (stencilFormat, side) {
            var gl = this.context.gl;

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, this.glSides[side], this.stex.handle, 0);
        },
        checkStatus: function (side) {
            var gl = this.context.gl;

            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers[side]);
            //Finalize framebuffer creation
            var fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);

            switch (fbStatus) {
                case gl.FRAMEBUFFER_COMPLETE:
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
                    break;
                case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");
                    break;
                case gl.FRAMEBUFFER_UNSUPPORTED:
                    XML3D.debug.logError("Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");
                    break;
                default:
                    XML3D.debug.logError("Incomplete framebuffer: " + fbStatus);
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);

            this.valid = (fbStatus == gl.FRAMEBUFFER_COMPLETE);
            return this.valid;
        },
        fillOptions: function (options) {
            var gl = this.context.gl;
            var opt = {
                wrapS: gl.CLAMP_TO_EDGE,
                wrapT: gl.CLAMP_TO_EDGE,
                minFilter: gl.NEAREST,
                magFilter: gl.NEAREST,
                depthMode: gl.LUMINANCE,
                depthCompareMode: gl.COMPARE_R_TO_TEXTURE,
                depthCompareFunc: gl.LEQUAL,
                colorsAsRenderbuffer: false,
                depthAsRenderbuffer: false,
                stencilAsRenderbuffer: false,
                isDepth: false
            };

            for (var item in options) {
                opt[item] = options[item];
            }

            return opt;
        },
        dispose: function () {
            if (this.framebuffers.length <= 0)
                return;

            var gl = this.context.gl;
            for(var side in this.framebuffers)
                gl.deleteFramebuffer(this.framebuffers[side]);

            if (this.colorTarget.handle !== null) {
                    this.colorTarget.handle.dispose();
            }
            if (this.depthTarget !== null) {
                this.depthTarget.handle.dispose();
            }
            if (this.stencilTarget !== null) {
                    this.stencilTarget.handle.dispose();
            }

            this.framebuffers = [];
        }
    });

module.exports = {
    GLCanvasTarget: GLCanvasTarget,
    GLRenderTarget: GLRenderTarget,
    GLScaledRenderTarget: GLScaledRenderTarget,
    GLCubeMapRenderTarget: GLCubeMapRenderTarget
};



},{}],115:[function(require,module,exports){
var utils = require("./utils.js");
var StateMachine = require("../../../contrib/state-machine.js");
var SamplerConfig = require("../../../xflow/interface/data.js").SamplerConfig;
var XC = require("../../../xflow/interface/constants.js");
var uniqueObjectId = utils.getUniqueCounter();

//noinspection JSValidateJSDoc
/**
 * @param {GLContext} context
 * @constructor
 */
var GLTexture = function (context) {
    SamplerConfig.call(this);

    /**
     * @type {GLContext}
     */
    this.context = context;

    /**
     * @type {number}
     */
    this.id = uniqueObjectId();

    /**
     * Unit the texture is currently bound to (or -1 if bound to no unit)
     * @type {number}
     */
    this.unit = -1;

    this.setDefaults();

    this.width = 0;
    this.height = 0;
    this.handle = null;

    this.textureType = context.gl.TEXTURE_2D;

    this.textureUnitCallback = this.lostTextureUnit.bind(this);
};

XML3D.createClass(GLTexture, SamplerConfig);

GLTexture.State = {
    NONE: "none", LOADING: "loading", READY: "ready", ERROR: "error"
};


var getOrCreateFallbackTexture = (function () {

    var c_fallbackTexture = null;

    return function (context) {
        if (!c_fallbackTexture) {
            c_fallbackTexture = new GLTexture(context);
            var size = 16;
            var texels = new Uint8Array(size * size * 3);
            for (var i = 0; i < texels.length; i++) {
                texels[i] = 128;
            }
            c_fallbackTexture.createTex2DFromData(WebGLRenderingContext.RGB, size, size, WebGLRenderingContext.RGB, WebGLRenderingContext.UNSIGNED_BYTE, {
                texels: texels, wrapS: WebGLRenderingContext.REPEAT, wrapT: WebGLRenderingContext.REPEAT, minFilter: WebGLRenderingContext.LINEAR, magFilter: WebGLRenderingContext.LINEAR
            });
        }
        return c_fallbackTexture;
    }
}());

var isPowerOfTwo = function (dimension) {
    return (dimension & (dimension - 1)) == 0;
};
var nextHighestPowerOfTwo = function (x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
};

/**
 * Scale up the texture to the next highest power of two dimensions.
 * @returns {HTMLCanvasElement}
 */
var scaleImage = function (image, width, height) {
    /**
     * @type {HTMLCanvasElement}
     */
    var canvas = document.createElement("canvas");
    canvas.width = nextHighestPowerOfTwo(width);
    canvas.height = nextHighestPowerOfTwo(height);

    var context = canvas.getContext("2d");
    if (image instanceof HTMLElement) {
        context.drawImage(image, 0, 0, canvas.width, canvas.height);
    } else {
        var tmpCanvas = document.createElement("canvas");
        tmpCanvas.width = width;
        tmpCanvas.height = height;
        var tmpContext = tmpCanvas.getContext("2d");
        var imageData = tmpContext.createImageData(width, height);
        imageData.data.set(image.data);
        tmpContext.putImageData(imageData, 0, 0);

        context.drawImage(tmpCanvas, 0, 0, canvas.width, canvas.height);
    }

    return canvas;
};

var glTextureFormatFromXflow = function (format, gl) {
    switch (format) {
        case XC.TEXTURE_FORMAT.ALPHA:
            return gl.ALPHA;
        case XC.TEXTURE_FORMAT.RGB:
            return gl.RGB;
        case XC.TEXTURE_FORMAT.RGBA:
            return gl.RGBA;
        case XC.TEXTURE_FORMAT.LUMINANCE:
            return gl.LUMINANCE;
        case XC.TEXTURE_FORMAT.LUMINANCE_ALPHA:
            return gl.LUMINANCE_ALPHA;
        default:
            throw new Error("Unsupported Texture Format!");
    }
};

var glTextureTypeFromXflow = function (type, gl) {
    switch (type) {
        case XC.TEXTURE_TYPE.FLOAT:
            return gl.FLOAT;
        case XC.TEXTURE_TYPE.UBYTE:
            return gl.UNSIGNED_BYTE;
        case XC.TEXTURE_TYPE.USHORT_4_4_4_4:
            return gl.UNSIGNED_SHORT_4_4_4_4;
        case XC.TEXTURE_TYPE.USHORT_5_5_5_1:
            return gl.UNSIGNED_SHORT_5_5_5_1;
        case XC.TEXTURE_TYPE.USHORT_5_6_5:
            return gl.GL_UNSIGNED_SHORT_5_6_5;
        default:
            throw new Error("Unsupported Texture Type!");
    }
};

XML3D.extend(GLTexture.prototype, {
    /**
     * @param {Xflow.TextureEntry} textureEntry
     */
    updateFromTextureEntry: function (textureEntry) {
        if (!textureEntry.isLoading()) {
            this.set(textureEntry.getSamplerConfig());
            var img = textureEntry.asGLTextureValue();
            if (!img)
                return this.failed();
            this.createOrUpdateTexture(img);
        } else {
            this.loads();
        }
    }, /**
     * We need to scale texture when one of the wrap modes is not CLAMP_TO_EDGE and
     * one of the texture dimensions is not power of two.
     * Otherwise rendered texture will be just black.
     * @param {number} width
     * @param {number} height
     * @returns {boolean}
     */
    needsScale: function (width, height) {
        return (this.generateMipMap || this.wrapS != WebGLRenderingContext.CLAMP_TO_EDGE || this.wrapT != WebGLRenderingContext.CLAMP_TO_EDGE) && (!isPowerOfTwo(width) || !isPowerOfTwo(height))
    },


    _bind: function () {
        var gl = this.context.gl;
        var textureManager = this.context.textureManager;
        var unit = this.unit = textureManager.bind(this.id, { dispose: this.textureUnitCallback });
        if (unit == -2) {
            XML3D.debug.logError("All available texture units are full.");
        } else {
            gl.activeTexture(WebGLRenderingContext.TEXTURE0 + unit);
            gl.bindTexture(this.textureType, this.handle);
        }
        return unit;
    },

    unbind: function (unit) {
        // Do nothing, texture manager will handle this
    },

    destroy: function () {
        var gl = this.context.gl;
        var textureManager = this.context.textureManager;
        textureManager.dispose(this.id);
        gl.deleteTexture(this.handle);
    },

    canBind: function () {
        return this.current == GLTexture.State.READY;
    },

    createOrUpdateTexture: function (texelSource) {

        if (!this.handle) {
            this.handle = this.context.gl.createTexture();
        }

        this.updateTextureFromData(texelSource);
    },

    updateTextureFromData: function (texelSource) {
        var gl = this.context.gl;
        this._bind();

        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, this.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, this.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, this.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, this.magFilter);

        var type = glTextureTypeFromXflow(texelSource.texelType, gl);
        var format = glTextureFormatFromXflow(texelSource.texelFormat, gl);

        var width = texelSource.width;
        this.width = width;
        var height = texelSource.height;
        this.height = height;

        if (this.generateMipMap && this.needsScale(width, height)) {
            if (type === gl.FLOAT)
                throw new Error("Should generate MipMaps but texture data is float and not power of two in size!");
            else
                texelSource = scaleImage(texelSource, width, height);
        }

        if (texelSource instanceof HTMLElement) {
            gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, texelSource);
        } else {
            if (texelSource.data instanceof Uint8ClampedArray) {
                // WebGL does not support Uint8ClampedArray, which is (correctly) used by async. Xflow. We just build a new view
                // on top of the underlying array buffer which should be relatively fast
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, new Uint8Array(texelSource.data.buffer));
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, texelSource.data);
            }
        }

        if (this.generateMipMap)
            gl.generateMipmap(this.textureType);

        this.created();
    },

    createTex2DFromData: function (internalFormat, width, height, sourceFormat, sourceType, opt) {
        var gl = this.context.gl;

        var opt = opt || {};
        var texels = opt.texels;

        if (!texels) {
            if (sourceType == gl.FLOAT) {
                texels = new Float32Array(width * height * 4);
            } else {
                texels = new Uint8Array(width * height * 4);
            }
        }
        this.width = width;
        this.height = height;
        this.handle = gl.createTexture();
        this._bind();

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, opt.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, opt.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, opt.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, opt.magFilter);

        if (!opt.isDepth) {
            if (texels instanceof Uint8ClampedArray) {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, new Uint8Array(texels.buffer));
            } else {
                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, texels);
            }
        } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, width, height, 0, sourceFormat, sourceType, null);
        }

        if (opt.generateMipmap) {
            gl.generateMipmap(this.textureType);
        }
        this.created();
    },

    lostTextureUnit: function() {
        this.unit = -1;
    }

});

StateMachine.create({
    target: GLTexture.prototype,
    initial: GLTexture.State.NONE,
    events: [{name: 'created', from: '*', to: GLTexture.State.READY}, {
        name: 'failed', from: '*', to: GLTexture.State.ERROR
    }, {name: 'loads', from: '*', to: GLTexture.State.LOADING}]
});

//noinspection JSValidateJSDoc
/**
 * @param {GLContext} context
 * @constructor
 */
var GLCubeMap = function (context) {
    GLTexture.call(this, context, context.gl.TEXTURE_CUBE_MAP);
    var gl = context.gl;
    this.textureType = context.gl.TEXTURE_CUBE_MAP;
    this.glSides = [gl.TEXTURE_CUBE_MAP_POSITIVE_X, gl.TEXTURE_CUBE_MAP_NEGATIVE_X, gl.TEXTURE_CUBE_MAP_POSITIVE_Y, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, gl.TEXTURE_CUBE_MAP_POSITIVE_Z, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z];

};
XML3D.createClass(GLCubeMap, GLTexture, {
    updateTextureFromData: function (texelSource) {
        debug.log("updateTextureFromData not implemented for CubeMapping!");
    },

    createTex2DFromData: function (internalFormat, width, height, sourceFormat, sourceType, opt) {
        var gl = this.context.gl;

        var opt = opt || {};
        var texels = opt.texels;

        if (!texels) {
            if (sourceType == gl.FLOAT) {
                texels = new Float32Array(width * height * 4);
            } else {
                texels = new Uint8Array(width * height * 4);
            }
        }
        this.width = width;
        this.height = height;
        this.handle = gl.createTexture();
        this._bind();

        // gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_S, opt.wrapS);
        gl.texParameteri(this.textureType, gl.TEXTURE_WRAP_T, opt.wrapT);
        gl.texParameteri(this.textureType, gl.TEXTURE_MIN_FILTER, opt.minFilter);
        gl.texParameteri(this.textureType, gl.TEXTURE_MAG_FILTER, opt.magFilter);

        for(var i = 0; i < this.glSides.length; ++i) {
            if (!opt.isDepth) {
                if (texels instanceof Uint8ClampedArray) {
                    gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, new Uint8Array(texels.buffer));
                } else {
                    gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, texels);
                }
            } else {
                gl.texImage2D(this.glSides[i], 0, internalFormat, width, height, 0, sourceFormat, sourceType, null);
            }
        }

        if (opt.generateMipmap) {
            gl.generateMipmap(this.textureType);
        }
        this.created();
    }
});

GLCubeMap.State = {
    NONE: "none", LOADING: "loading", READY: "ready", ERROR: "error"
};

StateMachine.create({
    target: GLCubeMap.prototype,
    initial: GLCubeMap.State.NONE,
    events: [{name: 'created', from: '*', to: GLCubeMap.State.READY}, {
        name: 'failed', from: '*', to: GLCubeMap.State.ERROR
    }, {name: 'loads', from: '*', to: GLCubeMap.State.LOADING}]
});


module.exports = {
    GLTexture: GLTexture,
    GLCubeMap: GLCubeMap
};



},{"../../../contrib/state-machine.js":49,"../../../xflow/interface/constants.js":179,"../../../xflow/interface/data.js":180,"./utils.js":116}],116:[function(require,module,exports){
module.exports = {
    /**
     * Set uniforms for active program
     * @param {WebGLRenderingContext} gl
     * @param u
     * @param value
     * @param {boolean=} transposed
     */
    setUniform: function (gl, u, value, transposed) {

        //noinspection FallthroughInSwitchStatementJS
        switch (u.glType) {
            case 35670: //gl.BOOL
                if (value && value.length !== undefined) {
                    // Transform a Unit8Array into a JS Array
                    gl.uniform1iv(u.location, Array.prototype.map.call(value, function(v) { return v; }));
                } else {
                    gl.uniform1i(u.location, value || 0);
                }
                break;
            case 5124:  //gl.INT
            case 35678: //gl.SAMPLER_2D
            case 35680: //gl.SAMPLER_CUBE
                if (value && value.length !== undefined) {
                    gl.uniform1iv(u.location, value);
                } else {
                    gl.uniform1i(u.location, value || 0);
                }
                break;

            case 35671: // gl.BOOL_VEC2
            case 35667:
                gl.uniform2iv(u.location, value);
                break; // gl.INT_VEC2

            case 35672: // gl.BOOL_VEC3
            case 35668:
                gl.uniform3iv(u.location, value);
                break; // gl.INT_VEC3

            case 35673: // gl.BOOL_VEC4
            case 35669:
                gl.uniform4iv(u.location, value);
                break; // gl.INT_VEC4

            case 5126:
                if (value.length != null)
                    gl.uniform1fv(u.location, value); else
                    gl.uniform1f(u.location, value);
                break; // gl.FLOAT
            case 35664:
                gl.uniform2fv(u.location, value);
                break; // gl.FLOAT_VEC2
            case 35665:
                gl.uniform3fv(u.location, value);
                break; // gl.FLOAT_VEC3
            case 35666:
                gl.uniform4fv(u.location, value);
                break; // gl.FLOAT_VEC4

            case 35674:
                gl.uniformMatrix2fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT2
            case 35675:
                gl.uniformMatrix3fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT3
            case 35676:
                gl.uniformMatrix4fv(u.location, transposed || false, value);
                break;// gl.FLOAT_MAT4

            default:
                XML3D.debug.logError("Unknown uniform type " + u.glType);
                break;
        }
    },

    getUniqueCounter: function () {
        var c_counter = 0;
        return function () {
            return c_counter++;
        }
    },

    checkError: function (gl, text) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            var textErr = "" + error;
            switch (error) {
                case 1280:
                    textErr = "1280 ( GL_INVALID_ENUM )";
                    break;
                case 1281:
                    textErr = "1281 ( GL_INVALID_VALUE )";
                    break;
                case 1282:
                    textErr = "1282 ( GL_INVALID_OPERATION )";
                    break;
                case 1283:
                    textErr = "1283 ( GL_STACK_OVERFLOW )";
                    break;
                case 1284:
                    textErr = "1284 ( GL_STACK_UNDERFLOW )";
                    break;
                case 1285:
                    textErr = "1285 ( GL_OUT_OF_MEMORY )";
                    break;
            }
            var msg = "GL error " + textErr + " occured.";
            if (text !== undefined)
                msg += " " + text;
            XML3D.debug.trace(msg);
        }
    },

    supported: function () {
        var canvas = document.createElement("canvas");
        try {
            return !!(window.WebGLRenderingContext && (canvas.getContext('experimental-webgl')));
        } catch (e) {
            return false;
        }
    }

};


},{}],117:[function(require,module,exports){
var AbstractCanvasHandler = require("../renderer/canvas-handler.js");
var Options = require("../../utils/options.js");
var xml3dFormatHandler = require("../../base/formathandler.js").xml3dFormatHandler;

var MAXFPS = 30;

var OPTION_CONTINUOUS = "renderer-continuous";
Options.register(OPTION_CONTINUOUS, false);

/**
 * GLCanvasHandler class.
 * Registers and handles the events that happen on the canvas element.
 *
 * @param xml3dElem
 *            the root xml3d node, containing the XML3D scene structure
 * @constructor
 * @extends AbstractCanvasHandler
 */
function GLCanvasHandler(xml3dElem, canvas) {
    AbstractCanvasHandler.call(this, xml3dElem, canvas);
    this.renderInterface = {};

    this.lastPickObj = null;

    this.lastKnownDimensions = {width: canvas.width, height: canvas.height};
    this.initialize();
}

XML3D.createClass(GLCanvasHandler, AbstractCanvasHandler);

GLCanvasHandler.prototype.setRenderer = function (renderer) {
    this.renderer = renderer;
};

GLCanvasHandler.prototype.initialize = function () {
     this.configureCanvas();

    // This function is called at regular intervals by requestAnimationFrame to
    // determine if a redraw
    // is needed
    var that = this;
    this.tick = function () {

        if(!that.renderer)
            return;

        XML3D.updateXflowObserver();
        XML3D.flushDOMChanges();

        if (that.canvasSizeChanged() || that.renderer.needsRedraw() || Options.getValue(OPTION_CONTINUOUS)) {
            that.dispatchUpdateEvent();
            that.draw();
        }

        window.requestAnimationFrame(that.tick, MAXFPS);
    };

      // Block the right-click context menu on the canvas unless it's explicitly toggled
    var cm = this._xml3dElement.getAttribute("contextmenu");
    if (!cm || cm == "false") {
        this._canvas.addEventListener("contextmenu", function (e) {
            e.preventDefault && e.preventDefault();
            e.stopPropagation && e.stopPropagation();
        }, false);
    }
};

GLCanvasHandler.prototype.configureCanvas = function () {
    var xml3dElement = this._xml3dElement;
    var canvas = this._canvas;

    var parent = xml3dElement.parentNode;
    // Place xml3dElement inside an invisble div
    var hideDiv = parent.ownerDocument.createElement('div');
    //hideDiv.style.display = "none";
    parent.insertBefore(hideDiv, xml3dElement);
    hideDiv.appendChild(xml3dElement);

    // Create canvas and append it where the xml3d element was before
    parent.insertBefore(canvas, hideDiv);

    var style = canvas.ownerDocument.defaultView.getComputedStyle(xml3dElement);
    if (!canvas.style.backgroundColor) {
        var bgcolor = style.getPropertyValue("background-color");
        if (bgcolor && bgcolor != "transparent")
            canvas.style.backgroundColor = bgcolor;
    }
    // Need to be set for correct canvas size
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;

    return canvas;
};

/**
 * Binds the picking buffer and passes the request for a picking pass to the
 * renderer
 *
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {Drawable|null} newly picked object
 */
GLCanvasHandler.prototype.getPickObjectByPoint = function (canvasX, canvasY) {
    // TODO
    //if (!this.renderOptions.pickingEnabled)
    //    return null;
    return this.renderer.getRenderObjectFromPickingBuffer(canvasX, canvasY);
};

/**
 *
 * @returns {HTMLElement}
 */
GLCanvasHandler.prototype.getPickedObject = function() {
    return this.renderer.pickedObject ? this.renderer.pickedObject.node : null;
};

/**
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {vec3|null} The world space normal on the object's surface at the given coordinates
 */
GLCanvasHandler.prototype.getWorldSpaceNormalByPoint = function (canvasX, canvasY) {
    return this.renderer.getWorldSpaceNormalByPoint(canvasX, canvasY);
};

/**
 * @param {number} canvasX
 * @param {number} canvasY
 * @return {vec3|null} The world space position on the object's surface at the given coordinates
 */
GLCanvasHandler.prototype.getWorldSpacePositionByPoint = function (canvasX, canvasY) {
    return this.renderer.getWorldSpacePositionByPoint(canvasX, canvasY);
};

GLCanvasHandler.prototype.canvasSizeChanged = function () {
    var canvas = this._canvas;
    if (canvas.clientWidth !== this.lastKnownDimensions.width || canvas.clientHeight !== this.lastKnownDimensions.height) {

        this.lastKnownDimensions.width = canvas.width = canvas.clientWidth;
        this.lastKnownDimensions.height = canvas.height = canvas.clientHeight;
        this.renderer.handleResizeEvent(canvas.width, canvas.height);
        this.dispatchResizeEvent({width: canvas.width, height: canvas.height});
        return true;
    }
    return false;
};

var c_timer = window.performance || Date;

/**
 * Called by tick() to redraw the scene if needed
 */
GLCanvasHandler.prototype.draw = function () {
    XML3D.flushDOMChanges();
    try {
        var start = c_timer.now();
        var stats = this.renderer.renderToCanvas();
        var end = c_timer.now();


        var factory = xml3dFormatHandler.getFactory("webgl", this.id);
        var xml3dAdapter = factory.getAdapter(this._xml3dElement);
        xml3dAdapter.onFrameDrawn();
        this.dispatchFrameDrawnEvent(start, end, stats);

    } catch (e) {
        XML3D.debug.logException(e);
    }

};

GLCanvasHandler.prototype.getMousePosition = function (evt) {
    var rct = this._canvas.getBoundingClientRect();
    return {
        x: (evt.clientX - rct.left), y: (evt.clientY - rct.top)
    };
};

module.exports =  GLCanvasHandler;


},{"../../base/formathandler.js":45,"../../utils/options.js":175,"../renderer/canvas-handler.js":88}],118:[function(require,module,exports){
var GLProgramObject = require("../base/program.js");
var XflowUtils= require("../xflow/utils.js");

/**
 * A ShaderClosure connects a mesh-specific GLProgram with it's Xflow data
 * @param {GLContext} context
 * @constructor
 */
var AbstractShaderClosure = function (context) {
    /**
     * @private
     * @type {GLProgramObject|null}
     */
    this.program = null;
    this.context = context;
    /**
     * A flag used by shadercomposer to sort out obsolete shaderclosures
     * @type {boolean}
     */
    this.obsolete = false;
    this.id = "";

    this.uniformCollection = {
        envBase: {}, envOverride: null, sysBase: null
    };

    /**
     * Stores, if the underlying shader has semi-transparencies
     * and thus needs to considered for alpha-blending
     * @type {boolean}
     */
    this.isTransparent = false;

    /**
     * The source of a shader
     * @private
     * @type {{vertex: string, fragment: string}}
     */
    this.source = {
        vertex: "", fragment: ""
    }
};

Object.defineProperties(AbstractShaderClosure.prototype, {
        attributes: {
            writeable: false, get: function () {
                return this.program ? this.program.attributes : {}
            }
        }, uniforms: {
            writeable: false, get: function () {
                return this.program ? this.program.uniforms : {}
            }
        }, samplers: {
            writeable: false, get: function () {
                return this.program ? this.program.samplers : {}
            }
        }
    });
XML3D.createClass(AbstractShaderClosure, null, {

    equals: function (that) {
        return this.source.vertex === that.source.vertex && this.source.fragment === that.source.fragment;
    },

    hasTransparency: function () {
        return this.isTransparent;
    },

    compile: function () {
        if (!this.source.fragment || !this.source.vertex) {
            XML3D.debug.logError("No source found for material", this);
            return;
        }

        var programObject = new GLProgramObject(this.context.gl, this.source);
        this.program = programObject;
        this.id = programObject.id;
    },

    bind: function () {
        this.program.bind();
    },

    unbind: function () {
        this.program.unbind();
    },

    isValid: function () {
        return this.program.isValid();
    },

    /**
     * @param {Xflow.ComputeResult} xflowResult
     */
    updateUniformsFromComputeResult: function (xflowResult) {
        var map = xflowResult.getOutputMap();

        var envBase = this.uniformCollection.envBase = {};
        this.setDefaultUniforms(this.uniformCollection.envBase);

        for (var name in map) {
            envBase[name] = XflowUtils.getGLUniformValueFromXflowDataEntry(map[name], this.context);
        }
        var names = Object.keys(envBase);
        this.setUniformVariables(names, null, this.uniformCollection);

        this.isTransparent = this.getTransparencyFromInputData(map);
    },

    setUniformVariables: function (envNames, sysNames, uniformCollection) {
        this.program.setUniformVariables(envNames, sysNames, uniformCollection);
    },

    setSystemUniformVariables: function (sysNames, sysValues) {
        this.uniformCollection.sysBase = sysValues;
        this.setUniformVariables(null, sysNames, this.uniformCollection);
    },

    changeUniformVariableOverride: function (prevOverride, newOverride) {
        var overrideNames = prevOverride ? Object.keys(prevOverride) : [];
        if (newOverride) overrideNames.push.apply(overrideNames, Object.keys(newOverride));
        this.uniformCollection.envOverride = newOverride;
        this.setUniformVariables(overrideNames, null, this.uniformCollection);
    }
});

module.exports = AbstractShaderClosure;


},{"../base/program.js":113,"../xflow/utils.js":157}],119:[function(require,module,exports){
var GLScene = require("../scene/glscene.js");
var GLLights = require("../scene/gllights.js");
var MaterialEvents = require("../materials/events.js");
var EventEmitter = require("events").EventEmitter;
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;
var XC = require("../../../xflow/interface/constants.js");

/**
 * @interface
 */
var IShaderComposer = function () {
};

/**
 * @enum
 */
IShaderComposer.UpdateState = {
    SHADER_UPDATED: 1, SHADER_COMPILED: 2, SHADER_UNCHANGED: 3
};

IShaderComposer.State = {
    OK: 1, NO_SCRIPT: 2, NO_PROGRAM: 3
};

/**
 * @param {scene} scene
 * @param {{}=} opt
 */
IShaderComposer.prototype.update = function (scene, opt) {
};

/**
 *
 * @returns AbstractShaderClosure|null
 */
IShaderComposer.prototype.getShaderClosure = function (scene) {
    return null;
};

/**
 * @returns {Array.<string>}
 */
IShaderComposer.prototype.getRequestFields = function () {
    return [];
};

/**
 * @returns {{}}
 */
IShaderComposer.prototype.getShaderAttributes = function () {
    return {};
};

/**
 * @constructor
 * @extends EventEmitter
 */
var AbstractShaderComposer = function (context, shaderInfo) {
    EventEmitter.call(this);
    this.context = context;
    this.shaderClosures = [];
    this.dataChanged = false;
    this.updateLightValues = false;
    this.request = null;
    this.setMaxListeners(0);
};

XML3D.createClass(AbstractShaderComposer, EventEmitter, {

    // Implemented by subclass
    setShaderInfo: null,


    updateRequest: function (xflowDataNode) {
        if (this.request) this.request.clear();

        this.request = new ComputeRequest(xflowDataNode, this.getRequestFields(), this.onShaderRequestChange.bind(this));
        this.setShaderRecompile();
    },

    onShaderInfoChanged: function (shaderInfo) {
        this.setShaderInfo(shaderInfo);
        this.setShaderRecompile();
        this.context.requestRedraw("Shader script changed");
    },

    onShaderRequestChange: function (request, changeType) {
        this.dataChanged = true;
        if (changeType == XC.RESULT_STATE.CHANGED_STRUCTURE)
            this.setShaderRecompile();
        this.context.requestRedraw("Shader data changed");
    },

    /**
     * @param {Scene} scene
     * @param {{}=} opt
     */
    update: function (scene, opt) {
        opt = opt || {};
        var that = this;

        // Clean up shaderClosures that are not used!
        var i = this.shaderClosures.length;
        while (i--) {
            if (this.shaderClosures[i].obsolete) this.shaderClosures.splice(i, 1);
        }

        if (!this.shaderClosures.length)
            return;

        if (this.dataChanged) {
            var result = this.getShaderDataResult();
            this.shaderClosures.forEach(function (shader) {
                that.updateClosureFromComputeResult(shader, result);
            });
            this.dataChanged = false;
        }

        if (this.updateLightValues) {
            this.shaderClosures.forEach(function (shader) {
                that.updateClosureFromLightParameters(shader, scene);
            });
        }
    },

    /**
     * @param {AbstractShaderClosure} shaderClosure
     * @param {Xflow.ComputeResult} result
     */
    updateClosureFromComputeResult: function (shaderClosure, result) {
        if (!result || !result.getOutputMap) {
            return;
        }
        shaderClosure.bind();
        shaderClosure.updateUniformsFromComputeResult(result);
    },

    updateClosureFromLightParameters: function (shaderClosure, scene) {
        shaderClosure.bind();
        shaderClosure.setSystemUniformVariables(GLLights.ALL_PARAMETERS, scene.systemUniforms);
    },

    updateSystemUniforms: function (names, scene) {
        this.shaderClosures.forEach(function (shader) {
            shader.bind();
            shader.setSystemUniformVariables(names, scene.systemUniforms);
        });
    },


    createShaderClosure: function () {
        throw new Error("AbstractComposer::createShaderClosure needs to be overridden");
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        throw new Error("AbstractComposer::createObjectDataRequest needs to be overridden");
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        throw new Error("AbstractComposer::distributeObjectShaderData needs to be overridden");
    },

    getShaderClosure: function (scene, vsRequest) {
        var shader = this.createShaderClosure();

        try {
            shader.createSources(scene, this.getShaderDataResult(), vsRequest)
        } catch (e) {
            throw new Error("Shader: " + e.message)
        }

        for (var i = 0; i < this.shaderClosures.length; i++) {
            if (this.shaderClosures[i].equals(shader)) {
                this.shaderClosures[i].obsolete = false;
                return this.shaderClosures[i];
            }
        }

        this.initializeShaderClosure(shader, scene);
        return shader;
    },

    initializeShaderClosure: function (shaderClosure, scene) {
        shaderClosure.compile();

        scene.emit(MaterialEvents.MATERIAL_INITIALIZED);
        this.updateClosureFromComputeResult(shaderClosure, this.getShaderDataResult());
        this.updateClosureFromLightParameters(shaderClosure, scene);
        this.shaderClosures.push(shaderClosure);
    },

    setShaderRecompile: function () {

        for (var i = 0; i < this.shaderClosures.length; ++i) {
            this.shaderClosures[i].obsolete = true;
        }
        this.emit(MaterialEvents.MATERIAL_STRUCTURE_CHANGED);
        this.dataChanged = true;
        this.updateLightValues = true;
    },


    /**
     * @returns {Xflow.ComputeResult|null}
     */
    getShaderDataResult: function () {
        return this.request ? this.request.getResult() : null;
    }


});


/**
 * @implements IShaderComposer
 * @constructor
 */
var DefaultComposer = function (context) {
    this.context = context;
};
XML3D.createClass(DefaultComposer, AbstractShaderComposer, {
    update: function () {
    },

    getShaderClosure: function (scene, vsRequest) {
        return this.context.programFactory.getFallbackProgram();
    },

    getShaderAttributes: function () {
        return {color: null, normal: null /* for picking */};
    },

    getRequestFields: function () {
        return ["diffuseColor", "useVertexColor"];
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        return new ComputeRequest(objectDataNode, ["position", "color", "normal", "diffuseColor", "useVertexColor"], callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var result = objectRequest.getResult();

        var dataMap = result.getOutputMap(), requestFields = this.getRequestFields();
        for (var name in dataMap) {
            if (requestFields.indexOf(name) != -1)
                uniformCallback(name, dataMap[name]); else
                attributeCallback(name, dataMap[name]);
        }
    }
});


module.exports = {
    AbstractShaderComposer: AbstractShaderComposer,
    DefaultComposer: DefaultComposer
}


},{"../../../xflow/interface/constants.js":179,"../../../xflow/interface/request.js":182,"../materials/events.js":120,"../scene/gllights.js":152,"../scene/glscene.js":153,"events":12}],120:[function(require,module,exports){
module.exports = {
    MATERIAL_STRUCTURE_CHANGED: "material_structure_changed",
    MATERIAL_INITIALIZED: "material_initialized"
};

},{}],121:[function(require,module,exports){
var AbstractShaderClosure = require("./../abstractshaderclosure.js");
var JSShaderComposer = require("./jsshadercomposer.js");
var SystemNotifier = require("../../system/system-notifier.js");
var getJSSystemConfiguration = require("./jssystemconfiguration.js");
var XC = require("../../../../xflow/interface/constants.js");
var Options = require("../../../../utils/options.js");


var c_jsShaderCache = {};


function convertEnvName(name) {
    return ("_env_" + name).replace(/_+/g, "_");
}

function addDefaultChanneling(vsConfig, inputName) {
    var outputName = convertEnvName(inputName);
    vsConfig.channelAttribute(inputName, outputName, null);
}


function channelVsAttribute(vsConfig, inputName, spaceInfo) {
    if (!spaceInfo || !spaceInfo[inputName]) {
        addDefaultChanneling(vsConfig, inputName);
        return;
    }

    var i = spaceInfo[inputName].length;
    while (i--) {
        var entry = spaceInfo[inputName][i];
        var outputName = convertEnvName(entry.name), code = null;
        switch (entry.space) {
            case Shade.SPACE_VECTOR_TYPES.OBJECT:
                break;
            case Shade.SPACE_VECTOR_TYPES.VIEW_POINT:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelViewMatrix", true);
                code = outputName + " = ( modelViewMatrix * vec4(#I{" + inputName + "}, 1.0) ).xyz;";
                break;
            case Shade.SPACE_VECTOR_TYPES.VIEW_NORMAL:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT3X3, "modelViewMatrixN", true);
                code = outputName + " = normalize( modelViewMatrixN * #I{" + inputName + "} );";
                break;
            case Shade.SPACE_VECTOR_TYPES.WORLD_POINT:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelMatrix", true);
                code = outputName + " = ( modelMatrix * vec4(#I{" + inputName + "}, 1.0) ).xyz;";
                break;
            case Shade.SPACE_VECTOR_TYPES.WORLD_NORMAL:
                vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT3X3, "modelMatrixN", true);
                code = outputName + " = normalize( modelMatrixN * #I{" + inputName + "} );";
                break;
            default:
                throw new Error("Can't handle Space Type: " + entry.space);
        }
        vsConfig.channelAttribute(inputName, outputName, code);
    }
}


/**
 * @param {XC.DATA_TYPE} xflowType
 */
var convertXflow2ShadeType = function (xflowType, source) {
    var result = {}
    switch (xflowType) {
        case XC.DATA_TYPE.BOOL:
            result.type = Shade.TYPES.BOOLEAN;
            break;
        case XC.DATA_TYPE.INT:
            result.type = Shade.TYPES.INT;
            break;
        case XC.DATA_TYPE.FLOAT:
            result.type = Shade.TYPES.NUMBER;
            break;
        case XC.DATA_TYPE.FLOAT2:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT2;
            break;
        case XC.DATA_TYPE.FLOAT3:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT3;
            break;
        case XC.DATA_TYPE.FLOAT4:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.FLOAT4;
            break;
        case XC.DATA_TYPE.FLOAT3X3:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.MATRIX3;
            break;
        case XC.DATA_TYPE.FLOAT4X4:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.MATRIX4;
            break;
        case XC.DATA_TYPE.TEXTURE:
            result.type = Shade.TYPES.OBJECT;
            result.kind = Shade.OBJECT_KINDS.TEXTURE;
            break;
        case XC.DATA_TYPE.UNKNOWN:
        default:
            throw new Error("Unknown Xflow DataType: " + xflowType);
    }
    result.source = source;
    return result;
}

/**
 * @param context
 * @param sourceTemplate
 * @param dataCallback
 * @constructor
 */
var JSShaderClosure = function (context, sourceTemplate, extractedParams) {
    AbstractShaderClosure.call(this, context);
    this.sourceTemplate = sourceTemplate;
    this.extractedParams = extractedParams;
    this.uniformSetter = function () {
    };
    this.uniformConverter = [];
};

XML3D.createClass(JSShaderClosure, AbstractShaderClosure, {
    /**
     *
     * @param {GLScene} scene
     * @param {Xflow.ComputeResult} shaderResult
     * @param objectData
     */
    createSources: function (scene, shaderResult, vsRequest) {

        var vsDataResult = vsRequest.getResult();

        var systemParameters = getSystemParameters(this.context, scene.systemUniforms);
        var environmentParameters = {};



        var shaderEntries = shaderResult && shaderResult.getOutputMap(), vsShaderOutput = vsDataResult && vsDataResult.outputNames;

        for (var i = 0; i < this.extractedParams.length; ++i) {
            var paramName = this.extractedParams[i];
            if (vsShaderOutput && vsShaderOutput.indexOf(paramName) != -1) {
                environmentParameters[paramName] = convertXflow2ShadeType(vsDataResult.getOutputType(paramName), vsDataResult.isOutputUniform(paramName) ? Shade.SOURCES.UNIFORM : Shade.SOURCES.VERTEX);
            } else if (shaderEntries && shaderEntries[paramName]) {
                environmentParameters[paramName] = convertXflow2ShadeType(shaderEntries[paramName].type, Shade.SOURCES.UNIFORM);
            }
        }

        var contextData = {
            "this": { "type": "object", "kind": "any", "info": systemParameters },
            "global.shade": [{"extra": {"type": "object", "kind": "any", "global": true, "info": environmentParameters }}]
        };

        XML3D.debug.logDebug("CONTEXT:", contextData);

        var options = {
            propagateConstants: true,
            validate: true,
            sanitize: true,
            transformSpaces: Options.getValue("shadejs-transformSpaces"),
            extractUniformExpressions: Options.getValue("shadejs-extractUniformExpressions")
        };
        var compileOptions = {
            useStatic: true, uniformExpressions: options.uniformExpressions
        };
        var implementation = scene.deferred ? "xml3d-glsl-deferred" : "xml3d-glsl-forward";

        var jsShaderKey = implementation + ";" + JSON.stringify(options) + ";" + JSON.stringify(environmentParameters) + ";" + this.sourceTemplate;

        var cacheEntry;
        if (!(cacheEntry = c_jsShaderCache[jsShaderKey])) {
            try {
                var workSet = new Shade.WorkingSet();
                workSet.parse(this.sourceTemplate, {loc: true});
                workSet.analyze(contextData, implementation, options);
                var spaceInfo = workSet.getProcessingData('spaceInfo');
                var glslShader = workSet.compileFragmentShader(compileOptions);

                cacheEntry = {
                    source: glslShader.source, uniformSetter: glslShader.uniformSetter, spaceInfo: spaceInfo
                };
                cacheEntry.hasTransparentShaderClosure = workSet.getProcessingData("isTransparent");

                this.uniformSetter = glslShader.uniformSetter;
                this.source = {
                    fragment: glslShader.source, vertex: this.createVertexShader(vsRequest, vsDataResult, spaceInfo)
                }

                if (scene.deferred) {
                    cacheEntry.signatures = workSet.getProcessingData("colorClosureSignatures");
                }
                if (Options.getValue("shadejs-cache"))
                    c_jsShaderCache[jsShaderKey] = cacheEntry;
            } catch (e) {
                SystemNotifier.sendEvent('shadejs', {
                    shadejsType: "error", event: e, code: this.sourceTemplate
                });

                var errorMessage = "Shade.js Compile Error:\n" + e.message + "\n------------\n" + "Shader Source:" + "\n------------\n" + XML3D.debug.formatSourceCode(this.sourceTemplate);
                throw new Error(errorMessage);
            }
        }
        this.source = {
            fragment: cacheEntry.source, vertex: this.createVertexShader(vsRequest, vsDataResult, cacheEntry.spaceInfo)
        };
        this.hasTransparentShaderClosure = cacheEntry.hasTransparentShaderClosure;

        this.uniformSetter = cacheEntry.uniformSetter;
        if (scene.deferred) {
            scene.colorClosureSignatures.push.apply(scene.colorClosureSignatures, cacheEntry.signatures);
        }

        // TODO: Handle errors.
        XML3D.debug.logDebug(this.source.vertex);
        XML3D.debug.logDebug(this.source.fragment);

        SystemNotifier.sendEvent('shadejs', {
            shadejsType: "success", vertexShader: this.source.vertex, fragmentShader: this.source.fragment
        });

        return true;
    },

    createVertexShader: function (vsRequest, vsDataResult, spaceInfo) {
        var vsConfig = vsRequest.getConfig();
        var names = vsDataResult.outputNames;
        for (var i = 0; i < names.length; ++i) {
            channelVsAttribute(vsConfig, names[i], spaceInfo);
        }
        vsConfig.addInputParameter(XC.DATA_TYPE.FLOAT4X4, "modelViewProjectionMatrix", true);
        vsConfig.addCodeFragment("gl_Position = modelViewProjectionMatrix * vec4(#I{position}, 1.0);");
        return vsRequest.getVertexShader().getGLSLCode();
    },

    setUniformVariables: function (envNames, sysNames, inputCollection) {
        this.uniformSetter(envNames, sysNames, inputCollection, this.program.setUniformVariable.bind(this.program));
    },

    getTransparencyFromInputData: function (dataMap) {
        // TODO: Compute Transparency
        return this.hasTransparentShaderClosure;
    },

    /* Default values are compiled into shade.js */
    setDefaultUniforms: function () {
    }

});

/**
 * @param {GLContext} context
 * @param {{}} globals
 * @returns {{}}
 */
function getSystemParameters(context, globals) {
    var result = getJSSystemConfiguration(context);

    // Update light parameters which vary in their size depending on number of lights defined
    ["point", "directional", "spot"].forEach(function(model) {
        var on = model + "LightOn";
        result["MAX_" + model.toUpperCase() + "LIGHTS"].staticValue = globals[on] && globals[on].length;
    });

    for (var global in globals) {
        var entry = result[global];
        if(entry && entry.staticSize) {
            var aLength = globals[global].length;
            if (aLength) {
                var tupleSize = getTupleSize(entry);
                entry.staticSize = aLength / tupleSize;
            } else {
                // Do not allow a array of size 0, remove entry instead
                // TODO(ksons): Remove once we can check array size in shade.js
                delete result[global];
            }
        }

    }
    return result;
}

/**
 * @param {{}} desc Object type descriptor
 * @returns {number}
 */
function getTupleSize(desc) {
    if(desc.type == "array") {
        var elements = desc.elements;
        if (elements.type == "object") {
            switch(elements.kind) {
                case "texture":
                case "float": return 1;
                case "float2": return 2;
                case "float3": return 3;
                case "float4": return 4;
                case "matrix4": return 16;
                default: throw ("Unknown array element kind:" + elements.kind);
            }
        }
    }
    return 1;
}

module.exports = JSShaderClosure;


},{"../../../../utils/options.js":175,"../../../../xflow/interface/constants.js":179,"../../system/system-notifier.js":156,"./../abstractshaderclosure.js":118,"./jsshadercomposer.js":122,"./jssystemconfiguration.js":123}],122:[function(require,module,exports){
var AbstractShaderComposer = require("./../abstractshadercomposer.js").AbstractShaderComposer;
var JSShaderClosure = require("./jsshaderclosure.js");
var VSConfig = require("../../../../xflow/processing/vs-connect.js").VSConfig;
var VertexShaderRequest = require("../../../../xflow/interface/request.js").VertexShaderRequest;
var XC = require("../../../../xflow/interface/constants.js");

/**
 *
 * @param {GLContext} context
 * @param {MaterialConfiguration} config
 * @extends AbstractShaderComposer
 * @constructor
 */
var JSShaderComposer = function (context, config) {
    AbstractShaderComposer.call(this, context, config);

    if (!window.Shade)
        throw new Error("shade.js library not found");

    this.context = context;

    /** @type string*/
    this.sourceTemplate = config.model.script;

    /**
     * @private
     * @type {Array.<string>}
     */
    this.extractedParams = [];

    /**
     * @private
     * @type {Xflow.ComputeRequest|null}
     */
    this.request = null;

    this.setShaderInfo(config);
};

JSShaderComposer.convertSysName = function (name) {
    return name;
};

XML3D.createClass(JSShaderComposer, AbstractShaderComposer, {
    setShaderInfo: function (config) {
        try {
            var ast = Shade.parse(this.sourceTemplate, {loc: true});
            this.extractedParams = Shade.extractParameters(ast, {implementation: "xml3d-glsl-forward"}).shaderParameters;
            // FIXME: Shader.js should always request position (in case
        } catch (e) {
            // We ignore errors here. They will reoccur when updating connected mesh closures
            this.extractedParams = [];
        }
        if (this.extractedParams.indexOf("position") == -1) this.extractedParams.push("position");

        // The composer is interested in changes of all possible shader parameters (extracted)
        // the instances (closures) will only set those, that occur in the instance
        if (this.extractedParams.length) {
            this.updateRequest(config.dataNode);
        }
    },

    getRequestFields: function () {
        return this.extractedParams;
    },

    getShaderAttributes: function () {
        return {color: null, normal: null, texcoord: null};
    },

    createShaderClosure: function () {
        return new JSShaderClosure(this.context, this.sourceTemplate, this.extractedParams);
    },

    createObjectDataRequest: function (objectDataNode, callback) {

        var vsConfig = new VSConfig();
        var names = this.extractedParams.slice();
        //if(names.indexOf("position") == -1) names.push("position");
        vsConfig.addAttribute(XC.DATA_TYPE.FLOAT3, "position", true);
        for (var i = 0; i < names.length; ++i) {
            var name = names[i];
            if (name == "position") continue;
            var xflowInfo = objectDataNode.getOutputChannelInfo(name);
            if (xflowInfo) {
                vsConfig.addAttribute(xflowInfo.type, name, true);
            }
        }
        return new VertexShaderRequest(objectDataNode, vsConfig, callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var vertexShader = objectRequest.getVertexShader();
        var inputNames = vertexShader.inputNames;
        var i, name, entry;

        for (i = 0; i < inputNames.length; ++i) {
            name = inputNames[i];
            entry = vertexShader.getInputData(name);
            if (vertexShader.isInputUniform(name))
                uniformCallback(name, entry); else
                attributeCallback(name, entry);
        }
        var outputNames = vertexShader.outputNames;
        for (i = 0; i < outputNames.length; ++i) {
            name = outputNames[i];
            if (vertexShader.isOutputFragmentUniform(name)) {
                uniformCallback(vertexShader.getOutputSourceName(name), vertexShader.getUniformOutputData(name));
            }
        }
    }

});


module.exports = JSShaderComposer;



},{"../../../../xflow/interface/constants.js":179,"../../../../xflow/interface/request.js":182,"../../../../xflow/processing/vs-connect.js":229,"./../abstractshadercomposer.js":119,"./jsshaderclosure.js":121}],123:[function(require,module,exports){
var GLContext = require("../../base/context.js");
var singleton = null;

var SYSTEM_CONTEXT_TEMPLATE =  {
        "coords": {"type": "object", "kind": "float3", "source": "uniform"},
        "cameraPosition": {"type": "object", "kind": "float3", "source": "uniform"},
        "viewMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "viewInverseMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelViewMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelViewProjectionMatrix": {"type": "object", "kind": "matrix4", "source": "uniform"},
        "modelMatrixN": {"type": "object", "kind": "matrix3", "source": "uniform"},
        "modelViewMatrixN": {"type": "object", "kind": "matrix3", "source": "uniform"},

        "MAX_POINTLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "pointLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "pointLightAttenuation": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightPosition": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "pointLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "pointLightProjection": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "pointLightNearFar": {
            "type": "array",
            "elements": {"type": "object", "kind": "float2"},
            "staticSize": 5,
            "source": "uniform"
        },

        "MAX_DIRECTIONALLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "directionalLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "directionalLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightDirection": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "directionalLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },

        "MAX_SPOTLIGHTS": {"type": "int", "source": "constant", "staticValue": 5},
        "spotLightOn": {"type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"},
        "spotLightAttenuation": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightIntensity": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightPosition": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightDirection": {
            "type": "array", "elements": {"type": "object", "kind": "float3"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCosFalloffAngle": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCosSoftFalloffAngle": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightCastShadow": {
            "type": "array", "elements": {"type": "boolean"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightShadowBias": {
            "type": "array", "elements": {"type": "number"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightShadowMap": {
            "type": "array", "elements": {"type": "object", "kind": "texture"}, "staticSize": 5, "source": "uniform"
        },
        "spotLightMatrix": {
            "type": "array",
            "elements": {"type": "object", "kind": "matrix4"},
            "staticSize": 5,
            "source": "uniform"
        },
        "ssaoMap": {"type": "object", "kind": "texture", "source": "uniform"},
        "environment": {"type": "object", "kind": "texture", "source": "uniform"}
};

function createSystemConfiguration(context) {
    var result = SYSTEM_CONTEXT_TEMPLATE;
    var ext = context.getExtensionByName(GLContext.EXTENSIONS.STANDARD_DERIVATES);
    if (ext) {
        result.fwidth = {type: Shade.TYPES.FUNCTION};
        result.dx = {type: Shade.TYPES.FUNCTION};
        result.dy = {type: Shade.TYPES.FUNCTION};
    }
    return result;
}


module.exports = function (context) {
    if (!singleton) {
        singleton = createSystemConfiguration(context);
    }
    return singleton;
};




},{"../../base/context.js":110}],124:[function(require,module,exports){
var JSShaderComposer = require("./js/jsshadercomposer.js");
var URNShaderComposer = require("./urn/urnshadercomposer.js");
var DefaultComposer = require("./abstractshadercomposer.js").DefaultComposer;

/**
 * @param {GLContext} context
 * @constructor
 */
var ShaderComposerFactory = function (context) {
    this.context = context;
    /** @type {Object.<number, IShaderComposer>} */
    this.composers = {};
    this.defaultComposer = new DefaultComposer(context);
    this.lightValuesDirty = true;
};


XML3D.extend(ShaderComposerFactory.prototype, {
    /**
     *
     * @param {MaterialConfiguration} materialConfiguration
     * @returns {IShaderComposer}
     */
    createComposerFromMaterialConfiguration: function (materialConfiguration) {
        if (!materialConfiguration) {
            return this.defaultComposer;
        }
        var result = this.composers[materialConfiguration.id];
        if (!result) {
            try {
                var modelType = materialConfiguration.model.type;
                switch (modelType) {
                    case "urn":
                        result = new URNShaderComposer(this.context, materialConfiguration);
                        break;
                    case "text/javascript":
                    case "application/javascript":
                    case "text/shade-javascript":
                        result = new JSShaderComposer(this.context, materialConfiguration);
                        break;
                    default:
                        XML3D.debug.logError("Can not create shader of type:", modelType, materialConfiguration.model)
                }

            } catch (e) {
                XML3D.debug.logError("No shader could be created for '" + materialConfiguration.name + "':", e.message);
                result = this.defaultComposer;
            }
            if (result) {
                this.composers[materialConfiguration.id] = result;
                this.context.getStatistics().materials++;
            }
            return result || this.defaultComposer;
        }
        return result;
    },

    getTemplateById: function (id) {
        return this.composers[id];
    },

    update: function (scene) {
        for (var i in this.composers) {
            this.composers[i].update(scene, {updateLightValues: this.lightValuesDirty});
        }
        this.lightValuesDirty = false;
    },

    setLightStructureDirty: function () {
        this.setShaderRecompile();
    },

    setShaderRecompile: function () {
        for (var i in this.composers) {
            this.composers[i].setShaderRecompile();
        }
    },

    updateSystemUniforms: function (names, scene) {
        for (var i in this.composers) {
            this.composers[i].updateSystemUniforms(names, scene);
        }
    },

    setLightValueChanged: function () {
        for (var i in this.composers) {
            this.composers[i].updateLightValues = true;
        }
    }

});

module.exports = ShaderComposerFactory;



},{"./abstractshadercomposer.js":119,"./js/jsshadercomposer.js":122,"./urn/urnshadercomposer.js":134}],125:[function(require,module,exports){
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var Targets = require("../base/rendertarget");

var LightPass = require("../render-passes/light-pass");
var PointLightPass = require("../render-passes/pointlight-pass");

/**
 * @param {GLContext} context
 * @param {GLScene} scene
 * @constructor
 */
var ShadowMapService = function (context, scene) {
    this.context = context;
    scene.on(EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, this.onLightStructureChanged.bind(this));
    scene.on(EVENT_TYPE.LIGHT_VALUE_CHANGED, this.onLightValueChanged.bind(this));
    scene.on(EVENT_TYPE.SCENE_SHAPE_CHANGED, this.onSceneShapeChanged.bind(this));

    this.shadowMapInfos = [];
    this.dirty = true;
};

XML3D.extend(ShadowMapService.prototype, {
    onLightStructureChanged: function (light, removed) {
        var shadowMapInfos = this.shadowMapInfos;
        if (removed) {
            removeLight(shadowMapInfos, light);
        } else {
            if (lightNeedsShadowMap(light)) {
                addLight(shadowMapInfos, light);
                this.requestRendering("light added");
            }
        }
    },

    onLightValueChanged: function () {
        this.requestRendering("light value changed");
    },

    onSceneShapeChanged: function () {
        this.requestRendering("scene shape changed");
    },

    requestRendering: function(/*reason*/) {
        this.dirty = true;
    },

    updateForRendering: function() {
        if(this.dirty) {
            var shadowMaps = this.shadowMapInfos;
            for (var i = 0; i < shadowMaps.length; i++) {
                shadowMaps[i].pass.renderScene();
            }
            this.dirty = false;
        }
    },

    fillGlobalParameters: function(globals) {
        var shadowUnits = mergeShadowParameters(this.shadowMapInfos);
        XML3D.extend(globals, shadowUnits);
    }

});

function lightNeedsShadowMap(light) {
    return !!light.model.getParameter("castShadow")[0];
}

function addLight(shadowMapInfos, light) {
    var context = light.scene.context;
    var passInfo = createPassInfo(light, context);
    shadowMapInfos.push(passInfo);
}


function removeLight(shadowMapInfos, light) {
    for (var i = 0; i < shadowMapInfos.length; i++) {
        if (shadowMapInfos[i].light === light) {
            shadowMapInfos.splice(index, 1);
            // TODO: Free pass and other resources, free texture slot
            return;
        }
    }
}

function createPassInfo(light, context) {
    var size = Math.max(context.canvasTarget.width, context.canvasTarget.height) * 2;
    var params = {
        width: size,
        height: size,
        colorFormat: context.gl.RGBA,
        depthFormat: context.gl.DEPTH_COMPONENT16,
        stencilFormat: null,
        depthAsRenderbuffer: true
    };

    var pass = light.model.id == "point" ? createPointLightPass(light, context, params) : createLightPass(light, context, params);
    pass.init(context);

    // Bind target in order to create texture map
    pass.output.bind();

    // TODO: Better way to fix the texture unit?
    var unitEntry = context.textureManager.getEntry(pass.output.colorTarget.handle.id);
    unitEntry.fixed = true;

    pass.output.unbind();

    return {
        light: light, pass: pass, slot: unitEntry.slot
    };
}


function createLightPass(light, context, params) {
    var lightFramebuffer = new Targets.GLRenderTarget(context, params);
    return new LightPass({context: context}, lightFramebuffer, light);
}

function createPointLightPass(light, context, params) {
    var lightFramebuffer = new Targets.GLCubeMapRenderTarget(context, params);
    return new PointLightPass({context: context}, lightFramebuffer, light);
}

function mergeShadowParameters(shadowMapInfos) {
    var result = {};
    ["spot", "point", "directional"].forEach(function(model) {
        var sameModel = shadowMapInfos.filter(function(info) { return info.light.model.id == model; });
        result[model + "LightShadowMap"] = sameModel.map(function (info) {
            return info.slot;
        });
    });
    return result;
}

module.exports = ShadowMapService;

},{"../../renderer/scene/constants.js":95,"../base/rendertarget":114,"../render-passes/light-pass":140,"../render-passes/pointlight-pass":144}],126:[function(require,module,exports){


XML3D.materials.register("default", {

	vertex: "attribute vec3 position;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec2 texcoord;\nattribute vec3 color;\n\nvarying vec3 fragWorldPosition;\nvarying vec3 fragPosition;\nvarying vec3 fragNormal;\nvarying vec3 fragTangent;\nvarying vec3 fragBitangent;\nvarying vec3 fragColor;\nvarying vec2 fragTexcoord;\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 modelViewMatrixN;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n    vec3 N;\n    vec3 T;\n    vec3 B;\n    #if HAS_NORMAL\n        fragNormal = modelViewMatrixN * normal;\n    #endif\n    #if HAS_TANGENT\n        fragTangent = modelViewMatrixN * tangent;\n        fragBitangent = modelViewMatrixN * normalize(cross(normal, tangent));\n    #endif\n\n    fragWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n    fragPosition = (viewMatrix * vec4(fragWorldPosition, 1.0)).xyz;\n    fragTexcoord = texcoord;\n    fragColor = color;\n\n    gl_Position = projectionMatrix * vec4(fragPosition, 1.0);\n}",
	fragment: "varying vec3 fragWorldPosition;\nvarying vec3 fragPosition;\nvarying vec3 fragNormal;\nvarying vec3 fragTangent;\nvarying vec3 fragBitangent;\nvarying vec3 fragColor;\nvarying vec2 fragTexcoord;\n\nuniform vec3 coords;\nuniform mat4 viewMatrix;\nuniform sampler2D ssaoMap;\n\n#if MAX_POINT_LIGHTS\n\tuniform vec3 pointLightPosition[MAX_POINT_LIGHTS];\n\tuniform vec3 pointLightIntensity[MAX_POINT_LIGHTS];\n\tuniform vec3 pointLightAttenuation[MAX_POINT_LIGHTS];\n\tuniform bool pointLightOn[MAX_POINT_LIGHTS];\n\tuniform bool pointLightCastShadow[MAX_POINT_LIGHTS];\n#endif\n\n#if MAX_SPOT_LIGHTS\n\tuniform vec3 spotLightPosition[MAX_SPOT_LIGHTS];\n\tuniform vec3 spotLightDirection[MAX_SPOT_LIGHTS];\n\tuniform vec3 spotLightIntensity[MAX_SPOT_LIGHTS];\n\tuniform vec3 spotLightAttenuation[MAX_SPOT_LIGHTS];\n\tuniform float spotLightCosFalloffAngle[MAX_SPOT_LIGHTS];\n\tuniform float spotLightCosSoftFalloffAngle[MAX_SPOT_LIGHTS];\n\tuniform float spotLightSoftness[MAX_SPOT_LIGHTS];\n\tuniform bool spotLightOn[MAX_SPOT_LIGHTS];\n\tuniform bool spotLightCastShadow[MAX_SPOT_LIGHTS];\n\t#if HAS_SPOT_LIGHT_SHADOWMAPS\n\t\tuniform mat4 spotLightMatrix[MAX_SPOT_LIGHTS];\n\t\tuniform sampler2D spotLightShadowMap[MAX_SPOT_LIGHTS];\n\t\tuniform float spotLightShadowBias[MAX_SPOT_LIGHTS];\n\t#endif\n#endif\n\n#if MAX_DIRECTIONAL_LIGHTS\n\tuniform vec3 directionalLightDirection[MAX_DIRECTIONAL_LIGHTS];\n\tuniform vec3 directionalLightIntensity[MAX_DIRECTIONAL_LIGHTS];\n\tuniform bool directionalLightOn[MAX_DIRECTIONAL_LIGHTS];\n\tuniform bool directionalLightCastShadow[MAX_DIRECTIONAL_LIGHTS];\n#endif\n\nuniform vec3 baseColor;\nuniform float subsurface;\nuniform float metallic;\nuniform float specular;\nuniform float specularTint;\nuniform float roughness;\nuniform float anisotropic;\nuniform float sheen;\nuniform float sheenTint;\nuniform float clearCoat;\nuniform float clearCoatGloss;\nuniform float clearCoatThickness;\nuniform float ambientIntensity;\nuniform float opacity;\n\nuniform sampler2D baseColorTexture;\nuniform sampler2D subsurfaceTexture;\nuniform sampler2D metallicTexture;\nuniform sampler2D specularTexture;\nuniform sampler2D specularTintTexture;\nuniform sampler2D roughnessTexture;\nuniform sampler2D anisotropicTexture;\nuniform sampler2D sheenTexture;\nuniform sampler2D sheenTintTexture;\nuniform sampler2D clearCoatTexture;\nuniform sampler2D clearCoatGlossTexture;\nuniform sampler2D clearCoatThicknessTexture;\nuniform sampler2D opacityTexture;\n\nuniform sampler2D normalMap;\n\nstruct TangentSpace {\n\tvec3 N;\n\tvec3 T;\n\tvec3 B;\n};\n\nTangentSpace getTangentSpace() {\n\tTangentSpace s;\n\t#if HAS_NORMAL\n\t\ts.N = normalize(fragNormal);\n\t#else\n\t\t#if GL_OES_standard_derivatives\n\t\t\tvec3 X = dFdx(fragPosition);\n\t\t\tvec3 Y = dFdy(fragPosition);\n\t\t\ts.N = normalize(cross(X, Y));\n\t\t#else\n\t\t\t#error Sorry, shader cannot be compiled because the 3D models does not have normals and GL_OES_standard_derivatives extension is not available on the device.\n\t\t#endif\n\t#endif\n\n\t#if HAS_TANGENT\n\t\ts.T = normalize(fragTangent);\n\t\ts.B = normalize(fragBitangent);\n\t#else\n\t\ts.T = normalize(cross(s.N, vec3(0.0, 0.999999, 0.000001)));\n\t\ts.B = normalize(cross(s.N, s.T));\n\t#endif\n\n\treturn s;\n}\n\nTangentSpace normalMapping(TangentSpace original) {\n\t#if HAS_NORMAL_MAP && HAS_TEXCOORD\n\t\tTangentSpace perturbed;\n\t\tvec3 sample = texture2D(normalMap, fragTexcoord).rgb;\n\t\tvec3 nN = normalize((sample - 0.5) * 2.0);\n\t\tperturbed.N = normalize(original.N * nN.z + original.T * nN.y + original.B * nN.x);\n\t\tperturbed.T = normalize(original.T - perturbed.N * dot(perturbed.N, original.T));\n\t\tperturbed.B = normalize(cross(perturbed.N, perturbed.T));\n\t\treturn perturbed;\n\t#else\n\t\treturn original;\n\t#endif\n}\n\nvec3 linearize(const vec3 color) {\n\treturn pow(color, vec3(2.2));\n}\n\nvec3 getBaseColor() {\n\tvec3 color;\n\t#if HAS_BASE_COLOR_TEXTURE && HAS_TEXCOORD\n\t\tcolor = linearize(texture2D(baseColorTexture, fragTexcoord).rgb);\n\t#else\n\t\t#if HAS_COLOR\n\t\t\t// We assume that vertex colors are already linearized\n\t\t\tcolor = fragColor;\n\t\t#else\n\t\t\tcolor = linearize(baseColor);\n\t\t#endif\n\t#endif\n\n\treturn color;\n}\n\nfloat getSubsurface() {\n\t#if HAS_SUBSURFACE_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(subsurfaceTexture, fragTexcoord).r;\n\t#else\n\t\treturn subsurface;\n\t#endif\n}\n\nfloat getMetallic() {\n\t#if HAS_METALLIC_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(metallicTexture, fragTexcoord).r;\n\t#else\n\t\treturn metallic;\n\t#endif\n}\n\nfloat getSpecular() {\n\t#if HAS_SPECULAR_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(specularTexture, fragTexcoord).r;\n\t#else\n\t\treturn specular;\n\t#endif\n}\n\nfloat getSpecularTint() {\n\t#if HAS_SPECULARTINT_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(specularTintTexture, fragTexcoord).r;\n\t#else\n\t\treturn specularTint;\n\t#endif\n}\n\nfloat getRoughness() {\n\t#if HAS_ROUGHNESS_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(roughnessTexture, fragTexcoord).r;\n\t#else\n\t\treturn roughness;\n\t#endif\n}\n\nfloat getAnisotropic() {\n\t#if HAS_ANISOTROPIC_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(anisotropicTexture, fragTexcoord).r;\n\t#else\n\t\treturn anisotropic;\n\t#endif\n}\n\nfloat getSheen() {\n\t#if HAS_SHEEN_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(sheenTexture, fragTexcoord).r;\n\t#else\n\t\treturn sheen;\n\t#endif\n}\n\nfloat getSheenTint() {\n\t#if HAS_SHEENTINT_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(sheenTintTexture, fragTexcoord).r;\n\t#else\n\t\treturn sheenTint;\n\t#endif\n}\n\nfloat getClearCoat() {\n\t#if HAS_CLEARCOAT_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(clearCoatTexture, fragTexcoord).r;\n\t#else\n\t\treturn clearCoat;\n\t#endif\n}\n\nfloat getClearCoatGloss() {\n\t#if HAS_CLEARCOATGLOSS_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(clearCoatGlossTexture, fragTexcoord).r;\n\t#else\n\t\treturn clearCoatGloss;\n\t#endif\n}\n\nfloat getClearCoatThickness() {\n\t#if HAS_CLEARCOATTHICKNESS_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(clearCoatThicknessTexture, fragTexcoord).r;\n\t#else\n\t\treturn clearCoatThickness;\n\t#endif\n}\n\nfloat getOpacity() {\n\t#if HAS_OPACITY_TEXTURE && HAS_TEXCOORD\n\t\treturn texture2D(opacityTexture, fragTexcoord).r;\n\t#else\n\t\treturn opacity;\n\t#endif\n}\n\nfloat getSSOA() {\n\t#if HAS_SSAO_MAP\n\t\treturn 1.0 - texture2D(ssaoMap, gl_FragCoord.xy / coords.xy).r;\n\t#else\n\t\treturn 1.0;\n\t#endif\n}\n\nstruct SurfaceParameters {\n\tfloat subsurface;\n\tfloat metallic;\n\tfloat specular;\n\tfloat specularTint;\n\tfloat roughness;\n\tfloat anisotropic;\n\tfloat sheen;\n\tfloat sheenTint;\n\tfloat clearCoat;\n\tfloat clearCoatGloss;\n\tfloat clearCoatThickness;\n\tfloat opacity;\n\tfloat ssao;\n};\n\nSurfaceParameters getSurfaceParameters() {\n\treturn SurfaceParameters(\n\t\tgetSubsurface(),\n\t\tgetMetallic(),\n\t\tgetSpecular(),\n\t\tgetSpecularTint(),\n\t\tgetRoughness(),\n\t\tgetAnisotropic(),\n\t\tgetSheen(),\n\t\tgetSheenTint(),\n\t\tgetClearCoat(),\n\t\tgetClearCoatGloss(),\n\t\tgetClearCoatThickness(),\n\t\tgetOpacity(),\n\t\tgetSSOA()\n\t);\n}\n\nfloat luminance(const vec3 color) {\n\treturn dot(vec3(0.3, 0.6, 0.1), color);\n}\n\nstruct SurfaceColors {\n\tvec3 base;\n\tvec3 specular;\n\tvec3 sheen;\n};\n\nSurfaceColors getSurfaceColors(SurfaceParameters parameters) {\n\tvec3 linearBaseColor = getBaseColor();\n\tfloat luminance = luminance(linearBaseColor);\n\tvec3 tint = luminance > 0.0 ? linearBaseColor / luminance : vec3(1.0);\n\tvec3 specularColor = mix(parameters.specular * 0.8 * mix(vec3(1.0), tint, parameters.specularTint), linearBaseColor, parameters.metallic);\n\tvec3 sheenColor = mix(vec3(1.0), tint, parameters.sheenTint);\n\treturn SurfaceColors(linearBaseColor, specularColor, sheenColor);\n}\n\nfloat square(const float x) {\n\treturn x * x;\n}\n\nfloat smith(const float NdotV, const float sqrNdotV, const float sqrRoughness) {\n\treturn 1.0 / (NdotV + sqrt(sqrNdotV + sqrRoughness - sqrNdotV * sqrRoughness));\n}\n\nvec3 lightContribution(TangentSpace original, TangentSpace perturbed, vec3 L, vec3 V, SurfaceColors colors, SurfaceParameters parameters) {\n\tfloat NdotL = dot(perturbed.N, L);\n\tfloat NdotV = dot(perturbed.N, V);\n\n\tif (NdotL < 0.0)\n\t\treturn vec3(0.0);\n\n\tvec3 H = normalize(L + V);\n\tfloat HdotT = dot(H, perturbed.T);\n\tfloat HdotB = dot(H, perturbed.B);\n\tfloat NdotH = dot(perturbed.N, H);\n\tfloat LdotH = dot(L, H);\n\n\tfloat sqrNdotL = square(NdotL);\n\tfloat sqrNdotV = square(NdotV);\n\tfloat sqrRoughness = square(parameters.roughness);\n\tfloat sqrNdotH = square(NdotH);\n\n\tfloat NdotLschlick = pow(clamp(1.0 - NdotL, 0.0, 1.0), 5.0);\n\tfloat NdotVschlick = pow(clamp(1.0 - NdotV, 0.0, 1.0), 5.0);\n\tfloat LdotHschlick = pow(clamp(1.0 - LdotH, 0.0, 1.0), 5.0);\n\n\t// diffuse\n\tfloat fd90 = 0.5 + 2.0 * LdotH * LdotH * parameters.roughness;\n\tfloat diffuseContribution = mix(1.0, fd90, NdotLschlick) * mix(1.0, fd90, NdotVschlick) * parameters.ssao;\n\t// subsurface\n\tfloat fss90 = parameters.roughness * LdotH * LdotH;\n\tfloat fss = mix(1.0, fss90, NdotLschlick) * mix(1.0, fss90, NdotVschlick);\n\tfloat subsurfaceContribution = 1.25 * (fss * (1.0 / (NdotL + NdotV) - 0.5) + 0.5);\n\tvec3 diffuseColor = 1.0 / PI * mix(diffuseContribution, subsurfaceContribution, parameters.subsurface) * colors.base + LdotHschlick * parameters.sheen * colors.sheen;\n\n\t// specular\n\tfloat aspect = sqrt(1.0 - parameters.anisotropic * 0.9);\n\tfloat ax = max(0.001, sqrRoughness / aspect);\n\tfloat ay = max(0.001, sqrRoughness * aspect);\n\tfloat sqrRoughnessGeometric = square(parameters.roughness * 0.5 + 0.5);\n\tfloat Dspecular = 1.0 / (PI * ax * ay * square(square(HdotT / ax) + square(HdotB / ay) + sqrNdotH));\n\tfloat Gspecular = smith(NdotL, sqrNdotL, sqrRoughnessGeometric) * smith(NdotV, sqrNdotV, sqrRoughnessGeometric);\n\tvec3 specularColor = Dspecular * Gspecular * mix(colors.specular, vec3(1), LdotHschlick);\n\n\tvec3 surfaceReflectionColor = (diffuseColor * (1.0 - parameters.metallic) + specularColor) * NdotL;\n\n\t// clear coat\n\tvec3 clearCoatN = normalize(mix(perturbed.N, original.N, parameters.clearCoatThickness));\n\tfloat clearCoatNdotV = dot(clearCoatN, V);\n\tfloat clearCoatNdotL = dot(clearCoatN, L);\n\tfloat clearCoatNdotH = dot(clearCoatN, H);\n\n\tfloat clearCoatSqrNdotV = square(clearCoatNdotV);\n\tfloat clearCoatSqrNdotL = square(clearCoatNdotL);\n\tfloat clearCoatSqrNdotH = square(clearCoatNdotH);\n\n\tfloat clearCoatRoughness = mix(0.1, 0.001, parameters.clearCoatGloss);\n\tfloat clearCoatSqrRoughness = square(clearCoatRoughness);\n\tfloat DclearCoat = clearCoatRoughness >= 1.0 ? 1.0 / PI : (clearCoatSqrRoughness - 1.0) / (PI * log(clearCoatSqrRoughness) * (1.0 + (clearCoatSqrRoughness - 1.0) * clearCoatSqrNdotH));\n\tfloat FclearCoat = mix(0.04, 1.0, LdotHschlick);\n\tfloat GclearCoat = smith(clearCoatNdotL, clearCoatSqrNdotL, 0.25) * smith(clearCoatNdotV, clearCoatSqrNdotV, 0.25);\n\tfloat clearCoatReflection = 0.25 * parameters.clearCoat * GclearCoat * FclearCoat * DclearCoat * clearCoatNdotL;\n\n\treturn max(vec3(0.0), (surfaceReflectionColor + clearCoatReflection));\n}\n\nfloat attenuation(const vec3 L, const vec3 attenuation) {\n\tfloat dist = length(L);\n\treturn 1.0 / (attenuation.x + attenuation.y * dist + attenuation.z * dist * dist);\n}\n\nfloat unpackDepth(const vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n\nvoid main() {\n\tTangentSpace originalTangentSpace = getTangentSpace();\n\tTangentSpace perturbedTangentSpace = normalMapping(originalTangentSpace);\n\tSurfaceParameters parameters = getSurfaceParameters();\n\tSurfaceColors colors = getSurfaceColors(parameters);\n\tvec3 V = -normalize(fragPosition);\n\n\tvec3 finalColor;\n\t#if MAX_POINT_LIGHTS > 0\n\t\tfor (int idx = 0; idx < MAX_POINT_LIGHTS; ++idx) {\n\t\t\tif (pointLightOn[idx]) {\n\t\t\t\tvec4 lightPosition = viewMatrix * vec4(pointLightPosition[idx], 1.0);\n\t\t\t\tvec3 L = lightPosition.xyz - fragPosition;\n\t\t\t\tfloat attenuation = attenuation(L, pointLightAttenuation[idx]);\n\t\t\t\tL = normalize(L);\n\t\t\t\tfinalColor += lightContribution(originalTangentSpace, perturbedTangentSpace, L, V, colors, parameters) * pointLightIntensity[idx] * attenuation;\n\t\t\t}\n\t\t}\n\t#endif\n\n\t#if MAX_SPOT_LIGHTS > 0\n\t\tfor (int idx = 0; idx < MAX_SPOT_LIGHTS; ++idx) {\n\t\t\tif (spotLightOn[idx]) {\n\t\t\t\tfloat shadowInfluence = 1.0;\n\t\t\t\t#if HAS_SPOT_LIGHT_SHADOWMAPS\n\t\t\t\t\tshadowInfluence = 0.0;\n\t\t\t\t\tvec4 lspos = spotLightMatrix[idx] * vec4(fragWorldPosition, 1.0);\n\t\t\t\t\tvec3 perspectiveDivPos = lspos.xyz / lspos.w * 0.5 + 0.5;\n\t\t\t\t\tfloat lsDepth = perspectiveDivPos.z;\n\t\t\t\t\tvec2 lightuv = perspectiveDivPos.xy;\n\t\t\t\t\tfloat depth = unpackDepth(texture2D(spotLightShadowMap[idx], lightuv)) + spotLightShadowBias[idx];\n\t\t\t\t\tif(lsDepth < depth)\n\t\t\t\t\t\tshadowInfluence = 1.0;\n\t\t\t\t#endif\n\t\t\t\tif (shadowInfluence > 0.0) {\n\t\t\t\t\tvec4 lightPosition = viewMatrix * vec4(spotLightPosition[idx], 1.0);\n\t\t\t\t\tvec3 L = lightPosition.xyz - fragPosition;\n\t\t\t\t\tfloat attenuation = attenuation(L, spotLightAttenuation[idx]);\n\t\t\t\t\tL = normalize(L);\n\t\t\t\t\tvec3 D = normalize((viewMatrix * vec4(-spotLightDirection[idx], 0.0)).xyz);\n\t\t\t\t\tfloat angle = dot(L, D);\n\t\t\t\t\tif (angle > spotLightCosFalloffAngle[idx]) {\n\t\t\t\t\t\tfloat softness = 1.0;\n\t\t\t\t\t\tif (angle < spotLightCosSoftFalloffAngle[idx])\n\t\t\t\t\t\t\tsoftness = (angle - spotLightCosFalloffAngle[idx]) / (spotLightCosSoftFalloffAngle[idx] - spotLightCosFalloffAngle[idx]);\n\t\t\t\t\t\tfinalColor += lightContribution(originalTangentSpace, perturbedTangentSpace, L, V, colors, parameters) * spotLightIntensity[idx] * attenuation * softness * shadowInfluence;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t#endif\n\n\t#if MAX_DIRECTIONAL_LIGHTS > 0\n\t\tfor (int idx = 0; idx < MAX_DIRECTIONAL_LIGHTS; ++idx) {\n\t\t\tif (directionalLightOn[idx]) {\n\t\t\t\tvec3 L = normalize((viewMatrix * vec4(-directionalLightDirection[idx], 0.0)).xyz);\n\t\t\t\tfinalColor += lightContribution(originalTangentSpace, perturbedTangentSpace, L, V, colors, parameters) * directionalLightIntensity[idx];\n\t\t\t}\n\t\t}\n\t#endif\n\n\tfinalColor += colors.base * ambientIntensity * parameters.ssao;\n\n\tgl_FragColor = vec4(pow(finalColor, vec3(1.0 / 2.2)), parameters.opacity);\n}\n",

	addDirectives: function(directives, lights, params) {
		directives.push("#extension GL_OES_standard_derivatives : enable");
		directives.push("PI " + Math.PI);

		directives.push("HAS_NORMAL " + ("normal" in params ? "1" : "0"));
		directives.push("HAS_TANGENT " + ("tangent" in params ? "1" : "0"));
		directives.push("HAS_TEXCOORD " + ("texcoord" in params ? "1" : "0"));
		directives.push("HAS_COLOR " + ("color" in params ? "1" : "0"));

		["point", "directional", "spot"].forEach(function (type) {
			var numLights = lights.getModelCount(type);
			var castShadows = false;
			if(numLights) {
				castShadows = Array.prototype.some.call(lights.getModelEntry(type).parameters["castShadow"], function (value) {
					return value;
				});
			}
			directives.push("MAX_" + type.toUpperCase() + "_LIGHTS " + numLights);
			directives.push("HAS_" + type.toUpperCase() + "_LIGHT_SHADOWMAPS " + (castShadows ? 1 : 0));
		});

		directives.push("HAS_SSAO_MAP " + (XML3D.options.getValue("renderer-ssao") ? "1" : "0"));

		directives.push("HAS_BASE_COLOR_TEXTURE " + ("baseColorTexture" in params ? "1" : "0"));
		directives.push("HAS_SUBSURFACE_TEXTURE " + ("subsurfaceTexture" in params ? "1" : "0"));
		directives.push("HAS_METALLIC_TEXTURE " + ("metallicTexture" in params ? "1" : "0"));
		directives.push("HAS_SPECULAR_TEXTURE " + ("specularTexture" in params ? "1" : "0"));
		directives.push("HAS_SPECULARTINT_TEXTURE " + ("specularTintTexture" in params ? "1" : "0"));
		directives.push("HAS_ROUGHNESS_TEXTURE " + ("roughnessTexture" in params ? "1" : "0"));
		directives.push("HAS_ANISOTROPIC_TEXTURE " + ("anisotropicTexture" in params ? "1" : "0"));
		directives.push("HAS_SHEEN_TEXTURE " + ("sheenTexture" in params ? "1" : "0"));
		directives.push("HAS_SHEENTINT_TEXTURE " + ("sheenTintTexture" in params ? "1" : "0"));
		directives.push("HAS_CLEARCOAT_TEXTURE " + ("clearCoatTexture" in params ? "1" : "0"));
		directives.push("HAS_CLEARCOATGLOSS_TEXTURE " + ("clearCoatGlossTexture" in params ? "1" : "0"));
		directives.push("HAS_CLEARCOATTHICKNESS_TEXTURE " + ("clearCoatThicknessTexture" in params ? "1" : "0"));
		directives.push("HAS_OPACITY_TEXTURE " + ("opacityTexture" in params ? "1" : "0"));

		directives.push("HAS_NORMAL_MAP " + ("normalMap" in params ? "1" : "0"));
	},

	hasTransparency: function(params) {
		return (params.opacity && params.opacity.getValue()[0] < 1) || ("opacityTexture" in params);
	},

	uniforms: {
		baseColor: [1.0, 1.0, 1.0],
		subsurface: 0,
		metallic: 0,
		specular: 0.5,
		specularTint: 0,
		roughness: 0.5,
		anisotropic: 0.0,
		sheen: 0,
		sheenTint: 0.5,
		clearCoat: 0,
		clearCoatGloss: 1,
		clearCoatThickness: 1,
		opacity: 1.0,
		ambientIntensity: 0.0
	},
	samplers: {
		baseColorTexture: null,
		subsurfaceTexture: null,
		metallicTexture: null,
		specularTexture: null,
		specularTintTexture: null,
		roughnessTexture: null,
		anisotropicTexture: null,
		sheenTexture: null,
		sheenTintTexture: null,
		clearCoatTexture: null,
		clearCoatGlossTexture: null,
		clearCoatThicknessTexture: null,
		opacityTexture: null,
		normalMap: null
	},
	attributes: {
		normal: null,
		tangent: null,
		texcoord: null,
		color: null
	}
});

},{}],127:[function(require,module,exports){
XML3D.materials.register("diffuse", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",

        "void main(void) {",
        "    vec3 pos = position;",
        "    vec3 norm = normal;",

        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragNormal = normalize(modelViewMatrixN * norm);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "}"
    ].join("\n"),

    fragment : [
        "uniform float ambientIntensity;",
        "uniform vec3 diffuseColor;",
        "uniform vec3 emissiveColor;",
        "uniform float transparency;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",

        "#if HAS_EMISSIVETEXTURE",
        "uniform sampler2D emissiveTexture;",
        "#endif",
        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if MAX_POINTLIGHTS > 0",
        "uniform vec3 pointLightAttenuation[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightPosition[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightIntensity[MAX_POINTLIGHTS];",
        "uniform bool pointLightOn[MAX_POINTLIGHTS];",
        "#endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "uniform vec3 directionalLightDirection[MAX_DIRECTIONALLIGHTS];",
        "uniform vec3 directionalLightIntensity[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightOn[MAX_DIRECTIONALLIGHTS];",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "uniform vec3 spotLightAttenuation[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightPosition[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightIntensity[MAX_SPOTLIGHTS];",
        "uniform bool spotLightOn[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightDirection[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosFalloffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosSoftFalloffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightSoftness[MAX_SPOTLIGHTS];",
        "#endif",

        "void main(void) {",
        "  float alpha =  max(0.0, 1.0 - transparency);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec4 texDiffuse = texture2D(diffuseTexture, fragTexCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",

        "  #if HAS_EMISSIVETEXTURE",
        "    vec3 color = emissiveColor * texture2D(emissiveTexture, fragTexCoord).rgb + (ambientIntensity * objDiffuse);",
        "  #else",
        "    vec3 color = emissiveColor + (ambientIntensity * objDiffuse);",
        "  #endif",

        "  #if MAX_POINTLIGHTS > 0",
        "    for (int i=0; i<MAX_POINTLIGHTS; i++) {",
        "      if (!pointLightOn[i])",
        "         continue;",
        "      vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "      vec3 L = lPosition.xyz - fragVertexPosition;",
        "      float dist = length(L);",
        "      L = normalize(L);",
        "      float atten = 1.0 / (pointLightAttenuation[i].x + pointLightAttenuation[i].y * dist + pointLightAttenuation[i].z * dist * dist);",
        "      vec3 Idiff = pointLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "      color = color + atten*Idiff;",
        "    }",
        "  #endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "  for (int i=0; i<MAX_DIRECTIONALLIGHTS; i++) {",
        "      if (!directionalLightOn[i])",
        "         continue;",
        "    vec4 lDirection = viewMatrix * vec4(directionalLightDirection[i], 0.0);",
        "    vec3 L =  normalize(-lDirection.xyz);",
        "    vec3 Idiff = directionalLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "    color = color + Idiff;",
        "  }",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "  for (int i=0; i<MAX_SPOTLIGHTS; i++) {",
        "      if (!spotLightOn[i])",
        "         continue;",
        "    vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "    vec3 L = lPosition.xyz - fragVertexPosition;",
        "    float dist = length(L);",
        "    L = normalize(L);",
        "    float atten = 1.0 / (spotLightAttenuation[i].x + spotLightAttenuation[i].y * dist + spotLightAttenuation[i].z * dist * dist);",
        "    vec3 Idiff = spotLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "    vec4 lDirection = viewMatrix * vec4(-spotLightDirection[i], 0.0);",
        "    vec3 D = normalize(lDirection.xyz);",
        "    float angle = dot(L, D);",
        "    if(angle > spotLightCosFalloffAngle[i]) {",
        "       float softness = 1.0;",
        "       if (angle < spotLightCosSoftFalloffAngle[i])",
        "           softness = (angle - spotLightCosFalloffAngle[i]) /  (spotLightCosSoftFalloffAngle[i] -  spotLightCosFalloffAngle[i]);",
        "       color += atten * softness * Idiff;",
        "    }",
        "  }",
        "#endif",

        "  gl_FragColor = vec4(color, alpha);",
        "}"
    ].join("\n"),

    addDirectives: function(directives, lights, params) {
        ["point", "directional", "spot"].forEach(function (type) {
            var numLights = lights.getModelCount(type);
            directives.push("MAX_" + type.toUpperCase() + "LIGHTS " + numLights);
        });
        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
        directives.push("HAS_EMISSIVETEXTURE " + ('emissiveTexture' in params ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.transparency && params.transparency.getValue()[0] > 0.001;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        emissiveColor   : [0.0, 0.0, 0.0],
        transparency    : 0.0,
        ambientIntensity: 0.0,
        useVertexColor : false
    },
    samplers: {
        diffuseTexture : null,
        emissiveTexture : null
    },
    attributes: {
        normal : {
            required: true
        },
        texcoord: null,
        color: null
    }
});

},{}],128:[function(require,module,exports){
XML3D.materials.register("matte", {

    vertex: [
        "attribute vec3 position;",
        "attribute vec3 color;",

        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "   fragVertexColor = color;",
        "   gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "uniform vec3 diffuseColor;",
        "uniform bool useVertexColor;",

        "varying vec3 fragVertexColor;",

        "void main(void) {",
        "    vec3 color = diffuseColor;",
        "    if (useVertexColor)",
        "       color *=  fragVertexColor;",
        "    gl_FragColor = vec4(color, 1.0);",
        "}"
    ].join("\n"),

    uniforms: {
        diffuseColor : [1.0, 1.0, 1.0],
        useVertexColor: false
    },
    attributes: {
        color: null,
        normal: null // For picking
    }
});

XML3D.materials.register("flat", XML3D.materials.getScript("matte"));

},{}],129:[function(require,module,exports){
XML3D.materials.register("phong", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "varying vec3 fragWorldPosition;", //needed by any of the light types
        "#endif",

        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",

        "void main(void) {",
        "    vec3 pos = position;",
        "    vec3 norm = normal;",
        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragNormal = normalize(modelViewMatrixN * norm);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "    fragWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;",
        "#endif",
        "}"
    ].join("\n"),

    fragment : [
        "uniform float ambientIntensity;",
        "uniform vec3 diffuseColor;",
        "uniform vec3 emissiveColor;",
        "uniform float shininess;",
        "uniform vec3 specularColor;",
        "uniform float transparency;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",
		"uniform vec3 coords;",

        "#if HAS_EMISSIVETEXTURE",
        "uniform sampler2D emissiveTexture;",
        "#endif",
        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",
        "#if HAS_SPECULARTEXTURE",
        "uniform sampler2D specularTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "#if (HAS_POINTLIGHT_SHADOWMAPS || HAS_DIRECTIONALLIGHT_SHADOWMAPS || HAS_SPOTLIGHT_SHADOWMAPS)",
        "varying vec3 fragWorldPosition;",  //if there is Shadow we need world position and unpacking function
        "float unpackDepth( const in vec4 rgba_depth ) {",
        "  const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
        "  float depth = dot( rgba_depth, bit_shift );",
        "  return depth;",
        "}",
        "#endif",

        "#if MAX_POINTLIGHTS > 0",
        "uniform vec3 pointLightAttenuation[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightPosition[MAX_POINTLIGHTS];",
        "uniform vec3 pointLightIntensity[MAX_POINTLIGHTS];",
        "uniform bool pointLightOn[MAX_POINTLIGHTS];",
        "uniform bool pointLightCastShadow[MAX_POINTLIGHTS];",
            "#if HAS_POINTLIGHT_SHADOWMAPS",
            "uniform samplerCube pointLightShadowMap[MAX_POINTLIGHTS];",
            "uniform float pointLightShadowBias[MAX_POINTLIGHTS];",
            "uniform vec2 pointLightNearFar[MAX_POINTLIGHTS];",
            "float vecToDepth(vec3 vec, float n, float f){",
                "vec3 absVec = abs(vec);" +
                "float maxComp = max(absVec.x, max(absVec.y, absVec.z));",
                "float res = (f+n)/(f-n)-(2.0*f*n)/(f-n)/maxComp;",
                "return res*0.5+0.5;",
            "}",
            "#endif",
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "uniform vec3 spotLightAttenuation[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightPosition[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightIntensity[MAX_SPOTLIGHTS];",
        "uniform bool spotLightOn[MAX_SPOTLIGHTS];",
        "uniform vec3 spotLightDirection[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosFalloffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightCosSoftFalloffAngle[MAX_SPOTLIGHTS];",
        "uniform float spotLightSoftness[MAX_SPOTLIGHTS];",
        "uniform bool spotLightCastShadow[MAX_SPOTLIGHTS];",
            "#if HAS_SPOTLIGHT_SHADOWMAPS",
            "uniform mat4 spotLightMatrix[ MAX_SPOTLIGHTS ];",//used for shadowmapcoord calculation
            "uniform sampler2D spotLightShadowMap[MAX_SPOTLIGHTS];",
            "uniform float spotLightShadowBias[MAX_SPOTLIGHTS];",
            "#endif",
        "#endif",


        "#if MAX_DIRECTIONALLIGHTS > 0",
        "uniform vec3 directionalLightDirection[MAX_DIRECTIONALLIGHTS];",
        "uniform vec3 directionalLightIntensity[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightOn[MAX_DIRECTIONALLIGHTS];",
        "uniform bool directionalLightCastShadow[MAX_DIRECTIONALLIGHTS];",
            "#if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
            "uniform mat4 directionalLightMatrix[MAX_DIRECTIONALLIGHTS];",
            "uniform sampler2D directionalLightShadowMap[MAX_DIRECTIONALLIGHTS];",
            "uniform float directionalLightShadowBias[MAX_DIRECTIONALLIGHTS];",
            "#endif",
        "#endif",


		"uniform sampler2D ssaoMap;",

        "void main(void) {",
        //calculate shadowmap coords (vector for pointlight)
        "#if MAX_POINTLIGHTS > 0 && HAS_POINTLIGHT_SHADOWMAPS",
        "    vec3 pointLightShadowMapDirection[MAX_POINTLIGHTS];",
        "    for(int i = 0; i < MAX_POINTLIGHTS; i++) {",
        "       pointLightShadowMapDirection[i] = fragWorldPosition - pointLightPosition[i];",
        "    }",
        "#endif",
        "#if MAX_SPOTLIGHTS > 0 && HAS_SPOTLIGHT_SHADOWMAPS",
        "    vec4 spotLightShadowMapCoord[MAX_SPOTLIGHTS];",
        "    for(int i = 0; i < MAX_SPOTLIGHTS; i++) {",
        "      spotLightShadowMapCoord[i] = spotLightMatrix[i] * vec4(fragWorldPosition, 1.0);",
        "    }",
        "#endif",
        "#if MAX_DIRECTIONALLIGHTS > 0 && HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "    vec4 directionalLightShadowMapCoord[MAX_DIRECTIONALLIGHTS];",
        "    for(int i = 0; i < MAX_DIRECTIONALLIGHTS; i++) {",
        "      directionalLightShadowMapCoord[i] = directionalLightMatrix[i] * vec4(fragWorldPosition, 1.0);",
        "    }",
        "#endif",

        "  float alpha =  max(0.0, 1.0 - transparency);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec4 texDiffuse = texture2D(diffuseTexture, fragTexCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",
        "  #if HAS_EMISSIVETEXTURE",
        "    vec3 color = emissiveColor * texture2D(emissiveTexture, fragTexCoord).rgb + (ambientIntensity * objDiffuse);",
        "  #else",
        "    vec3 color = emissiveColor + (ambientIntensity * objDiffuse);",
        "  #endif",
        "  vec3 objSpecular = specularColor;",
        "  #if HAS_SPECULARTEXTURE",
        "    objSpecular = objSpecular * texture2D(specularTexture, fragTexCoord).rgb;",
        "  #endif",
		"  #if HAS_SSAOMAP",
		"	 float ssao = 1.0 - texture2D(ssaoMap, gl_FragCoord.xy / coords.xy).r;",
        "  #endif",

        "  float shadowInfluence = 0.0;", //used for sampling shadow

		"#if MAX_POINTLIGHTS > 0",
        "  for (int i = 0; i < MAX_POINTLIGHTS; i++) {",
        "    shadowInfluence = 1.0;",
        "    if(pointLightOn[i]){",
        "   #if HAS_POINTLIGHT_SHADOWMAPS",
        "       if(pointLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           float lsDepth = vecToDepth(pointLightShadowMapDirection[i], pointLightNearFar[i].x, pointLightNearFar[i].y );",
        "		    float depth = unpackDepth( textureCube(pointLightShadowMap[i], pointLightShadowMapDirection[i])) +  pointLightShadowBias[i];",
        "           if(lsDepth < depth)",
        "               shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "   #endif",
        "       vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
        "       vec3 L = lPosition.xyz - fragVertexPosition;",
        "       float dist = length(L);",
        "       L = normalize(L);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       float atten = 1.0 / (pointLightAttenuation[i].x + pointLightAttenuation[i].y * dist + pointLightAttenuation[i].z * dist * dist);",
        "       vec3 Idiff = pointLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
		"   #if HAS_SSAOMAP",
		"       Idiff *= ssao;",
		"   #endif",
        "       vec3 Ispec = pointLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       color = color + (atten*shadowInfluence*(Idiff + Ispec));",
        "   #if HAS_POINTLIGHT_SHADOWMAPS",
        "       }",  //pointlight visible
        "   #endif",
        "     }", //pointLight on
        "  }", //pointLight loop
        "#endif",

        "#if MAX_SPOTLIGHTS > 0",
        "  for (int i=0; i<MAX_SPOTLIGHTS; i++) {",
        "    shadowInfluence = 1.0;",
        "    if(spotLightOn[i]) {",
        "  #if HAS_SPOTLIGHT_SHADOWMAPS",
        "       if(spotLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           vec4 lspos = spotLightShadowMapCoord[i];",
        "			vec3 perspectiveDivPos = lspos.xyz / lspos.w * 0.5 + 0.5;",
        "			float lsDepth = perspectiveDivPos.z;",
        "			vec2 lightuv = perspectiveDivPos.xy;",
        "			float depth = unpackDepth(texture2D(spotLightShadowMap[i], lightuv)) + spotLightShadowBias[i];",
        "           if(lsDepth < depth)",
        "               shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "  #endif",
        "       vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
        "       vec3 L = lPosition.xyz - fragVertexPosition;",
        "       float dist = length(L);",
        "       L = normalize(L);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       float atten = 1.0 / (spotLightAttenuation[i].x + spotLightAttenuation[i].y * dist + spotLightAttenuation[i].z * dist * dist);",
        "       vec3 Idiff = spotLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
        "   #if HAS_SSAOMAP",
        "	    Idiff *= ssao;",
        "   #endif",
        "       vec3 Ispec = spotLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       vec4 lDirection = viewMatrix * vec4(-spotLightDirection[i], 0.0);",
        "       vec3 D = normalize(lDirection.xyz);",
        "       float angle = dot(L, D);",
        "       if(angle > spotLightCosFalloffAngle[i]) {",
        "           float softness = 1.0;",
        "           if (angle < spotLightCosSoftFalloffAngle[i])",
        "               softness = (angle - spotLightCosFalloffAngle[i]) /  (spotLightCosSoftFalloffAngle[i] -  spotLightCosFalloffAngle[i]);",
        "           color += atten*softness*shadowInfluence*(Idiff + Ispec);",
        "       }",
        "   #if HAS_SPOTLIGHT_SHADOWMAPS",
        "       }", //light visible if shadow enabled
        "   #endif",
        "   } ", // spotlight on
        "  }", // light loop
        "#endif",

        "#if MAX_DIRECTIONALLIGHTS > 0",
        "  for (int i=0; i<MAX_DIRECTIONALLIGHTS; i++) {",
        "   shadowInfluence = 1.0;",
        "   if(directionalLightOn[i]){",
        "   #if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "       if(directionalLightCastShadow[i]){",
        "           shadowInfluence = 0.0;",
        "           vec4 lspos = directionalLightShadowMapCoord[i];",
        "           vec3 orthogonalDivPos = lspos.xyz / lspos.w *0.5 + 0.5;",
        "           float lsDepth = orthogonalDivPos.z;",
        "           vec2 lightuv = orthogonalDivPos.xy;",
        "               float depth = unpackDepth(texture2D(directionalLightShadowMap[i], lightuv))+directionalLightShadowBias[i];",
        "               if(lsDepth < depth) shadowInfluence = 1.0;",
        "       }",
        "       if(shadowInfluence > 0.0){",
        "   #endif",
        "       vec4 lDirection = viewMatrix * vec4(directionalLightDirection[i], 0.0);",
        "       vec3 L =  normalize(-lDirection.xyz);",
        "       vec3 R = normalize(reflect(L,fragNormal));",
        "       vec3 Idiff = directionalLightIntensity[i] * objDiffuse * max(dot(fragNormal,L),0.0);",
		"   #if HAS_SSAOMAP",
		"       Idiff *= ssao;",
		"   #endif",
        "       vec3 Ispec = directionalLightIntensity[i] * objSpecular * pow(max(dot(R,fragEyeVector),0.0), shininess*128.0);",
        "       color = color + shadowInfluence*((Idiff + Ispec));",
        "   #if HAS_DIRECTIONALLIGHT_SHADOWMAPS",
        "       }", //light visible
        "   #endif",
        "   }", //dirLight on
        "  }", // dirLight loop
        "#endif",
        "  gl_FragColor = vec4(color, alpha);",
        "}"
    ].join("\n"),

    addDirectives: function (directives, lights, params) {
        ["point", "directional", "spot"].forEach(function (type) {
            var numLights = lights.getModelCount(type);
            var castShadows = false;
            if(numLights) {
                castShadows = Array.prototype.some.call(lights.getModelEntry(type).parameters["castShadow"], function (value) {
                    return value;
                });
            }
            directives.push("MAX_" + type.toUpperCase() + "LIGHTS " + numLights);
            directives.push("HAS_" + type.toUpperCase() + "LIGHT_SHADOWMAPS " + (castShadows ? 1 : 0));
        });

        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
        directives.push("HAS_SPECULARTEXTURE " + ('specularTexture' in params ? "1" : "0"));
        directives.push("HAS_EMISSIVETEXTURE " + ('emissiveTexture' in params ? "1" : "0"));
        directives.push("HAS_SSAOMAP " + (XML3D.options.getValue("renderer-ssao") ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.transparency && params.transparency.getValue()[0] > 0.001;
    },
    uniforms: {
        diffuseColor    : [1.0, 1.0, 1.0],
        emissiveColor   : [0.0, 0.0, 0.0],
        specularColor   : [0.0, 0.0, 0.0],
        transparency    : 0.0,
        shininess       : 0.2,
        ambientIntensity: 0.0,
        useVertexColor : false
    },

    samplers: {
        diffuseTexture : null,
        emissiveTexture : null,
        specularTexture : null,
        directionalLightShadowMap : null,
        spotLightShadowMap : null,
        pointLightShadowMap : null,
		ssaoMap: null
    },

    attributes: {
        normal : {
            required: true
        },
        texcoord: null,
        color: null
    }
});

},{}],130:[function(require,module,exports){
XML3D.materials.register("point", {

    vertex : [
        "attribute vec3 position;",
        "attribute vec3 color;",
        "attribute vec2 texcoord;",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat3 modelViewMatrixN;",
        "uniform vec3 eyePosition;",
        "uniform vec3 coords;",
        "uniform float pointSize;",

        "void main(void) {",
        "    vec3 pos = position;",

        "    gl_Position = modelViewProjectionMatrix * vec4(pos, 1.0);",
        "    fragVertexPosition = (modelViewMatrix * vec4(pos, 1.0)).xyz;",
        "    fragEyeVector = normalize(fragVertexPosition);",
        "    fragTexCoord = texcoord;",
        "    fragVertexColor = color;",
        "    vec4 pos2 = vec4(fragVertexPosition, 1.0); pos2.x += pointSize;",
        "    gl_PointSize = distance( gl_Position.xy, (projectionMatrix * pos2).xy ) * coords.x / gl_Position.w;",
        "}"
    ].join("\n"),

    fragment : [
        "uniform vec3 diffuseColor;",
        "uniform float transparency;",
        "uniform mat4 viewMatrix;",
        "uniform bool useVertexColor;",
        "uniform vec2 texCoordOffset;",
        "uniform vec2 texCoordSize;",

        "#if HAS_DIFFUSETEXTURE",
        "uniform sampler2D diffuseTexture;",
        "#endif",

        "varying vec3 fragNormal;",
        "varying vec3 fragVertexPosition;",
        "varying vec3 fragEyeVector;",
        "varying vec2 fragTexCoord;",
        "varying vec3 fragVertexColor;",

        "void main(void) {",
        "  float alpha =  max(0.0, 1.0 - transparency);",
        "  vec3 objDiffuse = diffuseColor;",
        "  if(useVertexColor)",
        "    objDiffuse *= fragVertexColor;",
        "  #if HAS_DIFFUSETEXTURE",
        "    vec2 texCoord = fragTexCoord + texCoordOffset + gl_PointCoord*texCoordSize;",
        "    texCoord.y = 1.0 - texCoord.y;",
        "    vec4 texDiffuse = texture2D(diffuseTexture, texCoord);",
        "    alpha *= texDiffuse.a;",
        "    objDiffuse *= texDiffuse.rgb;",
        "  #endif",
        "  if (alpha < 0.05) discard;",
        "  gl_FragColor = vec4(objDiffuse, alpha);",
        "}"
    ].join("\n"),
    addDirectives: function(directives, lights, params) {
        directives.push("HAS_DIFFUSETEXTURE " + ('diffuseTexture' in params ? "1" : "0"));
    },
    hasTransparency: function(params) {
        return params.transparency && params.transparency.getValue()[0] > 0.001;
    },
    uniforms: {
        diffuseColor: [1.0, 1.0, 1.0],
        texCoordOffset: [0, 0],
        texCoordSize: [1, 1],
        transparency: 0.0,
        useVertexColor: false,
        pointSize: 1.0
    },
    samplers: {
        diffuseTexture: null
    },
    attributes: {
        texcoord: null,
        color: null
    }
});

},{}],131:[function(require,module,exports){
var c_globalScripts = {};

module.exports = {

    register: function (name, script) {
        c_globalScripts[name] = script;
        script.name = name;
    },

    getScript: function (script) {
        return c_globalScripts[script];
    }
};

},{}],132:[function(require,module,exports){
var ShaderDescriptor = function () {
    this.uniforms = {};
    this.samplers = {};
    this.attributes = {};
    this.name = "";
    this.fragment = "";
    this.vertex = "";
};
ShaderDescriptor.prototype.addDirectives = function () {
};
ShaderDescriptor.prototype.hasTransparency = function () {
    return false;
};

module.exports = ShaderDescriptor;

},{}],133:[function(require,module,exports){
var AbstractShaderClosure = require("./../abstractshaderclosure.js");
var SystemNotifier = require("../../system/system-notifier.js");

/**
 * A ShaderClosure connects a mesh-specific GLProgram with it's Xflow data
 * @param {GLContext} context
 * @param descriptor
 * @constructor
 */
var ShaderClosure = function (context, descriptor) {
    AbstractShaderClosure.call(this, context);
    this.descriptor = descriptor;
};

XML3D.createClass(ShaderClosure, AbstractShaderClosure);

XML3D.extend(ShaderClosure.prototype, {

    setDefaultUniforms: function (dest) {
        XML3D.extend(dest, this.descriptor.uniforms);
    },

    createSources: function (scene, shaderData, vsRequest) {

        var objectData = vsRequest && vsRequest.getResult();
        var directives = [];

        var inputData = {};
        shaderData && XML3D.extend(inputData, shaderData.getOutputMap());
        objectData && XML3D.extend(inputData, objectData.getOutputMap());


        for (var attrName in this.descriptor.attributes) {
            var entry = this.descriptor.attributes[attrName];
            if (entry && entry.required && !inputData[attrName]) {
                throw new Error("Mesh is missing '" + attrName + "' attribute.");
            }
        }

        this.descriptor.addDirectives(directives, scene.lights || {}, inputData);
        this.source = {
            fragment: this.addDirectivesToSource(directives, this.descriptor.fragment),
            vertex: this.addDirectivesToSource(directives, this.descriptor.vertex)
        };

        SystemNotifier.sendEvent('urnshader', {
            urnshaderType: "code", vertexShader: this.source.vertex, fragmentShader: this.source.fragment
        });

        return true;
    },

    addDirectivesToSource: function (directives, source) {
        var header = "";
        directives.forEach(function (v) {
            if (v[0] === "#")
                header += v + "\n";
            else
                header += "#define " + v + "\n";
        });
        return header + "\n" + source;
    },

    getTransparencyFromInputData: function (dataMap) {
        return this.descriptor.hasTransparency(dataMap);
    }
});

module.exports = ShaderClosure;


},{"../../system/system-notifier.js":156,"./../abstractshaderclosure.js":118}],134:[function(require,module,exports){
var AbstractShaderComposer = require("../abstractshadercomposer.js").AbstractShaderComposer;
var URNShaderClosure= require("./urnshaderclosure.js");
var ShaderDescriptor = require("./shader-descriptor.js");
var ComputeRequest = require("../../../../xflow/interface/request.js").ComputeRequest;
var addFragmentShaderHeader = require("../../shader/shader-utils.js").addFragmentShaderHeader;
require("./diffuse.js");
require("./default.js");
require("./phong.js");
require("./matte.js");
require("./point.js");
require("./utility.js");

/**
 * @param {string} path
 * @returns {*}
 */
var getShaderDescriptor = function (path) {
    var shaderName = path.substring(path.lastIndexOf(':') + 1);
    return XML3D.materials.getScript(shaderName);
};


/**
 * @implements {IShaderComposer}
 * @extends AbstractShaderComposer
 * @constructor
 */
var URNShaderComposer = function (context, materialConfiguration) {
    AbstractShaderComposer.call(this, context, materialConfiguration);
    this.descriptor = null;
    this.setMaterialConfiguration(materialConfiguration);
};

XML3D.createClass(URNShaderComposer, AbstractShaderComposer, {
    /**
     *
     * @param {MaterialConfiguration} materialConfiguration
     */
    setMaterialConfiguration: function (materialConfiguration) {
        var shaderScriptURI = materialConfiguration.model.urn;
        this.setShaderScript(shaderScriptURI);

        if (this.descriptor) {
            materialConfiguration.dataNode && this.updateRequest(materialConfiguration.dataNode);

            this.descriptor.fragment = addFragmentShaderHeader(this.descriptor.fragment);
        }
    },

    setShaderScript: function (uri) {

        if (!uri) {
            XML3D.debug.logError("Shader has no script attached: ", this.adapter.node);
            return;
        }
        if (uri.scheme != "urn") {
            XML3D.debug.logError("Shader script reference should start with an URN: ", this.adapter.node);
            return;
        }
        var descriptor = getShaderDescriptor(uri.path);
        if (!descriptor) {
            throw new Error("Unknown URN: " + uri);
        }

        this.descriptor = new ShaderDescriptor();
        XML3D.extend(this.descriptor, descriptor);
    },

    getRequestFields: function () {
        return Object.keys(this.descriptor.uniforms).concat(Object.keys(this.descriptor.samplers));
    },

    /**
     * Get the attributes required by the shader
     * @returns {Object<string, *>}
     */
    getShaderAttributes: function () {
        return this.descriptor.attributes;
    },

    createShaderClosure: function () {
        return new URNShaderClosure(this.context, this.descriptor);
    },

    createObjectDataRequest: function (objectDataNode, callback) {
        var requestNames = ["position"];
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.attributes));
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.uniforms));
        requestNames.push.apply(requestNames, Object.keys(this.descriptor.samplers));
        return new ComputeRequest(objectDataNode, requestNames, callback);
    },

    distributeObjectShaderData: function (objectRequest, attributeCallback, uniformCallback) {
        var result = objectRequest.getResult();

        var dataMap = result.getOutputMap();
        for (var name in dataMap) {

            if (name == "position" || this.descriptor.attributes[name] !== undefined)
                attributeCallback(name, dataMap[name]); else if (this.descriptor.uniforms[name] !== undefined || this.descriptor.samplers[name] !== undefined) {
                uniformCallback(name, dataMap[name]);
            }
        }
    }

});

module.exports = URNShaderComposer;



},{"../../../../xflow/interface/request.js":182,"../../shader/shader-utils.js":155,"../abstractshadercomposer.js":119,"./default.js":126,"./diffuse.js":127,"./matte.js":128,"./phong.js":129,"./point.js":130,"./shader-descriptor.js":132,"./urnshaderclosure.js":133,"./utility.js":135}],135:[function(require,module,exports){
XML3D.materials.register("pickobjectid", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "uniform vec3 id;",

        "void main(void) {",
        "    gl_FragColor = vec4(id, 0.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("pickedposition", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform vec3 bbox[2];",  // min = bbox[0], max = bbox[1]

        "varying vec3 worldCoord;",

        "void main(void) {",
        "    worldCoord = (modelMatrix * vec4(position, 1.0)).xyz;",
        "    vec3 diff = bbox[1] - bbox[0];",
        "    worldCoord = worldCoord - bbox[0];",
        "    worldCoord = worldCoord / diff;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 worldCoord;",

        "void main(void) {",
        "    gl_FragColor = vec4(worldCoord, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});


XML3D.materials.register("pickedNormals", {
    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat3 modelViewMatrixN;",

        "varying vec3 fragNormal;",

        "void main(void) {",
        "    fragNormal = normalize(modelViewMatrixN * normal);",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 fragNormal;",

        "void main(void) {",
        "    gl_FragColor = vec4((fragNormal+1.0)/2.0 * (254.0 / 255.0), 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("light-depth", {

    vertex: [
        "attribute vec3 position;",
        "varying vec4 worldPosition;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",

        "void main(void) {",
        "   worldPosition = modelMatrix * vec4(position, 1.0);",
        "   gl_Position   = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "varying vec4 worldPosition;",
        "uniform mat4 viewMatrix;",

        "vec4 pack_depth( const in float depth ) {",
        "const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
        "const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
        "vec4 res = fract( depth * bit_shift );",
        "res -= res.xxyz * bit_mask;",
        "return res;",
        "}",


        "void main(void) {",
        "    gl_FragColor = pack_depth( gl_FragCoord.z );",
        "}"
    ].join("\n"),

    uniforms: {}
});

XML3D.materials.register("render-normal", {
    vertex : [
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "uniform mat4 modelViewProjectionMatrix;",
        "uniform mat3 modelMatrixN;",

        "varying vec3 fragNormal;",

        "void main(void) {",
        "    fragNormal = modelMatrixN * normal;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 fragNormal;",

        "void main(void) {",
        "   gl_FragColor = vec4((normalize(fragNormal) + 1.0) / 2.0, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("render-position", {
    vertex : [
        "attribute vec3 position;",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewProjectionMatrix;",

        "varying vec3 worldCoord;",

        "void main(void) {",
        "    worldCoord = (modelMatrix * vec4(position, 1.0)).xyz;",
        "    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "varying vec3 worldCoord;",

        "void main(void) {",
        "    gl_FragColor = vec4(worldCoord, 1.0);",
        "}"
    ].join("\n"),

    uniforms : {}
});

XML3D.materials.register("boxblur", {
    vertex: [
        "attribute vec3 position;",

        "void main(void) {",
        "   gl_Position = vec4(position, 1.0);",
        "}"
    ].join("\n"),

    fragment: [
        "uniform sampler2D sInTexture;",
        "uniform vec2 canvasSize;",
        "uniform vec2 blurOffset;",

        "const float blurSize = 1.0/512.0;",

        "void main(void) {",
        "   vec2 texcoord = (gl_FragCoord.xy / canvasSize.xy);",
        "   vec4 sum = vec4(0.0);",
        "   float blurSizeY = blurOffset.y / canvasSize.y;",
        "   float blurSizeX = blurOffset.x / canvasSize.x;",

        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - 1.5*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - 2.0*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y - blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + 2.0*blurSizeY));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x, texcoord.y + 1.5*blurSizeY));",

        "   sum += texture2D(sInTexture, vec2(texcoord.x - 1.5*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x - 2.0*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x - blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + 2.0*blurSizeX, texcoord.y));",
        "   sum += texture2D(sInTexture, vec2(texcoord.x + 1.5*blurSizeX, texcoord.y));",

        "   gl_FragColor = sum / 12.0;",
        "}"
    ].join("\n"),

    uniforms: {
        canvasSize : [512, 512],
        blurOffset : [1.0, 1.0]
    },

    samplers: {
        sInTexture : null
    }
});

XML3D.materials.register("ssao", {
    vertex : [
        "attribute vec2 position;",

        "void main(void) {",
        "    gl_Position = vec4(position, 0.0, 1.0);",
        "}"
    ].join("\n"),

    fragment : [
        "#ifdef GL_ES",
        "precision highp float;",
        "#endif",

        "uniform vec2 canvasSize;",
        "uniform sampler2D sPositionTex;",
        "uniform sampler2D sNormalTex;",
        "uniform sampler2D sRandomNormals;",
        "uniform vec2 uRandomTexSize;",
        "uniform float uSampleRadius;",
        "uniform float uScale;",
        "uniform float uBias;",
        "uniform float uIntensity;",
        "uniform vec2 uConstVectors[4];",
        "uniform mat4 viewMatrix;",

        "vec3 getPosition(vec2 uv) {",
        "return texture2D(sPositionTex, uv).xyz;",
        "}",

        "float calcAmbientOcclusion(vec2 screenUV, vec2 uvOffset, vec3 origin, vec3 cnorm) {",
        "   vec3 diff = getPosition(screenUV + uvOffset) - origin;",
        "   vec3 v = normalize(diff);",
        "   float dist = length(diff) * uScale;",
        "   return max(0.0, dot(cnorm, v) - uBias) * (1.0/(1.0 + dist)) * uIntensity;",
        "}",

        "void main(void) {",
        "   vec2 screenUV = gl_FragCoord.xy / canvasSize.xy;",
        "   vec2 rand = normalize(texture2D(sRandomNormals, gl_FragCoord.xy / uRandomTexSize).xy * 2.0 - 1.0 );",
        "   vec3 norm = normalize(texture2D(sNormalTex, screenUV).xyz * 2.0 - 1.0 );",
        "   vec3 origin = getPosition(screenUV);",
        "   float radius = uSampleRadius / (viewMatrix * vec4(origin, 1.0)).z;",
        "   float ao = 0.0;",

        "   const int iterations = 4;",
        "   for (int i = 0; i < iterations; ++i) {",
        "       vec2 coord1 = reflect(uConstVectors[i], rand) * radius;",
        "       vec2 coord2 = vec2(coord1.x*0.707 - coord1.y*0.707, coord1.x*0.707 + coord1.y*0.707);",
        "       ao += calcAmbientOcclusion(screenUV, coord1*0.25, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord2*0.5, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord1*0.75, origin, norm);",
        "       ao += calcAmbientOcclusion(screenUV, coord2, origin, norm);",
        "   }",
        "   ao /= (float(iterations) * 4.0);",
        "   gl_FragColor = vec4(ao, ao, ao, 1.0);",
        "}"
    ].join("\n"),

    uniforms: {
        canvasSize      : [512, 512],
        uConstVectors   : [1,0, -1,0, 0,1, 0,-1],
        uRandomTexSize  : [64,64],
        uSampleRadius   : 0.9,
        uScale          : 0.9,
        uBias           : 0.2,
        uIntensity      : 1.0
    },

    samplers: {
        sPositionTex   : null,
        sNormalTex     : null,
        sRandomNormals : null
    },

    attributes: {
    }
});

},{}],136:[function(require,module,exports){
// Note: This context should only be used to access GL constants
var GL = window.WebGLRenderingContext;
var ForwardRenderTree = require("./render-trees/forward.js");

/**
 *
 * @param {GLContext} context
 * @param {Scene} scene
 * @constructor
 */
var GLRenderInterface = function (context, scene) {
    this.context = context;
    this.scene = scene;
    this.options = {
        pickingEnabled: true,
        mouseMovePickingEnabled: true,
        glBlendFuncSeparate: [GL.SRC_ALPHA, GL.ONE_MINUS_SRC_ALPHA, GL.ONE, GL.ONE_MINUS_SRC_ALPHA]
    };
    this.renderPipeline = null;
};

XML3D.extend(GLRenderInterface.prototype, {
    getRenderPipeline: function () {
        return (this.renderPipeline = this.renderPipeline || new ForwardRenderTree(this.context));
    },

    setRenderPipeline: function (pipeline) {
        //TODO cleanup old pipeline
        this.renderPipeline = pipeline;
        this.context.requestRedraw("Pipeline changed");
    },

    getRenderOptions: function () {
        return this.options;
    }
});

module.exports = GLRenderInterface;


},{"./render-trees/forward.js":149}],137:[function(require,module,exports){
/**
 * @constructor
 */
var BaseRenderPass = function (renderInterface, output, opt) {
    this.renderInterface = renderInterface;
    this.output = output;
    opt = opt || {};
    this.inputs = opt.inputs || {};
    this.id = opt.id || "";
    this.prePasses = [];
    this.postPasses = [];
    this.processed = false;
};

XML3D.extend(BaseRenderPass.prototype, {
    addPrePass: function (pass) {
        if (this.prePasses.indexOf(pass) === -1) {
            this.prePasses.push(pass);
            pass.postPasses.push(this);
        }
    },

    removePrePass: function (pass) {
        var idx = this.prePasses.indexOf(pass);
        if (idx !== -1) {
            this.prePasses.splice(idx, 1);
            pass.postPasses.splice(pass.postPasses.indexOf(this), 1);
        }
    },

    clearPrePasses: function () {
        var i = this.prePasses.length;
        while (i--)
            this.removePrePass(this.prePasses[i]);
    },

    setProcessed: function (processed) {
        if (this.processed && !processed) {
            var i = this.postPasses.length;
            while (i--)
                this.postPasses[i].setProcessed(false);
        }
        this.processed = processed;
    },

    renderTree: function (scene) {
        if (this.processed)
            return;
        this.processed = true;
        var i = this.prePasses.length;
        while (i--)
            this.prePasses[i].renderTree(scene);
        this.render(scene);
    },

    /**
     * Reads pixels from the pass's target
     *
     * @param {number} glX OpenGL Coordinate in the target
     * @param {number} glY OpenGL Coordinate in the target
     * @returns {Uint8Array} pixel data
     */
    readPixelDataFromBuffer: (function () {
        var c_data = new Uint8Array(8);

        return function (glX, glY, target) {
            var gl = this.renderInterface.context.gl;
            var scale = target.getScale();
            var x = glX * scale;
            var y = glY * scale;

            target.bind();
            try {
                gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, c_data);
                target.unbind();
                return c_data;
            } catch (e) {
                XML3D.debug.logException(e);
                target.unbind();
                return null;
            }
        }
    }())

});

module.exports = BaseRenderPass;


},{}],138:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var FullscreenQuad = require("../base/fullscreenquad.js");

var BoxBlurPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this._program = this.renderInterface.context.programFactory.getProgramByName("boxblur");
    this._screenQuad = new FullscreenQuad(this.renderInterface.context);
    this._uniformsDirty = true;
};

XML3D.createClass(BoxBlurPass, BaseRenderPass);

XML3D.extend(BoxBlurPass.prototype, {
    render: (function () {
        return function () {
            var gl = this.renderInterface.context.gl;
            var target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.disable(gl.DEPTH_TEST);

            this._program.bind();
            this._setNonVolatileShaderUniforms();

            this._screenQuad.draw(this._program);

            this._program.unbind();
            target.unbind();
        }
    }()),

    _setNonVolatileShaderUniforms: (function () {
        var uniforms = {};
        var uniformNames = ["canvasSize", "sInTexture", "blurOffset"];

        return function () {
            if (!this._uniformsDirty)
                return;

            var program = this._program;
            var target = this.output;

            uniforms["canvasSize"] = [target.width, target.height];
            uniforms["sInTexture"] = [this.inputs.buffer.colorTarget.handle];
            uniforms["blurOffset"] = [1.0, 1.0];
            program.setSystemUniformVariables(uniformNames, uniforms);

//                this._uniformsDirty = false;
        }
    })()
});

module.exports = BoxBlurPass;


},{"../base/fullscreenquad.js":111,"./base.js":137}],139:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");
var mat4 = require("gl-matrix").mat4;

var ForwardRenderPass = function (renderInterface, output, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.sorter = new ObjectSorter();
    this.lastRenderStats = {};
};

XML3D.createClass(ForwardRenderPass, SceneRenderPass);

XML3D.extend(ForwardRenderPass.prototype, {


    render: (function () {
        /**
         * @type mat4
         */
        var c_worldToViewMatrix = mat4.create();
        var c_viewToWorldMatrix = mat4.create();
        var c_projectionMatrix = mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "viewInverseMatrix", "projectionMatrix", "cameraPosition", "coords", "ssaoMap", "width"];

        return function (scene) {
            var gl = this.renderInterface.context.gl, count = {
                    objects: 0,
                    primitives: 0
                }, target = this.output, systemUniforms = scene.systemUniforms, width = target.getWidth(), height = target.getHeight(), aspect = width / height;

            target.bind();
            this.setGLStates();

            scene.updateReadyObjectsFromActiveView(aspect);
            scene.getActiveView().getWorldToViewMatrix(c_worldToViewMatrix);
            scene.getActiveView().getViewToWorldMatrix(c_viewToWorldMatrix);
            scene.getActiveView().getProjectionMatrix(c_projectionMatrix, aspect);

            var sorted = this.sorter.sortScene(scene, c_worldToViewMatrix);

            systemUniforms["viewMatrix"] = c_worldToViewMatrix;
            systemUniforms["viewInverseMatrix"] = c_viewToWorldMatrix;
            systemUniforms["projectionMatrix"] = c_projectionMatrix;
            systemUniforms["cameraPosition"] = scene.getActiveView().getWorldSpacePosition();
            systemUniforms["coords"] = [target.width, target.height, 1];

            if (this.inputs.ssaoMap)
                systemUniforms["ssaoMap"] = [this.inputs.ssaoMap.colorTarget.handle];

            //Render opaque objects
            for (var program in sorted.opaque) {
                this.renderObjectsToActiveBuffer(sorted.opaque[program], scene, target, systemUniforms, c_programSystemUniforms, {
                    transparent: false,
                    stats: count
                });
            }

            //Render transparent objects
            for (var k = 0; k < sorted.transparent.length; k++) {
                var objectArray = [sorted.transparent[k]];
                this.renderObjectsToActiveBuffer(objectArray, scene, target, systemUniforms, c_programSystemUniforms, {
                    transparent: true,
                    stats: count
                });
            }
            scene.lights.changed = false;
            target.unbind();
            this.lastRenderStats.count = count;
        }
    }()),

    getRenderStats: function () {
        return this.lastRenderStats;
    }

});


module.exports = ForwardRenderPass;


},{"../../renderer/tools/objectsorter.js":108,"./scene-pass.js":145,"gl-matrix":1}],140:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");
var mat4 = require("gl-matrix").mat4;

/**
 * @param {GLRenderInterface} renderInterface
 * @param {string} output
 * @param {RenderLight} light
 * @param {*} opt
 * @extends {SceneRenderPass}
 * @constructor
 */
var LightPass = function (renderInterface, output, light, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.light = light;
    this.program = null;
};

XML3D.createClass(LightPass, SceneRenderPass, {

    init: function (context) {
        this.sorter = new ObjectSorter();
        this.program = context.programFactory.getProgramByName("light-depth");
    },

    renderScene: function() {
        this.render(this.light.scene);
    },

    render: (function () {
        var c_viewMat_tmp = mat4.create();
        var c_projMat_tmp = mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "projectionMatrix"];

        return function (scene) {
            var gl = this.renderInterface.context.gl, target = this.output, width = target.getWidth(), height = target.getHeight(), aspect = width / height, frustum = this.light.getFrustum(aspect), program = this.program;

            target.bind();
            gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);

            var count = {objects: 0, primitives: 0};

            this.light.model.getLightViewMatrix(c_viewMat_tmp);
            frustum.getProjectionMatrix(c_projMat_tmp, aspect);

            scene.updateReadyObjectsFromMatrices(c_viewMat_tmp, c_projMat_tmp);
            var objects = this.sorter.sortScene(scene);

            var parameters = {};
            parameters["viewMatrix"] = c_viewMat_tmp;
            parameters["projectionMatrix"] = c_projMat_tmp;

            //Render opaque objects
            for (var shader in objects.opaque) {
                this.renderObjectsToActiveBuffer(objects.opaque[shader], scene, target, parameters, c_programSystemUniforms, {
                    transparent: false, stats: count, program: program
                });
            }

            // Do not render transparent objects (considered to not throw shadows
            target.unbind();
            return {count: count};
        }
    }())
});

module.exports = LightPass;


},{"../../renderer/tools/objectsorter.js":108,"./scene-pass.js":145,"gl-matrix":1}],141:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var vec3 = require("gl-matrix").vec3;
var mat4 = require("gl-matrix").mat4;
var mat3 = require("gl-matrix").mat3;

var PickNormalRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
};

XML3D.createClass(PickNormalRenderPass, BaseRenderPass, {
    render: (function () {
        var c_modelViewProjectionMatrix = mat4.create();
        var c_worldMatrix = mat4.create();
        var c_normalMatrix3 = mat3.create();
        var c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["modelViewProjectionMatrix", "modelViewMatrixN"];

        return function (object, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);

            if (viewMatrix && projMatrix) {
                object.updateModelViewMatrix(viewMatrix);
                object.updateModelViewProjectionMatrix(projMatrix);
            }

            object.getModelViewProjectionMatrix(c_modelViewProjectionMatrix);

            object.getWorldMatrix(c_worldMatrix);
            if (!XML3D.math.mat3.normalFromMat4(c_normalMatrix3, c_worldMatrix)) {
                mat3.identity(c_normalMatrix3);
            }

            var program = this.renderInterface.context.programFactory.getPickingNormalProgram();
            program.bind();

            c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_modelViewProjectionMatrix;
            c_uniformCollection.sysBase["modelViewMatrixN"] = c_normalMatrix3;

            program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
            object.mesh.draw(program);

            program.unbind();
            target.unbind();
        }
    }()), /**
     * Read normal from picking buffer
     * @param {number} glX OpenGL Coordinate of color buffer
     * @param {number} glY OpenGL Coordinate of color buffer
     * @returns {Object} Vector with normal data
     */
    readNormalFromPickingBuffer: (function () {
        var c_pickVector = vec3.create();
        var c_one = vec3.fromValues(1, 1, 1);

        return function (glX, glY) {
            var data = this.readPixelDataFromBuffer(glX, glY, this.output);
            if (!data) {
                return null;
            }
            c_pickVector[0] = data[0] / 254;
            c_pickVector[1] = data[1] / 254;
            c_pickVector[2] = data[2] / 254;

            vec3.scale(c_pickVector, c_pickVector, 2);
            return vec3.subtract(vec3.create(), c_pickVector, c_one);
        }
    }())
});


module.exports = PickNormalRenderPass;


},{"./base.js":137,"gl-matrix":1}],142:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var mat4 = require("gl-matrix").mat4;

var PickObjectRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
};
XML3D.createClass(PickObjectRenderPass, BaseRenderPass);

XML3D.extend(PickObjectRenderPass.prototype, {
    render: (function () {
        var c_mvp = mat4.create(), c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["id", "modelViewProjectionMatrix"];

        return function (objects, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;
            target.bind();

            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            var program = this.renderInterface.context.programFactory.getPickingObjectIdProgram();
            program.bind();
            for (var j = 0, n = objects.length; j < n; j++) {
                var obj = objects[j];
                var mesh = obj.mesh;

                if (!obj.pickable)
                    continue;

                if (viewMatrix && projMatrix) {
                    obj.updateModelViewMatrix(viewMatrix);
                    obj.updateModelViewProjectionMatrix(projMatrix);
                }

                obj.getModelViewProjectionMatrix(c_mvp);

                var objId = j + 1;
                var c1 = objId & 255;
                objId = objId >> 8;
                var c2 = objId & 255;
                objId = objId >> 8;
                var c3 = objId & 255;

                c_uniformCollection.sysBase["id"] = [c3 / 255.0, c2 / 255.0, c1 / 255.0];
                c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_mvp;

                program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
                mesh.draw(program);
            }
            program.unbind();
            target.unbind();
        };
    }()),

    /**
     * Reads pixels from the screenbuffer to determine picked object or normals.
     *
     * @param {number} x Screen Coordinate of color buffer
     * @param {number} y Screen Coordinate of color buffer
     * @param {Array} objects List of objects that were rendered in the previous picking pass
     * @returns {RenderObject|null} Picked Object
     */
    getRenderObjectFromPickingBuffer: function (x, y, objects) {
        var data = this.readPixelDataFromBuffer(x, y, this.output);

        if (!data)
            return null;

        var result = null;
        var objId = data[0] * 65536 + data[1] * 256 + data[2];

        if (objId > 0) {
            var pickedObj = objects[objId - 1];
            result = pickedObj;
        }
        return result;
    }
});

module.exports = PickObjectRenderPass;


},{"./base.js":137,"gl-matrix":1}],143:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var mat4 = require("gl-matrix").mat4;
var vec3 = require("gl-matrix").vec3;

var PickPositionRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    this.objectBoundingBox = new XML3D.Box();
};
XML3D.createClass(PickPositionRenderPass, BaseRenderPass, {
    render: (function () {

        var c_modelMatrix = mat4.create();
        var c_modelViewProjectionMatrix = mat4.create(), c_uniformCollection = {
                envBase: {},
                envOverride: null,
                sysBase: {}
            }, c_systemUniformNames = ["bbox", "modelMatrix", "modelViewProjectionMatrix"];

        return function (obj, viewMatrix, projMatrix) {
            var gl = this.renderInterface.context.gl, target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.CULL_FACE);
            gl.disable(gl.BLEND);

            if (viewMatrix && projMatrix) {
                obj.updateModelViewMatrix(viewMatrix);
                obj.updateModelViewProjectionMatrix(projMatrix);
            }
            obj.getWorldMatrix(c_modelMatrix);

            obj.getObjectSpaceBoundingBox(this.objectBoundingBox);
            this.objectBoundingBox.transformAxisAligned(c_modelMatrix);

            var program = this.renderInterface.context.programFactory.getPickingPositionProgram();
            program.bind();
            obj.getModelViewProjectionMatrix(c_modelViewProjectionMatrix);

            c_uniformCollection.sysBase["bbox"] = this.objectBoundingBox.data;
            c_uniformCollection.sysBase["modelMatrix"] = c_modelMatrix;
            c_uniformCollection.sysBase["modelViewProjectionMatrix"] = c_modelViewProjectionMatrix;

            program.setUniformVariables(null, c_systemUniformNames, c_uniformCollection);
            obj.mesh.draw(program);

            program.unbind();
            target.unbind();
        };
    }()),

    readPositionFromPickingBuffer: (function () {

        var c_vec3 = vec3.create();

        return function (x, y) {
            var data = this.readPixelDataFromBuffer(x, y, this.output);
            if (data) {

                c_vec3[0] = data[0] / 255;
                c_vec3[1] = data[1] / 255;
                c_vec3[2] = data[2] / 255;

                var size = this.objectBoundingBox.size();
                vec3.mul(c_vec3, c_vec3, size.data);
                return vec3.add(vec3.create(), c_vec3, this.objectBoundingBox.min.data);
            } else {
                return null;
            }
        }
    }())
});

module.exports = PickPositionRenderPass;


},{"./base.js":137,"gl-matrix":1}],144:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");
var ObjectSorter = require("../../renderer/tools/objectsorter.js");
var mat4 = require("gl-matrix").mat4;

/**
 * @param {GLRenderInterface} renderInterface
 * @param {string} output
 * @param {RenderLight} light
 * @param {*} opt
 * @extends {SceneRenderPass}
 * @constructor
 */
var PointLightPass = function (renderInterface, output, light, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this.light = light;
    this.program = null;
};

XML3D.createClass(PointLightPass, SceneRenderPass, {

    init: function (context) {
        this.sorter = new ObjectSorter();
        this.program = context.programFactory.getProgramByName("light-depth");
    },

    renderScene: function() {
        this.render(this.light.scene);
    },

    render: (function () {
        var c_viewMat_tmp = mat4.create();
        var c_projMat_tmp = mat4.create();
        var c_programSystemUniforms = ["viewMatrix", "projectionMatrix"];

        return function (scene) {

            var gl = this.renderInterface.context.gl, target = this.output, width = target.getWidth(), height = target.getHeight(), aspect = width / height, frustum = this.light.getFrustum(aspect), program = this.program;
            for (var side = 0; side < target.glSides.length; side++) {
                //calculate rotationmatrix for that face
                var mat_rot = new XML3D.Mat4();

                if (side == 0) { //look into +x o
                    mat_rot.m11 = 0;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = -1;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = -1;
                    mat_rot.m32 = 0;
                    mat_rot.m33 = 0;

                } else if (side == 1) { //look into -x
                    mat_rot.m11 = 0;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 1;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = 1;
                    mat_rot.m32 = 0;
                    mat_rot.m33 = 0;

                } else if (side == 2) { //look into +y
                    mat_rot.m11 = 1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = 0;
                    mat_rot.m23 = -1;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = 1;
                    mat_rot.m33 = 0;

                } else if (side == 3) { //look into -y
                    mat_rot.m11 = 1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = 0;
                    mat_rot.m23 = 1;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = -1;
                    mat_rot.m33 = 0;

                } else if (side == 4) { //look into +z
                    mat_rot.m11 = 1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = 0;
                    mat_rot.m33 = -1;

                } else if (side == 5) { //look into -z
                    mat_rot.m11 = -1;
                    mat_rot.m12 = 0;
                    mat_rot.m13 = 0;
                    mat_rot.m21 = 0;
                    mat_rot.m22 = -1;
                    mat_rot.m23 = 0;
                    mat_rot.m31 = 0;
                    mat_rot.m32 = 0;
                    mat_rot.m32 = 1;
                }

                target.bind(side);

                gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
                gl.enable(gl.DEPTH_TEST);

                var count = {objects: 0, primitives: 0};

                this.light.model.getLightViewMatrix(c_viewMat_tmp);
                //rotate for the apropriate side of the cubemap
                XML3D.math.mat4.mul(c_viewMat_tmp, mat_rot.data, c_viewMat_tmp);

                frustum.getProjectionMatrix(c_projMat_tmp, aspect);

                scene.updateReadyObjectsFromMatrices(c_viewMat_tmp, c_projMat_tmp);
                var objects = this.sorter.sortScene(scene);

                var parameters = {};
                parameters["viewMatrix"] = c_viewMat_tmp;
                parameters["projectionMatrix"] = c_projMat_tmp;

                //Render opaque objects
                for (var shader in objects.opaque) {
                    this.renderObjectsToActiveBuffer(objects.opaque[shader], scene, target, parameters, c_programSystemUniforms, {
                        transparent: false,
                        stats: count,
                        program: program
                    });
                }

                // Do not render transparent objects (considered to not throw shadows
                target.unbind();
            }
            return {count: count};
        }
    }())
});


module.exports = PointLightPass;


},{"../../renderer/tools/objectsorter.js":108,"./scene-pass.js":145,"gl-matrix":1}],145:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var Options = require("../../../utils/options.js");
var mat4 = require("gl-matrix").mat4;
var mat3 = require("gl-matrix").mat3;

var OPTION_FACECULLING = "renderer-faceculling";
var OPTION_FRONTFACE = "renderer-frontface";

Options.register(OPTION_FACECULLING, "none");
Options.register(OPTION_FRONTFACE, "ccw");

/**
 * @constructor
 */
var SceneRenderPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    /**
     * @type {function}
     */
    this.setFaceCulling = getGlobalFaceCullingSetter(Options.getValue(OPTION_FACECULLING));
    /**
     * @type {function}
     */
    this.setFrontFace = getGlobalFrontFaceSetter(Options.getValue(OPTION_FRONTFACE));

    var that = this;
    Options.addObserver(OPTION_FACECULLING, function (key, value) {
        that.setFaceCulling = getGlobalFaceCullingSetter(value);
    });
    Options.addObserver(OPTION_FRONTFACE, function (key, value) {
        that.setFrontFace = getGlobalFrontFaceSetter(value);
    });
};

XML3D.createClass(SceneRenderPass, BaseRenderPass, {
    setGLStates: function () {
        var gl = this.renderInterface.context.gl;
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
        this.setFaceCulling(gl);
        this.setFrontFace(gl);
        gl.enable(gl.DEPTH_TEST);
    }, /**
     * @param Array
     */
    renderObjectsToActiveBuffer: (function () {
        var tmpModelMatrix = mat4.create();
        var tmpModelMatrixN = mat3.create();
        var tmpModelView = mat4.create();
        var tmpModelViewProjection = mat4.create();
        var tmpModelViewN = mat3.create();
        var c_objectSystemUniforms = ["modelMatrix", "modelMatrixN", "modelViewMatrix", "modelViewProjectionMatrix", "modelViewMatrixN"];

        return function (objectArray, scene, target, systemUniforms, sceneParameterFilter, opt) {
            var objCount = 0;
            var primitiveCount = 0;
            var stats = opt.stats || {};
            var transparent = opt.transparent === true || false;
            var gl = this.renderInterface.context.gl;
            var program = opt.program || objectArray[0].getProgram();

            if (objectArray.length == 0) {
                return stats;
            }

            if (transparent) {
                gl.enable(gl.BLEND);
                gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }

            // At this point, we guarantee that the RenderObject has a valid shader
            program.bind();

            //Set global data that is shared between all objects using this shader
            program.setSystemUniformVariables(sceneParameterFilter, systemUniforms);

            var prevOverride = null;

            for (var i = 0, n = objectArray.length; i < n; i++) {
                var obj = objectArray[i];
                if (!obj.visible)
                    continue;

                var mesh = obj.mesh;
                XML3D.debug.assert(mesh, "We need a mesh at this point.");

                obj.getWorldMatrix(tmpModelMatrix);
                systemUniforms["modelMatrix"] = tmpModelMatrix;

                obj.getModelMatrixN(tmpModelMatrixN);
                systemUniforms["modelMatrixN"] = tmpModelMatrixN;

                obj.getModelViewMatrix(tmpModelView);
                systemUniforms["modelViewMatrix"] = tmpModelView;

                obj.getModelViewProjectionMatrix(tmpModelViewProjection);
                systemUniforms["modelViewProjectionMatrix"] = tmpModelViewProjection;

                obj.getModelViewMatrixN(tmpModelViewN);
                systemUniforms["modelViewMatrixN"] = tmpModelViewN;

                program.setSystemUniformVariables(c_objectSystemUniforms, systemUniforms);

                program.changeUniformVariableOverride(prevOverride, mesh.uniformOverride);
                prevOverride = mesh.uniformOverride;

                primitiveCount += mesh.draw(program);
                objCount++;

                if (transparent) {
                    gl.disable(gl.BLEND);
                }

            }
            program.changeUniformVariableOverride(prevOverride, null);

            program.unbind();
            stats.objects += objCount;
            stats.primitives += primitiveCount;
            return stats;
        }
    }())


});

function getGlobalFrontFaceSetter(mode) {
    if (mode.toLowerCase() == "cw") {
        return function (gl) {
            gl.frontFace(gl.CW);
        };
    }
    return function (gl) {
        gl.frontFace(gl.CCW);
    };
}

function getGlobalFaceCullingSetter(mode) {
    //noinspection FallthroughInSwitchStatementJS
    switch (mode.toLowerCase()) {
        case "back":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.BACK);
            };
            break;
        case "front":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT);
            };
            break;
        case "both":
            return function (gl) {
                gl.enable(gl.CULL_FACE);
                gl.cullFace(gl.FRONT_AND_BACK);
            };
            break;
        case "none":
        default:
            return function (gl) {
                gl.disable(gl.CULL_FACE);
            };
    }
}

module.exports = SceneRenderPass;

},{"../../../utils/options.js":175,"./base.js":137,"gl-matrix":1}],146:[function(require,module,exports){
var BaseRenderPass = require("./base.js");
var VertexAttributePass = require("./vertexattribute-pass.js");
var GLRenderTarget = require("../base/rendertarget.js").GLRenderTarget;
var FullscreenQuad = require("../base/fullscreenquad.js");
var Options = require("../../../utils/options.js");

var base64RandomNormals = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAIAAABMXPacAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAnRxJREFUeNoE4XeMpnmCGOb90pvDl3N9lau6qrs6T3dP3tmd3b3bS7yjjqIYZJKwLMKWLcuCSdiwDMg2LEA2DQMGBFiwqT8s+cR4PpG35OaZ2cnTuatD5fjl/L05/IKfB/7D/zX/AfZcU/p/LrtXs1qhr11w9vf7071c7r8KJne98t8ORl+ykvdurNrJl9M0e2h/2OCN5f7PuKXtZr1jHjrJX79KD5j57apf7OunMPgwNMgIWBLnCLC62FOFmOLlCH57HtXqalaHsJmkj6R3i/4/i9Wdq3T1WPw3c/4/rfMxV54tUQZA13Ljnvp3j+S2q+zeTe4eSv9dMt/ck//4J+y4b/vLaeM5/IuF9GOorNQnn9UForgmwDevjdYr7x8epbSo/6NScuOedcvBnxrJ33HoEKq/Mbg+VM5x8LeptKEPP8fVp4UoU0iAHR5fSitutjEnhXooQhykWDg4n4kjRxrNyGs/eZ7t/NXZsh6JRZx+Z0srEEwp3MvE/+Ew/MeuphH0H1Ym51eU/1sr2kGFxUPywoj/QW3WiTP/9UVy5WlsmKpb1wwdIwQcn92RBYQgV2KkQom6JvolgECaU5EbgQ2ZWSfSkBjiAt4bFcyXg8cL9ptbrGQnpaGSpxIVQunirlRmGKxVo9OempmTPU8da/DqwAifMSbocUNcV0GdBd/E5kyniwymCjhNAb4NLSisC5COJDykl2VtpsVE524TVRfRQOfVkxgC8tL1t/JYCUynSlMF6gyZHr3W0cHA+fqrfLQNyvm4VALLA7M7Fotd/TzhVSRZBR/qvHxNT66AiYUziJf6SmkvKLdFV8OjAum/7a5lpJKGx3O8ZAK3EiLO8q56OZXzZ3LTlS9nzLGU20lCLbBHRNOIghzrbNFGLA3Os5Xd2KHgxYIMMUhW0/JjfJpDB6ZdXedBCCZYdSRoV3EuAWoFNruSwzQwYWVDmywS3VRro8Qbp22F46YCFKSmvJuRQQ7iP0z+0zfUPNRRZaqv/BypL9PRSCTXZF0Rd7vuGdBfGSK5Jsg32tWv/flr5HgMRvJhC+oG+UE0SVN9iHDYoa2M0OfY2IBTGVFbbGuirIaHE/UsobUzUs6yaA9IXOrvJ24Rb/XSyoLwvgmPR0n0Ql6LsBEow98AoCmtPmEHsPFTFJ7xbEUGmjhqw+ayADeg+yFJB7JGUNxRmoU434VfKCyVdDohxbbMLjWikLsxRhh8onCQosZArvf9he78eES/ktNRNdkqKllXyvbgwqm/d1ToPBeF71B7N8mFyj0neBVB9E18oxWwzyP3i4h+K7oX+tkCszA2Y/W+m3hc+iLvr04VUYAOxU2KUAhAG/UQ96GWIKyl6sKAhDGscCB6XGGsdUWjVwG5ygZFqXIHOTUi26hsQGCCNEHpPiajqi7e+OpUrU0TtS63BmJhXXozgbU19lal1+TrvzqfSOf4e5ni4lby38dyAnjlBu2H0MMs2FfpqvCvhZsJ1o6UuSaCeryiS+ctdn4kqh/C6gz2fBIOKFNwrwRCQXPLyg2bebfJqyz7Qz+ZnOh/QdrvnFfVCm4paGUlncbQXsL1nPpEFU8o+EHK1hfxZ9n0Rjm67+HLut5+HgOPgnUUX4FKI3Cz7pWDnNFl+8/TbgIlJhdVmbjs/hgvZeL52zr692liwPncUXpG5UAWrxMzjg8Xi5cyu7WukgTGClUQzFxQHKt+LDGb9+oW4DBeBgcgSmeo0NF2Ih4+EOCAZJDiTtLsr4B3DZWpeLXI9C55i5DJDMJLgoW4zIBlKIqLqbcjxeU0ewCTxygNxNoSSX3gzuLllmhruFAmTRbNR4CM3gZ8qLtRmoNy5n4a2mwcA3EgeS15vqFiLSguRdpBSSn6rou1XGTN1PG5jC7TpXYyXVf2ZbA4U662/X/znLGQ0l8noaVklzWrgKKnUrgIVvpYs+CbS6rdksGV0B+K5JCY52GwpFnl6CMq/tlZ9Aojto6kba8z0PQ++r7POhy2XO/dc6Uw6/8yUGYoOSrkqwX16mqcX5N3x/iFRKp92jzIPh/PdiBTNtHZW+JmotoZ7mRYHLGcDzsjab9Jf0KSGiTgwiw+0dW+17dV66YeXUvqQqgJ9HeVZlueTbxQpUYOjLbxaFGaXetZttslSW5mXf188aTF9csEa9osD5Z0Mq9yOSLGBKqCV06k5AqNdnFf54CI2xaYeVC6jI+bSn+Bfz/LbSym98XU5aUArD1yQT+ZZJTTLF6vqB/OJkFeIoPd+E7e1Dja3UjHh7LeELdPw18h+aKXuJ2CdE3TqWzNZO8Z2r2uEy0oatAU4o4C5Tz6KlXOXoY3UilNhP5A11UxOBOUCBdxKQfiPXDuircMPrkGD3mi5+L6vrXQFrrB5RLu0OhFrrR543Itql1MQRpFW4GUS4W6TMlzgAWAHJB3ZSm28t1sOo2kAPoS7BYIArxSRvANH3dBGiVlqCiGmMwxXY58yPgplh6xUgzzZtgrmeRnvM3yByFrXJF3NElbSx1Cws2kO8O/04fmC++/V1jDVtUdeyRTU4dH2D+DeuYXtS6rybtJIUM45zUJ0fvqywm4mmfsHP4LNXy3YNYpPwuQtO+h1xAn7Fpe/q6GBpe45IQXEunHNAWifZm9Wp5Bbj4dQdXmsz+RoYHVoVJ9Ced77KBWtH44I0t/zI0Tpn5JkzEbRfE7h/JUx7abhCX8BGe8Mcx7ZMeDZpx+eYaDtlSvSysiSmX0zTW1m4nKkqRmw+ww8vKyvqf9LvL+0ShKwvhPg1xwj/RmsWohJSbAQ1uvdfraOVszIpOsfhiABBzXk0Uo1pec9ihJdq3iU8PRAG8m2bdnSWChU2QPQdKA4VJcdeT2CfPCcP3XkGcIxUgUEVuBVoP1tKTv6FEbZV/IDQmKkJ5dx2aLsEVxMEi/LwHTD/9iCdlXYZ0LeonHg1R8DpcDVMp6B+vZYlVkDd7qIzgDo3MwK1AQSzIT2eOECyAPE3xNneeAUmSrXRgMwB7nN8ckgNFQI1sNtv+BGbticCvBYykKkwIl5YwY5UT+kbTXD8+IVFb0YCI3zllURlMTVSuzsBBk5IxyKF1WYSaLCH1pxFlw9Vb6PNLSN7Ffk0eLoFhI+5j2taQkUE3i/kARtmAdYfWJ9Eh4CGp1ATCgmG/vq3zIDkJJJ6Qw98KMUDEp2Ho3kYNvxWqWjM/Y50W6M1BW2tOvdCmwOKsznUg5Jqq/UXsHKIbylYI8iFngxtOiFByDZMvwgLKTIO2p8+Zz5l6F9ia6V4HHI9ItAr6IBAMLxWgvVA7HfGWWteqxHnN1C784YQ9uQIwE3wIYMFDA9WvBianM+079yAQzHi0idJuXejIbiVFWC7aTgRytvMlcf52c6FJY4RlDsUKxBoPdht66wrYvpJMEKF9G9TCZQBzfNGmd3gzIdy18UEiu21yXyLGVVhBfLsXyWPEmMDiWXqtgjcB1Vz0Q3odTvNigJ5s4mICjh2n6tFRbBrWGD4vi512IvrNI5uc+XTQ678iJGRmbaKWX/NxDUCMrETw6Z42RGNrydAX87pQqR+Q3TnAsqSur/GRBvhzHd79RS4f9U6iwH+eaJltW2XPZmOTPt+SSNwDTgVTKMeBiEwDtJpdN6Fpe2KO3upnZ1+o8jrbxzCnJR0q6M4Ymhwc6LMwYyaJXz5TsXVDapOYNaF6a4gS8iIKrGY28FQmZU5Uu9NT4THpJo2ZRrrpi/FK2Q14toM4GE1goLxAtopGv2jXITmS3qOk0/ngvkKb+Ly4Usm2tJ1R0418QpX8W/U1Jk4LkuKGgFTaIA4NJjXH4hmgnayyrimItsc7wL2qooVnZVf5vy6PNebZcmXl6Lq174kJXsAh9Fj9VtSmTJskgBVwk9wURiB2bYlaOxlq+b0IQgW1OxSWYB/PzV5AsmNeCaU3JviQx4b9rjS+F8RjzDYA34/wE1nva/nP3A1lbzhDHT3gOd2fJyFCuotmrTDYexR2h7e+J23UlUxf8er6Jwb8y3BqRd2znWALKVL9DpUsPy/U04rC34FXOTLsLjng2yvmlQJXGsNaJowmdFMjFTSNZ6VMVqBEu9VU6RTFL4yvkLIQGE7HOc9uzilY6uXAziZFq8iFMPzjS8lHaSmE9ryRnIjRhaoDwDh2OscqQdc40CQ6gUCmTQunS04rn6UKqGnLy6vu1wWz2ICaA0va2ERbj9XN9wsR0GRWawTGEpZfaSht5Mi8S1t1Hbi+mBdRqSNIDL8vS9lQLPkMb/fRsrdDO+u++KU0DOlCxWUPNCbLNNEnAeEl9vUgSja4NybtfsfkxaLF4tKHChlg23fPt3PgScoscKHDrI0JUBigjd0Typqw8PY0Wf81OfpOe38revpEcRwp5A6UNmGXEicXs2Sh9UIveRrrEzC81uBumCe25Rr6Ekhx/IUGtpZQUyfWysikbh9jxZCDgrC4JSWSQes1N+mM5eu5nbBhqqbUF4D1MIvWVLkKd5yPD1VBeYnDbyU1UN0B6GyAKTh+KbN2Wq3Hj+iS3yCZvhPE1VAOgKSkpcoChuZ+O0/S0qmxdQemp0jyi8jx52lS0DbE1ByclmVww9A7tMAJMKpmxbUzzUwim/JChlYazPyS+RjINeu7IakiktmTn+eJMECqezRDjbC3m0ZBFIZ53QRtrSyNv1UMOT1unkNRQcx4HHEYoTQK4OAwNkT7CRrsY3UgkXEuicgBuM/JaNU+1+WUaT4Gfk9O7ifQOvf9GunzGvv65OV3HugFI9qErLDLeTD5YMFuefBzD+0BUUqV7F1jfsmYteX0IpzdQcsKop2BPUj9KOhN1fY70N/RXw/AGMlYWKbTghRKXPb0agRUgC1U4Y84kOJmxhaE0wkJaYZsVZXAJ2557xrXiQrjJEi+UfnPCM5eSOueHkrxew5LLXgk2AKhQIdkcoS+T8VjxPyOlDQgxMNbR0lDNTd1vEqu7lb5/m36p8e7UX8V606HdVWmGSVSgicp3Eq5g8kZHg4GSnXP9Nvx1mAGC/u6FOiPwzSlfODfhKGneB8eh7Mn8wS9jkYiUCyUL2pIsraKNPJ3Y6lPE/YTfvDAhEXxZazTBJRdkKmkO4AaxIhakEB1GdhZ28sb5jWCJq/ld8OwvYQNp9T9EuXyypjsj1zqO/eMlQ26jnEFK30wGxPosnVan+UWhEP5AKbSgk8bQNFYr+LuXrnVu3xPpnJNXRXh7KUbX9MJYX7wMjr+iEEaxayfL6G4Y/mVFmadpLsO/64pMDr53IAU6wq/TnEGfUMireO0Zi9xE703mN0vnLvr4B/OMZQvAg5Ho9JXqLK3uuS9HxAiZKlgA4Nklv1ZW8r4It+R4wEa32RWZxAxGPVH7MuIqhkzEZaXvEwVy8QLuvyOJKTYgDcZErPkVOerowOvImx212hudzTIa5LM5d6bJxhfBLhHrGdPYYt9OxPVhmsVM6rjzca4fRzt3c3ZNuK7UhUn7upTJxbirDA6xq4DgPVctBQsr+HJudhKIsklEkkXLYAFS97hUEtYlcre0VzWyKCUwwqNv2MfNuJfXfAyf/RMvrpKsna4TvrsAL47Axix+PkuTD8zF5cRAkn/GBAPkIjSADhnnu3240xCNd6XSIZ9l8PmRqL1P6QmZIGEeygulsU8K/3olXeiI0kykGsrfoh0X+lwAJCwFNCZe7zGdjKLp3eqwQasPouyuaim6lxjTUFAmvN9YVhObVJu6fOsVLwgHAuE1zaCM35IYp9I4J6wwNhTtq9b01mpOj0C6wophEm9it2/S55RCuHQ+z2+p/yx1QRnp+2beI4YlS+c07avRBZVVgqPUMigFsBFEraLer9HfL2J6nD1PHTSHCwVUNaXyXbrLjJULC0zYN2y2w8B8nei5pKJSeC4rn2Ec046Eu4t0fASKx/maFMOZ/LQkGg8VeYm5IbabSbxBsw79wIv/7VDae+LXDSJ7CawZvk7qa1B0+RMoWor/ZqOA1gI9Zvnv0GYheJ61/7IR3+bSu/vmo+NwImISXo2yZnCtnSldoIO2aMvJTxR4iGV6ixGHXFRgtktqvxNMUtxdmlQ5K4sg62gv7Wh+bl/LKfgh8vJx5jHWm8zfzClbYdAH2T2C/1t+voZXQ56WxKTLvGu0O9M4BdlILiKMl1CvYDfN+a1E+oQGT5ZQtjJPYuJ35Cylq8IeZOJgwrdjuXLgj+zsuRAfvE2/w/IszFcXomyKtrg6/xZkj3xvHjlCvJjrzbp6g6f/LCumKsE3kq6myiSwOsocwcyH/qKvEDN9NIc3eQz1pDtFf+Ot2aNW2eklUiL2O/pJxq+60uphnERiUtDkNT6XQtTGzUBuc1wfuOo888yL3jlSZhN6sMeX7pEon0i/z+Spfhomcl281c0dxuD8i6hWSSeWDH9oGUFwMkALgbkwBbk8F6diWEz7n7gfG7mycL/Ik6mRkl4pMGfyCpXUBFxCpjxE+r049xSfZVC4H2v3ZEdlnR7o1LVSX0gtg3SUcj/9JmOtHaclSVx0ZjAvhgV5XpJQ3R/ZSX6oLK3DUyIbBkAxSF8LrU7mQ4abVBUgDOjOAVdmSWcfT+8UuxZAGR5daAvn6rgLo8U0JaiuorPXnKapPQdzVYW+uPXGC3UcdiaZv5M/nUh+c1r92twYh24YRylrrZtxE5sPkrrPzQAbz/nsYaazrFqyyBygSwROF627WHy3x+cea9rpaWzpl6mehdEoLRbMQcTcmSieKSqB0mYUfJy+0kIFwpW+jriS7dO2gqyr2vo5Q0DuH4UsL2sT9vAr9IMlrX6tXxeZ1lIaPM9667S/x6/+oTSxaWp7OZmfnHH9GFZ/MxCTtCdJ8k42myLf1o+hXLPCD8/kR78d4t9t/+/zT7nahrNFqaPQmqZ5Z7IJxeowfg3BRYJkDWdbsv5Ygq+kyYzIBDUs1kpRri5Xivz0lq5jtcHhqxYBz0nupTr1sHLHi29NNwOlMkmPM/JFPsIR2vqS0kNxNIrfi2gAyecQbEJUC3nrjAwuo/yeWE74qE9OILiSYxzKXZLcPGJkFR2r8uJN5mJtb1tmAzQ5p2bb3Fxm5H4c/gFNf0QGN6MklvMjbaHN6Ujd3O31T5Jfn44+nBs6FWcxlw9ouQ+8Pp/ytGrq/QYkH8RX1XBcs3sKRDahRVjgGE2pZ6rzmSrP1XRfmwegYaDNIJ1PRBoTpCM+5fOKRFREbxP7hJEube8ZpaPY+yVFTyelFxRMyXlFvlCYkU9DX84o5EYxgdeU6IFNl6x4G7QMWjFVRYPdBXy1EhmoQOYyGi8ZqQL9FFQ72KhAGjJ4D0RE4hatXcrsZdoTdDrhyX09WIofhBT64MIKa9fATI0VhRtL5rgvG6ekmmHOPp+YPPqviV6sKCxlGQhCUXkDfIV3lrRIgzUi8WJoc56/QkefaPlBys7n8rpZXFOg4O55qozY4UhrRhTE6i7iqC2rV1mu5Ly85WSltHpRlM/l/nkaPsJg03jOyV07KZ4VRhc806cXtqxgUfsTdCYVaTy1WuK0TOQDtqqi50LgDLktyd+cxIqm1D3SK8l56i8fmoNhkmZAbo2gdfxsyt46FtmE/8oNFkzDKoPRogzW4KQPGxW6eCN9aaY5T12ZS+qKjB0+ZPBKg4Z6rn1Fhxy1eFr7BvGeJPY1TQWeyhwFaDfHDcqLlv7rr/RZOb0OlEEA/ITgrRj/L3v4w//4/yTrMCe48yo90hMu4coO7MrAFkDX4PQSbwdUTPhsSxtj4A1FfUgmBmlZad3RtXO109c2Q1gsRWgqZRMaDsVzOYYAbzssKSnpFXC8HWmbeB0qwIC+IuQJjIUS9clFKjUV2Lg/3fsBBCW8ACQVCCVLRIrPhq5qK5kCHt8DlECR59K5Ec+M+XO7gpHh40BGKMH+FA4u0eKukp3gWpeVB+5XEuyui9pHw9FiwKv0fQ88d/WVRJSW+D9fGm3ck+9i6h7Cs70x/TJZlu0oVDK2MM/R/szNHZGtIN3rcM2WqxZ/vomcrFj3ke2xICGbQfj5FO/poJwFwkxvvYLwCutr0vR7fpXiaDNlp/q1PjiYkYuGVynJtTdsMGTGcRopysmedmMoiq/j52U97rAPHY6/mn/leE4rX05yZGkOwEnaH1B+Q0dZ7lsJkCU5gWMfLz1JxBKcPiBLc/yrYTobRe9xK1tMOxeyIcuzTqpwUFWRGzLqim3UP2D64XXj/Tk52wSzKQYKaHVB0zHkhaSngeIRTwaRYUoOI7UyM6bk9X13LRTIV/Q9LauzQYYYhSR3DZC+PsxTVYYkgtoM+RfifAVtPktAjFtPU/ttvO7ipUzybRedFd2/QnUa8SMF07fyXhJVeuTo/7E8s9HvO6FTAedpdHeHpyPJp2E8LtuWs/2u9dLJXAasl5MpAlcizypo6gnwvfi5beSycMuOnwWKZ3hXc/baPPjWM954wcY1sOiTx9NUG6k1E7Nq5DNsyiI9M0aQF38KlSNv3B1fbpDNXPmeyfeykmfxuiNdJLwVBuwmZVdSpeCoJ6oyEItXNYsJsD9FX81IbjGId5jQATAHoCUDV56M8I12osRs9sY/IJlIiL+94eUahtNHV724uwtOElfVJLitCgVwAJvHiUioh7XuDatb86+mWnomLnX2Vk7M5vj4PGmekuJVsfAgyvTU5zGIY3YlBFKP73V4H2a+57DzJD2TEMmL4jH0ZanJwPSr8DlJ76YKXSEHcqIbSr0RnBjZToeudoTw2SuARR1VJaOTJdUwfUsJplN5ErjKXDaYpLdZWkQdbKxYcFD1Jgm+ni6k/zZ9vpNfeH9QsqjaylU+jV924DArz+4g6V1ITK7P0jkQo65UmoK0LSYhyxbDcM0wZOytzntTYMiR9KXS3EuSOnkigZVbUX5PYxmwkE/m/2M8MYtaGLSPk/HILK7ycynhedA40OZC2d831hue1jE2fKTknEfvcAzDm6+LV76j+F7u/3hpqH4xmZ4btYm+2JLDrlhktJ3X+B+hUQV0Mu6/ux/2nMKL09nHHgqrmldVmxC/GQU0ImuySJdQoSLOPpS/w2E+h94ZsFaVHBRmb9lo45LOJ/ipGsRVVKmkKMeqLTI7Y1GK8yY81Wkuo18r+0+uai5D97T0CMi9lNuboOZhywE9IMYLuI4kcMChUGxLnKzHm+dELkKB0DjLR2fhzpRkJokU8U976LKR3n07q+5gW1fFVfyFnVwDODqW0x5s+qTtJFJP9N3s9EwrMnlJUNWUJnXJTdEsn4YxQgDVHGnL9w9tedjnt0ZSLgG/QkJQWHxs+a5USNX1OVi+GP/LVspTfMVQZgKuumlUhG80QhQ+OdNMKK2WwDON6i3lbou3hqjFUyJIiQEZ4DmEKSGyKwPHyG/Mk98Zk29C3/5OvtbNoECYWZh6AusQFqCt06gvSZcoDuCxVuQa2FjNizjuLnMa8bIPyUS0cHA9MSSLS0q6dQg+2xN8mjolZWimaQ1qbbicDL69sDHy54fBq2bhe1cpqkeyrM8JKCRAraA9P/094Vk0c1iNeYkOC6koeZZAxR3oDzKsS9gRgylILbS7IVYlsejp2o20Y8NTwGtdtWTbjsvkkFTvcuVvhisTGbzA5/vhW+tofo59Oc7b9JLICuOaAtcWDDRln+y1y5X8tTxHTTpZoD2KMhf6zn/Fp4NZRoC9K0VYtTYW6RtdFjUyGMj8OJFXdFkGqgfbB9E7SbhQ9Dq+zi1+70t7ceL7Kv68ocsLuKSSks0CyF0f3fsGXqb0cJxka7g5QV6J+w7SopTm5V0GTIbMPuJ7eSlvEOd3U2Og15/5zyCo9kj9utzNsJAj7SV9PYFQhitLmbDOiZ2majhMySSETY0vPphSFccRlwJ5H2DTJMtDz14rxCN6+QEqDkjiaJCL+Tsa+GvIci34VFv6wps+dcOFvPs2H647OUVpOkQLyZia/YitWLLPQKdPN4L84k8Tv6CWYzhfRD0RvWWRgxx8TedXkLV6AX1F7nXgSpWbXOyXhL4MR6tUyAk/zpWeIDZKtJosKQLGUGBwZhO7GYV1fzoySiGEHqZcoogf97WSKhXHjHNSThi9Z77AWjomZhZJCjhVJH0jWRJJ8JaovDBaInRiYzXD+IynK+rr7TpaGJViTW9hNTYihGYSqxqQEB7NoYLx5lPvyDYP7OSPfyzRC9h+wnoz7+Vi9vY1YE+guAArYXq2JH8r+O2hQpa51VSIXKCgjHGXzBPoP6OL1EldPrhWmC+HVl6MntleC2YDpFoUYNwjOMgaJpeVcy6NuOSw03tW8e7kju58BaPhbq2OADshL3ZIscLqSqxL+NlWlGsYkmP+AnG7nmzP7RAA0Ed3zsPzRSsM2V3BfvYauRprCl0u0b6G95fBdUjlq9q+C6YOtWdqmOJlEvf6OAyY9G1qpIkFJc+QSF4bq4YFQP4tCmLkJODsuSgVgRrjyVORE2S4mk8Vsbrm9lRFwazxRLeB6Mrw5oRRIr2w8MfvX1431CMp1I/L80AKhhgAkTCcOjhzhaeXamEYkYGwmTgV2tM0vTotswm5aKOP12afKtlxEKylWdrDKxfcfjNJRJwWSH8r/FYy318Pt7Zxb2RIHmKYz+rMhHiY4PgsubYqZyxKKjK0TCbfSyRXo1nBOyBpQqCTvB+xPp8dBQtxJrkOkqxgyxxegKwHXADSDiw6QhlEc4NcmvDqKX0CFiMD3Ezg7GmsKGhBx2cuT/5M+d7E+TeO7GyJtXdnb+4SN4q3XtSiA0qPZ6uG7BTlb3xRhKRxMZoIDSowZ9DpChgZESm5Yc9cOlHPA3xOolWoGaP0IKsYb7Msl8yIuFC/yEdrM6W0y8OA5TVx8kIaO2kD43CRtEu8NJGzGL2JuHHEy1l01slkiNhuFyhPhjoRfZCnHi2ox0b43helVqyMcfSxQiY5ODvhywfSZJZ2riryevo2QfGOMjkWi99LvpvBEzr/4y8KiIl9QvdnuWUoxl6uH7O8QZrrPM3nWZ0eBhj5cf5TIuW4cx9OrKCch9EbqZKDykZCbUrPtcuxmHqYlP7fvsbobtaYVuN7RcNxefUMXN60wIZSfxBrPyvyCXvoJ/eAvPOYjx2+X0r0VZzI2AJkq6+6EzQlCQvgi2mazeDfIeGb31cuh/g6568HfGEcN5qx9EqO+85f/LQir6lvR2DnZPgl1MyKOakrZzVgm3x5CgcVM/KolSHsWxofkn1FoEr+do0VafDaMlgsChTWUTxti8MhqKwqBku7FQzmRFqM2IKYcDQMsDkAO1kYUHCR90WKakW0PuPnBBlTWQ3B6WmqVKRcTgptgIZiVgaQk0I/HUzmIc5dq4M3UiyPUALIsEjfj+kjVT1NgkZPVXM0K8cv1+THmQSRqBGiQiV2QzkQ1FVx8YSvTdGn7XnnSl5f47Ub01MDZyfah29yB2mATnH5hBUNNZuVg3VxlvAVhyTnslVhRQt5GUDMdSNWcMsEWi3VfD4VpNIHLw9Q3jXeWXM/eYspe3JwHmlvOlIa7JqZFKlrrjbMS1ICpnfhYRHLtlgd09OYRN+lupnsFhW1QbfO5+0Dc3jF8Oth7nox6KfHkngrD4gk8I6qct3T2LV99rOAVR7xJTN9rJsZObn6CvX9FEOWkyHbd45rVvyWliuypddabkZhyGZ5Qo8cPE58wQ6rylnR+2iYRyXmYpKu+EYhOjFS49wuTtXTCW0gYp0F2X0uCiBNefSO1NLYW1bSOdKea3FWk2YrAK6LHNJGBJK+MOdyz1TUSBTWwJShopySQzTsJAtn4RuUucQgu6j0pHTHlYmXzlJiQcRGXJITVlPi63hK4n4olVumAIrkow01SW5pk1rMAS5fyOrDeH7OcVMZ2HBTZtorNm/Hej8g2b85GmGpGzDJVwgghEvVD8IXI+O33F2cajfL/KQuLFOpL+ejtdwwH+b3jepXwZOzhFiK1jBQla3opMtweRctTZJv5uoldH6cy6tqyje1s2vzM0lvrrXunhR7r0X/s7B2RX/1ABs43DojB1zRXVFfk48XlUsjeWuqFDh9fE17N5Mep2TUh4ohGSFonPBch8bjZLBoWHUMb9nRBR4WRJoJlQyFPT4MpPRUiJfmJRCVDLo5dn7DjR5zcpqZNCRRUgoCehHwkzhBkA2losFsUyq+FsO2GVZwQ7f2UriTgHepcVrgm68ZI+QhFX8kB4dEvxjNBwXDWUHrfTDuAO8swBYqxm7bUUw3znH6eKvgYrAWWs4B7U6TnSoSABlVGGTh2I5yjrwcszMFDP49IY8Ujrg5xI4BcYxKO3hwPU/mn1dchIqY1Y9gZAknRtY1qXSOZg3jBJEIJ5lm2KDgbGkaM1yfa7k64/8jgBRpqyc/PRL7++4foyytCLMJyj+MXkVW9lgjfXCQKeZ/f+TOw4uCWvOUIoENTWtfYfMJ03+jcQGUcmLeTDI9skDS3iM0LTAZCOc2GLgxkOGHu/FfVqVXnvP+GYi7wW4xs3THOL2adt34ej11G9BRKOkTdqxIFOgmD++L4iUKIXJPqGRxOOFRU0AdaTC1q3I4gd1mcuufJ1ZvcpgwZ6dm2tJS1+3thgd5+XoMU4xeZKSrOWVyyGGccgpmNMENnuvzy2VZTjlrw6MKaw6wet8w5nieM8ZZXI41A6QXEecpv/MMuO34jSFeUFu9IuQAWM/ZUkscKqGW4uWCmH0FA1VcsCTSxTs5rFWZKZIoRWTiImyCLMJEB17AIyjcAbY5xx3UdtlmIPewrHAgf6kdKSCvoNV6lPgK10WQYK0CskwpztPpa2SP4/i5/rwQ1ksmyILzMgpOsqWJ6R4oRiJuLvt+FRwqbPuhRs+j9tAPb9m7c3Bbg+QsfZjH2YBkFvnoCTZtKHfiUVHrpm4WKeU7wZhnYapqrug8hLEKlFP9dV6IDFv0JBzIsxS7EgI+z9jUhSh3F7FmmEio2taSPnJfg4sq34RwEcrJ92Qr1s5qKQzQD1OweA3uo6rHoyKTz30y8kNdQ0SR2isQRKAaqpcKlXNkpSR+c4mXqdiRQIREKSSnU85XMKyHJTnWe9I0lGwTF94XpYn6qi+mvaT4WpqXANmSjTW45MOqx7sI7WnJj0bxRJIv43jCjHQgGQFlicB/4+7/ru9A/yxZ3sCtCrJtRHzhYxQURcbHaY/3Okm5TFIB/RJYjkUfkO4ZXmmjPOFdGfUy/k1XthELPbivKDPI366p8gFXHkbpv+2PDwN6yeUxAoHai+WNb0WV0FNJ6vxIckqkxiWrQQumGH4UeTYkmwkZqltMTHw0elukZbAUaCUgXi9KnavTGlAgkEaU4jKR5zAfE9gChg9Jj/a6KZyjaix6gFBZ5BMJ7huFF3h0ydX7Ml0RnY1AS6W3VkfO1XC3PLNy0C4JW+Z+g/VCuJSF5Ui8KCaORpabKYxxbwDXBPZHJLR54xmcGqiEwGUCs+dUbaVHNgeOpH2H848x2BNToqctLhdkuZ7Ml7gNteJpHJ8nOpaVPO+oIAWoyWmmQsJtdKZCf4HLWFJW2WrZscspfpD7B4d5uKzKpU705DyWkVwhgseg5bMHk0TE4inzbnoSV/FukFQ8Uumlrkn8BphyrHWh+QxppqQWufITt3udXyx53NWbebgNgqBUaHOYpWhoY61PoyWJFkj8Y298M2muOSDQogK9ciamNvn2V6zqG5WvsbEGIozaH4VdD8oCvTUCR0BJW3iLyd16AusxbFIu0BpHrZmYKPx9QTNeennpG8PYdeALGt08hJVvJy8PYzOj6ovSfg5I5yTFWJ3hUgdf/oWs/gvKnsvsQF1m8LBlshCtTLHn47nAAoGAYT1Gm32onNBOhwaYKE2IQ4gdkG+ltSVxVFOOq94a0EoQcJukd/HpQqrZRO9iFJBYA9nl8IZML4Fx+GyIxlKpL8wiOjRQz6ZmLV2SkBEprU5y51kiEvmTJEPE31USHOUxxWdSMkSZPExSMNqiD35K7Rz7ckKNq8bsdTrygSxz6aYYCgkBYfdAqAOL85mBnwf8T7sBfyW9HIb1bLZRxqMF0PiTgFoRYMw+ruhH8mXEi69S8h5+/tLEm372N/WFEbd7cXLuqBiaQrwp8m2hOxGeA6BSJBJYEqRY94eKfjAV4JB4HS2nwpIAyREtzeYnJaulxWKZZIQo5wruodtryIhHCzmhBZDmM28aYDULJ22mYdw4wJeE50C0eVU9XSu3eaBFxM2BkZwqyxFLIDIpHsvAJYuvpWgJOBWQ2RYrL8gThR8IvnM/SUIScTCVGIDRR59m7X50qKLGDWlkijQFVxupCPHpCIALrBYMWnMzPw61u4UO5mRXXupHF5c8U1NaL5VKEecu6esCL47GI6X0SJ3hzN/8X/lz8D0kRI4qwADfJke9uDiRa4vwbEVRCmpcF3RJ0e+xXpMaCmlgxhXYiaCigxWa0hUy6rLrMJ30xedXoVpSSobkHfME2DyVF2M1y8ARgMUVdmUMDp8kwVfDzLck1xPrSXjmYPFOpv+uJu4pPgPyonolTh/PmXiC7Ei2zkTuIBm9ggHHjSLqBDzAYLHN1DXsrquKwMyFY4eUPozJA2/2A+ZXEMhK7+A0u8x+raot7m6FOmuA0gzlW3Fw6FsOOGiY2UUQYDyXmdDlbsVfdjXFJ1FXy/Xl9BIaPUpeR60QqTVsboXeXHH2EmmkrbYEF+SoKxkR+d7h4NLBn8Lxtp1x26gfpHeOZUmGExtmBVJ6DLr4lChgxY8BUNaT+5H7qJB5lk4fMN2UhGLDKEcaP4InW9JuYUIW/4twpqAn9dwGos1qGgTx83V55oXXHkTZi8x4I83/CoMq7F+QaoClMQvbM91QyjELLfXLJTUs8fotwioJM3FGdeEIb71Gj7akw4dJcUnN9ahWgPfm/CiEXGZ3EPtpSR9HXBNgmDGqNTCtiCkAxbF0eZDEaQpHHl83TnPJzhWkhsiKQaoroAVSBFUK/Qx3q6hoxTMC1wdgnJEP+47imBkSN6y48dx47rA9U7lZTPJNcBkncSZCc5KucHMDVCaZmcZ6jF2dweU2eYS9wktuy9Jld6ZeLfga3ICpjwjclEsxOh7w57+NfnBDbVRpqwhmF4ILSAeQcVEdiuLNeLqQnyG/OkjYpTR6krYzEg9AIQuXDxzSc74NwJt9+PZSzcyieIVFTfeO4c+HRjsWaYZmVbF+qBzrxDiQf+Qu4g/+t/9XmDFz/TQpKtE6zv4kHCNNwtLFvhrq+J04flOQrD4EkUh9Vm/KtQL2bdXFxMvJ+8tRvgbXq6GDpT5ByUkOHihXY65dAHlCwePBVFEiiWgGjAWabxLtD3z2PeDfkBaaulEQcYgepeLkInj/CjNUY1KGN1TRyWhdGi6eqc3DUALoUR9rBWS3eIrQYJRQQjYO+GCf2DZI6rC9wJNzHM2lmwdQ0/gehpu6WO7OHh/bx5Fj0kwxwcVCMs+zasXnFj9+jutVONSgsx09GODa7uA1T2k3JiXDiAXEyHWEmoExwcqI9V9HzFHWfKnDOMuRJTudWNhjaAfNvgSZw8Hso4yNAUpN1S2iYZWvSWBT8ZKCFVh25LCz4ZTOhd1G1RFuXxpnU7Y0lII+ylBpcxJ99VIqvkxujx0iJVDJg4sfy6iUNiDKMPzWMWj12bPhJCNVuk0FrIV3VfRVooYOjmrcybPKnF2W4KU+B6FQjsrzl7Lhcb2Ilto8zqODCpGWeXY5mbUrQym91QaZZvhMgRWTtSEGjFeyzBUJSeH90D01shfV9KJB00q6BcQZhcoZL1xqSY9KlJ0jU5nTq3XYTgCwAPHBrJNEWXJLiffz2i5PFpfgyht4cRB3GNd/hGcFD06MaUUdx2lVWDe+YPb58FMJJbb0t24qU6g3azDKJLHK755kmtbw9Q8Wjpa7+qSIJAA8rGqiHcISANUKSE3tDZO8DsMEWxSRgSDjdCHkk5DvbVTgPi1b2ckBFjcg+MjHLbXSI7lu1L9iTLeiSsJ6+/kjf1LyzQ2HfeOosx3wvSY6i6nzStRa0rwoXXWg/h7uSxK+F/0vVt64ylB68nIqhL3zkJWKiYfUpzsp7KPrfTb7Fc84uHsmZpBn9+CYa7ot3ELSPVM2D3Obr9M9ANYFgxC2A6Ha+MRj5WVmC+GszdWJ4Zuil0pJJtk80mePtM4bnIuNnCRsxMGafwSl+jdm5s+CZy+Boec0QxQ0ZpRRUsOr19JXy0Cp40wMnzTT+wVxWYfWOboTBKND+t2QKfupeamuXDoRkXoRnTL1eB79TyYj0gP/hFPb0xZyWpg3nG09qUibEA41Mt0Kxww0BvLiIO1rRvoH4xnXr2vy/BlvV6FVF9c4jVvg+Xlib+PVKaxdxIMXk7YXh5isqpAY6NyU6qpws8pBxa2OjJwnxt+hJEAbe2Ggy7tAFjVR073Miv+y5qo1/GEmOb2DXlizRUPauYQBVUAMiIJKiKoXtP0oJvQ/h9c/k1/9wpkq/dpTNb5jDq9wmA0WOGqm6sjhvIjdLRKkILcZy4+Ipwj2FOefmORkynLypKmsRxwkvN3j/DrZeuxqZ8Gjn83NbG6jnl8FbFJQnil0Z6qXUfQFIkZJbnwW9Fw6BCC7k29K8mgVJLjA7Qg+pL2+XpQEb/IoAmoE4Cslj6HNk1kpVfrKxlhq+3E3wfEtK2PAgR1f/02ybc8/werRW8kfpah+JF+ouTiBEEUbfXKr6TzZNoc8llLUGisDQ7A97eopvXm0/zjIfbqpgyemBvCVVnqYkxZasPgkmiUiMUFWkfbO6ZaQr/1EfDHMSwLULEmKYztNCxPp5ybOVOgayiQfAnwKWQjNmSg34W6VvFDnHx/ZsypEY1JMMmkCpZI3CaGxZ95uR62J1F2AZAHbCC2nTjdWunWVlLomuN0n75sEKvGBqoTsuK9SVVzp6jXMIhuuGUR0BXkySb+WX5cEKJFcSV4Nks31Ao54O2QFCRnraPlAHMzhqa5Zf8VMZ7YhqS6DbI3BEOIUGgG0VFqZKIPzKBWwIKO9jNR6E8McEHlZ/TjIjUnXgZvPPaRi8HnEVs0xk7Q6HJhCyaPqpcaJ8FVY/SNMTdYrj2gKN8fm1Qfc8XOHqa/WUKObzIEyzoD8Qqyv0P1x+JNT0H7K1w+jKhenedatocyafHU+ymeTJyE7KIz/4Jt6uULmkC0I3MKUQ9L4m7xdDM1MSH5dTVbiUTmqfnzJesXgda5P5ZoWpSWeN3kSwsyFcuU8aVsKvS8cRQwgUVyeSrTyhspvwIXL1QLK9tlZwXYQf5+okRNCzmNFkBYv5MXjRm7ho9GOERD5Z9B/P8O2YzWVrAWqPUaZ/XTwGUu0NLsuTi/w3MY0AdrvFbNHXEYCfhUPfozJQpqzvMK/srr7wayokQVppxLZx3Cwg8CHPUMKcue1yaUyJ2y7kry3Kyt58SqxJxt8ea4nV+h0yU+JW3AUxwNPO86Pv7XXZMg2eEOWjxycBDRK2aWl5C0RKCBp4d97MfVT+DhLbabxSFJfFkAkIMPmYtfNAw59ZVjc6I8kKfP/AnRTMd45NYYxD7JRbVNM3rGdCWYDgaKETkT2Dp3fQ5GeFmlU+pkEL+mXnC2VSW0LFe+AYEq8L6SFxJwR8WUQy//crKiZbpAuW8LdQiWA6pX4X53zkqr80KPthvrCjjazyGBwQsT6eXp334xPRlISvtgqozG4YUrDPW9aoPHdcvB9zBSAu1z6Lci13PNC9hAVzC2XEAl+9a3+6g0pqdb3EqwLNyzp5wvpPaZgPRg3JXPNzRuRqaaze9Z8TyNHcv6n4cSUSFnfuju/V7KePktm/9/x7IMSXsUDKRn/l6ZWLmYrZJ7nowFYOqVoFvwroFd3tI1r8aXqJ2PN6Oo3HpqzbRDuwoUd2OqK/BqnA4zeigWUpVV/8XmJpyD6POUGGrqs8rE5U3CqTpSBjKC0NKcXFPk5oIzA57mMcaJfM0w3C8UdUOioUBXtiGY0PFXJnMLK+lz3pWRdGp5Dscc5Qf395U55Vp4tLGwEwy0S2pElx5cBniT47qWsF/EYwHdizzvTuklcZiJoygtJcvAdfci4XVbXc5AjkNg8uRG6kyhzni1+On9e0GBWut5gRduY4/zJxnQxzTZK4Ztb2Xqba2+SV8+1+rsExbz41+N4rlzMuN2SzFEOv/9/+N/QLVY0lEgBsiNV6nS8AweL3opQyh499OVLyPFeNvfIEsdaqSHyZYihehhGQQbdyNIciffLxsWmRN9N5HX/ZkzsPfzMm/uKUqoge0CW0sS5qbpX5H457l2QrIpuPYXBIxG9nqYTaaQiycJigefPSMHlflcWXQL3LPiCuQxHBfK2HJ/VlYtr4cbyuG2I+XNyJZZxLFomXHqSmHP4y3P5WlezxzjV5Sbyv/Gk6cNwy9MUhs4gRgwuPFL6R2rsSjVG4iowJM2ZSp2p+u5XKNHVZyGsCTl8rgeHaDOSyVYkN1Nvy3NMta7iZYwOEQ5ien0evUowbaolC50Shl1QT8TuGcq+gCsz4RoKyhAlh/DNxP2+O/hg3MLwaoNYkYwLTDXIQ52WZcWUQTDFhVgmMfKWkm4lQolMZkfqpBrlTVofyqU6P6rJZ4AvfVGsjeKBLA+NVJ7JO7NIscATJsEh+PiEehvgqYlyDL36XF8p0+bH/sh03HZ++YmR8+PkI6L37LPIze9mF7PCyNJvJKMbsGainPZY9lDOUWeqG5f/UW7OhFX32aHhUt5kiSfwYw7WY0BkoJawtswnMUpM4R3ww09Sm9V/7Kc9joc9Hy1qlT4PF5QQiMYY0xw8nSVJQ7nz7WypkH1U97GE7KPokqa4qKAsojloJ8DRRQR4tBmFmaTQMUhO7pyh4kwsePQc8qAGlcPUfwp7k1gxVXNLUm5Fg02QBrB0oYKFeN1Vvs2F3T7+XSo9z6OXHDZdSFWpb4LkgdMcyQfnyvQXUvmd0kktaEKx8caYXiI3hVv5lKna9HY8oTBp8LXf8rMpYn/Jry2YrgTwvdp/VvwyLfRkd8wnNeQNpYrA9RhIReBkMKtDeYREXk4QzjLk7CfNefqmqJ3E3vcllcRAUcHPeyD+WvrRSzw8pfGSlmmGrikNGV24xFdA6nXBb+fC0qQGBmpA8Iy525p+LzqwY5ai4kT1U3j3G17iyRMqj27H7y3G4zVxWmNLl1g8SgJXOV+h68QshMAJgbGMoxQPdRRlUf7txFuAeBOkTe42eW4l3mr4j67JnZz/70I0V9RLBiQONxltUfKGxdcjPO6K0YnSvFBhpJgmgwDJFM4MfHqF2StiOY8wJlZRdSn42k5MqF3Jem0VsXWnYLIIY+nUiAOoITzThKKC7YQmEv7a8xovje99ffGkq7xSgsWZRv4iZAcynOAmTmmGdM+AN+XeKypc8k4f6WX+pKlIS4rZorgTkNwfMnBpuo+ojeDkGZNiGudJr4Zqi4mDhNaSyhogMT9pgrLKtNu4owEP+0uesjgLTjw9cnn+SZAaJMzh8e/gnkYrQr4/FiG1xjk+hRJ4V1ofkkuYtg/w+1IQCPDLJyLf0RKLAQCWUhDHiC9IaBZLicj9WdzH6BTH9ZKx7AxTZP9r7AJD/L1p9MlIT3xqeaj/HjcMBlXqdLRlxtdn8X9jwoTxD7sqFvj6L6VPzPizqnnvB32LK4UXGe1VdBDTatNACnBlsdwH5wDJLg/nxJHhxu3gywwthFLpUHM1rt2OZ1lWPtP8S+n5QUjn+eutZDojj1P27g5GCn80Cq7UrWwPSwjEXarRlBdEOKHGKsqfoaorocNJQlnzUfuymJuUbfQ9xXoPVvMJ7aj6rmDP+2c3ytMSvfF+UsrJ88gkS3NQtNyH960O5+tPxcTER1G8mWjKCzIqoCuxsGrppyOiclBBdKSAs4orde0PxsR5kihxrG7iywXpPs4MA3DY9t8XhkNAJycWCgJCSUgsHqHagLXbwXmRvLVBnOsoHQlA4WYPa+P0acJzaZK9T+IZDtdRX1a2ryoIinmWGx5MV1N4DNCU+Cpq/FH6MkFgAMiADLMJAqSGRfUgupB12veXFgxnDIaFzNVkVI0zX7cHNw6z5QwkhsA/oYW+dSrcO465XpXO66yS4SxCpQlTuujFoXaZ8T6Ya4bP/ddUKUrZRMrq/LnHXJP6tlgr+LvCvAxiEGMLsaKuTU64YGKWR+pHYI3FmZ7MNvBoVUgize6bSc8id8OVof31VAQ4/fs8PpsoX52Bv5IwFKWTZm4wSVuSV/5pXv2AqjmX6GMIB1iz4FYbzLelIBGSTdwTbrW9+ankqvKClixNQYvS/2EBZXPy1e9KbEgjSUjXJFDne9WwpLtZkMw7Vu1A5RFwUq4bouKBiSXi5xw7sSGYVtGHOHgN9GwpeL+ZvjkzJ5fwrsqfF3A1wh0XzTakW7Wgukp2WdJJ43fLqFtAsczWuJ10wLmMonNYybNpiOZJUnsmpYy7BZzTo3ZTnU6TUkExAcblRPwNJgLq7Cf8CyYS3Cyms7rl++IGsw8cnjri/VH6ZQQ1FW7l2VmA2ShtdtPMYnpkY/sjrLzmfgqHDBfvCgej8ZDpmcR4Ox5Qt5UX9lhuYLT6BTznuFeMY4Ut2+Hduf5mzJ/0VmpvOfJHl2mg1U/tzfFYGxef2kcX6nWaFUzhV8JpUJQ/WZSXPMWWpPZFWqAYhDLpfZaaNzQGAF9G1OQTLdmcKU2ROk0DMBDa0pQB1pSWDvE8TNIgrXhsF5DujnytGQ4W/VHHEDPbdtVmG3CGZw73izw6IdlzNzS1SY6sfEQX39BHEXJbbsuTuy/InbxaVvF6Ji7xuDfhxWZubcY5QuPP1HMLDpOokrW8c3xZYstd2rT4MweNOXcPk3hNvVWjmpD2LWZ0OHTjaV5Jx4AY0DiAnSWc3bfqM9CIcnmPBTlyILObIT09U2TAGpb4ukSLsZTuSIUXgKVC7YQ3RPSbOT7NU5qHUoNXMky9n2xPxKuJ9U1nupFkqhEOYqkTm8wIcKKPypGJRO1Hs/0wM99Ltj+xhpIqtsSmhPF+enZudK8YayVgOoJPoaUT3dfyWdq1BcqmajuezvSzQXTHklSIPSuxvjP985TINaWL8djmazV//NwKdJDp8c7bMJuKmyF+zSjIgdJGN/ieFF4QfKybFZpNpccwNA910tfqI6jN+RsI/noyEJ71/xuFJDVDG5u3oAhwr0lXA6zVYnEO4nexJGTOAOSQ12lfEZqHl7tWwYVDhg7a8e0b8jtK8qyvHfWD9UMxWtO9nLJR8u+MyGSKHtdZJcfPFSQksFoH2Yw0mMDZjC+NJtmYH4IeMOtgCfieAiJgmSStI0MRVkx9WRtKsa6B+pkSYzGwYO1HdILhyXeZ22Iq2xbPMaLD8SAFXWmlALLCOcGm0Pk2wACCY26DGJiBmvwUMKzNijibo7at6lNOdHQi+NUTgUrsfFOeAZ75OlpVmayCzu8rE22an+rHj4n/S/92DL0iamcVewzPigS70l1NzV66YSSIc+wf78dBWW2XLKUCSAyDTbh1RFuOAnqpZKALKPTflPJ5UDKhpML5GE1CyBB0bb42hott9+Vx+uUigDaQNvG0LtUBrvdoKMihJlAbW/suX8dKFWVTYz6gMkIXVeIeosJNrmTCzEbivMqtUO56yomWUFcpAtjSibVBMudh+1jM9vCCHV9U7SmdWZYU+8ptNTk5Vy5kcF1JJ9eVKZHz5Xgc0spvRfgGFKbeMpJf4Givandr8XAL5KJkkarsBcEA4Ej0D2nRgkWCknUwXQGTxRYZ4O3vMmcH4sLyZ4FeuQGzuaQy0mELjHss+hFHSbqaqNKMDEMxwkz0udQTqkkWMf3EEuNjqGUwrbJKPdQsfXIszlNYixXd5XdgZinHW9uGh8G4SgyZIYM7Q74iVKNFVcwbdYV4L/dPNyw3az5o2ps02dXE0UisjYXFaGtZ0ROxcJG4A/c80MJFVKUyOo2qkLR1MHTpgiHlyonayE/9QVqRwiWqKsliy7LO4uErOqqwTVsX9+Q3il4LgHiu+gfDAoOOqQAEXwws2zevlqQXNcgTBHzQfxncz+Etdf7YUV9uku111ZWFv4dXUff8XNH6wcKn4nmRlqi1jd2nPu7WjGkFajvOCodRS3KKWPUSLQvCFB9X5vlF8/fONLwfuYcuKWqHEr+yILUg3iuLsq2wnHAXY1EQZG5eV2GzGUwsXT2GXYIrr/VuhWx9J7QyG8b02m/IJAYb/Si6I88RM8sY9UBsoL4UWFOVByi5olzrep/3cfFX5E/fch4/0IdVh6nCHGk/fCpOBvLUENkVMAgVH0NA4owBLJ3nUwjuKCNfIfRXVaWFgxEfdUFxBs0DUZ9F/DZxC4TW4+K+gt6RGZeRxuElkwTwbyohRGwi9C4HAEg2ty2mjsm3cq7fB40GvHcUmvXkn0CrVZ98rCmFWfhzy1zjYvPv+GdfNJaPokcvu1hVzntJ9kb1RjYhEdB9vqBjv2CdcMQmVlPHZ+Nk9Yp0s+4CaMTnyu6iRDbztb7R2Z+UJHZUzb5aSt/LkcQB8z83KzNRUMH95VgxRb+UoTWahSj7ioS95CBE0YPidVO8rIhHVJQb8TKHvhJAiuQYub8tFg/S1Ge9O/KaxGZ1+cBLryH84JBHGfIqg9wrINMB8XF6bd57+OeDo3y60Gwe/8DmerrjWpXeNNPShkdxEnpBTe2pUuISdybbv8g0Lj3U6YaEn8hGfzvjcG2NiLABoz28mgH+CE7qMGjwUX5KqloomAWfy0UuhstYusmuXZC9uXI6oX/Spg8zSgIAueFUf5spnrKO4yxZeCcIvsait4jydYWGiM2RkVfMMfAPUzcnz4lwPmJ6xBZjY3BEar4SCxStp4nCF/+gXU4o8zJEIHrOp3WncC52uvB4DAcVXimQXCi6m9IW569p+tW/jf5aWXcs4t8Wq5VpkJ06QC6PLdpS+yFctZExEMF+Kst4dBen9fg8IRXERD3QZ5axl5X26a216GRBf6lQp0u6Z8n1uVR7CD6fBrKEYVXdmQsgJWMCmw150AF+hmSupCORFr0oTq0Di8xZihSQux7wNY1lCs5ZrjpMEo//LAKbRVoyQQqwfVWPejCb5ctdexTE33Tk/dXoxkfkylfIy5eFglNbuWxO7l5o6g365RRlGrgwp8e6nIUAHmiBpeD/fPAPSg+zB/0gI5lyR4w9tKjCwyIY1IO7y4lbF50UkL72B+c9LYY/p15azFzPs33bbMnzDZi5pnnPF9T+sreQI8iUU4boHaHIjM4U/JSsP5/FO8avwGzb1Cr/WJzMi4GtoCtdUwYeI/GRdm2Erib9PZZ5Hbo3F+VhAexbwdUAS2NdjjCiOK0ivchOvyycHMjlT/IfyGw+V7+KQuNSLVIIr2DpThL3ifGGZAfI0SV5Kjc/4RdTjBelWg4cvSCtN9GiKkdVtDAQjf32pOV2YOpq6MaathU67UB+jCJRJGUTTkco6sEFQvRGEpbhLvQNKJUlshZ7qhXtrQixFV1COp+m7xwYi0MRyJLfYOKal5RgoEkVXxkhkUCwnRfwXgh+PG99kHglmTnK5sNYO0wfXsykulEjUrTIPCgghFIXE0NPxy683AmrWQ6rqPAGG2FUvVBel4XDrWCBAMoVB80/JFUn1LgdY9697gs8L+9a8DvWzVpzGdmnmVWQzgDrqPjga8EG0nXZeyYZs9XMOMSM8uwJrmjp7ovgk33/w8KGQXkwSmrTkEvxpKB4Baj3gPhno1iVqE5bPzAUBOQ/YPBz4gxA7wvcWKPf2GzchHAXmoxeHRF/UUwhhtmk+0ouj6AWi5eYX30FqxPXLRpmjPhJSp2omYVP3gPHGl2KcHmHig8LvAz8Fg07fF6A9izSpjo5cIozMhfA9aK0LF0sqmqeZ3Cy2LfSiUh8PKgYfmBXW+iGxMJB2slE8OkoZuljVTcxrubUCQV3isnZBn564ldH8v5X4dZGZiGjRiUDF2ne4rn/AOW+4hqT5t9OO40qCrGSgozBp2VBXpsL7oekbhv8RIAULmXFK1sZdNgSNfaOWdURcxN7JT4zcFwPNgh6c568uChcU7gxUTsWfKhoiZGu+FLUos8tfNtJ0/PQ6zqvV4uPr8Z/9HY8OrNFylbOvfo17xXCPRYAXlrqBNOcFjIwXLLcumg0qBRaaB9eJElxDqcv2fowrL+Cv5G95pbVuEOeLkH5FdIXxZmlKcuBOdDPwsQ+VRd+CaUTB9/KhgjQRTHsk/UP4cigiDBrrA01xctE2hR6c75ywKwi3cWmtzZcKRpOTAbfUONavLEE/6mSgBH8u176eWp7LTf+p/OTnNJYM7LLonxCrdZwpCidt7OrC6yXSOE0/t6ZMl2zFMLDu9j1QCYDyQTTOL1konZTK+S52ss6XbDPiU+AYrI1Dks81W+mIQeTJZ4aAvkgx0Eyg0NFYPv//J/2F4Y5GyJHt8/lZZgKGTZN0EFwXAGZAo5CYJyL1+eKiazGXB5JZHKCqm3t4zdn3XPyb9goC8zbCwnKw8MrSWGLLuyk85vFy7o0NKNEku/O4TTSi7uixvxXx+ac0nXPsHUwLErGNVw26dfr9IQkfwz9Bon+uR3o60qhIKey3PDis6yiDLlxBz2cCrMgbe6hM4HWpyBdoOee2F5Aqoxb78pzC2wP2OyIO7NUWtQKn8ONp+D1d3RoaA5B+ZaxMCLUQhjCM5ccPOFvDc3cmMRzZpX1bk6ebYdaGVRuB6AoFafGnMJDJbSaWt2B9hUg1vWzK5pHxR0tiPPIrZNbDD5dxvPrgC8EopzeTliqw+4CPy/55WZy9bU6DHBK4PRBEBfjYkczfy2877inmhSpIgvtNzIeg+sXzrTN9y8dvPL3/yPUybx3mdclnO/BzDz97pD7VTk/gUIg3QGuARQLARNGY6wD6J/LcoqMECxtJ7Vp8lkonL3RNZrTOmz3COHIWC16/vb8pZVUXmfWPhVnbSQovrbDxDL8xW2aF/ZyDzZcX9oPd0/T6ZmY+LI5VGsaxDE89U2rRXgeXN0MlzbcP8tHpjA/aAdfObCUla8Ok/3LdNaBfKqqYwJTHBSEueyXjtV1xf9M4MudqOYYVyw/0JXflthaSwJ7QFCU4WC+ypdhjCvgxSTO2OoqZaU6uuzIr4tcvNZpV2q+scsJaFai9g3lzEp32gr/ZjKGGqwgdS08oQJWiR4DN89LTTqAZIKpvmcAis2u0pymyZF8dC6sx3qjm8IEHeZ4yJDd1RZDvsF957rxTALjug8n0oIi2xrMl8Gsrg0WJfynW//3tZ+JN996wR7/KHFeBfpIFtcb4ARBkyDHFRmAzIzwTzmIAW1xkcP6SNihMDWobye/XiOhJq0aNjGwBaXxXjge2NKpVQv1fB/mzx1/Ro89H942w8XUKjG7AIuS4mzIo2uq/Ba27kOeyMMwrRE5veeEVShM3D+gTaHkA/4CaNVbqWEoJ2VujuWfjC8OQO63jdkHBW3RY1+MowmHWyeKPmbRGm4vQrsI1edk4VboXElP3u5lt3CxpBhjUpimj05Tr6mV9dRfhSSVQAnEGxHJI+4RfCwyU3gRcVSQNvPTg7Elv0HXzt1uydyDMfeJ2ZUrY4J94k+wLcNWli1H2PdI/zReBEpZYbNlUOwzeMj357Mb143Dt/ie6izHxuYYRBaEWxQZ/PUUWqfy0li+szuePHO+kTV6S5CtgKy8CC2dPq4YqIz1fJiV0Dim7UOkE4htkF5njgNIgqp1rKe8JRMwYLiIlfO4/RrDFWN9TX75Vrcf0FUQxaF2VFCqbdDHKPdVZH2M/buWWwvEmdoNAD6zs12UeJCXuF6NpXoQCngRYGUR3m2g7xx+5XXpnhY+VoVpSvaY7RfsJDODoW4UwquB4RggWdWyGcIHwp2gZuDGGA+HTpnoaon/hVDcNL29b1jj8Mln2Z4mrki5lXkKEuH03d2sDDjjIWz76nKWDzwYOyjra1Et5Rqy34PKGZFScepyqZ6vbXmldSQAIYiaPhy7SQlJMoXeOV4YJPtTcvEc3WtS19OmWYx7/I2Bf/DKKaveI567uEd/acPbLhp2sqEPfA3OUpgfybmEbiL5jRf6GvvrvKs68b/57nTji+wHqkwyTZhBnFzyY80djo2MxDQHekU4W031AsUT+T5O92fK4UZyj0HZAN4xMXPCKiCqok8kOfsC3owbR3N/p2FkClxpgHAFpAyWl0EwQhON77wwzqz49MQvyplyiXWySJRT+UA9uJDzDvnQTvZsPA2QnaXeHvKKSrWFCgTuYqwMYBNlBk/ZHFlr/fgiEf37NnfRdlAYT2jvillYSkYzxgScETLpsZqm5k02+lvCDWjVwxs/dy4nPE554Y+y/kJS5or2c9rrB7igkg2ZQzDf42FewWuikKNNzh630a4ybkrVt3n42jQ+yyT1DFik+CThjV1eDsNf+PIqEZChC3U6LxRwmS6EZKUb/1Yi/pSP/sSqvjbfG2uvv7mEcv5qRhuPg74uVST40pbuYlZa4mNDkTEM/nZWq8bBhVz67zJWr03aTckxwMqiNG8Bj+O8ngQVPMunJVfqODA3weWRsyuI+7NQ3dF9RIwaV85Ru4ZzCk1X59mCxoeScqJpnJ8kittNr2fh5JwMVlHmgsevQLw/uJWIDkta1TQ19Vsl+OgkNtVkGeOjbHoGiAu5DcQkA0srwkOILcMqoHNKoAf8C1b2sE3SWU6hy3iXykqWrywAL0JRDHLPNGgEjiOVjbg8Uc4yoZzXlyFnCcpNYXlT+Ir9y5VoC3LmIH+Cr94RE8NIKMh3ILFAYQG1IOw9S2RbtiIne9umfTBG4qynJwLmRopcBYvHdIhJjwK7qoRVAm3KsChOLG9Pkmd8K4rx0FdmaXIr+zMgqX9l8rf+Bf2fF8UlTv+9CnwE1K8SB2dzW1k+Z7I7h2sz+hmJPw3q93Mv3lpQF26CbNfEP/zT/0zNJGzR79o8vwHsDGNEH77k6X5S7KEoFZtL/LyhDhvASBQcQpQgBGF2wNuhBD8l2SJJIhxvxlcvQCshJ164Opc5B3MHFe7Fi8tMfaAOi8WzG5qUSmlRthxA3zWTDRmvSaMsWM9jtoQHWwxaEBeYgcAGC31HenPB1iXoTEHF4YVp8ColEw2VOJzI0JijiIAjhVYVfOMZ8TvJC5eUrkvlEzQ9jc8fs0qs5nIM3A7qabzr6pOfh8uhNjBZbo0a1ag9xuWE1N+ELVOWj+LQwvmns5u289/2Ybcw+w9aSlqSvlLZMiLpPpu5oAxgxRKzRbxvJKVm0nyuwJdo/nTkx6JmI/WG0i9kzu6DZz33TyxQXxp8umM5lfT7I0WqSl9X0+KilkFotAzmADbfDrqL6ATEpVcL5fOClE8uFj0yGZLqVyQ/EPfaflCR/3xVv1tHel7x5pTLMPDjkavGLjDX4cRgRBH3XqYXcynsx35WgrNk9LnihUm1oXMpqs0pYaKjA/yAUgaNDrbG6e6yVltM46J4KmhpVVQ62Muz71DwgS7fm+H4CyoGkR6lFzkgmJS31YklDYvkVllAIGIkNrJ8kFqXdb48A94CbIeprpH3n/i7ntI16G1JPHpLdyRa2AismWFegq/8aIDEki8uXhTjQmRoQvl7+OqT9NVc+P8Xpwi4IUXRlUJ3TYuKfK0C8zN0uZb5einHZP86XIiBONpNs0gsJMHjkuHdAz8O6XGgvN6Ll6Ea7GnAZT8shd+YpZOaqC4Lb90pSs5FjBhI2SjjKNmibJgpRkU2LYFCR0svQBSLsAKWIacz+bDl7KxZxpwfK/Lku5Jdz+G/B/9jztGxIHbTdD26Z0Zbi7KyHnoFCVgoMBAokaHOmzOJnILCsTA8+saWF2u4wMDBuuQSYF+Tlx97UVa9JHh2nS+OiHMBwy6sRGBSkQdVmsvEUV8zoVz8Brk+8b+NzgDbOlFXT30XS3uL0kJZl6A8RqxiKeYyHNaBaFBJBqoigbssqOP5VuCUxXUE+BnxZCDp0sUGikNw68fumwUWK+LOTzHOo6whnq7T5JxtjcVxQvIVUbLYMy1sAnXJkTCTpjl9sKrVYpgQOBmJYIdLCV744exyiQYSurGnOQl0t5WFHCn7yWPOB15y20U2599lUzsjVyDI1EXd9Hd183kylpG+9lq1v1a8P2dnw8TSCrVACN92DmF0k3BFKItUkUiwxpIJud3yR4/BcSfcPDM0T/QtchLHsiuT/FvqYJlMqvHGcjv2bP80lb6y8r9OR7LUrYHperyYlWTIpQmUHJjpxcm2PGykqB7VnxLRI/KMqyFWZNiacEcTOU8+WGEPnvJ9Hb9eJg8WZ88dE2pKYdm7NMOrsGCB9NdbioI5nCCko96tEGXnBQTqn9ZaE/lbP1lvEr2HygEcc1zK0NZM1sfo2n7mtzA8LhP7Bss+Q2uWl4ytz2v0Xzmm8UZ6WxLHMb2opPcb6c1EmctEmdJSDL96gRfafIXrs22pvJSEfziPE0kVLGpn4kNSHUD3SyndBNKxsTsVm0P1gen8fyo6KsZ/NHV3P8iezqa304KSRieRLDKJGcKoxi8ArBt4m8UHsTYbMJ5gEzN5y9YEH7ZpUJYXLqILgIN/HIeb5nwD3cDA3MXdp177Lf38xyCX0TOf4jRm8DhNFlgoOJki+ddp6vLg6mm1xvn73dLUBGLB8raAdYl4V41+lWAD0yyw18RyNv1VYuxf9P80MPNZX+PFXj1q9GHtx/wZQ8fIX5+b9wdIXxX7ILzzSnOfKakXja4bZWHVqpZuRZOMmMzoX/0VAs7sz3Oq3VXlsebG4jZt/8quvEKD27NFReEzhrN9jjPgbEJvbGIZQ+GBqycJV9AzGVo9ddIP5AKcm2BLk6UCm97kNU9yhqT0CMgNPLgUcxMkDWC+jVOK6BHsenKwW+QqN+Z4FdOTK0nrelo41Z0RdCbSbQ2DptjN66LkVY4zphvlhyzNUiQBFImJDWOHaSqQjqGho+mqerQULnZ14kpjG5jXvYzmySd4cEl5AMpXUhQqY6IxyHqD6GOo5IfBZdl4viD0DNuycPoOjySh78vL+0w6H5PBo1CV+DQnnZWN7SZtZCm44UM5lVWeFDLLj1SnIicBDQwI2gBVuWsyCDmR2dkCMcv9GwyjMX8FYSZMNzQQnDE0h6GFkpRdrXLT4XMd6xI/uwBaB9AscSukSMVOsfcQ5B4tjP4d2LyliC9T8db3rWyNx0648FVaGDhf+PL5FaO0BdZsYgI+suBdpJ+M+UkvuvUxeDDpf3698ZvZNIc0f4n5CEy16O4TKX4Tem668ip1MaFF3UHiWQ7fTyGosF+5yc1X6qYiDs7SmQSIgHxDXYr5XMEvqvA2YE84iF6SHw7Uk1FwkM92yxLiKFQ4WaKNkL86xXNFFAO2B2H6QjN9dYELs5d+6cKzYf52GdziyKWiB4BWA0tzEL4XfHXJtUhefzWZFowESe2DILeXbBIJZ4S/oViySHfUszom6X8Cwi6pfKfWdt1XF7K2pgps3v+FX37T+5dyPL5eufMOmr+WZ0fRJGLjQC0BCHLoGbcLShyF6o0nksfww4hdyxGjJ0+PXPmB/msO87ayqY4/sWqT4nTjWDe2hOiAXgbOj1iugd33sbvkaUGQTR3CWKCwSyLMKbp+uKL2gskonS8YnVy8MNWqLn86g8NK8od1YVXTniodzMH3XZioMJ6njVzO/UqMS0BNrR111G+a34lMtev1SsZu4gmOK1+gROb5FYB1mFkRaYD8Gyhn0WcUplOe1zjri9EC84FcsTg+B83LzkOj/Of3pXe/d7k1V8Kxb5xSU/DKCHtV/mQJLt8IeVuzP6OuRYAv8CYZtENTyJU5OCLJHU6Ux+ggK0pfZFbnLJilA9N0CjKOwcZEWUujPSzeQO+Gmctl6b0oyhOT2P9cVUsAmqCWgYd97zhwfvxQLmbd9mL5fI3lrySFthLWgB4oigVfEtiR2E9eZzKj8SdfRGo9W6xGY80cN5LVObsoKBPJiphwL5LrY+zKhPQdeAd3knSdS2bM3ARHOlR08SgqyJ202NcmA9MspbIiziSkj/B9BHJ3kqho+TpozSZpp1HIJ9EGyREcEsZaOiXQ/iZF7zCm8UpVZx2REvDOE//xLHhlK8Z7UqpD769ww0kKGMrfarWUvgYMDYmyDiERBuc3GOqfS/NadBtpytw/IpIfxuECCQNU/lGg/p6Icu54wuwvao1LeW/qH9VNeT167yPpsynv0fDWQzMSEBbJrIHyNVHGdKZIrAPqZ9Ospf88m/4kKy8ouD9kxETbiUxt0Y7lNUzbTbK/k011pskctMFkRhZf8NxoTkg/gn0Wb2vr2/7z7erefleHaPpOPrkaq6pzto8yajFP43/xtpxPSFlnK2eytIwCJkKb+DqnN8RYoloKcnF4iNX5dgx6pDGX82G0b+faP8BmEkEb5hzu78AgFsqNlFzKF0O0/FjZRsAxBH3CcxIZWHC7JhYWvWlLHSRk5xeR5+PUGx5fyR2VnfcmWeXSVZIEVTKTa9LRinkZpz8MtOcJIHnUsMm/jiwtJb2M1C4GVyjoaRy5xLhNc5tIGpDLPle+ZufbcqihJT1uaWocs1U1pSEyIFxry+03SYYCeKxNNqszCUnnjJynK7NQSsAzDAxq3H4wLvfy50EqHwRSXW2/LTjjfYyUh1K5BiYNkLmlLOzpX2edcUZJ6gEL4RKGEwhOErzwJtE99pBDcjMsufJpJNwWuxsldeyAgk2qP8Rr3yn/ctz+ZWP5xspsnC+xKfwNgaIrL8VW9pDNl6E3IhykORfpMTh2xQ8W/PZ9FHt87ZX13acsBWAHKodZxVdBPlCpxtcLIHhbHsdwtekctuE4YQpR26agDBdmJPM6LYzTAxOP1mHlqsieg7KHD/eDeZcIpGzDeU/JGULkVgv9I+/Oxbz02uFZMi/o8f3cAIRvCxz/yggVshn4j5H2uhh87/te3QYnAJPdwtYrQ/6qv7+hSGWydTO1ZrAdwZnKpJLkztnOHGzN+5/zWsea2lZBKdD5kSRzkJnEPGGvR85B27yZlTUdjdbgfI3NrNTfE+U2n3+eNWz4wzifGMmLiM9eiQ88EuloYsKbPmWntHfFGG2mHKZtF77zCSJv5p+fu0eLOv2TivLxDMtBvVdsP9GVl8n1AM+XQM9UlTuZbkkQKRHS9zD1QX8pWA7Jwu35eKyTkZyPsflUJBb45gjdv5Y2Z0pnJvIU3MrR8AV4eC4XpqCWhW0FKATVKugiBySF5304G8FyjqUdEnV4/xfKAmeOjZSxm8hqF0bNrCoZUAM4Isgfx40/w1V1cnAujcsEVe27VRxskzM1eac4a3DtHCYTqjLfThK5ELP9xiwYUJnjCZK4yliWLQ0kGoMnPzOdTFpdY1qbnWcQuJdzVsMYhtqFNWG42UyvjOEXK+D81F+u2U2ckRW00itij+06VvWjdHPMvvvQ5C6q2PxUiRb2yfIo/O7reBgYV4tqJ8ejAO1bouqKZj75RpG3W+ngUfQCcWvNVhZgNyCVVdCbIS6BO2mhL+g0wLcbSVJqTtLh8BW7vmery2pHkRo2NH9Ist+hN8N0REFmSTvPpiQY4KgsdCS1H2NwkFZ165ur0MpxUaHWjrJO8P6chh1ppZ3MBT5cwO9cxHXJOxoFK4v5d7DzjzTUKGqWYKc9nHPBlbnziGoPCf8YoPwDXjyWRwXu9pKyjbZeeLETh+Hw+L3F3F25ovHD42Rxj+nu6KVS6d7mxW0aOJLPpOyppnb5+a4Uv63UFbFmSNMJfumr7oFWoLRW4e3leHEimy3QdbkL0pRItSPQ7ivXeHjlCn15D9MkzbdNRiAsMU7BGZXIk/R6rFdOwtFdvV8JGp4x1dkhYYu1wJwjTGXMYO0C7T6PoSxLOuXX7MnlbLevbhc1tM7DECqWmGQwu+0DAHJDQz8kUZcePQx3dszM7TnF6uWZeGtiFhGOvx9bysRuyNEzMDtJv5nIDybKRhFVcuHLHLD//XhzLl8e6ReP0vhzQI7+2OtNlD/4biEcsmMZb8aR/rMUGbJGEFoBu5BOarGmKagAoCnimTDrCVZTqkMx4GIEjC5yAgpHYpGzlwa4D9hqEX5+OQdXSvoMP9+OLI3fFEawE1dkTckX2w/D48VYRfBvyDSFefffoUEhAeth2ktzp4Vymn421K8hoXARrQtI+OipuTSgiUftJUmYaJQTZxM1HIKNi4BNA8jIatPAGejWsOaCwY4SRXgwYduPs0KFZ30q56WCYLWbqcKkgRCDb2PjLx1C49KyOtyS+oXg1r+x8sqQDw3uJpIMjJw+eA82NXRHdQcHVpiySQRiwjefM2sZ/7zDkIbvLfhyJX7YJNMzdXNmFL/03/xaGmZh821VASD14MkzpWUvNz41P6CAH7rtt/CFqroWnTvazc+C9s2MP0aVd12HW2UikcKhdUkAr4jlLDjBRGCpOLAO3swrU6rvpiKHrB7Qs/Qsr01ddq/FRwV9YBgVKzUTcr6sLF4XuedqHwnnCi/LYtbgpzzSUhF2hPYNt1e1Uyf6a3oa9IzJA7ax2jr4I2p/U525tHdurpoCDdFRMYu/k+ovU3rojctK0wS0DlslhWSjtC9V84m/CTyHhHOYPUm1hF5m8YKMSuuUlYwhxwt9FA15vMIrNTzAKEvB9gxdctEzhVfG24sMIzYYKJbClx3Y+/vIxkrxML8vJ1bIbyV6xo2Ojby2jitZ3oEoXRyDmd2P5OYF2UmkLzpR6EHzGIZLshIwboLST0HPV5CKi3f09IafM8HVavBnvj1Fye0TKB+7iIOJyqNVXLTosxLmJbN2xMD5OE9Z2rBpmnb+dSJFtD7IReuiaFL8P9P+k8Ebaa6SGzw6lAj2SP2uoywZk/fh7D4qZ43S8+TsMnqug8KidDsfH2QVPwPutDG/gAeXUAKyWWfD1ZToPBVg9RK3Iy2JSd0U7joQKcY9uJGm+1B9vR4sH2dyA0v5Jbrw06Ijv6U5n83V1yfgqiObsjx/G1cNwmw4mYJJSsIA5RJpM6ZBKKUn6N7RuH/kHtIglrFVVDNFMWhAaqEHqThh+BA474QyOhTBq9BoJ3MJz3yqUky65Izjsil2PO+Fop72+IeCCiB96c9NrrzvUpun7VCZUUSX2KULohQtf6NKGHt5cNVyx6Y5xNxYksG1JF2nrMmqim4CgurSRYueXtKdvrL0Qb/fyPkuMZ45poxOt4zIQssWOVEVXuLaZgSrUmZDN4U6m6VrNejkzcv76gXkaVVsySkZ3bUnKSKewB1GiXi+RR+cmeVCeubAZqCsgvTl75gZzUiSoCNFipVQnciXclYPvygr8gyaxyKKyGglqQ61B8PkfKqc6LQRq42Z36qYeisGOvnKVFUL4KdmZ4RWUbL2Nvg6gVOBRqpiWrzKcSI4AaIr+ytZfTuMf1qXS4680SG7cnpYVpo+ta4R1ZCLP87GgyDM8HHKuCIG58ZCF1TT2ZmQfDUuKaFWkb++roMitfOReaZGpyCKRXYKEwO2FhTFjhaeKZNHwAoSs670pZCvEYHpWKHzhJoJ2qZ496kSW4jbfJBJHrhh2TDbGdGYgfY/5TNLqlOwmE8Oq8qhmdSuoB//nEwl/u3ny+s6K8eonde8LW0KY5blw5x0XnU1CBeOdA0JWWLWXTp0jEcCZLKMaGxYibaHGf00Ji7Elg1kGzCCix7KfpLA7tRBqNdAbh1c3RDZmx4d6Dd+pu0f978sFa5I1DXRSU6rfOhzBp0Axy/kO/9CFMa9lxHgd8oWwOkCdIl2xPjWNWXToL9BrO6gehd6FRhUUYGlxMVTwSxOJ1RJYpT3oTNidiTHZTnUwHYktVzey4pbHYR9cC5L0mY8uuNCEBTncvhbjYfCfQ41mc5MPNuWV1I1v0tm/eDVmqkUgDrGe68NtMgqV0XMmDfA1acMLZBphBrrXMqBU02xfAhHgP+Szq4bpi8Nb0RvjtDH5bSWV/r51BoRZarJvlMCIJbZDMPFZeURpACSjTodGmk2y66HLPhI6rfxEIH3FwPTTp7YuDgikiMgAMYUzGKpfqkaNj87BUsaghgu5Pg5Qv0WNhGKRexzIDcAJtf+IZzi9wrJGCsXq7SMVekdrbVo+NvgqqHCCf7NHn83kDet5LdreKePKzp7YiutTTpKxO2QwEDSEGow0V7IGLfMfhU4ISsJkl1l/rW0YjEW4oNLtj6GSQb3YxrYuDYT04w8NpP3dgN3qr8aBUvX8BrhL6EYAfZx7EcD9FRi61BWi+j4PFEtkr5GHdVAfaNJ0PoLAt54fBS2C5qzA+UF6gNco3JUUoc5UBkD5WGYdOhlIqiMVxNScmGGsfNzHszpkgM9SLpVlruQ5QRp5/E51GYKXD1EQYoqPagYsHfMHIe++9LPOcFftlCOq2odd65Fym0/XwWGzXpdxd4l9NPYtOVmxPRL+t0x6qpWoczUgMQIRiOoUHne4dfnLJEQULF8lZ+uC6OehAuJn+VwKS4FxjtuRKaMNDcV28XzQ2AKqo+V5F0fVBxDYhsPa+lvo4uEWQpNN6HXRHWizt+Te5gMSoGB4fqpMfGAJ4OSxuU/nlci5USB+FPr2hwPD4LP+sjMyMACExUt3OG5lKoHsJOA08vkg4306lAaHwooQwdBjmDuX7q9nJ5mKa5K5Cyxqnor8a5N5QLlx0vy2Wqycankfx1f5KUNF8l3wWwlm14PpBmIxqD9wngwDmf36a+tsKBCQ0DjHSg0QJ9BMAbLZ547Yac5Hawr3nbIHsJ8O3r8LN0mUjsnJR9moAQmuXhrQAb5+HKmLSvpDsejAXNSEJqGv6FxjTtKTGfiwVEeOeBowK6LlMRsd13vAfSekmZJ/D/YYjGUtEPDBvz6C/4wYU6OVyWJX2e7Z7xym+kRbOO0YaZrM+lzLSUBWSvTliKTmUKSDSc/MCQFDYGkD8Hpb5VCt1DOEXMY65vkBVK1lB6maDyV7sWwUQr/cixjIm1/h06TWCa4jIWc8G/286SM34LJoQxhAwdrSm4IN87iyw1Nc0W8yEd9pbyWuJgaA0V7E+Wej1an6ctrRSbzzIYymEmTtwmHsWWD2YaccwKDYGmAnQwY4vD61DAzPFhXlL3YzRP9Auo/ci9QvBzjt+bo4DDZK6jOBbD65Ed9rzUFn93Va3W0nOOTqVANARvqqxy/Y/Oiq0w3QBMz2DUIxKkqdgvxtUhuPpFkmKIeFDXgqzB5V1SniiJJURLNrECX8dVX1ss47B36C/cM/zayMnF+yn4JUYo4WQx4ZS5TNJvRH35nURf2I5Au4dY8/r2RAPtJy2bqWd5IIWipoq9GBnQkuuJLd8LpYSX75k6M/6ryX5S6YJbDQZk2silzZe0yURkY3FLtq9GFDWIZ2DU4yEXrdd7H0qVJf+8rDhPxQmXyHfmtnpc5Hn56Np5ntNtVAAwIRqBnCxzCTS/9ZBq0Nb6c6FgC706GD+fWuBv+oJj66zb8XeNZDXqL/GaFT3/ghQSmAuaeKJkqhi7uQDWyeSOEQwXor2BGhywrqldEdxGeUgD31eqf8+VvQqmXHqo43SD2AFgxjD3wellVMCqN4MrrxE3wcppc7Gjf8NmGqYlHIFeEKgVyHWIfPZr5tbFan4qpjaGB0w6nLjgKxOpGuqE4jwtolocFLI8DsXmOtQiHOUlW0ClOVxheOZ8Ov5Gft4ZUr1oGGfn6+sDe7IRnGQ1soMktb1aiP1ymsWpMO8g79/0BbQAZ92LJwK2AZyxScdPzFvA+C8hYh2qZiAmoHMBYkxJF1P6I7AZwVnEaTLpGRMsk8zY0Rv//guArxtLsQAzzSf/5839zqlt1K8fO3dPdEznkcEkutdpdaSEIkmF59eQn+2UBAwJsWI8G/GY/6cmADRleYAHL1FK7S3LJ4QwndZjuru7qCl256uZ8/5zOOf4+SjiIqlJJIup2mEykhCThHgOrRPwwBwTudgI3yEgAtPMoc8g3WCptSH3F32hQ0hITg0/7WnGCIJa7ltS751IGrIGunSjtE9F+jh462PFjEiXtXwh5h6xG9G0lsockV5HAfTAzGGkTWkr9U3V5nkVjoJUVPQbHUA7eA6zHshgvSQz8CLsVX3Jo5NFCNwpl6Wkxk/PF/cNcmkX9CqcWV7rSRid8q0i+loAGi0Ns5WILMLqJ1SHmZ+LilxAZdF2DzRXQ98QtT87PpfsqnBaD+ROjtgcuMtJDEq3eVv7aD5PXidc0GUtLGYiqYjafdKo27ekbDM/UAH5o1+8YT4Z4oWtujqKDde1CiJJMZQF7H6vyQshtDf83f/Lvs2ex/2LWd8FhDtdX4AqL3nDUmoTrOWmpxfZT4g35QwmDVnR4EaYOmLsJ3LoYZWF+RLOL3FsOLSjb13K6Lwp1pKm8twyGC5Dd9kWgp8dEvIkLHinuJHJeOlgL2ZnBgFw8o6vH4mACW3r80JHWQPBmykaPUXlZSWtCTVDPF0TD946jCxf738TrGL5o0bQEVgB3VHRv0evcpeerECdo8QzKCuxARPro3bd+5Youpkh9n3eobD+yF08krYJ3z71kHT7uQXOQDGX5eIHLWbx6LbcdMIigwcjaSBT24uGr8cANO8vqXANkdgV+Gc1m4nqBmALVhzIKxKiG0jzcuOEOHwdvamnZzK+exKKVkqtgxI2LPgp8We5IhZCEU1kNiLE2sVOtQpDR4Wc5LClwDsB9I8VT2gBiTDD+NPrvJjHytzK5n+GuDLQ+KT3znache+M1D+AdT8SKdoaTRxk+W5UZoLRCXp3yNZlsHoMuwruX/MxRH02hWqALM0CeTodfT6S95DUF6J3+UVs47+Ih5WRB9lwlr6XdKdUktPWVh9rpEVC6/8TBq+Fn+Viy0bcMSjayKWi42IS8HSFH8NtJMu2AUy2tr8nDmpA1sdVPp1PSKknGGMfVFD0ljU3QuuQ5Fa107WNJGuO04BJmymkHjs5x9ZrVFtkrE3AbbFxyOQMu8nSWCjFBqQ8TWdQFrvfTwQBlC2J+S91fVztjb1NS6ml0VtXjWGR6wr2I+XkYExwWYN5DlNLTi5yHyH1ATQ3ZdRXL9LAKVseg8Cba79mf7dn2tfjdRZQG5Y0z/P7L9rALfoU8ryHuN4SXSIkL0Ds4aCNS/UsLaezL+fHJVFpFmg7F+L+SqjJODvPTp35Ll8MBNwEajNDVIzb/g1R6IYdH/tkpXsY8UzYuQFqZqtNNwSjj/zSIJhYvqqinRAO3usfns/6vt1UjwdZJEjfdoKYOjJC+p9GPiZ2DkDLc0vLfAom6ronpQzi+incuCCXpKCdlY0F9oIOIL+qDJefIlKHCN19JXZe6KqyMoXqZOBNFLUI678meniPsOpuhZjp3iZsUtI7Y6mN4NYXpR7yTwIcjLTqLz7x07gPpmqV5hukUTu+HXiJKHTpJsb0Nq+tusxyCrlo/NqN3gi3D6lL4wgWbX+AMBwOK2xnR6dk/HSPvtXgrgpuy5vN0UKfyw0TZYKUr+XpZrGS1jXPcVpMZQmCdOqdRbY7nJfs4U1bOeo+Oyfck6RfjrYemKWA5Qrg49z83L/B1B+p99VOSjCzk2HQ9ScZZ2LPQKsKjocAySlV8ehUvWtKCFJGGcVwl7IeS9QPHzaieC9wLnB3jBcTYXHjSGGlzrpSV9GWs1kF3HlhFRG2pPC+fK2RgsKqQ9YUUznmDjhYeQjOC6CdoeDsuVhOsqABIloFZCKwEuB4PdBWpqN1h0ve8uoc0ipxtVJCE7aNZifTn4608V4/JCYTF7ehqxynU4mUFnxjcwNLja/9sX7QusRPR0hKbK4PeknzeBxUd1YTwRvB6P+Fn4K4E3FU4dZF8rQTPrIyvWRokGPdU0gxQtZ5UHjmjh0BalusvgH/myylVNHxVVYxOzIryXiHNpnSjl0xPYKfGazuJeZ/hD3n/Hgoq7OapNAux9SnGP4meb0IFFdSK6i6hRZfoSMx8SFQOVyzkMblLgvhMRgmaztiFoW2LpFampwOgNXAqgbc534gkf4a7dVSa76JYaUJ+d09PCH6JGNxEgcp3Y1Xd1ch3WUHgRpkxg52ZojKlFci9He6t204MF7oaeCa+PAd/GiqfmO7vAs3+kXjF4UJA86/l8wDc9EC16fyWUVqjy3cxzrLuEJEyVIoaY6gYhehL8b2KyssyejRRxnLjQFzNFAPC0yl9N2Yf1eFa6hwMC2Ocomnil2WHJ0VGc4ipKdA0UXzi9SHch7z8MEMUSU5gaIl3E1RPYXEQHYWk0BcqBKM62uomNiN7e2DjVqaoIAfC7VJ4nRhHGtp6KCV1m/xcKjpstC91TxJjWVn+NHgasud9+m+z/heSBQ7po5GwS6gE2NOq2gfJZ3cca7N1MTG8Aei+lebmE7KFSPZfBO6p7j0JWZ41c/I8ickqiXx0oqG2ka7cS2I9FRO50VdqbeiO2ctr8C+L+Z/vR7868b6Dif6jWroYSxRvPk/SUfJEor4kKjq9vhSkKsklaWuShiE+SKE1y/pG8pMpGBBwCdiooSm5UA+li9+5qs2ZplRy4cMBvIDYjIG1Jh9lg0yOrp2D+T6/xKgoQJgVx5fodjCbDOnxuc1+D7Z7MzMXfFuq+8vSzlvFE6l0lZXVsD4GiQuzCynbTnrp7GdnyvkvWC1JlSUJ3TazEjxm/npGFBPSiuNTR94cpiUcR6O0pBKXib4GBeEmSyWGR7H78qR0k/Ic5fhWuvAJPjzBl31IjzR0C7OXoD5OTkxxnmCV4HlbGUbJ6XV+m7B+nyGfVQlwAvH6f4+UrFpPagGE8jTc4aKWC3tfh8OMTKz/DTgbEN0nhg6kkUgJdBxktdkciDtAenIT/PNrZRiQw/1Z0Q1aqtKqhxNRWq7xQqHuLAOjJUgXux1upuFY4GspKq3qIgfSAFEJ4CHESOSdKDDoYMDqDjVQwBAkBvEDONYpK/FMTp5KycaVMDvBRQf0Fw3+x1owZ6M2VpukAN1pRXc7kTxGvofje7RUD6+4Fb1Ql6dIWcryVbcvQGE9zfREwdamr+PpqlLKsmYB7wd5Zz/WdaPuBu7HelcTSiUuZDwOSByE/Gs1P+GXlI0Wea0OfIa1MWpMxa8yQMoBzWTegzRDWT6Qlg6gb6O2QW6MUzxTCgmcesxOY+ULqlRw47b4nvBuz/nhd/RIAaHKYJkUTgNTw7td+MUO/lNCbsLC3w0HN0R+Mw5eVy145gd2LOwwPw3I5L+WpwXbogk6yjgzuN7x45CeFGTik5Cl5f/HkUTMFIOVZONnqqNgpYWIBk/vkNx8VxwXLq6hP46XKkaduuNqqYn7ZV3iAkeC3z8i06O0aZFGAXvLSTqFDRdEAWa+2ObSrh/c6hNzm0xjaDGyPxZbd4ztj4LzRHp1Gaz2zTlVJAC4OVLnoV6VUkA9yJKEabuiUKL9j6eozD0p3aexNcOpK9dH8i2XpnF4ZqvyjO9UeSclvuGXXCWYYyNFwGrkvlFDXWYprGbV7aLnjdHfcdvaBevl+Ds5S2/G8xkHB1Jk43wsJx1VH2IaJ+2x2IGpHUt9IFNFyGWwJKNJEZ4G8MF80EtQZVcxoXrWjwebqQkkH0CxgGId+x+iOSMWccw0kGnT0YK73BNexjdmdAMGX1kmVFOS6Kn0rcWOQhrG+SWEEoYRICeesSTrRBo8yPRukanB1aorrqh1ImMfHo2hG+vVJ+ajMLisKN8N+RCxE704SUljWJTe4WsE6oCocuJlpX4e5w2YscEV8DOUAAKGSySRxL1I8WboXZKsBBIfp3UDjE3UXAIZP6w2FXiWShyANXwJ5EI2zhEAA6HaJHZEyvF4LHxbmvPVS4qpz1csdJqGl2XpseR0l9T/DOLNZeUHiTMOLPka1Cb81Zwy8dI7Ju3PWDFKXQb8ptNZN0OdaCUl5NDrgZmcplxaXlBuHCjf8eA8DRbXNSzg+zNJLYFzSseFdInEniBvDf+W0EoQjS1fbqmSyu5PuB2AgxLSuqIQAefzSfuDzHg9kTIh2jfFBVNcxOfDyZU6XIoLgim5CLhiJrjQPMKfq7UU2NuqORZ9Faqf6VbN6RCUcwiVkh0OpSA5iYR5qfsRvMtZKTbHLV967SGJ7N7OcRdCA+nvkvQm6hJ0ryPHqnjhzpbz2WV//I7Unpu2sqbILlp0tM2XrVmfn3lSrpI9WJaTNXavSQzCLiH8vMqyr/DdrgWKYOthlHfp83bcOokLHypKJb57qinXgD+dOMvmcM0EjSRqpg7CE53pdZjxAAQAlBK7wZjhFMZqogQDwvNklulLd/8Admfpker8OSZD04ymLOaQG/SKSotZ3hCGrSZaDnZLvCe7f9Qjm+Xo1TVUAxRegt4tnttOHI/MHQoak11M8vNpo2tRTUxGIOMZip12E7pWiFRE/lN19tgu1hGYMKs/g6+eojUjc8dMgjsiGaGiLMWHPOOByyupNU9u+LaB9IvzkFiLPK/FHZ1nrlTDBYcOvSVrS3nuKqx+pg099PVJWKsqjYvEvksy1RQuQAy0ZYskLe/wfIYKyuIHsp8HVxfQi0F1UxAB1p4Z5d3Bu4C9rc9IDBSbQiEaV4niON9L9VePwj9XtGUn/fvvA0rUynD2G4xNzaiU8GAgWgNeHWu5uy78GPFLos1w9AtteexMiNxeN/w10QdK6YKqU5p1Yi9hwy1F1TlWOfgNycri0sgBjauX3Gcop3E4L1GDpTLxowRliDwF3p/TcshzRfH6W+FOkJwyVhSH83oGgKxt2Wp6eSOp30JgQF8fpsY5fsChM0UUs1kTDDNiTkI3XsdfS2KCgh8XrBkhNBJJAQ7rmABAF1KVJu2fRKUj05+mEaN5Ep8N1fl+su+Bi4yvd7ihG7uxP31MMpiTNYNc/PW0m1NNSdrM+sOz5MCNRm58XDdLunoX2xcFE78HS3qqYHJ6JHhe2l70n/8UTfOBhURvEjYi+f7fBW890hOip0KrCGsuLP0YkYucvBxHZhSESfnbFF0nM5WEf2lN3utth2i5Dzr/IVvqRYHrHn1Sm25MMz2EJ6Jx5cQOeNpKFu5lNqvic5HQ55GcsHBend4h6dawMDamCRJtoRZFdEKShPeb8X0kmS2UgPQptEYZsAkRvQf3I/JT26vNyMn7fA5FBgTjc9m4F51nkpCAWwOYW4bjcpCTYCJHdpdqMdTb0LHw4CupMc9DAq+208o5PXouGOA/uu9+t6mFNFl+CqcN2lci3gBLHe8ly1yXuDQvelqwPTZphwxPUdlS60OnPsXHYFzKZnIykyVGUyIMQT7gBSUVJ6jZUaEhqjseUdczXhUYgszqHK7JjyNLP4jaVqQQUrgZtSeyYyf3hma4E5GbIGJweKnM8glsG9n1waqQ3cS3duTVCf5/1VijhL+iBTcsZeHRh2mnOq2O9Z1OGVlcr1K7QP42qb59O/3kqjD3dhTexblS/rISUMlpJPiOB099gX+q5zRmXCqtA+F+zz7ikM/Rs3mY3PSKu1j5Q/Zqat9eyaUN4NejUsPfEMr+a5zfDbTr4TeGpWJtqIqZCT7WUjPPOySVg/AcpQsdfTVrNVVJZmn990ZI4XguzW46HZAGTWtnT20Nkuw0aWzL34/gOJ8sXxPFFVZM8m6UKOi8gc+QYfhI6kmWN77cpp3p9CfX88nl9Bwn6gPUtOXaMdI9eOom7xWIcRG6Fm3ETAby3sT/wZoGbjC7j0ACJpd6ZEiLDugPhXfl3/xbQKI/9cS5Wj/ns1M6ucFuyfboJp69DknJ8A7VnJCSQdwuAkuXpWLKZe7cCHiEQiBabyqFJrkbMMOanjzE05lTC/O1ITeuptffJU++g2An837dXD4JGAfTOfV40fen/OPPcw/m7et6xnngFzm61Nykre10rPW22wn0ZA9Jq5DR2P4h0QJacfmwB9vXYZuQf5uGqxX9aJHYOcw04Z1TX8ere0JrMWU867y/cGC5NwUlx0kiAxlAz5dZVskV0WvZvxFCx1FUX4RTKdThwjR95sDyr6yyAY3jOK/ElwuUL9FIY2ke5ooQARZ4WLOlpCDoDMo90T3kGTdqV2hUpv0ZYSHfmKaZTFw8o72/CScI1AAsZOQTzLuPycYSCuZCTwFb1+qvL9neAD6Y0gzCiURnLtFi/h4Ur/ME2LTuBCT+G7oxSEiGvx1HlTPFmdPbH4iH84rp42Nq3CmAbypqqxUHHUk/w8uJSLjMR0mWA2VsX1a1mUUqkgq+V9fGZLGbRiJhN6zoLyTXtauvSWUvnJXoyV3OqvYmR1czZNZRD2jRDCX/xfwGhR+cWJGM31F/7s9IYvmNXY38xsmakrOJRovJByRowWwX+B/18+q6a1IpSeLZOcwc8SuUuAGaX+JJUe4+yHatWS07LbsJOc2868RDWVkI4DiFg6nYkvQUicEkLRaJSoXaiHSX2wkgqnxT52GOEDkxj4G3xE/bqFQAzTfAmYCtbGD3pd05sJyh5S0+WpOqCl5v47Em5GdxKWe4CbjYyNpbqDbWZpdskfi/4fLp3LjOdC0Qs7fGTAM3S/5G1rhaCHpH6vIO03+DWQ1cnAH6Q7j4gufnIWxTcq34jfcL+UVvKiMDgItC4A6UTVk4x+jsTngnFJsDhb9zxzB6WxJ3ZGpe2jMiZQGdn1OOEIgqAlYYGAJmoYab7pZVpcaXqFsaGdVmNB56QVOpvYbfmuyc81tmRtnmrxfQIy8qRuDra6TdVq4YGOk+mpL8QJ4vumd/alzOPCuKi23KC6G+7hdj7Mti0DSDsbTjZqvtqe+nIouaeXOOgzyIjw7Vr2Pvtt3Ia6AdwXpNzpylDiF8xlIItHZopGnPiDOVYl0VzQhsB3wZqk4CwTUGOvT7hKZA/0N8tkpuvGBFLg4Z17GUXZTCaTA/EFpTXHuguy0LDqiC1+bZ6Uj7LfZ/ntU2VxypQvTA/J1pNGvORg3Sl6DXp9TlTg5cEL1RDdt6XGtLyS44ZemY0Nk9Vi+G/CfCnDGlDPDdf/3v4RwXY0WoYONEejnG6ES6y9O0BftD4lxLH3ZmuYTvNSdtNV5aKdQ/jl+8j6XH+OGSf+1Zp6cjGuXMBbZQEt4aHulgSAV+JW87wLmhjX8u848wMUxziGshQn3vFSETDj4rT65MrWmTO+vRLgXRUlD6Xhu3xK2Rn2fsbU+yeZJtQi2nHLaoFcvrI8BU1LnJallJfojshtm7J8w83WoFsx58euErQHnc4vF5iNtxdBJfAwwK0g0rvKZ0LhBzcvo59kejeA6ZN16l2lF4+jzuhny1mRo291vposw6EdqNZ3cqRrJA3jwIP84B1GDPeZqd1+KUMJ3EY16yUElO1WriaNpUcOkVuHgKs2eyviZaG17AROEy8+BbVwLwOCXOZqI3JVWCB+fgMzMkNthdl3CD8xi5hxREdLEya68lpOYqV06w0CTmity8ZI978YDy50Npax7ce+78ogwfFGTrn4/R+Xycjp4HaaWRmgExRzI/ZfoCUOqaI/OFUDQ1OM7Gd1zJD5FfQuieD+OUx1CNceGj0egx6bpoqZX3/TgdpNFMMYdw7Sb/g00pEY8OCjAD4o/DEwuLAC3GqHOtRCUUMagpQAA4zYGdMB7sKcOCqHrAryXejA3NJPksyaB4Z5Y7/SI5XJJhTtYX2PoLnGKw76X5bVklXHzIbALwWCpdZ/hRGiciqSooS8s5lBTAMIMqCetkkFtOt3uFkQGUGMQknWgK6cFqTIorcZrFZN1O3lr+CIxewjzh0ZIYFUOwnClzCSwEIILhkQaPYh0A+Y7UMaW2EuemdDFh7c+ZCtJ8xrFx/p0/Lrwp354kbyJwds3qtCDxAP/lX/0PN94qvB2fHc5qi7pYovtzoESlUiUpFME3FZEsKqV8xNb9IUCeB6qjbGZfXjtJxky+XEvZhr1+bpID5lzAUw5+2nRKf+j+ct+/bmnFllJ6xvpfOM6hsXUtF2zlsBxDDG61ZbqX7DJVUUgyRvU2nrkiHbPcPrweaUZFqPPOFBFgMAkQJANzhEQE68Nwepp676JJGw8CSbKJAvG9YQIC6auZZK5hdZ7nSqwsxGSRH1qcJmSd86sxzmSFNiYjIFtdWugkxpxUwHGrrJ6dzXBDCRZT844Trtk4ptsBePeU7YXR7bdanuOui9Nb6dkZKiXEeqfyIfrweupMxIt5wyuy7FZKi0kWQ7irDH+V5K94Qkm/LtaqgisgbFLUFL6Fa4uwn5NqVBYZfKhgmODGQxGVJRlK4yPxbkZJe9e4w0PlhvRuyvM18CPo7cr0tBgZBWGtOZ+clr8ee8bz0r2l0P+DeKtH7xx3bttUlsBZCR7Pove+Kz+2e782ywdSlE2pP0+1DzTFUqYtsYJjwsV5kg0icO4TBEB8gj64AhaK3sXE3YAzxBdkVNZZz0MLOTS9jFunfmmfRNlsUgJmCSsA5afM9jhvhfYGdf4MuaVgc4QKA/idw7Kn6NRVxApd3WGi4vd3LfsMghEnd6XFWsofe6ddlYdcf02uEa42kxtS8nZRbtaEkcg3+1FvwfAv0kksSqe50iw5jbHsBaUN3e+hoIBfqmBFBpsn0ospjwtwkOeqCiql8LmaOamOyxrxXZR7Yay5wSBNS+vSIC8d0ElZUc3ddDaBZOTMqfiJRNyS9F6VjSkYK9wQ6fY18TpgiPmnKP1HC11FLum/9cv3ovYWZHGwds0vjpWxHH4Ua5CAnp+/6cz+oIonOW+1huv/VG5HlDWRWhdHBSwwq3Ml7zKlwkexEKsC2GD/HtvS3WJh5oHCzNfNAN5m4okL1Ymo5fnBMBmXNFrCuUb63dSpJdqaGR0s4tDmDRHnc/I3BA572krCWkPmjRnzITfgzJSqd5WE8v4Qrjq67aN+j98domvAB3cUaSmaDaW5X6jW2LnYNPkiGQfi6PvoVsO458ZvFPmoIB6BcGDRJwkmS7EqCbs+LdhIGNw9zMoMJW2QU1JtHffmUJ4H3FNxJ32OomxO/+xF57tY+VbnH28Vq2nay5vTagTGdP33ercT4TQoSJN9rfy0gebn2M7bzGQWnxu68YhtU+Xal87cQYUVIxerCFQu4ZKrXGFGAFzlsMEmMzUzVF3iYP5/R1bjDM1lSZzA+a3ITCW7D1feeT5Eg/esnJKGZtIKZONeX+UQ7ShgLzO8JDvN1FawWIXddUW6QFlb9s/jt9RQO+a8igwB2TxD16KQS2eJmG3A4hTUt1Qzm/Y50mekMtATl/fr8nQG1lUeQihS8OnIjFrxZYbMKKv6WEagNUdzMw5K4ncT8P4eK+5d/QEo8EbZfyBFOB0mAr9VbrYjPAcP72RGNMlPkdkXNUdypqmb8DyPDhfBukrFZnxjTz79Tur1fKtQfuBdPz6W/14f06w2uCmZShyfKpen0meXXqkI/gamThBtTRC5pYwMCRhCvhDRVFxIWvoUPJ7QuOmNVbC9oI/z+XclnqvxsofDJeL0SYGk+iB5EmnjBjfmiTSGuAlynQB4adNh/H5mfRuXW5z1MGhGhk6IAtF0HG8f4Yap9g1YsgiTubfAiw/So5JoJUk+hegrY3AQnv02s6hTUcShJ0oYJATakCd1USLS+g13eGq8mgd8yHMWsEPARoB1RIAE1VGUjVCFh/N8yZXSt4pzEpsVMslFN+bUvg2lMy4r+HlZ+8HmTB4qvyzjBsIPi/RNyvI+Dc00OiOF40RjMHdTGB+WZgPNI6w+hgYjvJUSIngds5U0cXkMmZEhSla0TlD5MvIoRJwPx8H+XGGbg/HNuH5OtVg1r/zrbFaaJ3GdOV6ypcAhUtbdBHRAf8FcVMN6UW9P/KmkVBpBgmMlkfIqkzXxdQZoHVhb5a9+TEnBq19HJGS8iU88Vj+R1u7wSYQOAM5M8MpWOvFwY89YaTnPMVwo4bmlUGPF77UOPan8mTwarulWKlcuIf6L//XfuRNZ8tGUsW6BPwricaKmFzyX0Oal3nNRpq9+5oeBopxMXIuTUtN3OfQglG4iZYRGPTF5jspFyXJAJyPiodhSoHAhB8jnwLuFxzURcmQdq8Xf8sYLr3MS92pUmiNjM5UpqgdQngmPw3bMrSWxguzeLfZacVckaW5I2ynoOez2HV9FqOmQigxnaynfCCvH5tl5gGy+Y+FRwCNK2o40NwL6JT5KmWbi/MMIrcizT1O6TWYNJPUlekpWAh4t8FglKxQc/Jjwv+jr7/nXFlBGWnU+pQuJ/T5LqwAvxy/UWKqAzzB/AY0jz/9MymQwT1R4FcFyFbDF+AX3V2fm+mV60dL4Zar3IVeINobjgC9qyPs4umr42AQrrnxvOozPwtdUm65kp3cC24WZQF7eYoPVRLwXVW9T/K/+2f9IDSzWGd9iOiFzsthjKMmBch+2CZj3yNJBNJPpsIiDR2DBlIsYXqika3IFE5wHYQRvjePOOQzG4L2D4M3AH7l07gYCd6OkgrtWInlkrU0mLrDGyfwd8eymNfpkenMkuxcYfR82hvG4oRwaiVyAoKlATYpcJRzL77/j8lHyvc89Ny1U5aya5FeS7zC6TtGjVGRLSWsLSjtCvxuE84RkYKiKjXIEfHIEEyrI+gBlx+L5MbEXk+JULSDEztIRl/A5vOV40wr9azDSRPYHL43Tvo4nqDEmAmA4kLVzfJXKo0xo5XgD4nwLnYR46QkgEd7DRKwkj9vp4Fty8sy5s4fVvNS+DbQ/8qOSMqqxikqWZdC85gff+ZUTSxnLtyseaEhPbxVxjU5koVCoxwqOEGxp1TdA7huttkLq58CrgBdxuthX5w95W5Z5ht9q8HYVlXr41pf9dtP7rm5NP1DuZBCPeVVEq1f49cxZPFG3suKdSfYfaUsDMU1hpT9bs5XZu7PkteynvGVp7TyOytnSuryTMvRjsotld3nKOrKhsI+Z+J2FPY+HgZha8cOu3nX5S0FXs2K9h8TZVGN8UICEQ/q5cpA3avfCOUtcRGI4U+cWR+V+/iSJ8cRYbzgLV3T/a/QiQ5S7MJ9F4JWwXveGPgxhon2jgDmiLsj+RxhIfH4/HZbULy1eA+bK7zTHS5QSAks8bpKpL2WuUmOdXw2R70t3TqykJpwYF2UUl7BXB2E1gQkklbQSSFUt72A6HKbm70E0lqcNkEqwoif+OZ8WJGbIsY7kXhp2gXZTLOz4b3Hstmiur1Q4zkWgNUhXx6F86NsOI8MS8l3cmOj1AXPXcL+SYDnOvFHlMbh2UvyBUVrRohZxmD/9pZl/XwyWkbEWrh/noAHfBsIrRPVyqs+lYkbFAy3ChsNV8qVSHERnEvbM4D6iswD2MiSfia8YW9jP0VPhWKBQS+rv4yOGmM8KrhxGsExE6zRBF7NMRT/ayN5ctm/uG2edSXQ1pBi/egJrqrzJeN9xHFXBVaBkqAsFeW4SNTA21OMCvz0CTNCzUnzjx/5zdfGId/44KZNrcRqzapuUxikDYhLi8+Lk5rTQINHAg5bLh+cxlgX2aH+JlGEQ5jlsgZwK+jO8oCQ5Xbq45VUVELnw4eeytAC4Be6ptHma+g5bYekg4FE7NXNqO8Q7Vc9h9G0myiO5eAP7lvSWKldu9ANHP4R4yqFJgMgDugXDCggNzlRG7H+Ao7yIF/lOjtcOwug/RV0WnizJeQ0tbcDWCuwtu49I7stn8njm73yhtJd0sJO8Nx8rAf48i2w9ZF9beju4MvG3/1IvZYNifRDeRUT1wDhf3s+HL+BJy116rAmbZAVYfxONe+mehsv3VAkkrBguXhnyAM5Cke2Fm07cZmAMobMZ3ozBZgUcC5reK+SH7LqXKE2/DNNDzseAWTLSIRiwuI+Uwh2AN3vMkfiTArgCsA6a9/F1vn9npN3oB5+HNJL4QovriPtLpJmCXFOvTwAqAr5FtWvhoLBZlKUa980UXYGcIjEFKKuMvAOdmESv43EP3TgFOYJGXuginUhgqR7aEg3fJ8DE6YNhcKyu25h78NkGUqM4O5YKp2gl5geQznvCJNqzES9A9N47d5cBmKP3FRBG2kVBYXdjYh8OE0NOxkZrXa2VAc7q2iSZUxBS4JspKP69hKaZNSt63VCDBWQO2JM3drmp3df9tmw41+6GDRfG1/uFQlMT9KUcR1IJZNUsWJgLLEJuDbG9xYkjtYww7ik/aXmI8INVy5lPQSbZeEtSVe8JeGcpueD4YVEAJL2tGF05nExTrpLi3dEcJAFwLAcYBkAtKxPGHCqdgk0OcRbAjpfMNvhbpiYv9T9+l+SLzv8h6DAKneMy1+WMkqbX0nYWz2wiR6k3R760oj+xReMA/UaMM1Nrc83pqVZoCmXM1Yu0MwoHO/pYS/ECh02SI6mwJE/CMgSSCkIVb0rJLoHTmG1YSWlefiExt0vobqkSgqIHvsXx8pTW67MG1GgITloonAIlELOJmE8F0IVz38gwOOCMXyXNgnLJkswbiXj/U1E+lMOLJHzlk58j594Emk74et6bSvMttC37X2OyRzSiAVpF+hy3qHkyiAYNtWA49+byLwZRe2lB3J4MQ/vDN3OeS87GcQbR6KWkUwksp02DSblk9Yk+I4AbWK+nsgPHUVT/B5xDIW87vccFx5QeIOYaxNZRv+SCFDQGRi/H+iO5zsH679PdguKXxOrGpINkX3KykOe24vIYP0tj7aWMJJjbt8kS6R1zuAHxlXg50uGEbdyUrxtpJWVZV7qskEgHmSb1DSh9BhVdnglonEVaEYrzxLUghHBHJ6cxjL1k3tDOU/TDmhsNEImhj4X4IQGK8Foq6oOOnswuFbjM8BBNl8KV1wotQFsR719J716nX/nKzQVlJ7T/QTffyd7PNhJtqv+DgDsOYRvhOAQVjs085CthIMJyrJFsPrA2BJvKZzP+/30RaU+tRr5UW4mvTDa8HWfdoCZyVyGMz1l5QnkYDvIJrYBmlVtMLj8cLDDa0Wdhy1zxLJ0LMhJmio6u4vwKVhJxhiAfki2ZrF/b3/n4SVnZvsEDza/16N1lEVbU6ZDICvR+5eZw2iybrVVCFXnltVLsx+OT2aWKP5QRmlPepq7FaeWpaAr9OGP/6Ym1GLj/eQJRgS1FwfMU3srSjBa5HHCfz7ivWDmQIe/GfOEI5zJpjwNji006aKIl0xV4xwlyvt59Bdk8KgzTWzOd9f3esjr5Z6l9IlbPVPBrmwswraGTDNbKMD9C3Sd8aqIPGuPrRnEiBbGq9+rRmqxcIdyZ48ZiAl0yj4Vek6YjoJQBGOHY5WvfAvfz+GlOFe8RVmTnU3T/DaqG4S81JTmFm3pOayf4j27/LwWULoug+558oEXZVbk4wYoD2Z5wORV1iKq+hlHunVR8Oe6OxCvswSrOT/VCAigGxx51rtXGiWqNMTeFWeAaIbzLS8cRHfLvz7z8iVB6KFPBwab2uhgtJ7KcT2FPqWwFp77ivm9LTN6oyNuW932gtXhKT+BcBEAKujdMd4tmH8vkYdiaE5lAXubgIEv7Nf9jisk87EPdSqSVNNkzcPgDKi0j8WdOiqzrarDR0YUBo6mozxIPkKGKHQKNFKo5dDBhc75sTomXReXVWC5y+z45KsNggb0XYMMhCoDXZeItyxuLsL8Og5UwrQDSgIYgq3E4vJI7JwlJjdM+3LRA9ivoTaH0HRs5eCUvCjHYy6bgLSp9EnOiFKBkjMNnDWqL5C6Uwl2UlEjVj4RD0FXo9UOfCbw2/W/ZuaQ9xi+IoIvx1liXU3QlwUXIeyl6afP7CON8GNXR8kcM6tZX1al6Kt0OlSub5J+Cyktx0RTCIuUldu5CbctrcDael3AXRWXKEyxVZU+CO6tRR5beEe/DL+M3byi7TksN/L3C7jeN3CWOCpAvQZylvQAwj23cwdEOGH08xDlglcPznp4L6MYu6C1J3VwqQ3yXJ4qaPJvHuIyWIOoAQnYTrU3Oy7KmCJAooYtzDG54sWrAv8/y4GGwVGZ5SVwOYP3zqFFD5xPMP/C7TXM7P8mF6OusL0nowVcgnKFLApMPwh2NRBh9OQs1KH1gwxShAz+9m4l9SXEspTOJEijuZER/HU024sVQLXriYjcKmaT3EaqTnk9vgGizPPv2cfZNZVJH5tabZBoIr0zmtlKYJ2dVysuy9REmR0uIYGm5jYdxfDstkCG7yvD6Fq/b/gvPGnV8/VpyuT65I7FNZ/rDib5HG8Rgl7FDIS7jEkjMVjppuuwLHC3q777BC5+ibJ7D/37IU6yF0ta+8c0VfLanSirIY6W+4PjIGNTjOz7mBiM2kDk/O4WKJivv9cup5DtUe0F2Pdz6SvsTG1+4qJuJ3lvTVzX3q5caPLI3EPovOXnthvmvsf1Lw3q9CX44S/9eJv5ZNPtW+lkMDYt+kXo/cnHtsvsfSbG15H3cLQfnsArTrA9rdXX6+9ksYsGJEt9KYaCMFC11+I2eOV8bfqeok/mgumcEPS4nLG/ReITaKc7044+miZMj+6vI2olhXxqdJ5PfiOCGJGoQ/XTGr3RlohdicUEAN2NlSHJOZM/J4z760KmmV+nRvBpvJnYcnxN59cawlIGga9W+lkn0L2JtIiW/j5SBC9L4fMtANdTv48wgWOqreyyJQzhM0du3kTwp3dyePUxzRYo8A9pJDEpEyUD+yBx0g1KPniZwjGNnl/gADS8rJkbz1UQaArWGagoIFZA7hFImnbjRBETjmeUbaXY5JVV2KTPzwthpZrknB4up5PGsLg10yWygzJAYEeuPxAYGlgynZU3VSXeRazfi9RCYXRgd4NkGf3SPXzwm+wfuqJgrXbHNgTweBMr9ymwZACGk18CIOVF4iSNlFeqhUsiqX84G5QGReWITjBY51kCYhTZL5D4tdVmwiM+rLDaD+VPLsthKGh4Zxm89rgXw5lfg7Ng/K8eHCzk3m5gneP0QpxP/t1vW+ZRv5fDpoQgsnqyCK0mGUlogqK/g6UK03ZEOObgeQw3mc19KZszHHUY+fddYuk7YMNqS9JM67ErOnDA2mhCVBBBkIczqrtdsqO1893ZBve6aK1NoZtnXOtRWkX2IaQOXDM7KSJ2m/pVMiTod4WbMKscQMeaeosqNdKeNxxTFz8NNAo5pdiKH5armVUgWgWuAqcCftmHq8TdvU3WJdq84uRdJHMU7fmEEr2rWtMPLfTxeloO5pLg9gl0rbcLq/wmVJd7ica1G20MKAVCXo/WuKWWANxbVhtTelgY/7lRtRXtXcCjYMnmzLPV70Kgl+SwTc+Gk7//0opJeOy+5Hyciu5Xafa3kUToRBRb3D3h/N4qqElsU/ArxPCLzzDD5xBbXA3mxjo64IlJQPMF0ys56bLZoaldiQ4HpF85VOV05o7EknYzJvZIIqDiZt3WChUw2x+g6BUd7pJEHldt2vyrwv/mrv1ouBq331e4/8ctZvR8J/CbdsYhF2VFRFQ1QmsMHAmZPqfk0bY/AgzBMcvhFO7p5LZMJ+9bAQQznQiozBLOoFpAIQJBDcRUJiLJc9Mc4INAoC7CFyQ/D0Qe+u5mUahxOlJ19zl94p2+C1atA74f7G0ZrK9ZMrMzUcIqhSzd2k2GizGTwwOTvsHQQJluDTPUAD19Laxi80Y1pBfws5z99wwHCa29Yt0FGb9I7eRbX0T/U+4WL8gefw+Q5O6dsLiLFXnJp4TYC2k3PZPBCoEaNbBW8Nzd1pytMX8tIQNNAkIHCxIN51C0zK5asCMsaVO56fkBLB4R8w662AL3rrnXV4xfusGv/RIfKsvLNLY4aYEEVNTvZFzhQwM5rp+3h6CBoMSk8YNmeWsqiNCPMFAYzMMlBqOHzABPpc23SSM/mQhaQhVw0mWgXiz5AUHaSpMcVBUkFAKbCVRnb1O1y4hXxOIHyvNh8Erxd0+1OeKsuiwnsFQBHgi8m6iUZqiLfRXCZuz6OTK7M+4CmPoSrb+l3zJiO3XsjbZowQeH4x2buSiwWZ687Zq8RkwtYQUQepl0MuA7Lee8PsXWszH5eUa1ryY1Te0o/DZr8WNqtFr9ZnZg3w8IV3Fyb+xr6dyf44UB8CdhpWT2DTDkz7p3HiYLotiLBxKZEDsBYS7MnmIf5vo9MKiUWpTjdfi23T91eMjO2MzvZ4ExVFAlUl/1jEMiRlhwTAMHoVXYgo3tVd1jVZmep/Sbz2ezSiHL/V+K9NIuTLTbxog9iFWST6b9JP3mW/8fEGxdK+QaeYLFwCWdUDg8m42O5QACrqX0ThEP+/tNQGyfk2Ut70c8qU2U8THINXkKINZTBJZ7ltaqBdifp+ZA+AuLJBr1Mw0UinwSEWaw0F6M/i90EhIO02KWTnlD24qmGB7fQ/cUoCqTRRBTHyFXFzExEXzI9NetD0gmkVGRclK+AnobFdihZAXrA7A4kGyk6gSkQpRnHjOdsMZgyt0LnuiGk8atJ3rqVLtgqrSAeKORR/gWI1Cvpj15bB4T3Pk4y1YDeROaR4lag0uZBDkRpqt2FMBa2zo0zLDt8sIBtNcg1qPQtymOw0ceDOLik1nwmXNzOX3LfivlYlhKdAQKuT9XF5+ROEL90Z5eq9HjmxrXsFx9o9R17Lat3ToWxyHhebfcnqoxmDiBZAcaQ7iF3kNVMVkRSd4vFejSzvNqC8ekJ/V4rvI2iPwlRb5V4drRakoMQTRcI4f8OXsRurq+tNODRkC53mdESzwrByhauZafHWPIDqZSwq0lQudQfDP1fSEjWyE01p7ozw6XzSDIdd6+g3iNiGvFvXvZ3GjW5AtWK0Ppg7ILiE4HtiIZxz1TdTynIidhIvZBHgr91yfqvJb0K35nIWvcfVZU9mbWr6MdR3AzM7tgmSOBFGkLgd5L6MyQLcJLj790mfKulk+jGr3dEM/51AVSJMH1FeMBccjQqt+ekwgSrA8u/TEUrMRTwLhuvBemrZ7QnT9bvzYNPwjETalfKDOlEp2QhXp2Cs77osHiJSplTbBo86vGdPCGtiLqxDlCvaF0QcNR0Nl+oS3fTPQOc3lbWp70bDePNV5ELkkJHqaNwj6mDrvjZvH/umM+G/rKmLiuqXIx1LSneJQMXRBk+8njjUqq/9U82NPIjj/D/qE2yXNGwusXqXVYY+6MZcrT0HwfGTwOYrYuoRfOyl+toch0ruuAAOTErXyUjlaazRF5Urg1jbhHpEoeurLQ1712UNIkuQaBCuZckFE2qClmxKgN2PcPSk3BpyertuRVTSkahRsThVBlvSu87JKlE85hWLoF24XsVY1aLhzdhInsVykqnmP4+Fk5KffnMKYy+LdU60Yfz7tv3jAu1p7WKW89xooijlWJBhpX18I0r0AbPfembOHzd5tclL7yRyUhE3ldHL6N+T1upxD7ggIHRAB048vuyuJ0aTTu8es5LgGfCMEnRKg4uN3J778M7KxI3k7wAuZbUuLAv/l66mptNzMrCbufuvvQNGtifqMYSUpz0RhI8H6pfDkyEQKUmDS/TR710L8Rgna4P2LdJMm1bWk4s5Vgq0b2+vfS3Bsm97vdKuFfNKLG2NB1nrPgfk0KiJZ1Lf1IylAhqAQAzJCKhO9jXhJXiKUwKFrO3ZW9Kxa1wJKCaoCAEFchKDQ1wMutGeRnDBFomcdZIZ8nRl+zNDml1La1JoM1DAqtpesiYnKcTE76Lxzeuy1LATQCWvUDn4f50Fqgx9LUTW9Eguuf4WiP5/UxzwuDDJpiESHEjv6h9fxEZmrrSBZbgSSCe9dPFGMeBOp56nzygleUggDTCigeGr3OFh8ZkU8pcHPq0h3ZGycyXzJEvyaSdTfmmtUr51RAkbqrXZMpxygns+e9S5Fg+LciXEb8TqPf6ar3QuwiKIzw53m/8ROreyxv/YWmoQ/OOZgAWp5dooRUdqGRSB5YErRAX1GCqSFEKPxFpWagnIctiuJkfv1jLuWdibgj+f68Wy1ygV5GEAAAAAElFTkSuQmCC"

var OPTION_SSAO_SCALE = "renderer-ssao-scale";
var OPTION_SSAO_INTENSITY = "renderer-ssao-intensity";
var OPTION_SSAO_BIAS = "renderer-ssao-bias";
var OPTION_SSAO_RADIUS = "renderer-ssao-radius";
var FLAGS = {};
FLAGS[OPTION_SSAO_SCALE] = {defaultValue: 1};
FLAGS[OPTION_SSAO_INTENSITY] = {defaultValue: 5};
FLAGS[OPTION_SSAO_BIAS] = {defaultValue: 0.2};
FLAGS[OPTION_SSAO_RADIUS] = {defaultValue: 1};
for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}

var SSAOPass = function (renderInterface, output, opt) {
    BaseRenderPass.call(this, renderInterface, output, opt);
    var context = this.renderInterface.context;
    this._program = context.programFactory.getProgramByName("ssao");
    this.randomVectorTexture = this.createRandomVectorTexture(context);
    this.loadRandomVectorImage();
    this._screenQuad = new FullscreenQuad(context);
    this._uniformsDirty = true;
//		if (!this.inputs.positionBuffer)
//			this._positionPass = this.createVertexAttributePass("render-position");
//		if (!this.inputs.normalBuffer)
//			this._normalPass = this.createVertexAttributePass("render-normal");
};

XML3D.createClass(SSAOPass, BaseRenderPass);

XML3D.extend(SSAOPass.prototype, {
    createRandomVectorTexture: function (context) {
        var gl = context.gl;
        var tex = context.createTexture();
        tex.createTex2DFromData(gl.RGBA, 64, 64, gl.RGBA, gl.UNSIGNED_BYTE, {
            wrapS: gl.REPEAT, wrapT: gl.REPEAT, minFilter: gl.LINEAR, magFilter: gl.LINEAR
        });
        tex.isTexture = true;
        return tex;
    },

    loadRandomVectorImage: function () {
        var img = new Image();
        img.src = base64RandomNormals;
        var gl = this.renderInterface.context.gl;
        var texhandle = this.randomVectorTexture.handle;

        img.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, texhandle);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        }
    },

    createVertexAttributePass: function (programName) {
        var context = this.renderInterface.context;
        var buffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            colorType: context.gl.FLOAT,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        return new VertexAttributePass(this.renderInterface, buffer, {
            programName: programName
        });
    },

    render: (function () {
//			if (this._positionPass)
//				this._positionPass.setProcessed(false);

        var viewMatrix = XML3D.math.mat4.create();
        var uniformNames = ["viewMatrix"];
        return function (scene) {
            var gl = this.renderInterface.context.gl;
            var target = this.output;

            target.bind();
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            gl.disable(gl.DEPTH_TEST);

            this._program.bind();
            this._setNonVolatileShaderUniforms();

            var uniforms = {};
            scene.getActiveView().getWorldToViewMatrix(viewMatrix);
            uniforms["viewMatrix"] = viewMatrix;
            this._program.setSystemUniformVariables(uniformNames, uniforms);
            this._screenQuad.draw(this._program);

            this._program.unbind();
            target.unbind();
        }
    }()),

    _setNonVolatileShaderUniforms: (function () {
        var uniformNames = ["canvasSize", "sPositionTex", "sNormalTex", "sRandomNormals", "uRandomTexSize", "uScale", "uBias", "uIntensity", "uSampleRadius", "uConstVectors"];

        return function () {
            if (!this._uniformsDirty)
                return;

            var uniforms = {};
            var program = this._program;
            program.bind();
            var target = this.output;

            uniforms["canvasSize"] = [target.width, target.height];
            uniforms["sPositionTex"] = [this.inputs.positionBuffer.colorTarget.handle];
            uniforms["sNormalTex"] = [this.inputs.normalBuffer.colorTarget.handle];
            uniforms["sRandomNormals"] = [this.randomVectorTexture];
            uniforms["uRandomTexSize"] = [64, 64];
            uniforms["uScale"] = Options.getValue(OPTION_SSAO_SCALE);
            uniforms["uBias"] = Options.getValue(OPTION_SSAO_BIAS);
            uniforms["uIntensity"] = Options.getValue(OPTION_SSAO_INTENSITY);
            uniforms["uSampleRadius"] = Options.getValue(OPTION_SSAO_RADIUS);
            uniforms["uConstVectors"] = [1, 0, -1, 0, 0, 1, 0, -1];

            program.setSystemUniformVariables(uniformNames, uniforms);
            program.unbind();

//                this._uniformsDirty = false;
        }
    })()
});

module.exports = SSAOPass;


},{"../../../utils/options.js":175,"../base/fullscreenquad.js":111,"../base/rendertarget.js":114,"./base.js":137,"./vertexattribute-pass.js":147}],147:[function(require,module,exports){
var SceneRenderPass = require("./scene-pass.js");

var VertexAttributePass = function (renderInterface, output, opt) {
    SceneRenderPass.call(this, renderInterface, output, opt);
    this._program = this.renderInterface.context.programFactory.getProgramByName(opt.programName);
};

XML3D.createClass(VertexAttributePass, SceneRenderPass);

XML3D.extend(VertexAttributePass.prototype, {
    render: function (scene) {
        var gl = this.renderInterface.context.gl;
        var target = this.output;
        var width = target.getWidth();
        var height = target.getHeight();
        var aspect = width / height;

        target.bind();
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        gl.enable(gl.DEPTH_TEST);

        scene.updateReadyObjectsFromActiveView(aspect);

        this.renderObjectsToActiveBuffer(scene.ready, scene, target, scene.systemUniforms, [], {
            transparent: false,
            program: this._program
        });

        target.unbind();
    }
});

module.exports = VertexAttributePass;


},{"./scene-pass.js":145}],148:[function(require,module,exports){
var BaseRenderTree = function (renderInterface) {
    this.mainRenderPass = null;
    this.renderInterface = renderInterface;
};

XML3D.extend(BaseRenderTree.prototype, {
    render: function (scene) {
        this.mainRenderPass.renderTree(scene);
    }
});

module.exports = BaseRenderTree;


},{}],149:[function(require,module,exports){
var BaseRenderTree = require("./base.js");
var GLRenderTarget = require("../base/rendertarget.js").GLRenderTarget;
var GLCubeMapRenderTarget = require("../base/rendertarget.js").GLCubeMapRenderTarget;
var ForwardRenderPass = require("../render-passes/forward.js");
var BoxBlurPass= require("../render-passes/boxblur.js");
var LightPass= require("../render-passes/light-pass.js");
var PointLightPass= require("../render-passes/pointlight-pass.js");
var VertexAttributePass = require("../render-passes/vertexattribute-pass.js");
var SSAOPass = require("../render-passes/ssao-pass.js");
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var MaterialEvents = require("../materials/events.js");
/**
 *
 * @param {GLRenderInterface} renderInterface
 * @param {boolean} enableSSAO
 * @constructor
 */
var ForwardRenderTree = function (renderInterface, enableSSAO) {
    BaseRenderTree.call(this, renderInterface);
    var scene = renderInterface.scene;
    this._enableSSAO = enableSSAO;
    this.mainPass = null;
    this.createMainPass();
};

XML3D.createClass(ForwardRenderTree, BaseRenderTree);

XML3D.extend(ForwardRenderTree.prototype, {

    createMainPass: function () {
        var outputTarget = this.renderInterface.context.canvasTarget;
        if (this._enableSSAO) {
            var positionPass = this.createVertexAttributePass("render-position");
            var normalPass = this.createVertexAttributePass("render-normal");
            var ssaoPass = this.createSSAOPass(positionPass.output, normalPass.output);
            ssaoPass.addPrePass(positionPass);
            ssaoPass.addPrePass(normalPass);
            var blurPass = this.createBlurPass(ssaoPass.output);
            blurPass.addPrePass(ssaoPass);
            this._blurPass = blurPass;
            this._ssaoPass = ssaoPass;
            this._positionPass = positionPass;
            this._normalPass = normalPass;
            this.mainPass = new ForwardRenderPass(this.renderInterface, outputTarget, {
                inputs: {
                    ssaoMap: blurPass.output
                }
            });
            this.mainPass.addPrePass(blurPass);
        } else {
            this.mainPass = new ForwardRenderPass(this.renderInterface, outputTarget);
        }
        this.mainRenderPass = this.mainPass;
    },

    createVertexAttributePass: function (programName) {
        var context = this.renderInterface.context;
        var buffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            colorType: context.gl.FLOAT,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        return new VertexAttributePass(this.renderInterface, buffer, {
            programName: programName
        });
    },

    createSSAOPass: function (positionBuffer, normalBuffer) {
        var context = this.renderInterface.context;
        var ssaoBuffer = new GLRenderTarget(context, {
            width: context.canvasTarget.width,
            height: context.canvasTarget.height,
            colorFormat: context.gl.RGBA,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });

        return new SSAOPass(this.renderInterface, ssaoBuffer, {
            inputs: {
                positionBuffer: positionBuffer, normalBuffer: normalBuffer
            }
        });
    },

    createBlurPass: function (inputBuffer) {
        var context = this.renderInterface.context;
        var blurBuffer = new GLRenderTarget(context, {
            width: inputBuffer.width,
            height: inputBuffer.height,
            colorFormat: context.gl.RGBA,
            depthFormat: context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });

        return new BoxBlurPass(this.renderInterface, blurBuffer, {
            inputs: {
                buffer: inputBuffer
            }
        });
    },

    render: function (scene) {
        if (this._enableSSAO) {
            this._positionPass.setProcessed(false);
            this._normalPass.setProcessed(false);
            this._ssaoPass.setProcessed(false);
            this._blurPass.setProcessed(false);
        }
        this.mainRenderPass.setProcessed(false);
        BaseRenderTree.prototype.render.call(this, scene);
    },

    getRenderStats: function () {
        return this.mainPass.getRenderStats();
    }
});

module.exports = ForwardRenderTree;


},{"../../renderer/scene/constants.js":95,"../base/rendertarget.js":114,"../materials/events.js":120,"../render-passes/boxblur.js":138,"../render-passes/forward.js":139,"../render-passes/light-pass.js":140,"../render-passes/pointlight-pass.js":144,"../render-passes/ssao-pass.js":146,"../render-passes/vertexattribute-pass.js":147,"./base.js":148}],150:[function(require,module,exports){
var GLContext = require("./base/context.js");
var GLScene = require("./scene/glscene.js");
var GLScaledRenderTarget = require("./base/rendertarget.js").GLScaledRenderTarget;
var DataChangeListener = require("../renderer/tools/datachangelistener.js");
var RenderInterface = require("./render-interface.js");
var PickObjectRenderPass= require("./render-passes/pick-object.js");
var PickPositionRenderPass = require("./render-passes/pick-position.js");
var PickNormalRenderPass = require("./render-passes/pick-normal.js");
var ForwardRenderTree = require("./render-trees/forward.js");
var GLU = require("../../contrib/glu.js");
var Options = require("../../utils/options.js");
var xml3dFormatHandler = require("../../base/formathandler.js").xml3dFormatHandler;
var MAX_PICK_BUFFER_DIMENSION = 512;
var vec3 = require("gl-matrix").vec3;
var quat = require("gl-matrix").quat;
var mat4 = require("gl-matrix").mat4;

var OPTION_SSAO = "renderer-ssao";
var FLAGS = {};
FLAGS[OPTION_SSAO] = {defaultValue: false, recompileOnChange: true};
for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}

/**
 * Convert the given y-coordinate on the canvas to a y-coordinate appropriate in
 * the GL context. The y-coordinate gets turned upside-down. The lowest possible
 * canvas coordinate is 0, so we need to subtract 1 from the height, too.
 *
 * @param {HTMLCanvasElement} canvas
 * @param {number} y
 * @return {number} the converted y-coordinate
 */
var canvasToGlY = function (canvas, y) {
    return canvas.height - y - 1;
};
/**
 * @interface
 */
var IRenderer = function () {
};

IRenderer.prototype.renderToCanvas = function () {
};
IRenderer.prototype.handleResizeEvent = function (width, height) {
};
IRenderer.prototype.requestRedraw = function (reason) {
};
IRenderer.prototype.needsRedraw = function () {
};
IRenderer.prototype.getWorldSpaceNormalByPoint = function (obj, x, y) {
};
IRenderer.prototype.getWorldSpacePositionByPoint = function (obj, x, y) {
};
IRenderer.prototype.getRenderObjectFromPickingBuffer = function (x, y) {
};
IRenderer.prototype.generateRay = function (x, y) {
};
IRenderer.prototype.dispose = function () {
};

/**
 * @param {Element} element The <xml3d> Element
 * @implements {IRenderer}
 * @constructor
 */
var GLRenderer = function (element, canvasHandler) {

    this._canvasHandler = canvasHandler;
    var canvas = this._canvasHandler.getCanvas();
    this.width = canvas.clientWidth;
    this.height = canvas.clientHeight;

    this.context = new GLContext(canvas, this._canvasHandler.id);
    this.scene = new GLScene(this.context);

    var factory = xml3dFormatHandler.getFactory("webgl", this._canvasHandler.id);
    factory.setScene(this.scene);
    factory.setRenderer(this);

    var xml3dAdapter = factory.getAdapter(element);
    xml3dAdapter.traverse(function () {
    });

    /** @type {RenderObject} */
    this.pickedObject = null;

    this.needsDraw = true;
    this.needsPickingDraw = true;
    this.context.requestRedraw = this.requestRedraw.bind(this);

    //Currently used as a helper to calculate view and projection matrices for ray casting, since the scene
    //must be rendered from the point of view of the ray
    this.rayCamera = this.scene.createRenderView();

    this.initGL();
    this.changeListener = new DataChangeListener(this);

    this.renderInterface = this.createRenderInterface();
    this.createDefaultPipelines();
    Options.addObserver(this.onFlagsChange.bind(this));
};

// Just to satisfy jslint
GLRenderer.prototype.generateRay = function () {
};

XML3D.extend(GLRenderer.prototype, {
    initGL: function () {
        var gl = this.context.gl;

        gl.clearColor(0, 0, 0, 0);
        gl.clearDepth(1);
        gl.clearStencil(0);

        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);

        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        gl.disable(gl.CULL_FACE);

        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.disable(gl.BLEND);

        gl.viewport(0, 0, this.width, this.height);

        gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.BROWSER_DEFAULT_WEBGL);

    },

    handleResizeEvent: function (width, height) {
        this.width = width;
        this.height = height;
        this.context.handleResizeEvent(width, height);
        this.createDefaultPipelines();
        this.scene.handleResizeEvent(width, height);
        this.needsDraw = this.needsPickingDraw = true;
    },

    createDefaultPipelines: function () {
        var pipeline = new ForwardRenderTree(this.renderInterface, Options.getValue(OPTION_SSAO));
        this.renderInterface.setRenderPipeline(pipeline);

        var pickTarget = new GLScaledRenderTarget(this.context, MAX_PICK_BUFFER_DIMENSION, {
            width: this.context.canvasTarget.width,
            height: this.context.canvasTarget.height,
            colorFormat: this.context.gl.RGBA,
            depthFormat: this.context.gl.DEPTH_COMPONENT16,
            stencilFormat: null,
            depthAsRenderbuffer: true
        });
        this.pickObjectPass = new PickObjectRenderPass(this.renderInterface, pickTarget);
        this.pickPositionPass = new PickPositionRenderPass(this.renderInterface, pickTarget);
        this.pickNormalPass = new PickNormalRenderPass(this.renderInterface, pickTarget);
    },

    createRenderInterface: function () {
        return new RenderInterface(this.context, this.scene);
        //TODO need to provide an interface for creating shaders, buffers and so on
    },

    requestRedraw: function (reason) {
        XML3D.debug.logDebug("Request redraw because:", reason);
        this.needsDraw = true;
        this.needsPickingDraw = true;
    },

    getWorldSpaceNormalByPoint: function (x, y, object) {
        var obj = object || this.pickedObject;
        if (!obj)
            return null;
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        this.pickNormalPass.render(obj);
        this.needsPickingDraw = true;
        return this.pickNormalPass.readNormalFromPickingBuffer(x, y);
    },

    getWorldSpacePositionByPoint: function (x, y, object) {
        var obj = object || this.pickedObject;
        if (!obj)
            return null;
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        this.pickPositionPass.render(obj);
        this.needsPickingDraw = true;
        return this.pickPositionPass.readPositionFromPickingBuffer(x, y);
    },

    getRenderObjectByRay: function (xml3dRay, viewMat, projMat) {
        var intersectedObjects = this.scene.findRayIntersections(xml3dRay);
        this.pickObjectPass.render(intersectedObjects, viewMat, projMat);
        //Target the middle of the buffer
        var x = Math.floor(this.pickObjectPass.output.getWidth() / 2 / this.pickObjectPass.output.getScale());
        var y = Math.floor(this.pickObjectPass.output.getHeight() / 2 / this.pickObjectPass.output.getScale());
        return this.pickObjectPass.getRenderObjectFromPickingBuffer(x, y, intersectedObjects);

    },

    getWorldSpaceNormalByRay: function (ray, intersectedObject, viewMat, projMat) {
        if (!intersectedObject)
            return null;
        this.pickNormalPass.render(intersectedObject, viewMat, projMat);
        var x = Math.floor(this.pickNormalPass.output.getWidth() / 2 / this.pickNormalPass.output.getScale());
        var y = Math.floor(this.pickNormalPass.output.getHeight() / 2 / this.pickNormalPass.output.getScale());
        return this.pickNormalPass.readNormalFromPickingBuffer(x, y);

    }, getWorldSpacePositionByRay: function (ray, intersectedObject, viewMat, projMat) {
        if (!intersectedObject)
            return null;
        this.pickPositionPass.render(intersectedObject, viewMat, projMat);
        var x = Math.floor(this.pickPositionPass.output.getWidth() / 2 / this.pickPositionPass.output.getScale());
        var y = Math.floor(this.pickPositionPass.output.getHeight() / 2 / this.pickPositionPass.output.getScale());
        return this.pickPositionPass.readPositionFromPickingBuffer(x, y);

    },

    calculateMatricesForRay: function (ray, viewMat, projMat) {
        this.rayCamera.updatePosition(ray.origin.data);
        this.rayCamera.updateOrientation(this.calculateOrientationForRayDirection(ray));
        this.rayCamera.getWorldToViewMatrix(viewMat);
        var aspect = this.pickObjectPass.output.getWidth() / this.pickObjectPass.output.getHeight();
        this.rayCamera.getProjectionMatrix(projMat, aspect);
    },

    calculateOrientationForRayDirection: (function () {
        var tmpX = vec3.create();
        var tmpY = vec3.create();
        var tmpZ = vec3.create();
        var up = vec3.create();
        var q = quat.create();
        var m = mat4.create();

        return function (ray) {
            vec3.set(up, 0, 1, 0);
            vec3.cross(tmpX, ray.direction.data, up);
            if (!vec3.length(tmpX)) {
                vec3.set(tmpX, 1, 0, 0);
            }
            vec3.cross(tmpY, tmpX, ray.direction.data);
            vec3.negate(tmpZ, ray.direction.data);

            XML3D.math.quat.setFromBasis(q, tmpX, tmpY, tmpZ);
            mat4.fromRotationTranslation(m, q, [0,0,0]);
            return m;
        }
    })(),

    needsRedraw: function () {
        return this.needsDraw;
    },

    renderToCanvas: function () {
        this.needsDraw = false; //Set this early to avoid endless rendering if an exception is thrown during rendering
        this.prepareRendering();
        this.renderInterface.getRenderPipeline().render(this.scene);
        var stats = this.renderInterface.getRenderPipeline().getRenderStats();
        XML3D.debug.logDebug("Rendered to Canvas");
        return stats;
    },

    getRenderObjectFromPickingBuffer: function (x, y) {
        y = canvasToGlY(this._canvasHandler.getCanvas(), y);
        if (this.needsPickingDraw) {
            this.needsPickingDraw = false;
            this.prepareRendering();
            this.scene.updateReadyObjectsFromActiveView(this.pickObjectPass.output.getWidth() / this.pickObjectPass.output.getHeight());
            this.pickObjectPass.render(this.scene.ready);
            XML3D.debug.logDebug("Rendered Picking Buffer");
        }
        this.pickedObject = this.pickObjectPass.getRenderObjectFromPickingBuffer(x, y, this.scene.ready);
        return this.pickedObject;
    },

    prepareRendering: function () {
        this.scene.update();
    },

    /**
     * Uses gluUnProject() to transform the 2D screen point to a 3D ray.
     * Not tested!!
     *
     * @param {number} canvasX
     * @param {number} canvasY
     */
    generateRay: (function () {

        var c_viewMatrix = mat4.create();
        var c_projectionMatrix = mat4.create();

        return function (canvasX, canvasY) {

            var glY = canvasToGlY(this._canvasHandler.getCanvas(), canvasY);

            // setup input to unproject
            var viewport = new Float32Array(4);
            viewport[0] = 0;
            viewport[1] = 0;
            viewport[2] = this.width;
            viewport[3] = this.height;

            // get view and projection matrix arrays
            var view = this.scene.getActiveView();
            view.getWorldToViewMatrix(c_viewMatrix);
            view.getProjectionMatrix(c_projectionMatrix, viewport[2] / viewport[3]);

            var ray = new XML3D.Ray();

            var nearHit = new Float32Array(3);
            var farHit = new Float32Array(3);

            // do unprojections
            if (false === GLU.unProject(canvasX, glY, 0, c_viewMatrix, c_projectionMatrix, viewport, nearHit)) {
                return ray;
            }

            if (false === GLU.unProject(canvasX, glY, 1, c_viewMatrix, c_projectionMatrix, viewport, farHit)) {
                return ray;
            }

            // calculate ray
            mat4.invert(c_viewMatrix, c_viewMatrix);
            ray.origin = vec3.fromValues(c_viewMatrix[12], c_viewMatrix[13], c_viewMatrix[14]);
            ray.direction = vec3.fromValues(farHit[0] - nearHit[0], farHit[1] - nearHit[1], farHit[2] - nearHit[2]);

            return ray;
        }
    }()),

    dispose: function () {
        this.scene.clear();
    },

    getRenderInterface: function () {
        return this.renderInterface;
    },

    onFlagsChange: function (key) {
        if (key == OPTION_SSAO) {
            this.scene.shaderFactory.setShaderRecompile();
            this.createDefaultPipelines();
        }
    }
});

module.exports = GLRenderer;

},{"../../base/formathandler.js":45,"../../contrib/glu.js":47,"../../utils/options.js":175,"../renderer/tools/datachangelistener.js":106,"./base/context.js":110,"./base/rendertarget.js":114,"./render-interface.js":136,"./render-passes/pick-normal.js":141,"./render-passes/pick-object.js":142,"./render-passes/pick-position.js":143,"./render-trees/forward.js":149,"./scene/glscene.js":153,"gl-matrix":1}],151:[function(require,module,exports){
var XflowMesh = require("../xflow/xflow-mesh.js");

/**
 * @constructor
 */
var DrawableFactory = function () {};

XML3D.extend(DrawableFactory.prototype, {
    createDrawable: function (obj, context) {
        XML3D.debug.logDebug("DrawableFactory::createDrawable", obj);
        try {
            var result = new XflowMesh(context, obj.getDataNode(), obj.getType(), {boundingBoxChanged: obj.setObjectSpaceBoundingBox.bind(obj)});
            obj.mesh = result.getMesh();
            return result;
        } catch (e) {
            XML3D.debug.logError(e, obj.node);
            return null;
        }
    }
});

module.exports = DrawableFactory;



},{"../xflow/xflow-mesh.js":158}],152:[function(require,module,exports){
var lightModels = {
    point: {
        parameters: [ "pointLightPosition", "pointLightAttenuation", "pointLightIntensity", "pointLightOn", "pointLightCastShadow", "pointLightMatrix", "pointLightShadowBias", "pointLightNearFar", "pointLightShadowMap"]
    },
    directional: {
        parameters: ["directionalLightDirection", "directionalLightIntensity", "directionalLightOn", "directionalLightCastShadow", "directionalLightMatrix", "directionalLightShadowBias", "directionalLightShadowMap"]
    },
    spot: {
        parameters: ["spotLightAttenuation", "spotLightPosition", "spotLightIntensity", "spotLightDirection", "spotLightOn", "spotLightSoftness", "spotLightCosFalloffAngle", "spotLightCosSoftFalloffAngle", "spotLightCastShadow", "spotLightMatrix", "spotLightShadowBias", "spotLightShadowMap"]
    }
};

var ALL_PARAMETERS = lightModels.point.parameters.concat(lightModels.directional.parameters).concat(lightModels.spot.parameters);

module.exports = {
    ALL_PARAMETERS: ALL_PARAMETERS
};

},{}],153:[function(require,module,exports){
var Scene = require("./../../renderer/scene/scene.js");
var DrawableFactory = require("./drawable-factory.js");
var C = require("./../../renderer/scene/constants.js");
var FrustumTest = require("./../../renderer/tools/frustum.js").FrustumTest;
var ShaderComposerFactory = require("../materials/shadercomposerfactory.js");
var Options = require("../../../utils/options.js");
var ShadowMapService = require("../materials/shadowmap-service");
var mat4 = require("gl-matrix").mat4;

var OPTION_FRUSTUM_CULLING = "renderer-frustumCulling";
var OPTION_SHADEJS_EXTRACT_UNIFORMS = "shadejs-extractUniformExpressions";
var OPTION_SHADEJS_TRANSFORM_SPACES = "shadejs-transformSpaces";
var OPTION_SHADEJS_CACHE = "shadejs-cache";


// All the shader flags
var FLAGS = {};
FLAGS[OPTION_SHADEJS_EXTRACT_UNIFORMS] = {defaultValue: false, recompileOnChange: true};
FLAGS[OPTION_SHADEJS_TRANSFORM_SPACES] = {defaultValue: true, recompileOnChange: true};
FLAGS[OPTION_FRUSTUM_CULLING] = {defaultValue: true, recompileOnChange: false};
FLAGS[OPTION_SHADEJS_CACHE] = {defaultValue: true, recompileOnChange: false};

for (var flag in FLAGS) {
    Options.register(flag, FLAGS[flag].defaultValue);
}


/**
 *
 * @param {GLContext} context
 * @extends {Scene}
 * @constructor
 */
var GLScene = function (context) {
    Scene.call(this);
    this.context = context;
    this.shaderFactory = new ShaderComposerFactory(context);
    this.drawableFactory = new DrawableFactory();

    this.shadowMapService = new ShadowMapService(context, this);
    /**
     * @type {Array.<RenderObject>}
     */
    this.ready = [];
    this.queue = [];
    this.lightsNeedUpdate = true;
    this.systemUniforms = {};
    this.deferred = window['XML3D_DEFERRED'] || false;
    this.colorClosureSignatures = [];
    this.doFrustumCulling = !!Options.getValue(OPTION_FRUSTUM_CULLING);
    this.addListeners();
};

XML3D.createClass(GLScene, Scene);

function removeSafe(arr, obj) {
    var index = arr.indexOf(obj);
    if (index != -1) {
        arr.splice(index, 1);
        return true;
    }
    return false;
}

XML3D.extend(GLScene.prototype, {
    remove: function (obj) {
        removeSafe(this.queue, obj);
        removeSafe(this.ready, obj);
    },

    clear: function () {
        this.ready = [];
        this.queue = [];
    },

    moveFromQueueToReady: function (obj) {
        if (removeSafe(this.queue, obj)) {
            this.ready.push(obj);
        }
    },

    moveFromReadyToQueue: function (obj) {
        if (removeSafe(this.ready, obj)) {
            this.queue.push(obj);
        }
    },

    update: function () {
        if (this.lightsNeedUpdate) {
            this.lightsNeedUpdate = false;
            this.updateLightParameters();
            this.lights.lightValueChanged();
        }
        this.updateObjectsForRendering();

        // Render shadow maps if necessary
        this.shadowMapService.updateForRendering();

        // Make sure that shaders are updates AFTER objects
        // Because unused shader closures are cleared on update
        this.updateShaders();
    }, updateLightParameters: function () {
        var parameters = this.systemUniforms;

        this.lights.fillGlobalParameters(parameters);
        this.shadowMapService.fillGlobalParameters(parameters);

        // Derived parameters that are implementation specific.
        // TODO: Put those to an appropriate place
        var spotLightFalloffAngle = parameters["spotLightFalloffAngle"];
        var spotLightSoftness = parameters["spotLightSoftness"];
        if(spotLightFalloffAngle) {
            // Map both parameters into cosinus space
            var spotLightCosSoftFalloffAngle = [];
            var spotLightCosFalloffAngle = [];
            for (var i = 0; i < spotLightFalloffAngle.length; i++) {
                spotLightCosFalloffAngle[i] = Math.cos(spotLightFalloffAngle[i]);
                spotLightCosSoftFalloffAngle[i] = Math.cos(spotLightFalloffAngle[i] * (1.0 - spotLightSoftness[i]));
            }
            parameters["spotLightCosFalloffAngle"] = spotLightCosFalloffAngle;
            parameters["spotLightCosSoftFalloffAngle"] = spotLightCosSoftFalloffAngle;
        }


    },

    updateSystemUniforms: function (names) {
        this.shaderFactory.updateSystemUniforms(names, this);
    },

    updateShaders: function () {
        this.shaderFactory.update(this);
    },

    updateObjectsForRendering: function () {
        this.forEach(function (obj) {
            obj.updateForRendering();
        });
    },

    forEach: function (func, that) {
        this.queue.slice().forEach(func, that);
        this.ready.slice().forEach(func, that);
    },

    updateReadyObjectsFromActiveView: (function () {
        var c_worldToViewMatrix = mat4.create();
        var c_viewToWorldMatrix = mat4.create();
        var c_projMat_tmp = mat4.create();
        var c_bbox = new XML3D.Box();
        var c_frustumTest = new FrustumTest();

        return function (aspectRatio) {
            var activeView = this.getActiveView(), readyObjects = this.ready, i, l, obj;

            // Update all MV matrices
            activeView.getWorldToViewMatrix(c_worldToViewMatrix);

            for (i = 0, l = readyObjects.length; i < l; i++) {
                obj = readyObjects[i];
                obj.updateModelViewMatrix(c_worldToViewMatrix);
                obj.updateModelMatrixN();
                obj.updateModelViewMatrixN();
            }
            this.updateBoundingBox();

            activeView.getProjectionMatrix(c_projMat_tmp, aspectRatio);
            activeView.getViewToWorldMatrix(c_viewToWorldMatrix);

            var frustum = activeView.getFrustum();
            c_frustumTest.set(frustum, c_viewToWorldMatrix);

            for (i = 0, l = readyObjects.length; i < l; i++) {
                obj = readyObjects[i];
                obj.updateModelViewProjectionMatrix(c_projMat_tmp);
                obj.getWorldSpaceBoundingBox(c_bbox);
                obj.inFrustum = this.doFrustumCulling ? c_frustumTest.isBoxVisible(c_bbox) : true;
            }
        }
    }()),
    updateReadyObjectsFromMatrices: function (worldToViewMatrix, projectionMatrix) {
        var readyObjects = this.ready;
        for (var i = 0, l = readyObjects.length; i < l; i++) {
            var obj = readyObjects[i];
            obj.updateModelViewMatrix(worldToViewMatrix);
            obj.updateModelMatrixN();
            obj.updateModelViewProjectionMatrix(projectionMatrix);
        }
    },
    addListeners: function () {
        this.on(C.EVENT_TYPE.SCENE_STRUCTURE_CHANGED, function (child, removed) {
            if (removed) {
                this.removeChildEvent(child);
            } else {
                this.addChildEvent(child);
            }
        });
        this.on(C.EVENT_TYPE.VIEW_CHANGED, function (/*newView*/) {
            this.context.requestRedraw("Active view changed.");
        });
        this.on(C.EVENT_TYPE.LIGHT_STRUCTURE_CHANGED, function (/*event*/) {
            this.lightsNeedUpdate = true;
            this.shaderFactory.setLightStructureDirty();
            this.context.requestRedraw("Light structure changed.");
        });
        this.on(C.EVENT_TYPE.LIGHT_VALUE_CHANGED, function (light) {
            this.lightsNeedUpdate = true;
            this.shaderFactory.setLightValueChanged();
            this.lights.lightValueChanged(light);
            this.context.requestRedraw("Light value changed.");
        });
         this.on(C.EVENT_TYPE.SCENE_SHAPE_CHANGED, function (/* event */) {
            // Need to update light frustum. Defer this until the next render phase
            // TODO(ksons) Only light frustum and shadow maps need update, not the whole scene
             this.lightsNeedUpdate = true;
        });

        Options.addObserver(this.onFlagsChange.bind(this));
    },

    addChildEvent: function (child) {
        if (child.type == C.NODE_TYPE.OBJECT) {
            this.queue.push(child);
            this.context.requestRedraw("Object was added to scene.");
        }
    },

    removeChildEvent: function (child) {
        if (child.type == C.NODE_TYPE.OBJECT) {
            this.remove(child);
            child.dispose();
            this.context.requestRedraw("Object was removed from scene.");
        }
    },

    handleResizeEvent: function (/*width, height*/) {
        this.getActiveView().setProjectionDirty();
    },

    createDrawable: function (obj) {
        return this.drawableFactory.createDrawable(obj, this.context);
    },

    requestRedraw: function (reason) {
        return this.context.requestRedraw(reason);
    },

    onFlagsChange: function (key, value) {
        if (FLAGS[key] && FLAGS[key].recompileOnChange)
            this.shaderFactory.setShaderRecompile();
        if (key == OPTION_FRUSTUM_CULLING) {
            this.doFrustumCulling = !!value;
        }
    }
});
module.exports = GLScene;


},{"../../../utils/options.js":175,"../materials/shadercomposerfactory.js":124,"../materials/shadowmap-service":125,"./../../renderer/scene/constants.js":95,"./../../renderer/scene/scene.js":105,"./../../renderer/tools/frustum.js":107,"./drawable-factory.js":151,"gl-matrix":1}],154:[function(require,module,exports){
var ShaderUtils = require("./shader-utils.js");
var ShaderDescriptor = require("../materials/urn/shader-descriptor.js");
var URNShaderClosure = require("../materials/urn/urnshaderclosure.js");

var ProgramFactory = function (context) {
    this.context = context;
    this.programs = {
        fallback: null, picking: {
            id: null, normal: null, position: null
        }
    }
};



XML3D.extend(ProgramFactory.prototype, {

    getProgramByName: function (name) {
        var scriptDescriptor = XML3D.materials.getScript(name);
        if (!scriptDescriptor || !scriptDescriptor.vertex) {
            XML3D.debug.logError("Unknown shader: ", name);
            return null;
        }
        var descriptor = new ShaderDescriptor();
        XML3D.extend(descriptor, scriptDescriptor);
        descriptor.fragment = ShaderUtils.addFragmentShaderHeader(descriptor.fragment);
        var shader = new URNShaderClosure(this.context, descriptor);
        shader.createSources({}, null, null);
        shader.compile();
        return shader;
    },

    getFallbackProgram: function () {
        if (!this.programs.fallback) {
            var descriptor = new ShaderDescriptor();
            XML3D.extend(descriptor, XML3D.materials.getScript("matte"));
            descriptor.fragment = ShaderUtils.addFragmentShaderHeader(descriptor.fragment);
            var shader = new URNShaderClosure(this.context, descriptor);
            shader.uniformCollection.envBase.diffuseColor = [1, 0, 0];
            shader.createSources({}, null, null);
            shader.compile();
            this.programs.fallback = shader;
            this.programs.fallback.bind();
            this.programs.fallback.setUniformVariables(["diffuseColor"], null, {envBase: {diffuseColor: [1, 0, 0]}});
            this.programs.fallback.unbind();
        }
        return this.programs.fallback;
    },

    getPickingObjectIdProgram: function () {
        var picking = this.programs.picking;
        if (!picking.id) {
            picking.id = this.getProgramByName("pickobjectid");
        }
        return picking.id;
    },

    getPickingPositionProgram: function () {
        var picking = this.programs.picking;
        if (!picking.position) {
            picking.position = this.getProgramByName("pickedposition");
        }
        return picking.position;
    },

    getPickingNormalProgram: function () {
        var picking = this.programs.picking;
        if (!picking.normal) {
            picking.normal = this.getProgramByName("pickedNormals");
        }
        return picking.normal;
    }

});

module.exports = ProgramFactory;


},{"../materials/urn/shader-descriptor.js":132,"../materials/urn/urnshaderclosure.js":133,"./shader-utils.js":155}],155:[function(require,module,exports){
var FRAGMENT_HEADER = ["#ifdef GL_FRAGMENT_PRECISION_HIGH", "precision highp float;", "#else", "precision mediump float;", "#endif // GL_FRAGMENT_PRECISION_HIGH", "\n"].join("\n");

module.exports = {
    addFragmentShaderHeader: function (fragmentShaderSource) {
        return FRAGMENT_HEADER + fragmentShaderSource;
    }
};

},{}],156:[function(require,module,exports){
var SystemNotifier = {
    node: null,

    setNode: function (node) {
        this.node = node;
    },

    sendEvent: function (type, data) {
        if (this.node) {
            var event = document.createEvent('CustomEvent');
            data.systemtype = type;
            event.initCustomEvent('xml3dsystem', true, true, data);
            this.node.dispatchEvent(event);
        }
    }
};

module.exports = SystemNotifier;

},{}],157:[function(require,module,exports){
var XC = require("../../../xflow/interface/constants.js");

function convertToJSArray(value) {
    var jsArray = [value.length];
    for (var i = 0; i < value.length; i++) {
        jsArray[i] = value[i];
    }
    return jsArray;
}

/**
 * @param {GLContext} context
 * @param {Uint32Array} data
 * @param {number} maxIndex
 */
var createElementBuffer = function (context, data, maxIndex) {
    var gl = context.gl;
    var bufferData = data;
    var glType = gl.UNSIGNED_INT;

    if (maxIndex < (1 << 8)) {
        glType = gl.UNSIGNED_BYTE;
        bufferData = new Uint8Array(data);
    } else if (maxIndex < (1 << 16)) {
        glType = gl.UNSIGNED_SHORT;
        bufferData = new Uint16Array(data);
    } else if (!context.extensions["OES_element_index_uint"]) {
        XML3D.debug.logError("Trying to use index data with indices larger than 65535, but this is not supported on your platform. Indexing errors will occur.");
        glType = gl.UNSIGNED_SHORT;
        bufferData = new Uint16Array(data);
    }

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, bufferData, gl.STATIC_DRAW);
    buffer.bytesPerElement = bufferData.BYTES_PER_ELEMENT;
    buffer.length = data.length;
    buffer.glType = glType;
    return buffer;
};

/**
 * @param {GLContext} context
 * @param {Object} data
 */
var createArrayBuffer = function (context, data) {
    var gl = context.gl;

    var buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
    buffer.length = data.length;
    buffer.glType = getGLTypeFromArray(data);
    return buffer;
};

var getGLTypeFromArray = function (array) {
    var GL = window.WebGLRenderingContext;
    if (array instanceof Int8Array)
        return GL.BYTE;
    if (array instanceof Uint8Array)
        return GL.UNSIGNED_BYTE;
    if (array instanceof Int16Array)
        return GL.SHORT;
    if (array instanceof Uint16Array)
        return GL.UNSIGNED_SHORT;
    if (array instanceof Int32Array)
        return GL.INT;
    if (array instanceof Uint32Array)
        return GL.UNSIGNED_INT;
    if (array instanceof Float32Array)
        return GL.FLOAT;
    return GL.FLOAT;
};


module.exports = {
    getGLUniformValueFromXflowDataEntry: function (xflowDataEntry, context) {
        var value;
        if (!xflowDataEntry)
            return null;
        if (xflowDataEntry.type == XC.DATA_TYPE.TEXTURE) {
            var webglData = context.getXflowEntryWebGlData(xflowDataEntry);
            var texture = webglData.texture || context.createTexture();
            if (webglData.changed)
                texture.updateFromTextureEntry(xflowDataEntry);

            webglData.texture = texture;
            webglData.changed = 0;
            value = [texture];
        } else if (xflowDataEntry.type == XC.DATA_TYPE.BOOL) {
            //TODO Can we get Xflow to return boolean arrays as normal JS arrays? WebGL doesn't accept Uint8Arrays here...
            //TODO Alternatively we could set boolean uniforms using uniform1fv together with Float32Arrays, which apparently works too
            value = convertToJSArray(xflowDataEntry.getValue());
        } else {
            value = xflowDataEntry.getValue();
        }

        return value;
    },

    getGLBufferFromXflowDataEntry: function (xflowDataEntry, context, elementBuffer) {
        var webglData = context.getXflowEntryWebGlData(xflowDataEntry);
        var buffer = webglData.buffer;
        var gl = context.gl;

        // Also write min and max values for elementBuffers
        if (webglData.changed && elementBuffer) {
            var indexValue = xflowDataEntry.getValue();
            var minIndex = 100000000, maxIndex = 0;
            var i = indexValue.length;
            while (i--) {
                minIndex = Math.min(minIndex, indexValue[i]);
                maxIndex = Math.max(maxIndex, indexValue[i]);
            }
            webglData.maxIndex = maxIndex;
            webglData.minIndex = minIndex;
        }

        //noinspection FallthroughInSwitchStatementJS
        switch (webglData.changed) {
            case XC.DATA_ENTRY_STATE.CHANGED_VALUE:
                if (elementBuffer) {
                    var bufferData = xflowDataEntry.getValue();
                    switch (buffer.glType) {
                        case gl.UNSIGNED_BYTE:
                            bufferData = new Uint8Array(bufferData);
                            break;
                        case gl.UNSIGNED_SHORT:
                            bufferData = new Uint16Array(bufferData);
                            break;
                        case gl.UNSIGNED_INT:
                            // This is what we expect anyway
                            break;
                        default:
                            XML3D.debug.logError("Unknown GL type for element buffer: ", buffer.glType);
                            return null;
                    }
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);
                    gl.bufferSubData(gl.ELEMENT_ARRAY_BUFFER, 0, bufferData);
                } else {
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferSubData(gl.ARRAY_BUFFER, 0, xflowDataEntry.getValue());
                }
                break;
            case XC.DATA_ENTRY_STATE.CHANGED_NEW:
            case XC.DATA_ENTRY_STATE.CHANGED_SIZE:
            case XC.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE:
                if (elementBuffer) {
                    buffer = createElementBuffer(context, xflowDataEntry.getValue(), webglData.maxIndex);
                } else {
                    buffer = createArrayBuffer(context, xflowDataEntry.getValue());
                }
                buffer.tupleSize = xflowDataEntry.getTupleSize();
                webglData.buffer = buffer;
                break;
        }

        webglData.changed = 0;
        return buffer;
    },

    /**
     * Calculate bounding box from positions and optional indices
     * TODO: Remove FloatArray creation
     * @param {Float32Array} positions
     * @param {Int16Array|null} index
     * @returns {Float32Array}
     */
    calculateBoundingBox: function (positions, index) {
        var box = new XML3D.Box(), i;

        if (!positions || positions.length < 3)
            return box;

        var bbox = box.data;

        if (index) {
            var i0 = index[0] * 3;
            bbox[0] = positions[i0];
            bbox[1] = positions[i0 + 1];
            bbox[2] = positions[i0 + 2];
            bbox[3] = positions[i0];
            bbox[4] = positions[i0 + 1];
            bbox[5] = positions[i0 + 2];

            for (i = 1; i < index.length; i++) {
                var i1 = index[i] * 3;
                var p1 = positions[i1];
                var p2 = positions[i1 + 1];
                var p3 = positions[i1 + 2];

                if (p1 < bbox[0])
                    bbox[0] = p1;
                if (p2 < bbox[1])
                    bbox[1] = p2;
                if (p3 < bbox[2])
                    bbox[2] = p3;
                if (p1 > bbox[3])
                    bbox[3] = p1;
                if (p2 > bbox[4])
                    bbox[4] = p2;
                if (p3 > bbox[5])
                    bbox[5] = p3;
            }
        } else {
            bbox[0] = positions[0];
            bbox[1] = positions[1];
            bbox[2] = positions[2];
            bbox[3] = positions[0];
            bbox[4] = positions[1];
            bbox[5] = positions[2];

            for (i = 3; i < positions.length; i += 3) {
                if (positions[i] < bbox[0])
                    bbox[0] = positions[i];
                if (positions[i + 1] < bbox[1])
                    bbox[1] = positions[i + 1];
                if (positions[i + 2] < bbox[2])
                    bbox[2] = positions[i + 2];
                if (positions[i] > bbox[3])
                    bbox[3] = positions[i];
                if (positions[i + 1] > bbox[4])
                    bbox[4] = positions[i + 1];
                if (positions[i + 2] > bbox[5])
                    bbox[5] = positions[i + 2];
            }
        }
        return box;
    }
};

},{"../../../xflow/interface/constants.js":179}],158:[function(require,module,exports){
var DrawableClosure = require("../../renderer/scene/drawableclosure.js");
var GLMesh = require("../base/mesh.js");
var XflowUtils = require("./utils.js");
var EVENT_TYPE = require("../../renderer/scene/constants.js").EVENT_TYPE;
var MaterialEvents = require("../materials/events.js");
var XC = require("../../../xflow/interface/constants.js");
var ComputeRequest = require("../../../xflow/interface/request.js").ComputeRequest;

var CHANGE_STATE = {
    NOTHING_CHANGED: 0,
    STRUCTURE_CHANGED: 1,
    TYPE_DATA_CHANGED: 2,
    VS_DATA_CHANGED: 4,
    TYPE_CHANGED: 2 + 1,
    VS_CHANGED: 4 + 1,
    SHADER_CHANGED: 32
};
var SHADER_CLOSURE_NEEDS_UPDATE = CHANGE_STATE.STRUCTURE_CHANGED | CHANGE_STATE.SHADER_CHANGED;

var READY_STATE = DrawableClosure.READY_STATE;


var MESH_PARAMETERS = {};

MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES] = {
    attributeData: {"position": XC.DATA_TYPE.FLOAT3}, typeData: {
        "index": XC.DATA_TYPE.INT, "solid": XC.DATA_TYPE.BOOL, "vertexCount": XC.DATA_TYPE.INT
    }, bboxFix: {
        "boundingBox": XC.DATA_TYPE.FLOAT3
    }, bboxCompute: {
        "position": XC.DATA_TYPE.FLOAT3
    }
};
MESH_PARAMETERS[WebGLRenderingContext.LINE_STRIP] = MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES];
MESH_PARAMETERS[WebGLRenderingContext.LINES] = MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES];
MESH_PARAMETERS[WebGLRenderingContext.POINTS] = MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES];
MESH_PARAMETERS[WebGLRenderingContext.TRIANGLE_STRIP] = MESH_PARAMETERS[WebGLRenderingContext.TRIANGLES];


/**
 * Class that synchronizes data changes from Xflow with a GLMesh instance
 *
 * @param {GLContext} context
 * @param {Xflow.DataNode} dataNode
 * @param {string} type
 * @param {object} opt
 * @extends {DrawableClosure}
 * @constructor
 */
var XflowMesh = function (context, dataNode, type, opt) {
    DrawableClosure.call(this, context, DrawableClosure.TYPES.MESH);
    opt = opt || {};
    this.mesh = new GLMesh(context, type);

    /**
     * Data Node of the renderObject
     * @type {Xflow.DataNode}
     */
    this.dataNode = dataNode;

    /**
     * Shader Composer that will provide ShaderClosure and Program
     * @type {AbstractShaderComposer}
     */
    this.shaderComposer = null;

    /**
     * Shader Closure used by this mesh
     * @type {AbstractShaderClosure}
     */
    this.shaderClosure = null;

    /**
     * Attributes required to create the GLMesh
     * @type {ComputeRequest}
     */
    this.typeRequest = null;

    /**
     * Are all attributes required by drawable available?
     * @type {boolean}
     */
    this.typeDataValid = true;

    /**
     * Attributes and uniforms values for the shader
     * @type {Xflow.Request}
     */
    this.objectShaderRequest = null;

    /**
     * Bitfield that records the changes reported by Xflow
     * @private
     * @type {number}
     */
    this.changeState = CHANGE_STATE.STRUCTURE_CHANGED;

    /**
     * Callback if bounding box has changed. Gets only called if
     * this.boundingBoxRequired is true.
     * @type {*|function(Float32Array)}
     */
    this.boundingBoxChanged = opt.boundingBoxChanged || function () {
    };

    this.initialize();
};

XML3D.createClass(XflowMesh, DrawableClosure, {
    initialize: function () {
        this.typeDataChanged(this.typeRequest, XC.RESULT_STATE.CHANGED_STRUCTURE);
        this.shaderChanged();
    },

    setShaderComposer: function (shaderComposer) {
        if (!this.bindedShaderChanged) this.bindedShaderChanged = this.shaderChanged.bind(this);

        if (this.shaderComposer)
            this.shaderComposer.removeListener(MaterialEvents.MATERIAL_STRUCTURE_CHANGED, this.bindedShaderChanged);

        this.shaderComposer = shaderComposer;
        if (this.shaderComposer)
            this.shaderComposer.on(MaterialEvents.MATERIAL_STRUCTURE_CHANGED, this.bindedShaderChanged);

        this.changeState |= CHANGE_STATE.SHADER_CHANGED;
    },

    update: function (scene) {
        if (this.changeState === CHANGE_STATE.NOTHING_CHANGED) {
            return;
        }
        XML3D.debug.logDebug("Update mesh closure", this.changeState);

        var oldValid = !!this.shaderClosure && this.typeDataValid, someError = null, typeDataResolved = false;

        try {
            if (this.changeState & SHADER_CLOSURE_NEEDS_UPDATE) {
                this.mesh.clear();
            }

            if (this.changeState & CHANGE_STATE.TYPE_CHANGED) {
                this.updateTypeData();
            }

            typeDataResolved = true;

            if (this.changeState & (SHADER_CLOSURE_NEEDS_UPDATE | CHANGE_STATE.TYPE_CHANGED)) {
                this.updateIndexBuffer();
            }

            if (this.changeState & SHADER_CLOSURE_NEEDS_UPDATE) {
                this.updateObjectShaderRequest();
                this.updateShaderClosure(scene);
                this.updateObjectShaderData();
            } else if (this.changeState & CHANGE_STATE.VS_CHANGED) {
                this.updateObjectShaderData();
            }

            if (this.dataNode.isSubtreeLoading()) {
                this.shaderClosure = null;
                this.typeDataValid = false;
            }
        } catch (e) {
            someError = e;
            if (!typeDataResolved)
                this.typeDataValid = false; else
                this.shaderClosure = null;
        }


        var newValid = !!this.shaderClosure && this.typeDataValid;

        if (oldValid != newValid) {
            this.emit(EVENT_TYPE.DRAWABLE_STATE_CHANGED,
                newValid ? READY_STATE.COMPLETE : READY_STATE.INCOMPLETE,
                oldValid ? READY_STATE.COMPLETE : READY_STATE.INCOMPLETE
            );
        }
        this.changeState = CHANGE_STATE.NOTHING_CHANGED;

        if (someError) throw someError;
    },

    calculateBoundingBox: (function () {
        var c_empty = new XML3D.Box();

        return function () {
            // compute bounding box from positions and indices, if present
            var dataResult = this.typeRequest.getResult();
            var boundingBoxEntry = dataResult.getOutputData("boundingBox");
            if (boundingBoxEntry) {
                this.boundingBoxChanged(XflowUtils.calculateBoundingBox(boundingBoxEntry.getValue(), null));
                return;
            }
            var positionEntry = dataResult.getOutputData("position");
            if (!positionEntry) {
                this.boundingBoxChanged(c_empty);
                return;
            }
            var indexEntry = dataResult.getOutputData("index");
            this.boundingBoxChanged(XflowUtils.calculateBoundingBox(positionEntry.getValue(), indexEntry ? indexEntry.getValue() : null));
        }
    }()), /**
     *
     * @param {ComputeRequest} request
     * @param {XC.RESULT_STATE} state
     */
    typeDataChanged: function (request, state) {
        this.changeState |= state == XC.RESULT_STATE.CHANGED_STRUCTURE ? CHANGE_STATE.STRUCTURE_CHANGED : CHANGE_STATE.TYPE_DATA_CHANGED;
        this.emit(EVENT_TYPE.SCENE_SHAPE_CHANGED);
        this.context.requestRedraw("Mesh Type Data Change");
        XML3D.debug.logDebug("XflowMesh: Type data changed", request, state, this.changeState);
    },

    getMesh: function () {
        return this.mesh;
    },

    getMeshType: function () {
        return this.mesh.glType;
    },

    updateObjectShaderRequest: function () {
        if (this.objectShaderRequest) this.objectShaderRequest.clear();
        this.objectShaderRequest = null;
        if (this.dataNode.isSubtreeLoading())
            return;

        this.objectShaderRequest = this.shaderComposer.createObjectDataRequest(this.dataNode, this.shaderInputDataChanged.bind(this));
    },

    updateShaderClosure: function (scene) {
        this.shaderClosure = null;
        if (!this.dataNode.isSubtreeLoading() && !this.dataNode.getOutputChannelInfo("position")) {
            throw new Error("Mesh does not have 'position' attribute.");
            //XML3D.debug.logError("Mesh does not have 'position' attribute.", this.mesh, this.getMeshType());
        } else if (!this.dataNode.isSubtreeLoading()) {
            var objectShaderResult = this.objectShaderRequest.getResult();
            if (!objectShaderResult.loading)
                this.shaderClosure = this.shaderComposer.getShaderClosure(scene, this.objectShaderRequest);
        }
    },

    updateIndexBuffer: function () {
        // Add Index buffer, if available
        var dataResult = this.typeRequest.getResult();
        var entry = dataResult.getOutputData("index");
        if (entry && entry.getValue())
            this.handleBuffer("index", entry, true);
    },

    updateObjectShaderData: function () {
        if (!this.shaderClosure) {
            return; // if only the data has changed, it can't get valid after update
        }

        if (!this.bindedHandleBuffer) this.bindedHandleBuffer = this.handleBuffer.bind(this);
        if (!this.bindedHandleUniform) this.bindedHandleUniform = this.handleUniform.bind(this);

        this.shaderComposer.distributeObjectShaderData(this.objectShaderRequest, this.bindedHandleBuffer, this.bindedHandleUniform);

        if (!this.mesh.isReadyToRender()) {
            throw new Error("Mesh has empty vertex attributes.");
        }
    },

    updateTypeData: function () {
        if (!this.typeDataValid && !(this.changeState & CHANGE_STATE.STRUCTURE_CHANGED)) {
            return; // only if structure has changed, it can't get valid after update
        }

        this.updateTypeRequest();

        this.calculateBoundingBox();

        var dataResult = this.typeRequest.getResult();

        var entry = dataResult.getOutputData("vertexCount");
        this.mesh.setVertexCount(entry && entry.getValue() ? entry.getValue() : null);
        this.typeDataValid = true;
    },

    /**
     * @param {string} name
     * @param {Xflow.BufferEntry} xflowDataEntry
     * @param {boolean=} isIndex
     */
    handleBuffer: function (name, xflowDataEntry, isIndex) {
        isIndex = isIndex || false;
        var mesh = this.mesh;

        if (name == "position" && !xflowDataEntry) {
            throw new Error("'position' attribute of mesh is empty.");
        }

        if (!xflowDataEntry) {
            this.mesh.removeBuffer(name);
            return;
        }

        if (xflowDataEntry.type == XC.DATA_TYPE.TEXTURE) {
            XML3D.debug.logError("Texture as mesh parameter is not yet supported");
            return;
        }

        var buffer = XflowUtils.getGLBufferFromXflowDataEntry(xflowDataEntry, this.context, name == "index");
        if (isIndex) {
            this.updateIndexRange(xflowDataEntry);
        } else {
            this.mesh.checkBufferCompatible(name, xflowDataEntry);
        }
        // In every case, set the buffer, because other meshes might have already
        // performed one or more of the tasks above
        //console.log("Set buffer", name, buffer.id);
        mesh.setBuffer(name, buffer);
    },

    updateIndexRange: function (xflowDataEntry) {
        var webglData = this.context.getXflowEntryWebGlData(xflowDataEntry);
        this.mesh.setIndexRange(webglData.minIndex, webglData.maxIndex);
    },

    /*checkBufferSize: function(name, xflowDataEntry){
     if(xflowDataEntry.getIterateCount){
     var cnt = xflowDataEntry.getIterateCount();
     if(cnt >= this.mesh.maxIndex)
     throw new Error("Index range of [" + this.mesh.minIndex + ", " + this.mesh.maxIndex + "] " +
     " goes beyond element count " + cnt + " of attribute '" + name + "'");
     }
     },*/

    handleUniform: function (name, xflowDataEntry) {
        var value = XflowUtils.getGLUniformValueFromXflowDataEntry(xflowDataEntry, this.context);
        this.mesh.setUniformOverride(name, value);
    }, /**
     *
     */
    updateTypeRequest: function () {
        var meshConfig = MESH_PARAMETERS[this.getMeshType()];
        if (!meshConfig) {
            XML3D.debug.logError("Unsupported Mesh request: ", this.mesh, this.getMeshType());
            this.typeDataValid = false;
            return;
        }
        var requestNames = this.getTypeRequestNames(meshConfig);

        if (!this.typeRequest || this.typeRequest.filter != requestNames) {
            if (this.typeRequest) this.typeRequest.clear();
            this.typeRequest = new ComputeRequest(this.dataNode, requestNames, this.typeDataChanged.bind(this));
        }
    },

    getTypeRequestNames: function (meshConfig) {
        var requestNames = [];
        requestNames.push.apply(requestNames, Object.keys(meshConfig.typeData));
        // We always request fixed bounding box values: that way we can react, when those values get available
        requestNames.push.apply(requestNames, Object.keys(meshConfig.bboxFix));
        var computeBBox = !this.checkXflowTypes(this.dataNode, meshConfig.bboxFix);

        if (computeBBox) {
            if (!this.checkXflowTypes(this.dataNode, meshConfig.bboxCompute)) {
                this.typeDataValid = false;
            }
            requestNames.push.apply(requestNames, Object.keys(meshConfig.bboxCompute));
        }
        return requestNames;
    },

    checkXflowTypes: function (dataNode, requirements) {
        for (var name in requirements) {
            var info = dataNode.getOutputChannelInfo(name);
            if (!info) return false;
            if (info.type != requirements[name])
                return false;
        }
        return true;
    },

    /**
     * @param {ComputeRequest} request
     * @param {XC.RESULT_STATE} state
     */
    shaderInputDataChanged: function (request, state) {
        this.changeState |= state != XC.RESULT_STATE.CHANGED_DATA_VALUE ? CHANGE_STATE.STRUCTURE_CHANGED : CHANGE_STATE.VS_DATA_CHANGED;
        // TODO: We don't know if the change of data only influences the surface shading or the actual mesh shape
        this.emit(EVENT_TYPE.SCENE_SHAPE_CHANGED);
        this.context.requestRedraw("Mesh Attribute Data Changed");
        XML3D.debug.logDebug("XflowMesh: Attribute data changed", request, state, this.changeState);
    },

    shaderChanged: function () {
        this.changeState |= CHANGE_STATE.SHADER_CHANGED;
    },

    getProgram: function () {
        return this.shaderClosure;
    }

});

module.exports = XflowMesh;


},{"../../../xflow/interface/constants.js":179,"../../../xflow/interface/request.js":182,"../../renderer/scene/constants.js":95,"../../renderer/scene/drawableclosure.js":96,"../base/mesh.js":112,"../materials/events.js":120,"./utils.js":157}],159:[function(require,module,exports){
var vec4 = require("gl-matrix").vec4;
var Vec3 = require("./vec3.js");

var AxisAngle = function(vec) {
    if (this instanceof AxisAngle) {
        this.data = vec4.create();
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new AxisAngle(vec);
};


Object.defineProperty(AxisAngle.prototype, "axis", {
    set: function(vec){
        this.data[0] = vec.data ? vec.data[0] : vec[0];
        this.data[1] = vec.data ? vec.data[1] : vec[1];
        this.data[2] = vec.data ? vec.data[2] : vec[2];
    },
    get: function(){ return Vec3.wrap(this.data) }
});
Object.defineProperty(AxisAngle.prototype, "angle", {
    set: function(a){
        this.data[3] = a;
    },
    get: function(){ return this.data[3]; }
});

AxisAngle.prototype.clone = function() {
   return new AxisAngle(this);
};

AxisAngle.fromValues = function(x, y, z, angle) {
    return new AxisAngle(vec4.fromValues(x,y,z,angle));
};

AxisAngle.fromQuat = function(q) {
    var out = new AxisAngle();
    out.data.set(XML3D.math.vec4.fromQuat(q.data ? q.data : q));
    return out;
};

AxisAngle.prototype.toDOMString = function() {
    return vec4.toDOMString(this.data);
};

AxisAngle.fromDOMString = function(str) {
    var out = new AxisAngle();
    out.data.set( vec4.fromDOMString(str) );
    return out;
};

AxisAngle.prototype.toQuat = function() {
    var out = new Quat();
    quat.setAxisAngle(out.data, this.data, this.data[3]);
    return out;
};

AxisAngle.wrap = function(vec) {
    var v = AxisAngle();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = AxisAngle;

},{"./vec3.js":168,"gl-matrix":1}],160:[function(require,module,exports){
var Vec3 = require("./vec3.js");
var vec3 = require("gl-matrix").vec3;

var Box = function(box) {
    if (this instanceof Box) {
        this.data = new Float32Array(6);
        if (box) {
            this.data.set(box.data ? box.data : box);
        } else {
            this.setEmpty();
        }
    } else return new Box(box);
};

Object.defineProperty(Box.prototype, "min", {
    set: function(v){
        var val = v.data ? v.data : v;
        this.data[0] = val[0];
        this.data[1] = val[1];
        this.data[2] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(0,3));
    }
});

Object.defineProperty(Box.prototype, "max", {
    set: function(v){
        var val = v.data ? v.data : v;
        this.data[3] = val[0];
        this.data[4] = val[1];
        this.data[5] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(3,6));
    }
});

Box.prototype.clone = function() {
    return new Box(this);
};

Box.prototype.copy = function(other) {
    this.copyMin(other);
    this.copyMax(other);
    return this;
};

Box.prototype.copyMin = function(other) {
    vec3.copy(this.data, other.data ? other.data : other);
    return this;
};

Box.prototype.copyMax = function(other) {
    vec3.copy(this.data.subarray(3,6), other.data ? other.data.subarray(3,6) : other.subarray(3,6));
    return this;
};

Box.prototype.extend = function(other) {
    var box = other.data ? other.data : other;
    for (var i = 0; i < 3; i++) {
        this.data[i] = Math.min(box[i], this.data[i]);
        this.data[i + 3] = Math.max(box[i + 3], this.data[i + 3]);
    }
    return this;
};

Box.prototype.setEmpty = function() {
    this.data[0] = Number.MAX_VALUE;
    this.data[1] = Number.MAX_VALUE;
    this.data[2] = Number.MAX_VALUE;
    this.data[3] = -Number.MAX_VALUE;
    this.data[4] = -Number.MAX_VALUE;
    this.data[5] = -Number.MAX_VALUE;
    return this;
};

Box.prototype.isEmpty = function() {
    return (this.data[0] > this.data[3] || this.data[1] > this.data[4] || this.data[2] > this.data[5]);
};

Box.prototype.center = function(target) {
    var cen = target || new Vec3();
    cen.x = (this.data[0] + this.data[3]) * 0.5;
    cen.y = (this.data[1] + this.data[4]) * 0.5;
    cen.z = (this.data[2] + this.data[5]) * 0.5;
    return cen;
};

Box.prototype.size = function(target) {
    var size = target || new Vec3();
    size.x = Math.max(this.data[3] - this.data[0], 0);
    size.y = Math.max(this.data[4] - this.data[1], 0);
    size.z = Math.max(this.data[5] - this.data[2], 0);
    return size;
};

Box.prototype.extent = function() {
    return this.size().scale(0.5);
};

Box.prototype.transformAxisAligned = function(mat) {
    if (this.isEmpty()) {
        return this;
    }
    var out = new Float32Array(6);
    var m = mat.data ? mat.data : mat;
    if (m[3] == 0 && m[7] == 0 && m[11] == 0 && m[15] == 1) {

        for (var i = 0; i < 3; i++) {
            out[i] = out[i + 3] = m[12 + i];

            for (var j = 0; j < 3; j++) {
                var a, b;

                a = m[j * 4 + i] * this.data[j];
                b = m[j * 4 + i] * this.data[j + 3];

                if (a < b) {
                    out[i] += a;
                    out[i + 3] += b;
                }
                else {
                    out[i] += b;
                    out[i + 3] += a;
                }
            }
        }
        this.data.set(out);
        return this;
    }
    throw new Error("Matrix is not affine");
};

Box.prototype.transform = function(mat) {
    if (this.isEmpty()) {
        return this;
    }
    vec3.transformMat4(this.min.data, this.min.data, mat.data ? mat.data : mat);
    vec3.transformMat4(this.max.data, this.max.data, mat.data ? mat.data : mat);
    return this;
};

Box.prototype.longestSide = function() {
    if (this.isEmpty()) {
        return 0;
    }
    var x = Math.abs(this.data[3] - this.data[0]);
    var y = Math.abs(this.data[4] - this.data[1]);
    var z = Math.abs(this.data[5] - this.data[2]);
    return Math.max(x, Math.max(y, z));
};

Box.prototype.intersects = function(ray, opt) {
    if (this.isEmpty()) {
        if (opt !== undefined && opt.dist !== undefined) {
            opt.dist = Infinity;
        }
        return false;
    }
    var origin = ray.origin;
    var direction = ray.direction;
    var inverseDirX = 1 / direction.x;
    var inverseDirY = 1 / direction.y;
    var inverseDirZ = 1 / direction.z;

    var t1 = (this.data[0] - origin.x) * inverseDirX;
    var t2 = (this.data[3] - origin.x) * inverseDirX;
    var t3 = (this.data[1] - origin.y) * inverseDirY;
    var t4 = (this.data[4] - origin.y) * inverseDirY;
    var t5 = (this.data[2] - origin.z) * inverseDirZ;
    var t6 = (this.data[5] - origin.z) * inverseDirZ;

    var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
    var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

    if (opt === undefined || opt.dist === undefined) {
        return tmax > 0 && tmin <= tmax;
    }

    if (tmax < 0 || tmin > tmax) {
        opt.dist = Infinity;
        return false;
    }

    opt.dist = tmin;
    return true;
};

Box.prototype.toString = function() {
    return 'XML3D.Box(' + this.data[0] + ', ' + this.data[1] + ', ' + this.data[2] + ', ' + this.data[3] + ', ' +
        this.data[4] + ', ' + this.data[5] + ')';
};

Box.EMPTY_BOX = new Box();

module.exports = Box;

},{"./vec3.js":168,"gl-matrix":1}],161:[function(require,module,exports){
var XC = require("../xflow/interface/constants.js");
var Resource = require("../base/resourcemanager.js").Resource;

var c_XflowObserverList = [];

var XML3DDataObserver = function(callback){
    this.callback = callback;
    this.observed = [];
};

XML3DDataObserver.prototype.observe = function(node, options){
    if(!node)
        throw new Error("The node to observe is null.");


    if(!node._configured)
        throw new Error("Note to observe is not   (yet). Make sure to pass an XML3D node and to execute " +
            "this function after XML3D has been configured e.g. inside a DOMContentLoaded listener.");


    var dataAdapter = Resource.getAdapter(node, "data");
    if(!dataAdapter)
        throw new Error("Can't observe node. XML3DataObserver can only observe data containers such as <data>, <mesh> or <shader>");

    if(this.observed.length == 0)
        c_XflowObserverList.push(this);

    var entry = {
        node: node,
        changed: false,
        request: null
    };

    var names = options && options['names'];
    var typeOfNames = Object.prototype.toString.call(names).slice(8, -1);
    if (typeOfNames === "String") {
        names = [names];
    }

    entry.request = dataAdapter.getComputeRequest(names, function(request, changeType){
        entry.changed = true;
    });
    // Fetch result to synchronize Xflow structures and connect to callbacks
    // TODO: Find an option to connect request to callback structure without computing result
    entry.request.getResult();

    this.observed.push(entry);
};

XML3DDataObserver.prototype.disconnect = function(){
    for(var i = 0; i < this.observed.length; ++i){
        this.observed[i].request.clear();
    }
    this.observed = [];
    var i = c_XflowObserverList.length;
    while(i--){
        if(c_XflowObserverList[i] == this)
            c_XflowObserverList.splice(i, 1);
    }
};


XML3D.updateXflowObserver = function(){
    for(var i = 0; i < c_XflowObserverList.length; ++i){
        var observer = c_XflowObserverList[i];
        var records = [];
        for(var j = 0; j < observer.observed.length; ++j){
            var entry = observer.observed[j];
            if(entry.changed){
                entry.changed = false;
                var result = entry.request.getResult();
                var dataResult = new XML3DDataResult(result);
                records.push( new XML3DDataRecord(entry.node, dataResult));
            }
        }
        if(records.length > 0 && observer.callback){
            observer.callback(records, observer);
        }
    }
};

var XML3DDataRecord = function(target, result){
    this.target = target;
    this.result = result;
};


var XML3DDataResult = function(result){
    this._entries = {};
    constructDataResult(this, result);
};

XML3DDataResult.prototype.getValue = function(name) {
    if (this._entries[name])
        return this._entries[name].value;
    return null;
};

XML3DDataResult.prototype.getType = function(name) {
    if (this._entries[name])
        return this._entries[name].type;
    return null;
};

XML3DDataResult.prototype.getNames = function(){
    var result = [];
    for(var name in this._entries){
        result.push(name);
    }
    return result;
};

XML3DDataResult.FLOAT  = 0;
XML3DDataResult.FLOAT2 = 1;
XML3DDataResult.FLOAT3 = 2;
XML3DDataResult.FLOAT4 = 3;
XML3DDataResult.FLOAT4X4 = 4;
XML3DDataResult.INT = 10;
XML3DDataResult.INT4 = 11;
XML3DDataResult.BOOL = 20;
XML3DDataResult.TEXTURE = 30;
XML3DDataResult.BYTE = 40;
XML3DDataResult.UBYTE = 50;


function constructDataResult(dataResult, result){
    for(var i = 0; i < result.outputNames.length; ++i){
        var name = result.outputNames[i];
        var entry = result.getOutputData(name);
        var value = entry && entry.getValue();
        if (value !== null) {
            var type = getXML3DDataType(entry.type);
            dataResult._entries[name] = { type: type, value: value};
        }
    }
}

function getXML3DDataType(type){
    switch(type){
        case XC.DATA_TYPE.FLOAT : return XML3DDataResult.FLOAT;
        case XC.DATA_TYPE.FLOAT2 : return XML3DDataResult.FLOAT2;
        case XC.DATA_TYPE.FLOAT3 : return XML3DDataResult.FLOAT3;
        case XC.DATA_TYPE.FLOAT4 : return XML3DDataResult.FLOAT4;
        case XC.DATA_TYPE.FLOAT4X4 : return XML3DDataResult.FLOAT4X4;
        case XC.DATA_TYPE.INT : return XML3DDataResult.INT;
        case XC.DATA_TYPE.INT4 : return XML3DDataResult.INT4;
        case XC.DATA_TYPE.BOOL : return XML3DDataResult.BOOL;
        case XC.DATA_TYPE.TEXTURE : return XML3DDataResult.TEXTURE;
        case XC.DATA_TYPE.BYTE : return XML3DDataResult.BYTE;
        case XC.DATA_TYPE.UBYTE : return XML3DDataResult.UBYTE;
        default: throw new Error("WHAT IS THIS I DON'T EVEN...");
    }
}

var XML3DDataChannelInfo = function(type, origin, originalName, seqLength, seqMinKey, seqMaxKey){
    this.type = getXML3DDataType(type);
    this.origin = origin;
    this.originalName = originalName;
    this.seqLength = seqLength;
    this.seqMinKey = seqMinKey;
    this.seqMaxKey = seqMaxKey;
};

XML3DDataChannelInfo.ORIGIN_CHILD = 1;
XML3DDataChannelInfo.ORIGIN_COMPUTE = 2;
XML3DDataChannelInfo.ORIGIN_PROTO = 3;

module.exports = {
    XML3DDataChannelInfo: XML3DDataChannelInfo,
    XML3DDataResult: XML3DDataResult,
    XML3DDataObserver: XML3DDataObserver
};

},{"../base/resourcemanager.js":46,"../xflow/interface/constants.js":179}],162:[function(require,module,exports){
var mat2 = require("gl-matrix").mat2;

var Mat2 = function(mat) {
    if (this instanceof Mat2) {
        this.data = mat2.create();
        if (mat) {
            this.data.set(mat.data ? mat.data : mat);
        }
    } else return new Mat2(mat);
};

Object.defineProperty(Mat2.prototype, "m11", {
    set: function(x){ this.data[0] = x; },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Mat2.prototype, "m12", {
    set: function(x){ this.data[1] = x; },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Mat2.prototype, "m21", {
    set: function(x){ this.data[2] = x; },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Mat2.prototype, "m22", {
    set: function(x){ this.data[3] = x; },
    get: function(){ return this.data[3]; }
});

Mat2.prototype.adjoint = function() {
    var out = new Mat2();
    mat2.adjoint(out.data, this.data);
    return out;
};

Mat2.prototype.clone = function() {
   return new Mat2(this);
};

Mat2.prototype.determinant = function() {
    return mat2.determinant(this.data);
};

Mat2.prototype.invert = function() {
    var out = new Mat2();
    mat2.invert(out.data, this.data);
    return out;
};

Mat2.prototype.mul = Mat2.prototype.multiply = function(b) {
    var out = new Mat2();
    mat2.multiply(out.data, this.data, b.data ? b.data : b);
    return out;
};

Mat2.prototype.rotate = function(rad) {
    var out = new Mat2();
    mat2.rotate(out.data, this.data, rad);
    return out;
};

Mat2.prototype.scale = function(vec) {
    var out = new Mat2();
    mat2.scale(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat2.prototype.transpose = function() {
    var out = new Mat2();
    mat2.transpose(out.data, this.data);
    return out;
};

Mat2.wrap = function(mat) {
    var m = Mat2();
    m.data = mat.data ? mat.data : mat;
    return m;
};

module.exports = Mat2;

},{"gl-matrix":1}],163:[function(require,module,exports){
var mat3 = require("gl-matrix").mat3;

var Mat3 = function(mat) {
    if (this instanceof Mat3) {
        this.data = mat3.create();
        if (mat) {
            this.data.set(mat.data ? mat.data : mat);
        }
    } else return new Mat3(mat);
};

Object.defineProperty(Mat3.prototype, "m11", {
    set: function(x){ this.data[0] = x; },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Mat3.prototype, "m12", {
    set: function(x){ this.data[1] = x; },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Mat3.prototype, "m13", {
    set: function(x){ this.data[2] = x; },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Mat3.prototype, "m21", {
    set: function(x){ this.data[3] = x; },
    get: function(){ return this.data[3]; }
});
Object.defineProperty(Mat3.prototype, "m22", {
    set: function(x){ this.data[4] = x; },
    get: function(){ return this.data[4]; }
});
Object.defineProperty(Mat3.prototype, "m23", {
    set: function(x){ this.data[5] = x; },
    get: function(){ return this.data[5]; }
});
Object.defineProperty(Mat3.prototype, "m31", {
    set: function(x){ this.data[6] = x; },
    get: function(){ return this.data[6]; }
});
Object.defineProperty(Mat3.prototype, "m32", {
    set: function(x){ this.data[7] = x; },
    get: function(){ return this.data[7]; }
});
Object.defineProperty(Mat3.prototype, "m33", {
    set: function(x){ this.data[8] = x; },
    get: function(){ return this.data[8]; }
});


Mat3.prototype.adjoint = function() {
    var out = new Mat3();
    mat3.adjoint(out.data, this.data);
    return out;
};

Mat3.prototype.clone = function() {
   return new Mat3(this);
};

Mat3.prototype.determinant = function() {
    return mat3.determinant(this.data);
};

Mat3.fromMat4 = function(m) {
    var out = new Mat3();
    mat3.fromMat4(out.data, m.data ? m.data : m);
    return out;
};

Mat3.fromQuat = function(q) {
    var out = new Mat3();
    mat3.fromQuat(out.data, q.data ? q.data : q);
    return out;
};

Mat3.prototype.invert = function() {
    var out = new Mat3();
    mat3.invert(out.data, this.data);
    return out;
};

Mat3.prototype.mul = Mat3.prototype.multiply = function(b) {
    var out = new Mat3();
    mat3.multiply(out.data, this.data, b.data ? b.data : b);
    return out;
};

Mat3.normalFromMat4 = function(m) {
    var out = new Mat3();
    mat3.normalFromMat4(out.data, m.data ? m.data : m);
    return out;
};

Mat3.prototype.rotate = function(rad) {
    var out = new Mat3();
    mat3.rotate(out.data, this.data, rad);
    return out;
};

Mat3.prototype.scale = function(vec) {
    var out = new Mat3();
    mat3.scale(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat3.prototype.transpose = function() {
    var out = new Mat3();
    mat3.transpose(out.data, this.data);
    return out;
};

Mat3.prototype.translate = function(vec) {
    var out = new Mat3();
    mat3.translate(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat3.wrap = function(mat) {
    var m = Mat3();
    m.data = mat.data ? mat.data : mat;
    return m;
};

module.exports = Mat3;

},{"gl-matrix":1}],164:[function(require,module,exports){
var mat4 = require("gl-matrix").mat4;

var Mat4 = function(mat) {
    if (this instanceof Mat4) {
        this.data = mat4.create();
        if (mat) {
            this.data.set(mat.data ? mat.data : mat);
        }
    } else return new Mat4(mat);
};

Object.defineProperty(Mat4.prototype, "m11", {
    set: function(x){ this.data[0] = x; },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Mat4.prototype, "m12", {
    set: function(x){ this.data[1] = x; },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Mat4.prototype, "m13", {
    set: function(x){ this.data[2] = x; },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Mat4.prototype, "m14", {
    set: function(x){ this.data[3] = x; },
    get: function(){ return this.data[3]; }
});
Object.defineProperty(Mat4.prototype, "m21", {
    set: function(x){ this.data[4] = x; },
    get: function(){ return this.data[4]; }
});
Object.defineProperty(Mat4.prototype, "m22", {
    set: function(x){ this.data[5] = x; },
    get: function(){ return this.data[5]; }
});
Object.defineProperty(Mat4.prototype, "m23", {
    set: function(x){ this.data[6] = x; },
    get: function(){ return this.data[6]; }
});
Object.defineProperty(Mat4.prototype, "m24", {
    set: function(x){ this.data[7] = x; },
    get: function(){ return this.data[7]; }
});
Object.defineProperty(Mat4.prototype, "m31", {
    set: function(x){ this.data[8] = x; },
    get: function(){ return this.data[8]; }
});
Object.defineProperty(Mat4.prototype, "m32", {
    set: function(x){ this.data[9] = x; },
    get: function(){ return this.data[9]; }
});
Object.defineProperty(Mat4.prototype, "m33", {
    set: function(x){ this.data[10] = x; },
    get: function(){ return this.data[10]; }
});
Object.defineProperty(Mat4.prototype, "m34", {
    set: function(x){ this.data[11] = x; },
    get: function(){ return this.data[11]; }
});
Object.defineProperty(Mat4.prototype, "m41", {
    set: function(x){ this.data[12] = x; },
    get: function(){ return this.data[12]; }
});
Object.defineProperty(Mat4.prototype, "m42", {
    set: function(x){ this.data[13] = x; },
    get: function(){ return this.data[13]; }
});
Object.defineProperty(Mat4.prototype, "m43", {
    set: function(x){ this.data[14] = x; },
    get: function(){ return this.data[14]; }
});
Object.defineProperty(Mat4.prototype, "m44", {
    set: function(x){ this.data[15] = x; },
    get: function(){ return this.data[15]; }
});

Mat4.prototype.adjoint = function() {
    var out = new Mat4();
    mat4.adjoint(out.data, this.data);
    return out;
};

Mat4.prototype.clone = function() {
   return new Mat4(this);
};

Mat4.prototype.determinant = function() {
    return mat4.determinant(this.data);
};

Mat4.frustum = function(left, right, bottom, top, near, far) {
    var out = new Mat4();
    mat4.frustum(out.data, left, right, bottom, top, near, far);
    return out;
};

Mat4.prototype.invert = function() {
    var out = new Mat4();
    mat4.invert(out.data, this.data);
    return out;
};

Mat4.lookAt = function(eye, center, up) {
    var out = new Mat4();
    mat4.lookAt(out.data, eye.data ? eye.data : eye, center.data ? center.data : center, up.data ? up.data : up);
    return out;
};

Mat4.prototype.mul = Mat4.prototype.multiply = function(b) {
    var out = new Mat4();
    mat4.multiply(out.data, this.data, b.data ? b.data : b);
    return out;
};

Mat4.ortho = function(left, right, bottom, top, near, far) {
    var out = new Mat4();
    mat4.ortho(out.data, left, right, bottom, top, near, far);
    return out;
};

Mat4.perspective = function(fov, aspect, near, far) {
    var out = new Mat4();
    mat4.perspective(out.data, fov, aspect, near, far);
    return out;
};

Mat4.prototype.rotate = function(rad, axis) {
    var out = new Mat4();
    mat4.rotate(out.data, this.data, rad, axis.data ? axis.data : axis);
    return out;
};

Mat4.prototype.rotateX = function(rad) {
    var out = new Mat4();
    mat4.rotateX(out.data, this.data, rad);
    return out;
};

Mat4.prototype.rotateY = function(rad) {
    var out = new Mat4();
    mat4.rotateY(out.data, this.data, rad);
    return out;
};

Mat4.prototype.rotateZ = function(rad) {
    var out = new Mat4();
    mat4.rotateZ(out.data, this.data, rad);
    return out;
};

Mat4.prototype.scale = function(vec) {
    var out = new Mat4();
    mat4.scale(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat4.fromQuat = function(q) {
    var out = new Mat4();
    mat4.fromQuat(out.data, q.data ? q.data : q);
    return out;
};

Mat4.fromRotationTranslation = function(q, v) {
    var out = new Mat4();
    mat4.fromRotationTranslation(out.data, q.data ? q.data : q, v.data ? v.data : v);
    return out;
};

Mat4.prototype.transpose = function() {
    var out = new Mat4();
    mat4.transpose(out.data, this.data);
    return out;
};

Mat4.prototype.translate = function(vec) {
    var out = new Mat4();
    mat4.translate(out.data, this.data, vec.data ? vec.data : vec);
    return out;
};

Mat4.wrap = function(mat) {
    var m = Mat4();
    m.data = mat.data ? mat.data : mat;
    return m;
};


module.exports = Mat4;

},{"gl-matrix":1}],165:[function(require,module,exports){
var quat = require("gl-matrix").quat;

var Quat = function(vec) {
    if (this instanceof Quat) {
        this.data = quat.create();
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new Quat(vec);
};

Object.defineProperty(Quat.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Quat.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Quat.prototype, "z", {
    set: function(z){
        this.data[2] = z;
    },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Quat.prototype, "w", {
    set: function(w){
        this.data[3] = w;
    },
    get: function(){ return this.data[3]; }
});

Quat.prototype.add = function(b) {
    var out = new Quat();
    quat.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Quat.prototype.calculateW = function() {
    var out = new Quat();
    quat.calculateW(out.data, this.data);
    return out;
};

Quat.prototype.clone = function() {
   return new Quat(this);
};

Quat.prototype.conjugate = function() {
    var out = new Quat();
    quat.conjugate(out.data, this.data);
    return out;
};

Quat.prototype.dot = function(b) {
    return quat.dot(this.data, b.data ? b.data : b);
};

Quat.prototype.invert = function() {
    var out = new Quat();
    quat.invert(out.data, this.data);
    return out;
};

Quat.prototype.len = Quat.prototype.length = function() {
    return quat.length(this.data);
};

Quat.prototype.lerp = function(b, t) {
    var out = new Quat();
    quat.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Quat.prototype.mul = Quat.prototype.multiply = function(b) {
    var out = new Quat();
    quat.mul(out.data, this.data, b.data ? b.data : b);
    return out;
};

Quat.prototype.normalize = function() {
    var out = new Quat();
    quat.normalize(out.data, this.data);
    return out;
};

Quat.prototype.rotateX = function(rad) {
    var out = new Quat();
    quat.rotateX(out.data, this.data, rad);
    return out;
};

Quat.prototype.rotateY = function(rad) {
    var out = new Quat();
    quat.rotateY(out.data, this.data, rad);
    return out;
};

Quat.prototype.rotateZ = function(rad) {
    var out = new Quat();
    quat.rotateZ(out.data, this.data, rad);
    return out;
};

Quat.prototype.scale = function(s) {
    var out = new Quat();
    quat.scale(out.data, this.data, s);
    return out;
};

Quat.fromAxisAngle = function(axis, rad) {
    var out = new Quat();
    if (rad === undefined) {
        quat.setAxisAngle(out.data, axis.data ? axis.data : axis, axis.data ? axis.data[3] : axis[3]);
    } else {
        quat.setAxisAngle(out.data, axis.data ? axis.data : axis, rad);
    }
    return out;
};

Quat.fromBasis = function(x, y, z) {
    var out = new Quat();
    XML3D.math.quat.setFromBasis(out.data, x.data ? x.data : x, y.data ? y.data : y, z.data ? z.data : z);
    return out;
};

Quat.fromMat3 = function(m) {
    var out = new Quat();
    quat.fromMat3(out.data, m.data ? m.data : m);
    return out;
};

Quat.fromRotationTo = function(from, to) {
    var out = new Quat();
    quat.rotationTo(out.data, from.data ? from.data : from, to.data ? to.data : to);
    return out;
};

Quat.prototype.slerp = function(b, t) {
    var out = new Quat();
    quat.slerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Quat.prototype.toDOMString = function() {
    return quat.toDOMString(this.data);
};

Quat.fromDOMString = function(str) {
    var out = new Quat();
    out.data.set( quat.fromDOMString(str) );
    return out;
};

Quat.wrap = function(vec) {
    var v = Quat();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Quat;

},{"gl-matrix":1}],166:[function(require,module,exports){
var Vec3 = require("./vec3.js");
var vec3 = require("gl-matrix").vec3;

var Ray = function(ray) {
    if (this instanceof Ray) {
        this.data = new Float32Array(6);
        this.data[5] = -1;
        if (ray) {
            this.data.set( ray.data ? ray.data : ray );
        }
    } else {
        return new Ray(ray);
    }
};

Object.defineProperty(Ray.prototype, "origin", {
    set: function(v){
        var val = v.data ? v.data : v;
        this.data[0] = val[0];
        this.data[1] = val[1];
        this.data[2] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(0,3));
    }
});

Object.defineProperty(Ray.prototype, "direction", {
    set: function(v){
        var val = v.data ? v.data : v;
        vec3.normalize(val, val);
        this.data[3] = val[0];
        this.data[4] = val[1];
        this.data[5] = val[2];
    },
    get: function(){
        return Vec3.wrap(this.data.subarray(3,6));
    }
});

Ray.prototype.setFromOriginDirection = function(origin, direction) {
    this.origin = origin;
    this.direction = direction;
    return this;
};

Ray.prototype.clone = function() {
    return new Ray().copy(this);
};

Ray.prototype.copy = function(other) {
    this.copyOrigin(other);
    this.copyDirection(other);
    return this;
};

Ray.prototype.copyOrigin = function(other) {
    vec3.copy(this.data, other.data ? other.data : other);
    return this;
};

Ray.prototype.copyDirection = function(other) {
    vec3.copy(this.data.subarray(3,6), other.data ? other.data.subarray(3,6) : other.subarray(3,6));
    return this;
};

Ray.prototype.intersects = function(box, opt) {
    return box.intersects(this, opt);
};

Ray.prototype.toString = function() {
    return 'XML3D.Ray(origin: ' + this.data[0] + ', ' + this.data[1] + ', ' + this.data[2] + ', direction: ' + this.data[3] + ', ' +
        this.data[4] + ', ' + this.data[5] + ')';
};

module.exports = Ray;

},{"./vec3.js":168,"gl-matrix":1}],167:[function(require,module,exports){
var vec2 = require("gl-matrix").vec2;

var Vec2 = function(vec) {
    if (this instanceof Vec2) {
        this.data = vec2.create();
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
        Object.freeze(this);
    } else return new Vec2(vec);
};

Object.defineProperty(Vec2.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Vec2.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});

Vec2.prototype.add = function(b) {
    var out = new Vec2();
    vec2.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.clone = function() {
    return new Vec2(this);
};

Vec2.prototype.dist = Vec2.prototype.distance = function() {
    return vec2.dist(this.data);
};

Vec2.prototype.divide = function(b) {
    var out = new Vec2();
    vec2.divide(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.dot = function(b) {
    return vec2.dot(this.data, b.data ? b.data : b);
};

Vec2.fromValues = function(x, y) {
    return new Vec2(vec2.fromValues(x,y));
};

Vec2.prototype.len = Vec2.prototype.length = function() {
    return vec2.length(this.data);
};

Vec2.prototype.lerp = function(b, t) {
    var out = new Vec2();
    vec2.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Vec2.prototype.max = function(b) {
    var m = new Vec2();
    vec2.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec2.prototype.min = function(b) {
    var m = new Vec2();
    vec2.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec2.prototype.mul = Vec2.prototype.multiply = function(b) {
    var out = new Vec2();
    vec2.mul(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.negate = function() {
    var out = new Vec2();
    vec2.negate(out.data, this.data);
    return out;
};

Vec2.prototype.normalize = function() {
    var out = new Vec2();
    vec2.normalize(out.data, this.data);
    return out;
};

Vec2.random = function(scale) {
    var m = new Vec2();
    vec2.random(m.data, scale);
    return m;
};

Vec2.prototype.scale = function(s) {
    var out = new Vec2();
    vec2.scale(out.data, this.data, s);
    return out;
};

Vec2.prototype.sub = Vec2.prototype.subtract = function(b) {
    var out = new Vec2();
    vec2.sub(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec2.prototype.transformMat2 = function(m) {
    var out = new Vec2();
    vec2.transformMat2(out.data, this.data, m.data ? m.data : m);
    return out;
};

Vec2.prototype.transformMat3 = function(m) {
    var out = new Vec2();
    vec2.transformMat3(out.data, this.data, m.data ? m.data : m);
    return out;
};

Vec2.prototype.transformMat4 = function(m) {
    var out = new Vec2();
    vec2.transformMat4(out.data, this.data, m.data ? m.data : m);
    return out;
};

Vec2.prototype.toDOMString = function() {
    return vec2.toDOMString(this.data);
};

Vec2.fromDOMString = function(str) {
    var out = new Vec2();
    out.data.set( vec2.fromDOMString(str) );
    return out;
};

Vec2.wrap = function(vec) {
    var v = Vec2();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Vec2;

},{"gl-matrix":1}],168:[function(require,module,exports){
var vec3 = require("gl-matrix").vec3;

var Vec3 = function(vec) {
    if (this instanceof Vec3) {
        this.data = vec3.create();
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new Vec3(vec);
};

Object.defineProperty(Vec3.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Vec3.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Vec3.prototype, "z", {
    set: function(z){
        this.data[2] = z;
    },
    get: function(){ return this.data[2]; }
});

Vec3.prototype.add = function(b) {
    var out = new Vec3();
    vec3.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.clone = function() {
   return new Vec3(this);
};

Vec3.prototype.cross = function(b) {
    var out = new Vec3();
    vec3.cross(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.dist = Vec3.prototype.distance = function() {
    return vec3.dist(this.data);
};

Vec3.prototype.divide = function(b) {
    var out = new Vec3();
    vec3.divide(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.dot = function(b) {
    return vec3.dot(this.data, b.data ? b.data : b);
};

Vec3.fromValues = function(x, y, z) {
    return new Vec3(vec3.fromValues(x,y,z));
};

Vec3.prototype.len = Vec3.prototype.length = function() {
    return vec3.length(this.data);
};

Vec3.prototype.lerp = function(b, t) {
    var out = new Vec3();
    vec3.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Vec3.prototype.max = function(b) {
    var m = new Vec3();
    vec3.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec3.prototype.min = function(b) {
    var m = new Vec3();
    vec3.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec3.prototype.mul = Vec3.prototype.multiply = function(b) {
    var out = new Vec3();
    vec3.mul(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.negate = function() {
    var out = new Vec3();
    vec3.negate(out.data, this.data);
    return out;
};

Vec3.prototype.normalize = function() {
    var out = new Vec3();
    vec3.normalize(out.data, this.data);
    return out;
};

Vec3.prototype.random = function(scale) {
    var m = new Vec3();
    vec3.random(m.data, scale);
    return m;
};

Vec3.prototype.reciprocal = function() {
    var out = new Vec3();
    XML3D.math.vec3.reciprocal(out.data, this.data);
    return out;
};

Vec3.prototype.scale = function(s) {
    var out = new Vec3();
    vec3.scale(out.data, this.data, s);
    return out;
};

Vec3.prototype.sub = Vec3.prototype.subtract = function(b) {
    var out = new Vec3();
    vec3.sub(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec3.prototype.transformDirection = function(m) {
    var out = new Vec3();
    XML3D.math.vec3.transformDirection(out.data, this.data, m.data ? m.data : m);
    return out;
};

Vec3.prototype.transformMat3 = function(m) {
    var out = new Vec3();
    vec3.transformMat3(out.data, this.data, m.data ? m.data : m);
    return out;
};

Vec3.prototype.transformMat4 = function(m) {
    var out = new Vec3();
    vec3.transformMat4(out.data, this.data, m.data ? m.data : m);
    return out;
};

Vec3.prototype.transformQuat = function(q) {
    var out = new Vec3();
    vec3.transformQuat(out.data, this.data, q.data ? q.data : q);
    return out;
};

Vec3.prototype.toDOMString = function() {
    return vec3.toDOMString(this.data);
};

Vec3.fromDOMString = function(str) {
    var out = new Vec3();
    out.data.set( vec3.fromDOMString(str) );
    return out;
};

Vec3.wrap = function(vec) {
    var v = Vec3();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Vec3;

},{"gl-matrix":1}],169:[function(require,module,exports){
var vec4 = require("gl-matrix").vec4;
var Vec3 = require("./vec3.js");

var Vec4 = function(vec) {
    if (this instanceof Vec4) {
        this.data = vec4.create();
        if (vec) {
            this.data.set(vec.data ? vec.data : vec);
        }
    } else return new Vec4(vec);
};

Object.defineProperty(Vec4.prototype, "x", {
    set: function(x){
        this.data[0] = x;
    },
    get: function(){ return this.data[0]; }
});
Object.defineProperty(Vec4.prototype, "y", {
    set: function(y){
        this.data[1] = y;
    },
    get: function(){ return this.data[1]; }
});
Object.defineProperty(Vec4.prototype, "z", {
    set: function(z){
        this.data[2] = z;
    },
    get: function(){ return this.data[2]; }
});
Object.defineProperty(Vec4.prototype, "w", {
    set: function(w){
        this.data[3] = w;
    },
    get: function(){ return this.data[3]; }
});

Vec4.prototype.add = function(b) {
    var out = new Vec4();
    vec4.add(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.clone = function() {
   return new Vec4(this);
};

Vec4.prototype.dist = Vec4.prototype.distance = function() {
    return vec4.dist(this.data);
};

Vec4.prototype.divide = function(b) {
    var out = new Vec4();
    vec4.divide(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.dot = function(b) {
    return vec4.dot(this.data, b.data ? b.data : b);
};

Vec4.fromValues = function(x, y, z, w) {
    return new Vec4(vec4.fromValues(x,y,z,w));
};

Vec4.prototype.len = Vec4.prototype.length = function() {
    return vec4.length(this.data);
};

Vec4.prototype.lerp = function(b, t) {
    var out = new Vec4();
    vec4.lerp(out.data, this.data, b.data ? b.data : b, t);
    return out;
};

Vec4.prototype.max = function(b) {
    var m = new Vec4();
    vec4.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec4.prototype.min = function(b) {
    var m = new Vec4();
    vec4.max(m.data, this.data, b.data ? b.data : b);
    return m;
};

Vec4.prototype.mul = Vec4.prototype.multiply = function(b) {
    var out = new Vec4();
    vec4.mul(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.negate = function() {
    var out = new Vec4();
    vec4.negate(out.data, this.data);
    return out;
};

Vec4.prototype.normalize = function() {
    var out = new Vec4();
    vec4.normalize(out.data, this.data);
    return out;
};

Vec4.prototype.random = function(scale) {
    var m = new Vec4();
    vec4.random(m.data, scale);
    return m;
};

Vec4.prototype.scale = function(s) {
    var out = new Vec4();
    vec4.scale(out.data, this.data, s);
    return out;
};

Vec4.prototype.sub = Vec4.prototype.subtract = function(b) {
    var out = new Vec4();
    vec4.sub(out.data, this.data, b.data ? b.data : b);
    return out;
};

Vec4.prototype.transformMat4 = function(m) {
    var out = new Vec4();
    vec4.transformMat4(out.data, this.data, m.data ? m.data : m);
    return out;
};

Vec4.prototype.transformQuat = function(q) {
    var out = new Vec4();
    vec4.transformQuat(out.data, this.data, q.data ? q.data : q);
    return out;
};

Vec4.prototype.toDOMString = function() {
    return vec4.toDOMString(this.data);
};

Vec4.fromDOMString = function(str) {
    var out = new Vec4();
    out.data.set( vec4.fromDOMString(str) );
    return out;
};

Vec4.wrap = function(vec) {
    var v = Vec4();
    v.data = vec.data ? vec.data : vec;
    return v;
};

module.exports = Vec4;

},{"./vec3.js":168,"gl-matrix":1}],170:[function(require,module,exports){
// Add convienent array methods if non-existant
if (!Array.forEach) {
    Array.forEach = function(array, fun, thisp) {
        var len = array.length;
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                fun.call(thisp, array[i], i, array);
            }
        }
    };
}
if (!Array.map) {
    Array.map = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                res[i] = fun.call(thisp, array[i], i, array);
            }
        }
        return res;
    };
}
if (!Array.filter) {
    Array.filter = function(array, fun, thisp) {
        var len = array.length;
        var res = [];
        for ( var i = 0; i < len; i++) {
            if (i in array) {
                var val = array[i];
                if (fun.call(thisp, val, i, array)) {
                    res.push(val);
                }
            }
        }
        return res;
    };
}

if (!Array.erase) {
    Array.erase = function(array, object) {
        var erased = false;
        var idx = -1;
        while( (idx = array.indexOf(object) ) != -1){
            array.splice(idx, 1);
            erased = true;
        }
        return erased;
    };
}

if (!Array.set) {
    Array.set = function(array, offset, value) {
        for (var i=0; i < value.length; i++)
            array[offset+i] = value[i];
    };
}

if (!Array.isArray) {
    Array.isArray = function(arg) {
        return Object.prototype.toString.call(arg) == '[object Array]';
    };
}

},{}],171:[function(require,module,exports){
var CSSMatrix = require("./cssMatrix.js");

var css = {};

css.TRANSFORM_PROPERTY = null;

css.init = function () {
    if ('transform' in document.body.style) {
        css.TRANSFORM_PROPERTY = 'transform'
    } else if ('WebkitTransform' in document.body.style) {
        css.TRANSFORM_PROPERTY = '-webkit-transform'
    } else if ('MozTransform' in document.body.style) {
        css.TRANSFORM_PROPERTY = '-moz-transform'
    } else {
        XML3D.debug.logWarning("No supported transform css property found");
    }
};

css.getInlinePropertyValue = function (node, property) {
    var styleValue = node.getAttribute('style');
    if (styleValue) {
        var pattern = new RegExp(property + "\s*:([^;]+)", "i");
        var result = pattern.exec(styleValue);
        if (result)
            return result[1].trim();
    }
    return null;
};

css.getPropertyValue = function (node, property) {
    var value = this.getInlinePropertyValue(node, property);
    if (value)
        return value;

    var style = window.getComputedStyle(node);
    return style.getPropertyValue(property);
};

css.getCSSMatrix = function (node) {
    if (!css.TRANSFORM_PROPERTY || !CSSMatrix)
        return null;

    var style = null;

    if (css.TRANSFORM_PROPERTY != "transform")
        style = css.getInlinePropertyValue(node, "transform");

    if (!style)
        style = css.getPropertyValue(node, css.TRANSFORM_PROPERTY);

    if (!style || style == "none")
        return null;

    var result = null;
    try {
        result = new CSSMatrix(style);
    } catch (e) {
        XML3D.debug.logError("Error parsing transform property: " + style);
    }
    return result;

};


css.convertCssToMat4 = function (cssMatrix, m) {
    var matrix = m || new XML3D.Mat4();
    matrix.m11 = cssMatrix.m11;
    matrix.m12 = cssMatrix.m12;
    matrix.m13 = cssMatrix.m13;
    matrix.m14 = cssMatrix.m14;
    matrix.m21 = cssMatrix.m21;
    matrix.m22 = cssMatrix.m22;
    matrix.m23 = cssMatrix.m23;
    matrix.m24 = cssMatrix.m24;
    matrix.m31 = cssMatrix.m31;
    matrix.m32 = cssMatrix.m32;
    matrix.m33 = cssMatrix.m33;
    matrix.m34 = cssMatrix.m34;
    matrix.m41 = cssMatrix.m41;
    matrix.m42 = cssMatrix.m42;
    matrix.m43 = cssMatrix.m43;
    matrix.m44 = cssMatrix.m44;
    return matrix;
};

(function () {
    var styleElement = document.createElement("style");
    styleElement.textContent = "xml3d * { display: inherit; }" + "float,float2,float3,float4,float4x4,int,int4,bool,texture,compute { display: none; }";
    document.head.appendChild(styleElement);
}());


module.exports = css;


},{"./cssMatrix.js":172}],172:[function(require,module,exports){

/**
 *  class FirminCSSMatrix
 *
 *  The [[FirminCSSMatrix]] class is a concrete implementation of the
 *  `CSSMatrix` interface defined in the [CSS 2D Transforms][2d] and
 *  [CSS 3D Transforms][3d] Module specifications.
 *
 *  [2d]: http://www.w3.org/TR/css3-2d-transforms/
 *  [3d]: http://www.w3.org/TR/css3-3d-transforms/
 *
 *  The implementation was largely copied from the `WebKitCSSMatrix` class, and
 *  the supparting maths libraries in the [WebKit][webkit] project. This is one
 *  reason why much of the code looks more like C++ than JavaScript.
 *
 *  [webkit]: http://webkit.org/
 *
 *  Its API is a superset of that provided by `WebKitCSSMatrix`, largely
 *  because various pieces of supporting code have been added as instance
 *  methods rather than pollute the global namespace. Examples of these include
 *  [[FirminCSSMatrix#isAffine]], [[FirminCSSMatrix#isIdentityOrTranslation]]
 *  and [[FirminCSSMatrix#adjoint]].
 **/

/**
 *  new FirminCSSMatrix(domstr)
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 *
 *  @constructor
 **/
var FirminCSSMatrix = function(domstr) {
    this.m11 = this.m22 = this.m33 = this.m44 = 1;

    this.m12 = this.m13 = this.m14 =
    this.m21 =            this.m23 = this.m24 =
    this.m31 = this.m32 =            this.m34 =
    this.m41 = this.m42 = this.m43            = 0;

    if (typeof domstr == "string") {
        this.setMatrixValue(domstr);
    }
};

/**
 *  FirminCSSMatrix.displayName = "FirminCSSMatrix"
 **/
FirminCSSMatrix.displayName = "FirminCSSMatrix";

/**
 *  FirminCSSMatrix.degreesToRadians(angle) -> Number
 *  - angle (Number): an angle in degrees.
 *
 *  Converts angles in degrees, which are used by the external API, to angles
 *  in radians used in internal calculations.
 **/
FirminCSSMatrix.degreesToRadians = function(angle) {
    return angle * Math.PI / 180;
};

/**
 *  FirminCSSMatrix.determinant2x2(a, b, c, d) -> Number
 *  - a (Number): top-left value of the matrix.
 *  - b (Number): top-right value of the matrix.
 *  - c (Number): bottom-left value of the matrix.
 *  - d (Number): bottom-right value of the matrix.
 *
 *  Calculates the determinant of a 2x2 matrix.
 **/
FirminCSSMatrix.determinant2x2 = function(a, b, c, d) {
    return a * d - b * c;
};

/**
 *  FirminCSSMatrix.determinant3x3(matrix) -> Number
 *  - a1 (Number): matrix value in position [1, 1].
 *  - a2 (Number): matrix value in position [1, 2].
 *  - a3 (Number): matrix value in position [1, 3].
 *  - b1 (Number): matrix value in position [2, 1].
 *  - b2 (Number): matrix value in position [2, 2].
 *  - b3 (Number): matrix value in position [2, 3].
 *  - c1 (Number): matrix value in position [3, 1].
 *  - c2 (Number): matrix value in position [3, 2].
 *  - c3 (Number): matrix value in position [3, 3].
 *
 *  Calculates the determinant of a 3x3 matrix.
 **/
FirminCSSMatrix.determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3) {
    var determinant2x2 = FirminCSSMatrix.determinant2x2;
    return a1 * determinant2x2(b2, b3, c2, c3) -
    b1 * determinant2x2(a2, a3, c2, c3) +
    c1 * determinant2x2(a2, a3, b2, b3);
};

/**
 *  FirminCSSMatrix.determinant4x4(matrix) -> Number
 *  - matrix (FirminCSSMatrix): the matrix to calculate the determinant of.
 *
 *  Calculates the determinant of a 4x4 matrix.
 **/
FirminCSSMatrix.determinant4x4 = function(m) {
    var determinant3x3 = FirminCSSMatrix.determinant3x3,

        // Assign to individual variable names to aid selecting correct elements
    a1 = m.m11, b1 = m.m21, c1 = m.m31, d1 = m.m41,
    a2 = m.m12, b2 = m.m22, c2 = m.m32, d2 = m.m42,
    a3 = m.m13, b3 = m.m23, c3 = m.m33, d3 = m.m43,
    a4 = m.m14, b4 = m.m24, c4 = m.m34, d4 = m.m44;

    return a1 * determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
    b1 * determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
    c1 * determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
    d1 * determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};

/**
 * FirminCSSMatrix.toMatrixString(transformValue) -> String
 * - transformValue (String): `el.style.WebkitTransform`-style string (like `rotate(18rad) translate3d(50px, 100px, 10px)`)
 *
 * Tranforms a `el.style.WebkitTransform`-style string
 * (like `rotate(18rad) translate3d(50px, 100px, 10px)`)
 * into a `getComputedStyle(el)`-style matrix string
 * (like `matrix3d(0.6603167082440828, -0.7509872467716737, 0, 0, 0.7509872467716737, 0.6603167082440828, 0, 0, 0, 0, 1, 0, 108.11456008937151, 28.482308485824596, 10, 1)`)
 **/
FirminCSSMatrix.toMatrixString = function (transformValue) {
    var rgx = {
        functionSignature: /(\w+)\([^\)]+\)/ig,
        nameAndArguments: /(\w+)\(([^\)]+)\)/i,
        units: /([-\+]?[0-9]+[\.0-9]*)(deg|rad|grad|px|%)*/
    };
    var transformStatements = transformValue.match(/(\w+)\([^\)]+\)/ig);
    var onlyMatrices = transformStatements && transformStatements.every(function (t) { return (/^matrix/).test(t) });
    if (!transformStatements || onlyMatrices) return transformValue;

    var values = function (o) { return o.value };
    var cssFunctionToJsFunction = {
        matrix: function (m, o) {
            var m2 = new FirminCSSMatrix(o.unparsed);

            return m.multiply(m2)
        },
        matrix3d: function (m, o) {
            var m2 = new FirminCSSMatrix(o.unparsed);

            return m.multiply(m2)
        },

        perspective: function (m, o) {
            var m2 = new FirminCSSMatrix();
            m2.m34 -= 1 / o.value[0].value;

            return m.multiply(m2);
        },

        rotate: function (m, o) {
            return m.rotate.apply(m, o.value.map(values))
        },
        rotate3d: function (m, o) {
            return m.rotateAxisAngle.apply(m, o.value.map(values))
        },
        rotateX: function (m, o) {
            return m.rotate.apply(m, [o.value[0].value, 0, 0]);
        },
        rotateY: function (m, o) {
            return m.rotate.apply(m, [0, o.value[0].value, 0]);
        },
        rotateZ: function (m, o) {
            return m.rotate.apply(m, [0, 0, o.value[0].value]);
        },

        scale: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scale3d: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scaleX: function (m, o) {
            return m.scale.apply(m, o.value.map(values));
        },
        scaleY: function (m, o) {
            return m.scale.apply(m, [0, o.value[0].value, 0]);
        },
        scaleZ: function (m, o) {
            return m.scale.apply(m, [0, 0, o.value[0].value]);
        },

        skew: function (m, o) {
            var mX = new FirminCSSMatrix('skewX(' + o.value[0].unparsed + ')');
            var mY = new FirminCSSMatrix('skewY(' + o.value[1].unparsed + ')');
            var sM = 'matrix(1.00000, '+ mY.b +', '+ mX.c +', 1.000000, 0.000000, 0.000000)';
            var m2 = new FirminCSSMatrix(sM);

            return m.multiply(m2);
        },
        skewX: function (m, o) {
            return m.skewX.apply(m, [o.value[0].value]);
        },
        skewY: function (m, o) {
            return m.skewY.apply(m, [o.value[0].value]);
        },

        translate: function (m, o) {
            return m.translate.apply(m, o.value.map(values));
        },
        translate3d: function (m, o) {
            return m.translate.apply(m, o.value.map(values));
        },
        translateX: function (m, o) {
            return m.translate.apply(m, [o.value[0].value, 0, 0]);
        },
        translateY: function (m, o) {
            return m.translate.apply(m, [0, o.value[0].value, 0]);
        },
        translateZ: function (m, o) {
            return m.translate.apply(m, [0, 0, o.value[0].value]);
        }
    };
    var parseTransformStatement = function (str) {
        var pair = str.match(rgx.nameAndArguments).slice(1);

        return {
            key: pair[0],
            value: pair[1].split(/, ?/).map(function (value) {
                var parts = value.match(/([-\+]?[0-9]+[\.0-9]*)(deg|rad|grad|px|%)*/) || [];

                return {
                    value: parseFloat(parts[1]),
                    units: parts[2],
                    unparsed: value
                };
            }),
            unparsed: str
        };
    };

    var transformOperations = transformStatements.map(parseTransformStatement);
    var startingMatrix = new FirminCSSMatrix();
    var transformedMatrix = transformOperations.reduce(function (matrix, operation) {
        // convert to degrees b/c all CSSMatrix methods expect degrees
        operation.value = operation.value.map(function (operation) {
            if (operation.units == 'rad') {
                operation.value = operation.value * (180 / Math.PI);
                operation.units = 'deg';
            }
            else if (operation.units == 'grad') {
                operation.value = operation.value / (400 / 360); // 400 gradians in 360 degrees
                operation.units = 'deg'
            }

            return operation;
        });

        var jsFunction = cssFunctionToJsFunction[operation.key];
        var result = jsFunction(matrix, operation);

        return result || matrix;
    }, startingMatrix);

    return transformedMatrix.toString();
};

/**
 *  FirminCSSMatrix#a -> Number
 *  The first 2D vector value.
 **/

/**
 *  FirminCSSMatrix#b -> Number
 *  The second 2D vector value.
 **/

/**
 *  FirminCSSMatrix#c -> Number
 *  The third 2D vector value.
 **/

/**
 *  FirminCSSMatrix#d -> Number
 *  The fourth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#e -> Number
 *  The fifth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#f -> Number
 *  The sixth 2D vector value.
 **/

/**
 *  FirminCSSMatrix#m11 -> Number
 *  The 3D matrix value in the first row and first column.
 **/

/**
 *  FirminCSSMatrix#m12 -> Number
 *  The 3D matrix value in the first row and second column.
 **/

/**
 *  FirminCSSMatrix#m13 -> Number
 *  The 3D matrix value in the first row and third column.
 **/

/**
 *  FirminCSSMatrix#m14 -> Number
 *  The 3D matrix value in the first row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m21 -> Number
 *  The 3D matrix value in the second row and first column.
 **/

/**
 *  FirminCSSMatrix#m22 -> Number
 *  The 3D matrix value in the second row and second column.
 **/

/**
 *  FirminCSSMatrix#m23 -> Number
 *  The 3D matrix value in the second row and third column.
 **/

/**
 *  FirminCSSMatrix#m24 -> Number
 *  The 3D matrix value in the second row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m31 -> Number
 *  The 3D matrix value in the third row and first column.
 **/

/**
 *  FirminCSSMatrix#m32 -> Number
 *  The 3D matrix value in the third row and second column.
 **/

/**
 *  FirminCSSMatrix#m33 -> Number
 *  The 3D matrix value in the third row and third column.
 **/

/**
 *  FirminCSSMatrix#m34 -> Number
 *  The 3D matrix value in the third row and fourth column.
 **/

/**
 *  FirminCSSMatrix#m41 -> Number
 *  The 3D matrix value in the fourth row and first column.
 **/

/**
 *  FirminCSSMatrix#m42 -> Number
 *  The 3D matrix value in the fourth row and second column.
 **/

/**
 *  FirminCSSMatrix#m43 -> Number
 *  The 3D matrix value in the fourth row and third column.
 **/

/**
 *  FirminCSSMatrix#m44 -> Number
 *  The 3D matrix value in the fourth row and fourth column.
 **/

[["m11", "a"],
    ["m12", "b"],
    ["m21", "c"],
    ["m22", "d"],
    ["m41", "e"],
    ["m42", "f"]].forEach(function(pair) {
    var key3d = pair[0], key2d = pair[1];

    Object.defineProperty(FirminCSSMatrix.prototype, key2d, {
        set: function(val) {
            this[key3d] = val;
        },

        get: function() {
            return this[key3d];
        },
        enumerable : true,
        configurable : true
    });
});

/**
 *  FirminCSSMatrix#isAffine() -> Boolean
 *
 *  Determines whether the matrix is affine.
 **/
FirminCSSMatrix.prototype.isAffine = function() {
    return this.m13 === 0 && this.m14 === 0 &&
    this.m23 === 0 && this.m24 === 0 &&
    this.m31 === 0 && this.m32 === 0 &&
    this.m33 === 1 && this.m34 === 0 &&
    this.m43 === 0 && this.m44 === 1;
};

/**
 *  FirminCSSMatrix#multiply(otherMatrix) -> FirminCSSMatrix
 *  - otherMatrix (FirminCSSMatrix): the matrix to multiply this one by.
 *
 *  Multiplies the matrix by a given matrix and returns the result.
 **/
FirminCSSMatrix.prototype.multiply = function(otherMatrix) {
    if (!otherMatrix) return null;

    var a = otherMatrix,
    b = this,
    c = new FirminCSSMatrix();

    c.m11 = a.m11 * b.m11 + a.m12 * b.m21 + a.m13 * b.m31 + a.m14 * b.m41;
    c.m12 = a.m11 * b.m12 + a.m12 * b.m22 + a.m13 * b.m32 + a.m14 * b.m42;
    c.m13 = a.m11 * b.m13 + a.m12 * b.m23 + a.m13 * b.m33 + a.m14 * b.m43;
    c.m14 = a.m11 * b.m14 + a.m12 * b.m24 + a.m13 * b.m34 + a.m14 * b.m44;

    c.m21 = a.m21 * b.m11 + a.m22 * b.m21 + a.m23 * b.m31 + a.m24 * b.m41;
    c.m22 = a.m21 * b.m12 + a.m22 * b.m22 + a.m23 * b.m32 + a.m24 * b.m42;
    c.m23 = a.m21 * b.m13 + a.m22 * b.m23 + a.m23 * b.m33 + a.m24 * b.m43;
    c.m24 = a.m21 * b.m14 + a.m22 * b.m24 + a.m23 * b.m34 + a.m24 * b.m44;

    c.m31 = a.m31 * b.m11 + a.m32 * b.m21 + a.m33 * b.m31 + a.m34 * b.m41;
    c.m32 = a.m31 * b.m12 + a.m32 * b.m22 + a.m33 * b.m32 + a.m34 * b.m42;
    c.m33 = a.m31 * b.m13 + a.m32 * b.m23 + a.m33 * b.m33 + a.m34 * b.m43;
    c.m34 = a.m31 * b.m14 + a.m32 * b.m24 + a.m33 * b.m34 + a.m34 * b.m44;

    c.m41 = a.m41 * b.m11 + a.m42 * b.m21 + a.m43 * b.m31 + a.m44 * b.m41;
    c.m42 = a.m41 * b.m12 + a.m42 * b.m22 + a.m43 * b.m32 + a.m44 * b.m42;
    c.m43 = a.m41 * b.m13 + a.m42 * b.m23 + a.m43 * b.m33 + a.m44 * b.m43;
    c.m44 = a.m41 * b.m14 + a.m42 * b.m24 + a.m43 * b.m34 + a.m44 * b.m44;

    return c;
};

/**
 *  FirminCSSMatrix#isIdentityOrTranslation() -> Boolean
 *
 *  Returns whether the matrix is the identity matrix or a translation matrix.
 **/
FirminCSSMatrix.prototype.isIdentityOrTranslation = function() {
    var t = this;
    return t.m11 === 1 && t.m12 === 0 && t.m13 === 0 && t.m14 === 0 &&
    t.m21 === 0 && t.m22 === 1 && t.m23 === 0 && t.m24 === 0 &&
    t.m31 === 0 && t.m31 === 0 && t.m33 === 1 && t.m34 === 0 &&
        /* m41, m42 and m43 are the translation points */   t.m44 === 1;
};

/**
 *  FirminCSSMatrix#adjoint() -> FirminCSSMatrix
 *
 *  Returns the adjoint matrix.
 **/
FirminCSSMatrix.prototype.adjoint = function() {
    var result = new FirminCSSMatrix(), t = this,
    determinant3x3 = FirminCSSMatrix.determinant3x3,

    a1 = t.m11, b1 = t.m12, c1 = t.m13, d1 = t.m14,
    a2 = t.m21, b2 = t.m22, c2 = t.m23, d2 = t.m24,
    a3 = t.m31, b3 = t.m32, c3 = t.m33, d3 = t.m34,
    a4 = t.m41, b4 = t.m42, c4 = t.m43, d4 = t.m44;

    // Row column labeling reversed since we transpose rows & columns
    result.m11 =  determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
    result.m21 = -determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
    result.m31 =  determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
    result.m41 = -determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);

    result.m12 = -determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
    result.m22 =  determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
    result.m32 = -determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
    result.m42 =  determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);

    result.m13 =  determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
    result.m23 = -determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
    result.m33 =  determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
    result.m43 = -determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);

    result.m14 = -determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
    result.m24 =  determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
    result.m34 = -determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
    result.m44 =  determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);

    return result;
};

/**
 *  FirminCSSMatrix#inverse() -> FirminCSSMatrix | null
 *
 *  If the matrix is invertible, returns its inverse, otherwise returns null.
 **/
FirminCSSMatrix.prototype.inverse = function() {
    var inv, det, result, i, j;

    if (this.isIdentityOrTranslation()) {
        inv = new FirminCSSMatrix();

        if (!(this.m41 === 0 && this.m42 === 0 && this.m43 === 0)) {
            inv.m41 = -this.m41;
            inv.m42 = -this.m42;
            inv.m43 = -this.m43;
        }

        return inv;
    }

    // Calculate the adjoint matrix
    result = this.adjoint();

    // Calculate the 4x4 determinant
    det = FirminCSSMatrix.determinant4x4(this);

    // If the determinant is zero, then the inverse matrix is not unique
    if (Math.abs(det) < 1e-8) return null;

    // Scale the adjoint matrix to get the inverse
    for (i = 1; i < 5; i++) {
        for (j = 1; j < 5; j++) {
            result[("m" + i) + j] /= det;
        }
    }

    return result;
};

/**
 *  FirminCSSMatrix#rotate(rotX, rotY, rotZ) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *
 *  Returns the result of rotating the matrix by a given vector.
 *
 *  If only the first argument is provided, the matrix is only rotated about
 *  the z axis.
 **/
FirminCSSMatrix.prototype.rotate = function(rx, ry, rz) {
    var degreesToRadians = FirminCSSMatrix.degreesToRadians;

    if (typeof rx != "number" || isNaN(rx)) rx = 0;

    if ((typeof ry != "number" || isNaN(ry)) &&
    (typeof rz != "number" || isNaN(rz))) {
        rz = rx;
        rx = 0;
        ry = 0;
    }

    if (typeof ry != "number" || isNaN(ry)) ry = 0;
    if (typeof rz != "number" || isNaN(rz)) rz = 0;

    rx = degreesToRadians(rx);
    ry = degreesToRadians(ry);
    rz = degreesToRadians(rz);

    var tx = new FirminCSSMatrix(),
    ty = new FirminCSSMatrix(),
    tz = new FirminCSSMatrix(),
    sinA, cosA, sinA2;

    rz /= 2;
    sinA = Math.sin(rz);
    cosA = Math.cos(rz);
    sinA2 = sinA * sinA;

    // Matrices are identity outside the assigned values
    tz.m11 = tz.m22 = 1 - 2 * sinA2;
    tz.m12 = tz.m21 = 2 * sinA * cosA;
    tz.m21 *= -1;

    ry /= 2;
    sinA  = Math.sin(ry);
    cosA  = Math.cos(ry);
    sinA2 = sinA * sinA;

    ty.m11 = ty.m33 = 1 - 2 * sinA2;
    ty.m13 = ty.m31 = 2 * sinA * cosA;
    ty.m13 *= -1;

    rx /= 2;
    sinA = Math.sin(rx);
    cosA = Math.cos(rx);
    sinA2 = sinA * sinA;

    tx.m22 = tx.m33 = 1 - 2 * sinA2;
    tx.m23 = tx.m32 = 2 * sinA * cosA;
    tx.m32 *= -1;

    var isIdentity = (this.toString() === (new FirminCSSMatrix).toString());

    return (isIdentity)
    ? tz.multiply(ty).multiply(tx)
    : this.multiply(tx).multiply(ty).multiply(tz);
};

/**
 *  FirminCSSMatrix#rotateAxisAngle(rotX, rotY, rotZ, angle) -> FirminCSSMatrix
 *  - rotX (Number): the rotation around the x axis.
 *  - rotY (Number): the rotation around the y axis. If undefined, the x
 *    component is used.
 *  - rotZ (Number): the rotation around the z axis. If undefined, the x
 *    component is used.
 *  - angle (Number): the angle of rotation about the axis vector, in degrees.
 *
 *  Returns the result of rotating the matrix around a given vector by a given
 *  angle.
 *
 *  If the given vector is the origin vector then the matrix is rotated by the
 *  given angle around the z axis.
 **/
FirminCSSMatrix.prototype.rotateAxisAngle = function(x, y, z, a) {
    if (typeof x != "number" || isNaN(x)) x = 0;
    if (typeof y != "number" || isNaN(y)) y = 0;
    if (typeof z != "number" || isNaN(z)) z = 0;
    if (typeof a != "number" || isNaN(a)) a = 0;
    if (x === 0 && y === 0 && z === 0) z = 1;

    var t   = new FirminCSSMatrix(),
    len = Math.sqrt(x * x + y * y + z * z),
    cosA, sinA, sinA2, csA, x2, y2, z2;

    a     = (FirminCSSMatrix.degreesToRadians(a) || 0) / 2;
    cosA  = Math.cos(a);
    sinA  = Math.sin(a);
    sinA2 = sinA * sinA;

    // Bad vector, use something sensible
    if (len === 0) {
        x = 0;
        y = 0;
        z = 1;
    } else if (len !== 1) {
        x /= len;
        y /= len;
        z /= len;
    }

    // Optimise cases where axis is along major axis
    if (x === 1 && y === 0 && z === 0) {
        t.m22 = t.m33 = 1 - 2 * sinA2;
        t.m23 = t.m32 = 2 * cosA * sinA;
        t.m32 *= -1;
    } else if (x === 0 && y === 1 && z === 0) {
        t.m11 = t.m33 = 1 - 2 * sinA2;
        t.m13 = t.m31 = 2 * cosA * sinA;
        t.m13 *= -1;
    } else if (x === 0 && y === 0 && z === 1) {
        t.m11 = t.m22 = 1 - 2 * sinA2;
        t.m12 = t.m21 = 2 * cosA * sinA;
        t.m21 *= -1;
    } else {
        csA = sinA * cosA;
        x2  = x * x;
        y2  = y * y;
        z2  = z * z;

        t.m11 = 1 - 2 * (y2 + z2) * sinA2;
        t.m12 = 2 * (x * y * sinA2 + z * csA);
        t.m13 = 2 * (x * z * sinA2 - y * csA);
        t.m21 = 2 * (y * x * sinA2 - z * csA);
        t.m22 = 1 - 2 * (z2 + x2) * sinA2;
        t.m23 = 2 * (y * z * sinA2 + x * csA);
        t.m31 = 2 * (z * x * sinA2 + y * csA);
        t.m32 = 2 * (z * y * sinA2 - x * csA);
        t.m33 = 1 - 2 * (x2 + y2) * sinA2;
    }

    return this.multiply(t);
};

/**
 *  FirminCSSMatrix#scale(scaleX, scaleY, scaleZ) -> FirminCSSMatrix
 *  - scaleX (Number): the scaling factor in the x axis.
 *  - scaleY (Number): the scaling factor in the y axis. If undefined, the x
 *    component is used.
 *  - scaleZ (Number): the scaling factor in the z axis. If undefined, 1 is
 *    used.
 *
 *  Returns the result of scaling the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.scale = function(scaleX, scaleY, scaleZ) {
    var transform = new FirminCSSMatrix();

    if (typeof scaleX != "number" || isNaN(scaleX)) scaleX = 1;
    if (typeof scaleY != "number" || isNaN(scaleY)) scaleY = scaleX;
    if (typeof scaleZ != "number" || isNaN(scaleZ)) scaleZ = 1;

    transform.m11 = scaleX;
    transform.m22 = scaleY;
    transform.m33 = scaleZ;

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#skewX(skewX) -> FirminCSSMatrix
 *  - skewX (Number): the scaling factor in the x axis.
 *
 *  Returns the result of skewing the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.skewX = function(degrees) {
    var radians = FirminCSSMatrix.degreesToRadians(degrees);
    var transform = new FirminCSSMatrix();

    transform.c = Math.tan(radians);

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#skewY(skewY) -> FirminCSSMatrix
 *  - skewY (Number): the scaling factor in the x axis.
 *
 *  Returns the result of skewing the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.skewY = function(degrees) {
    var radians = FirminCSSMatrix.degreesToRadians(degrees);
    var transform = new FirminCSSMatrix();

    transform.b = Math.tan(radians);

    return this.multiply(transform);
};

/**
 *  FirminCSSMatrix#translate(x, y, z) -> FirminCSSMatrix
 *  - x (Number): the x component of the vector.
 *  - y (Number): the y component of the vector.
 *  - z (Number): the z component of the vector. If undefined, 0 is used.
 *
 *  Returns the result of translating the matrix by a given vector.
 **/
FirminCSSMatrix.prototype.translate = function(x, y, z) {
    var t = new FirminCSSMatrix();

    if (typeof x != "number" || isNaN(x)) x = 0;
    if (typeof y != "number" || isNaN(y)) y = 0;
    if (typeof z != "number" || isNaN(z)) z = 0;

    t.m41 = x;
    t.m42 = y;
    t.m43 = z;

    return this.multiply(t);
};

/**
 *  FirminCSSMatrix#setMatrixValue(domstr) -> undefined
 *  - domstr (String): a string representation of a 2D or 3D transform matrix
 *    in the form given by the CSS transform property, i.e. just like the
 *    output from [[FirminCSSMatrix#toString]].
 *
 *  Sets the matrix values using a string representation, such as that produced
 *  by the [[FirminCSSMatrix#toString]] method.
 **/
FirminCSSMatrix.prototype.setMatrixValue = function(domstr) {
    domstr = FirminCSSMatrix.toMatrixString(domstr.trim());
    var mstr   = domstr.match(/^matrix(3d)?\(\s*(.+)\s*\)$/),
    is3d, chunks, len, points, i, chunk;

    if (!mstr) return;

    is3d   = !!mstr[1];
    chunks = mstr[2].split(/\s*,\s*/);
    len    = chunks.length;
    points = new Array(len);

    if ((is3d && len !== 16) || !(is3d || len === 6)) {
        XML3D.debug.logError("Invalid CSS Matrix: ", domstr);
        return;
    }

    for (i = 0; i < len; i++) {
        chunk = chunks[i];
        if (chunk.match(/^-?\d+(\.\d+)?$/)) {
            points[i] = parseFloat(chunk);
        } else {
            XML3D.debug.logError("Invalid CSS Matrix: ", domstr);
            return;
        }
    }

    for (i = 0; i < len; i++) {
        var point = is3d ?
        ("m" + (Math.floor(i / 4) + 1)) + (i % 4 + 1) :
        String.fromCharCode(i + 97); // ASCII char 97 == 'a'
        this[point] = points[i];
    }
};

/**
 *  FirminCSSMatrix#toString() -> String
 *
 *  Returns a string representation of the matrix.
 **/
FirminCSSMatrix.prototype.toString = function() {
    var self = this, points, prefix;

    if (this.isAffine()) {
        prefix = "matrix(";
        points = ["a", "b", "c", "d", "e", "f"];
    } else {
        prefix = "matrix3d(";
        points = ["m11", "m12", "m13", "m14",
            "m21", "m22", "m23", "m24",
            "m31", "m32", "m33", "m34",
            "m41", "m42", "m43", "m44"];
    }

    return prefix + points.map(function(p) {
        return self[p].toFixed(6);
    }).join(", ") + ")";
};

module.exports = FirminCSSMatrix;


},{}],173:[function(require,module,exports){
var printStackTrace = require("../contrib/stacktrace-0.4.js");
var Options = require("./options.js");
var assert = require("assert");

(function (ns) {

    var OPTION_LOGLEVEL = "loglevel";
    Options.register(OPTION_LOGLEVEL, "warning");

    ns.exports = {
        ALL: 0,
        DEBUG: 1,
        INFO: 2,
        WARNING: 3,
        ERROR: 4,
        EXCEPTION: 5,
        params: {},
        isSetup: false,
        loglevel: 4,
        loglevels: {
            all: 0,
            debug: 1,
            info: 2,
            warning: 3,
            error: 4,
            exception: 5
        },

        setup: function () {
            var debug = XML3D.debug;
            if (!debug.isSetup) {
                debug.isSetup = true;
                debug.loglevel = debug.loglevels[Options.getValue(OPTION_LOGLEVEL)] || 3;
                Options.addObserver(function(key, value) {
                    if(key == OPTION_LOGLEVEL) {
                        debug.loglevel = debug.loglevels[value] || 3;
                    }
                })
            }
            return true;
        },
        _setLogLevel: function() {
        },
        doLog: function (logType, args) {
            var params = XML3D.debug.params;
            if (params.xml3d_nolog || logType < XML3D.debug.loglevel) {
                return;
            }
            args = Array.prototype.slice.call(args);
            if (window.console) {
                switch (logType) {
                    case XML3D.debug.INFO:
                        window.console.info.apply(window.console, args);
                        break;
                    case XML3D.debug.WARNING:
                        window.console.warn.apply(window.console, args);
                        break;
                    case XML3D.debug.ERROR:
                        window.console.error.apply(window.console, args);
                        break;
                    case XML3D.debug.EXCEPTION:
                        window.console.error(printStackTrace({e: args[0], guess: true}).join('\n'));
                        break;
                    case XML3D.debug.DEBUG:
                        window.console.debug.apply(window.console, args);
                        break;
                    default:
                        break;
                }
            }
        },
        logDebug: function () {
            XML3D.debug.doLog(XML3D.debug.DEBUG, arguments);
        },
        logInfo: function () {
            XML3D.debug.doLog(XML3D.debug.INFO, arguments);
        },
        logWarning: function () {
            XML3D.debug.doLog(XML3D.debug.WARNING, arguments);
        },
        logError: function () {
            XML3D.debug.doLog(XML3D.debug.ERROR, arguments);
        },
        logException: function () {
            XML3D.debug.doLog(XML3D.debug.EXCEPTION, arguments);
        },
        assert: assert,
        trace: function (msg, logType) {
            logType = logType !== undefined ? logType : XML3D.debug.ERROR;
            if (window.console.trace) {
                if (msg) {
                    XML3D.debug.doLog(logType, [msg]);
                }
                window.console.trace();
            } else {
                var stack = printStackTrace();
                msg && stack.splice(0, 0, msg);
                XML3D.debug.doLog(logType, stack);
            }
        },
        getNumberWithPadding: function (number, width) {
            var res = "" + number;
            while (res.length < width) res = " " + res;
            return res;
        },
        formatSourceCode: function (source) {
            var result = "";
            var sourceLines = source.split("\n");
            for (var i = 0; i < sourceLines.length; ++i) {
                result += this.getNumberWithPadding(i + 1, 3) + "  " + sourceLines[i] + "\n";
            }
            return result;
        }
    };

}(module));

},{"../contrib/stacktrace-0.4.js":48,"./options.js":175,"assert":11}],174:[function(require,module,exports){
// utils/misc.js

(function(exports) {


    /**
     * This function sends single or multiple adapter functions by calling functions
     * specified in funcs parameter for each adapter associated with the node.
     *
     * funcs parameter is used as a dictionary where each key is used as name of a
     * adapter function to call, and corresponding value is a list of arguments
     * (i.e. must be an array). For example sendAdapterEvent(node, {method : [1,2,3]})
     * will call function 'method' with arguments 1,2,3 for each adapter of the node.
     *
     * @param {Object} node
     * @param {Object} funcs
     * @return {Array} array of all returned values
     */
    exports.callAdapterFunc = function(node, funcs) {
        var result = [];
        if (!node || node._configured === undefined)
            return result;
        var adapters = node._configured.adapters;
        for (var adapter in adapters) {
            for (var func in funcs) {
                var adapterObject = adapters[adapter];
                var eventHandler = adapterObject[func];
                if (eventHandler) {
                    result.push(eventHandler.apply(adapterObject, funcs[func]));
                }
            }
        }
        return result;
    };

    /**
     * This function sends single or multiple adapter events by calling functions
     * specified in events parameter for each adapter associated with the node.
     *
     * events parameter is used as a dictionary where each key is used as name of a
     * adapter function to call, and corresponding value is a list of arguments
     * (i.e. must be an array). For example sendAdapterEvent(node, {method : [1,2,3]})
     * will call function 'method' with arguments 1,2,3 for each adapter of the node.
     *
     * @param {Object} node
     * @param {Object} events
     * @return {Boolean} false if node is not configured.
     */
    exports.sendAdapterEvent = function(node, events) {
        if (!node || node._configured === undefined)
            return false;
        var adapters = node._configured.adapters;
        for (var adapter in adapters) {
            for (var event in events) {
                var eventHandler = adapters[adapter][event];
                if (eventHandler) {
                    eventHandler.apply(adapters[adapter], events[event]);
                }
            }
        }
        return true;
    };

    /**
     *
     * Dispatch custom HTML event
     *
     * @param {Object} target element or document.
     * @param {string} eventType custom event type.
     * @param {boolean} canBubble Whether the event propagates upward. Sets the value for the bubbles property.
     * @param {boolean} cancelable Whether the event is cancelable and so preventDefault can be called. Sets the value
     *                  for the cancelable property.
     * @param {Object} detail A user-defined object that can contain additional information about the event.
     *                        This parameter can be of any type, or null. This value is returned in the detail property of the event.
     */
    exports.dispatchCustomEvent = function(target, eventType, canBubble, cancelable, detail) {
        var event = document.createEvent('CustomEvent');
        event.initCustomEvent(eventType, canBubble, cancelable, detail);
        return target.dispatchEvent(event);
    };

    /** Dispatch HTML event
     *
     * @param {Object} target    element or document
     * @param {string} eventType standard event type e.g. load, click
     */
    exports.dispatchEvent = function(target, eventType) {
        var evt = null;
        if (document.createEvent) {
                evt = document.createEvent("Events");
                evt.initEvent(eventType, true, true);
                return target.dispatchEvent(evt);
            } else if (document.createEventObject) {
                evt = document.createEventObject();
                return target.fireEvent('on' + eventType, evt);
            }
        };

    var __autoCreatedViewId = 0;
    /**
     * Returns the active view element corresponding to the given xml3d element.
     *
     * @param {!Object} xml3d
     * @return {Object} the active view element
     */
    exports.getOrCreateActiveView = function(xml3d)
    {
        // try to resolve reference
        var ref = xml3d.activeView;
        if(ref)
        {
            var v = window.XML3D.URIResolver.resolveLocal(ref);
            if(!v)
                throw "XML3D Error: xml3d references view that is not defined: '" + ref + "'.";

            return v;
        }

        // didn't succeed, so now try to just take the first view
        var firstView = xml3d.querySelector("view");
        if(firstView)
        {
            // if it has an id, set it as active
            if(firstView.id && firstView.id.length > 0)
                xml3d.activeView = "#" + firstView.id;

            return firstView;
        }

        // didn't find any: create new one
        XML3D.debug.logWarning("xml3d element has no view defined: creating one.");

        var vid = "xml3d.autocreatedview_" + __autoCreatedViewId++;
        var v = XML3D.createElement("view");
        v.setAttribute("id", vid);

        xml3d.appendChild(v);
        xml3d.activeView = "#" + vid;

        return v;
    };

    var tmpCanvas, tmpContext;

    exports.toImageData = function(imageData) {
        if(imageData instanceof ImageData)
            return imageData;
        if(!imageData.data)
            throw new Error("no data property");
        if(!imageData.width)
            throw new Error("no width property");
        if(!imageData.height)
            throw new Error("no height property");
        if(!tmpContext) {
            tmpCanvas = document.createElement('canvas');
            tmpContext = tmpCanvas.getContext('2d');
        }
        var newImageData = tmpContext.createImageData(imageData.width, imageData.height);
        for(var i = 0; i < imageData.data.length; ++i) {
            var v = imageData.data[i];
            if(v > 255)
                v = 255;
            if(v < 0)
                v = 0;
            newImageData.data[i] = v;
        }
        return newImageData;
    };

}(module.exports));

},{}],175:[function(require,module,exports){
(function (ns) {

    /**
     * Class to handle options. Currently only used for global options, could
     * be extended to work hierarchically to configure other elements.
     * @constructor
     */
    var Options = function () {
        this._options = {};
        this._listeners = { "*": [] };
    };

    Options.prototype = {
        register: function (key, defaultValue) {
            if (this._options.hasOwnProperty(key))
                throw new Error("Option already registered '" + key + "'");
            this._options[key] = {
                currentValue: defaultValue,
                defaultValue: defaultValue
            };
        },
        resetValue: function (key) {
            if (!this._options.hasOwnProperty(key))
                throw new Error("Invalid configuration key '" + key + "'");
            this._options[key].currentValue = this._options[key].defaultValue;
            this.notifyObservers(key, this._options[key].currentValue);
        },
        setValue: function (key, value) {
            if (!this._options.hasOwnProperty(key))
                throw new Error("Invalid configuration key '" + key + "'");
            this._options[key].currentValue = value;
            this.notifyObservers(key, value);
        },
        getValue: function (key) {
            if (!this._options.hasOwnProperty(key)) {
                throw new Error("Invalid configuration key '" + key + "'");
            }
            return this._options[key].currentValue;
        },
        getKeys: function () {
            return Object.keys(this._options);
        },
        notifyObservers: function (key, value) {
            // Notify specific observers
            if(this._listeners.hasOwnProperty(key)) {
                this._listeners[key].forEach(function(l) {
                   l(key, value);
                });
            }
            // Notify generic observers
            this._listeners["*"].forEach(function(l) {
               l(key, value);
            });
        },
        addObserver: function (key, observer) {
            if(typeof key == 'function') {
                observer = key;
                key = "*"
            }
            if(!this._options.hasOwnProperty(key) && key !== "*") {
                throw new Error("Can't register to unknown option '" + key + "'");
            }
            if(!this._listeners.hasOwnProperty(key)) {
                this._listeners[key] = [];
            }
            this._listeners[key].push(observer);
        },
        removeObserver: function (observer) {
            for(var filter in this._listeners) {
                var listeners = this._listeners[filter];
                var idx = listeners.indexOf(observer);
                if (idx != -1)
                    listeners.splice(idx, 1);
            }

        }
    };

    var GlobalOptions = new Options();

    GlobalOptions.setOptionsFromQuery = function () {
        var p = window.location.search.substr(1).split('&');

        p.forEach(function (e) {
            var keyVal = e.split('=');
            try {
                var key = keyVal[0].toLowerCase();
                if (key.indexOf("xml3d-") === 0) {
                    var value = decodeURIComponent(keyVal[1]);
                    try {
                        value = JSON.parse(value);
                    } catch (e) {
                        // Do nothing
                    }
                    XML3D.options.setValue(key.substr(6), value);
                }
            } catch (e) {
                XML3D.debug && XML3D.debug.logError(e);
            }
        });
    }

    ns.exports = GlobalOptions;

}(module));

},{}],176:[function(require,module,exports){
(function(exports) {
    /**
     * Class URI
     * @constructor
     * @param {string} str The URI as string
     */
    var URI = function (str) {
        str = str || "";
        if (str.indexOf("blob:") == 0) {
            // Based on http://www.w3.org/TR/FileAPI/#url
            var parser = /^(?:([^:\/?\#]+):)?([^\#]*)(?:\#(.*))?/;
            var result = str.match(parser);
            /**  @type {boolean} */
            this.valid = result != null;
            /**  @type {?string} */
            this.scheme = result[1] || null;
            /**  @type {?string} */
            this.authority = null;
            /**  @type {?string} */
            this.path = null;
            /**  @type {?string} */
            this.query = null;
            /**  @type {?string} */
            this.opaqueString = result[2] || null;
            /**  @type {?string} */
            this.fragment = result[3] || null;
        } else {
            // Based on the regex in RFC2396 Appendix B.
            var parser = /^(?:([^:\/?\#]+):)?(?:\/\/([^\/?\#]*))?([^?\#]*)(?:\?([^\#]*))?(?:\#(.*))?/;
            var result = str.match(parser);
            /**  @type {boolean} */
            this.valid = result != null;
            /**  @type {?string} */
            this.scheme = result[1] || null;
            /**  @type {?string} */
            this.authority = result[2] || null;
            /**  @type {?string} */
            this.path = result[3] || null;
            /**  @type {?string} */
            this.query = result[4] || null;
            /**  @type {?string} */
            this.opaqueString = null;
            /**  @type {?string} */
            this.fragment = result[5] || null;
        }
    };

    /**
     * @return {boolean} true if URI is relative to current document
     */
    URI.prototype.isLocal = function () {
        return this.scheme != "blob" && !this.authority && !this.path;
    }

    /**
     * @return {boolean} true if URI is absolute
     */
    URI.prototype.isAbsolute = function () {
        return this.scheme != null;
    }

    /**
     * Get absolute URI relative to the provided document uri
     * @param {string} docUri uri of document from which this uri originates
     * @returns {URI}
     */
    URI.prototype.getAbsoluteURI = function (docUri) {
        if (!this.valid || this.isAbsolute()) {
            return this;
        }

        var docUriObj = new URI(docUri);

        if (this.path) {
            if (this.path.indexOf("/") == 0) {
                docUriObj.path = this.path;
            } else {
                docUriObj.path = docUriObj.path.substr(0, docUriObj.path.lastIndexOf("/") + 1) + this.path;
            }
            docUriObj.query = this.query;
        } else if (this.query) {
            docUriObj.query = this.query;
        }
        docUriObj.fragment = this.fragment;

        return docUriObj;
    }

    /**
     * Returns if this URI has the same origin as the provided reference
     * @param {URI|string} other
     * @returns {boolean}
     */
    URI.prototype.hasSameOrigin = function (other) {
        if (typeof other == 'string')
            other = new URI(other);

        if (this.scheme == "blob" || this.scheme == "data") {
            return true;
        }

        return this.scheme == other.scheme && this.authority == other.authority;
    };


// Restore the URI to it's stringy glory.
    URI.prototype.toString = function () {
        var str = "";
        if (this.scheme == "blob") {
            str = "blob:" + this.opaqueString;
            if (this.fragment) {
                str += "#" + this.fragment;
            }
            return str;
        }
        if (this.scheme) {
            str += this.scheme + ":";
        }
        if (this.authority) {
            str += "//" + this.authority;
        }
        if (this.path) {
            str += this.path;
        }
        if (this.query) {
            str += "?" + this.query;
        }
        if (this.fragment) {
            str += "#" + this.fragment;
        }
        return str;
    };

// Restore the URI to it's stringy glory minus the fragment
    URI.prototype.toStringWithoutFragment = function () {
        var str = "";
        if (this.scheme == "blob") {
            str = "blob:" + this.opaqueString;
            return str;
        }
        if (this.scheme) {
            str += this.scheme + ":";
        }
        if (this.authority) {
            str += "//" + this.authority;
        }
        if (this.path) {
            str += this.path;
        }
        if (this.query) {
            str += "?" + this.query;
        }
        return str;
    };

    /**
     * Class URIResolver
     * @constructor
     */
    var URIResolver = function () {
    };

    /**
     * Resolve a local URI to an element
     * @param {(string|URI)} uri Element to resolve
     * @param {Document=} document Base document to use
     * @return {Element} The resolved element or null if it could not be resolved
     */
    URIResolver.resolveLocal = function (uri, document) {
        if (typeof uri == 'string')
            uri = new URI(uri);
        document = document || window.document;

        if (uri.scheme == 'urn' || uri.scheme == "blob") {
            return null;
        }

        if (!uri.path && uri.fragment) { // local uri
            return document.getElementById(uri.fragment);
        }
        return null;
    };


    /**
     * @deprecated
     */
    URIResolver.resolve = function (uri, document) {
        XML3D.debug.logWarning("You are using deprecated XML3D.URIResolver.resolve. Use XML3D.URIResolver.resolveLocal instead.");
        return URIResolver.resolveLocal(uri, document);
    };

    exports.URI = URI;
    exports.URIResolver = URIResolver;

    window.XML3D.URIResolver = URIResolver;

}(module.exports));

},{}],177:[function(require,module,exports){
//TODO: Helpful API methods concerning WebCL will be added when needed. Please provide feedback!

/**
 * @file WebCL API. Provides useful methods for initialising and utilising the WebCL platform.
 * @version 0.2
 * @author Toni Dahl
 */

(function (namespace, undefined) {

    var platforms = [],
        devices = [],
        ctx = null,

        WebCLNamespaceAvailable = false,
        OpenCLDriversAvailable = false;

    /**
     *     @constant {string} DEFAULT_DEVICE
     *     @default "CPU"
     */
    var DEFAULT_DEVICE = "CPU",

        /**
         *     @readonly
         *     @name CL_ERROR_CODES
         *     @enum {number}
         */
            CL_ERROR_CODES = {
            "SUCCESS": 0,
            "DEVICE_NOT_FOUND": -1,
            "DEVICE_NOT_AVAILABLE": -2,
            "COMPILER_NOT_AVAILABLE": -3,
            "MEM_OBJECT_ALLOCATION_FAILURE": -4,
            "OUT_OF_RESOURCES": -5,
            "OUT_OF_HOST_MEMORY": -6,
            "PROFILING_INFO_NOT_AVAILABLE": -7,
            "MEM_COPY_OVERLAP": -8,
            "IMAGE_FORMAT_MISMATCH": -9,
            "IMAGE_FORMAT_NOT_SUPPORTED": -10,
            "BUILD_PROGRAM_FAILURE": -11,
            "MAP_FAILURE": -12,
            "INVALID_VALUE": -30,
            "INVALID_DEVICE_TYPE": -31,
            "INVALID_PLATFORM": -32,
            "INVALID_DEVICE": -33,
            "INVALID_CONTEXT": -34,
            "INVALID_QUEUE_PROPERTIES": -35,
            "INVALID_COMMAND_QUEUE": -36,
            "INVALID_HOST_PTR": -37,
            "INVALID_MEM_OBJECT": -38,
            "INVALID_IMAGE_FORMAT_DESCRIPTOR": -39,
            "INVALID_IMAGE_SIZE": -40,
            "INVALID_SAMPLER": -41,
            "INVALID_BINARY": -42,
            "INVALID_BUILD_OPTIONS": -43,
            "INVALID_PROGRAM": -44,
            "INVALID_PROGRAM_EXECUTABLE": -45,
            "INVALID_KERNEL_NAME": -46,
            "INVALID_KERNEL_DEFINITION": -47,
            "INVALID_KERNEL": -48,
            "INVALID_ARG_INDEX": -49,
            "INVALID_ARG_VALUE": -50,
            "INVALID_ARG_SIZE": -51,
            "INVALID_KERNEL_ARGS": -52,
            "INVALID_WORK_DIMENSION": -53,
            "INVALID_WORK_GROUP_SIZE": -54,
            "INVALID_WORK_ITEM_SIZE": -55,
            "INVALID_GLOBAL_OFFSET": -56,
            "INVALID_EVENT_WAIT_LIST": -57,
            "INVALID_EVENT": -58,
            "INVALID_OPERATION": -59,
            "INVALID_GL_OBJECT": -60,
            "INVALID_BUFFER_SIZE": -61,
            "INVALID_MIP_LEVEL": -62,
            "INVALID_GLOBAL_WORK_SIZE": -63
        };
    Object.freeze(CL_ERROR_CODES);


    function isNumber(n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }

    /**
     * Returns a CL error name corresponding to a CL error code
     *
     * @function XML3D.webcl~getCLErrorName
     * @param {number} errorCode
     * @returns {string}
     */

    function getCLErrorName(errorCode) {
        var prop;

        if (isNumber(errorCode)) {
            for (prop in CL_ERROR_CODES) {
                if (CL_ERROR_CODES[prop] === errorCode) {
                    return prop;
                }
            }
            XML3D.debug.logDebug("Got unknown OpenCL Error Code:", errorCode);
        }

        return "UNKNOWN_ERROR";
    }

    /**
     * Gets an error code from a CL error message (thrown by Nokia WebCL Plugin)
     *
     * @param e
     * @returns {Integer|Boolean}
     */

    function getErrorCodeFromCLError(e) {
        var code = null;

        if (e.name && typeof e.name === "string") {
            if (CL_ERROR_CODES[e.name]) {
                return CL_ERROR_CODES[e.name];
            }
        }
        if (e.message && typeof e.message === "string") {
            code = e.message.match(/-?\d+/g);

            if (code instanceof Array) {
                return parseInt(code[code.length - 1], 10);
            }
        }

        return false;
    }

    /**
     * Creates instance of WebCLError
     *
     * @constructor XML3D.webcl~WebCLError
     * @param {string} [name="WebCLError"] Error name
     * @param {string} [msg="Generic WebCL error."] The desired error message
     */

    function WebCLError(name, msg) {
        if (name && typeof name !== "string") {
            XML3D.debug.logDebug("WebCL API: WebCLError: Error name not type of String");
            name = "";
        }

        if (msg && typeof msg !== "string") {
            XML3D.debug.logDebug("WebCL API: WebCLError: Error message not type of String");
            msg = "";
        }

        this.name = name || "WebCLError";
        this.message = msg || "Generic WebCL error.";
        this.stack = (new Error()).stack;
    }

    WebCLError.prototype = Object.create(Error.prototype);
    WebCLError.prototype.constructor = WebCLError;


    /**
     * Checks if WebCL namespace is available. The namespace can be provided by a WebCL plugin or native implementation.
     *
     * @function XML3D.webcl~hasWebCLNamespace
     * @returns {Boolean}
     */

    function hasWebCLNamespace() {
        WebCLNamespaceAvailable = window.webcl && webcl.getPlatforms;

        return WebCLNamespaceAvailable;

    }

    /**
     * Tests a basic WebCL method to see if the OpenCL drivers are working on users device.
     *
     * @function XML3D.webcl~hasOpenCLDrivers
     * @returns {Boolean}
     */

    function hasOpenCLDrivers() {
        var platArr;
        OpenCLDriversAvailable = true;

        try {
            platArr = webcl.getPlatforms();
        } catch (e) {
            OpenCLDriversAvailable = false;
        }

        if (!platArr || platArr.length === 0) {
            OpenCLDriversAvailable = false;
        }

        return OpenCLDriversAvailable;

    }

    /**
     * Combines WebCL namespace and driver test.
     *
     * @function XML3D.webcl~isAvailable
     * @returns {Boolean}
     */

    function isAvailable() {
        return hasWebCLNamespace() && hasOpenCLDrivers();
    }


    /**
     * Initialises the WebCL API with default values using a predefined device type or a default device type.
     *
     * @function XML3D.webcl~init
     * @param {string} [type="CPU"] Device type
     * @return {Boolean}
     */

    function init(type) {
        // Checking if WebCL is available in the users system
        if (!hasWebCLNamespace()) {
            XML3D.debug.logWarning("WebCL API: Unfortunately your system does not support WebCL. " +
                "WebCL namespace is not available.");
            return false;
        }

        if (!hasOpenCLDrivers()) {
            XML3D.debug.logWarning("WebCL API: Unfortunately your system does not support WebCL. " +
                "OpenCL drivers are not working properly.");
            return false;
        }

        getPlatforms();

        devices = getDevicesByType(type || DEFAULT_DEVICE);

        // Creating default context
        ctx = createContext(devices);

        return true;
    }

    /**
     * Returns all available WebCL device platforms.
     *
     * @function XML3D.webcl~getPlatforms
     * @returns {Array}
     */

    function getPlatforms() {
        if(platforms.length === 0) {
            platforms = webcl.getPlatforms();
        }

        return platforms;
    }

    /**
     * Returns all devices of a chosen type from a selected platform.
     *
     * @param {string} [type="CPU"] Device type
     * @param {IWebCLPlatform} platform
     * @returns {Array|Boolean}
     */

    function getPlatformDevicesByType(type, platform) {
        var deviceArr = [], errCode;

        if (!platform) {
            XML3D.debug.logError("WebCL API: getPlatformDevicesByType(): platform was not defined.");
            return false;
        }

        type = type || DEFAULT_DEVICE;

        try {
            if (type === "CPU") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_CPU);
            } else if (type === "GPU") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_GPU);
            } else if (type === "ALL") {
                deviceArr = platform.getDevices(webcl.DEVICE_TYPE_ALL);
            }

        } catch (e) {
            errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            } else if (errCode !== CL_ERROR_CODES.DEVICE_NOT_FOUND) {
                throw new WebCLError(getCLErrorName(errCode), "Could not get devices.");
            }

            return false;
        }

        return deviceArr;
    }

    /**
     * Gets all devices of a selected type from all available platforms.
     *
     * @function XML3D.webcl~getDevicesByType
     * @param {string} type Device type
     * @returns {Array|Boolean}
     */

    function getDevicesByType(type) {
        var resultArr = [], deviceArr, i;

        getPlatforms();

        for (i = platforms.length; i--;) {
            deviceArr = getPlatformDevicesByType(type, platforms[i]);

            if (deviceArr) {
                deviceArr.forEach(function (v) {
                    resultArr.push(v);
                });
            }
        }
        return resultArr.length === 0 ? false : resultArr;
    }


    /**
     * Gets the platform on where the device is.
     *
     * @function XML3D.webcl~getDevicePlatform
     * @param {IWebCLDevice} device
     * @returns {IWebCLPlatform|Boolean}
     */

    function getDevicePlatform(device) {
        var platform;

        if (!device) {
            XML3D.debug.logError("WebCL API: getDevicePlatform(): device was not defined.");
            return false;
        }

        try {
            platform = device.getInfo(webcl.DEVICE_PLATFORM);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }

            throw new WebCLError(getCLErrorName(errCode), "Could not get the platform of the device.");
        }

        return platform;
    }

    /**
     *
     * @param clCtx
     * @returns {boolean}
     */

    function getContextDevices(clCtx) {
        var deviceArr = [], errCode;

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: getContextDevices(): clCtx was not defined.");
            return false;
        }

        try {
            deviceArr = clCtx.getInfo(webcl.CONTEXT_DEVICES);
        }catch(e) {
            errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            } else {
                throw new WebCLError(getCLErrorName(errCode), "Could not get devices.");
            }

        }

        return deviceArr.length === 0 ? false : deviceArr;
    }

    /**
     * Creates a WebCL context
     *
     * @function XML3D.webcl~createContext
     * @param {object} [properties]
     * @returns {IWebCLContext}
     */

    function createContext(properties) {
      /*
        var props = {
            devices: getDevicesByType(DEFAULT_DEVICE)
            }, context;

        XML3D.extend(props, properties);*/

        try {
            var context = webcl.createContext(properties);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL context.");
        }

        return context;
    }

    /**
     * Gets the default WebCL context.
     *
     * @function XML3D.webcl~getDefaultContext
     * @returns {IWebCLContext}
     */

    function getDefaultContext() {
        return ctx;
    }


    /**
     * Creates a WebCL program from a string of WebCL code.
     *
     * @function XML3D.webcl~createProgram
     * @param {string} codeStr
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLProgram | Boolean}
     */

    function createProgram(codeStr, clCtx) {
        var program;

        clCtx = clCtx || ctx;

        if (!codeStr) {
            XML3D.debug.logError("WebCL API: createProgram(): codeStr was not defined.");
            return false;
        }

        if (!clCtx) {
            XML3D.debug.logError("WebCL API: createProgram(): clCtx was not defined.");
            return false;
        }

        try {
            program = clCtx.createProgram(codeStr);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }

            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL program.");
        }

        return program;
    }

    /**
     * Builds a WebCL program.
     *
     * @function XML3D.webcl~buildProgram
     * @param {IWebCLProgram} program
     * @param {Array} deviceArr
     * @returns {IWebCLProgram|Boolean}
     */

    function buildProgram(program, deviceArr) {
        deviceArr = deviceArr || devices;

        if (!program) {
            XML3D.debug.logError("WebCL API: buildProgram(): program was not defined.");
            return false;
        }

        try {
            program.build(deviceArr, "");
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode),
                program.getBuildInfo(deviceArr[0], WebCL.PROGRAM_BUILD_LOG));
        }

        return program;
    }

    /**
     * Creates a WebCL Kernel using a defined program.
     *
     * @function XML3D.webcl~createKernel
     * @param {IWebCLProgram} program
     * @param {string} name
     * @returns {IWebCLKernel|Boolean}
     */

    function createKernel(program, name) {
        var kernel;

        if (!program) {
            XML3D.debug.logError("WebCL API: createKernel(): program was not defined.");
            return false;
        }

        if (!name) {
            XML3D.debug.logError("WebCL API: createKernel(): name was not defined.");
            return false;
        }

        try {
            kernel = program.createKernel(name);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Failed to create a WebCL kernel.");
        }

        return kernel;
    }

    /**
     * Creates a WebCL Command Queue for queueing kernels for execution.
     *
     * @function XML3D.webcl~createCommandQueue
     * @param {IWebCLDevice} device
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLCommandQueue|Boolean}
     */

    function createCommandQueue(device, clCtx) {
        var cmdQueue;

        clCtx = clCtx || ctx;

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: createCommandQueue: clCtx was not defined");
            return false;
        }

        try {
            cmdQueue = clCtx.createCommandQueue(device || devices[0], 0);
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(getErrorCodeFromCLError(e)), "Could not create CommandQueue.");
        }

        return cmdQueue;
    }

    /**
     * Creates an input/output buffer to be used with a WebCL kernel
     *
     * @function XML3D.webcl~createBuffer
     * @param {int} size
     * @param {string} type
     * @param {IWebCLContext} clCtx
     * @returns {IWebCLMemoryObject|Boolean}
     */

    function createBuffer(size, type, clCtx) {
        clCtx = clCtx || ctx;

        if (!size) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer size was not defined.");
            return false;
        }else if (!isNumber(size) || size < 0) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer size must be a positive number.");
            return false;
        }

        if (!type) {
            XML3D.debug.logError("WebCL API: createBuffer(): Buffer type was not defined.");
            return false;
        }

        if(!clCtx) {
            XML3D.debug.logError("WebCL API: createBuffer(): clCtx was not defined.");
            return false;
        }

        try {
            if (type === "r") {
                return clCtx.createBuffer(webcl.MEM_READ_ONLY, size);
            } else if (type === "w") {
                return clCtx.createBuffer(webcl.MEM_WRITE_ONLY, size);
            } else if (type === "rw") {
                return clCtx.createBuffer(webcl.MEM_READ_WRITE, size);
            } else {
                XML3D.debug.logError("WebCL API: createBuffer(): Unknown buffer type:", type);
                return false;
            }
        } catch (e) {
            var errCode = getErrorCodeFromCLError(e);

            if (!errCode) {
                throw e;
            }
            throw new WebCLError(getCLErrorName(errCode), "Could not create a WebCL buffer.");
        }
    }

    /**
     * Creates an instance of KernelManager.
     *
     * @name KernelManager
     * @constructor XML3D.webcl~KernelManager
     */

    var KernelManager = function (clCtx, deviceArr) {
        var kernels = {};

        return {

            /**
             * Creates and builds a WebCL program from a code string and creates a WebCL kernel from the program.
             *
             * @function KernelManager~register
             * @param {string} name
             * @param {string} codeStr
             */

            register: function (name, codeStr) {
                if (kernels.hasOwnProperty(name)) {
                    XML3D.debug.logWarning("WebCL API: kernels.register(): Kernel with a same name is already defined.");
                    return false;
                }

                if (typeof name !== "string") {
                    XML3D.debug.logError("WebCL API: kernels.register(): Kernel name was not defined or was not type of String.");
                    return false;
                }

                if (typeof codeStr !== "string") {
                    XML3D.debug.logError("WebCL API: kernels.register(): Kernel code was not defined or was not type of String.");
                    return false;
                }

                var program, kernel;

                program = createProgram(codeStr, clCtx);

                buildProgram(program, deviceArr);

                if (program) {
                    kernel = createKernel(program, name);
                }

                if (kernel) {
                    kernels[name] = kernel;

                    return true;
                }

                return false;

            },

            /**
             * Deallocates and unregisters a kernel.
             *
             * @function KernelManager~unRegister
             * @param {string} name
             */

            unRegister: function (name) {
                if (kernels.hasOwnProperty(name)) {
                    try {
                        kernels[name].release();
                    } catch (e) {
                        var errCode = getErrorCodeFromCLError(e);

                        if (!errCode) {
                            throw e;
                        }

                        throw new WebCLError(getCLErrorName(errCode), "Could not release kernel resources.");
                    }
                    delete kernels[name];

                    return true;
                }

                return false;
            },

            /**
             * Gets a kernel of a specified name.
             *
             * @function KernelManager~getKernel
             * @param {string} name
             * @returns {IWebCLKernel | Boolean}
             */

            getKernel: function (name) {
                if (typeof name !== "string") {
                    return false;
                }

                if (kernels.hasOwnProperty(name)) {
                    return kernels[name];
                }

                return false;
            },

            /**
             * Sets arguments of a specified kernel.
             * The first argument of this function is a registered kernel name, other arguments are the kernel arguments respectively.
             *
             * @function KernelManager~setArgs
             * @param {IWebCLKernel} kernel WebCL kernel
             * @param {...*} args Kernel arguments in the same order as defined in the kernel code
             * @returns {boolean}
             */

            setArgs: function () {
                var args = Array.prototype.slice.call(arguments),
                    kernel, inputArgs, nKernelArgs, i;

                if (args.length < 2) {
                    XML3D.debug.logWarning("WebCL API: setArgs(): No kernel arguments were defined.");
                    return false;
                }

                kernel = args[0];
                inputArgs = args.slice(1);

                if (!kernel) {
                    XML3D.debug.logWarning("WebCL API: setArgs(): WebCL kernel was not defined.");
                    return false;
                }

                nKernelArgs = kernel.getInfo(webcl.KERNEL_NUM_ARGS);

                if (inputArgs.length > nKernelArgs) {
                    XML3D.debug.logWarning("WebCL: setArgs: Input args amount > kernel program args amount! Ignoring extra arguments.");
                } else if (inputArgs.length < nKernelArgs) {
                    XML3D.debug.logError("WebCL: setArgs: Not enough arguments were given to WebCL kernel.");
                    return false;
                }

                XML3D.debug.logDebug("Args for kernel:", kernel.getInfo(webcl.KERNEL_FUNCTION_NAME));

                i = nKernelArgs;

                try {
                    while (i--) {
                        XML3D.debug.logDebug("Arg:", i, inputArgs[i]);
                        kernel.setArg(i, inputArgs[i]);
                    }
                } catch (e) {
                    var errCode = getErrorCodeFromCLError(e);

                    if (!errCode) {
                        throw e;
                    }
                    throw new WebCLError(getCLErrorName(errCode), "Could not set kernel arguments.");
                }

                return true;

            }
        };
    };

    /**
     * Checks if WebCL is available and attaches a context to the given object
     * @param webclObject the object that the context will be attached to
     * @returns {boolean}
     */
    function initWebCLPlatform(webclObject) {
        if (!isAvailable()) {
            return false;
        }

        var clPlatforms = getPlatforms();
        if (!clPlatforms || clPlatforms.length <= 0) {
            return false;
        }

        try {
            // Trying initially to use GPU (for the best performance). Using CPU as a fallback.
            var clDevices = getDevicesByType("GPU") || getDevicesByType("CPU");
            if (!clDevices) {
                return false;
            }
            var clCtx = createContext(clDevices);
            var cmdQueue = createCommandQueue(clDevices[0], clCtx);

            /**
             *  TODO: Maybe we should just store the cl-platform objects in C.cl so they are more easily available and
             *  to avoid long prototype chains. Or we could pass the graph context to each node of the graph.
             *  However, it would be good to allow each Graph object to have at least own context, cmdQueue and kernelManager.
             */
            webclObject.cl = {
                API: webcl,
                kernelManager: new KernelManager(clCtx, clDevices),
                platforms: clPlatforms,
                devices: clDevices,
                ctx: clCtx,
                cmdQueue: cmdQueue
            };
            XML3D.debug.logDebug("Successfully initialized WebCL platform.");
            return true;
        } catch (e) {
            return false;
        }
    }

    /**
     * API
     *
     * @namespace webcl
     * @memberOf XML3D
     */

    namespace['webcl'] = {
        "init": init,
        "createContext": createContext,
        "createProgram": createProgram,
        "buildProgram": buildProgram,
        "createKernel": createKernel,
        "createCommandQueue": createCommandQueue,
        "createBuffer": createBuffer,
        "getDefaultContext": getDefaultContext,
        "getPlatforms": getPlatforms,
        "getDevicesByType": getDevicesByType,
        "getContextDevices": getContextDevices,
        "getDevicePlatform": getDevicePlatform,

        /** @name XML3D.webcl~kernels */
        "kernels": new KernelManager(),
        "KernelManager": KernelManager,

        "hasWebCLNamespace": hasWebCLNamespace,
        "hasOpenCLDrivers": hasOpenCLDrivers,
        "isAvailable": isAvailable,
        "WebCLError": WebCLError,
        "getCLErrorName": getCLErrorName
    };

    initWebCLPlatform(namespace.webcl);
    window.XML3D.webcl = namespace.webcl;

}(module.exports));

},{}],178:[function(require,module,exports){
var assert = require("assert");

// Error Callbacks:
var c_errorCallbacks = [];

var c_listedCallbacks = [];
var c_listedCallbacksData = [];

module.exports = {

    registerErrorCallback: function (callback) {
        c_errorCallbacks.push(callback);
    },

    notifyError: function (message, node) {
        if (c_errorCallbacks.length > 0) {
            var i;
            for (i = 0; i < c_errorCallbacks.length; ++i) {
                c_errorCallbacks[i](message, node);
            }
        } else {
            // TODO: Do Default error printing
        }
    },

    /**
     *
     * @param {Object} ctor Constructor
     * @param {Object} parent Parent class
     * @param {Object=} methods Methods to add to the class
     * @returns {Object}
     */
    createClass: function (ctor, parent, methods) {
        methods = methods || {};
        if (parent) {
            /** @constructor */
            var F = function () {
            };
            F.prototype = parent.prototype;
            ctor.prototype = new F();
            ctor.prototype.constructor = ctor;
            ctor.superclass = parent.prototype;
        }
        for (var m in methods) {
            ctor.prototype[m] = methods[m];
        }
        return ctor;
    },

    extend: function (a, b) {
        for (var i in b) {
            if (b.hasOwnProperty(i)) {
                a[i] = b[i];
            }
        }
    },

    /**
     * Cluster internal notifications to avoid multiple notifications
     * of same type. Mainly for Requests and Results
     *
     * @param requestOrResult Request or Result
     * @param {RESULT_STATE} resultState
     * @private
     */
    _queueResultCallback: function (requestOrResult, resultState) {
        assert(resultState !== undefined);
        var index;
        if (( index = c_listedCallbacks.indexOf(requestOrResult)) == -1) {
            index = c_listedCallbacks.length;
            c_listedCallbacks.push(requestOrResult);
        }
        var prevData = c_listedCallbacksData[index];

        if (!prevData || prevData < resultState) {
            c_listedCallbacksData[index] = resultState;
        }
    },

    _flushResultCallbacks: function () {
        if (c_listedCallbacks.length) {
            var i;
            for (i = 0; i < c_listedCallbacks.length; ++i) {
                c_listedCallbacks[i]._onPostponedResultChanged(c_listedCallbacksData[i]);
            }
            c_listedCallbacks = [];
            c_listedCallbacksData = [];
        }
    }
};







},{"assert":11}],179:[function(require,module,exports){
var C = {};

C.EPSILON = 0.000001;

/**
 * Type of DataEntry
 * @enum
 */
C.DATA_TYPE = {
    UNKNOWN: 0,
    FLOAT: 1,
    FLOAT2: 2,
    FLOAT3: 3,
    FLOAT4: 4,
    FLOAT3X3: 5,
    FLOAT4X4: 10,
    INT: 20,
    INT4: 21,
    BOOL: 30,
    TEXTURE: 40,
    BYTE: 50,
    UBYTE: 60,
    fromString: function(str) {
        if (!str || !str.toUpperCase) {
            return;
        }
        return this[str.toUpperCase()];
    }
};

C.DATA_TYPE_MAP = {
    'float': C.DATA_TYPE.FLOAT,
    'float2': C.DATA_TYPE.FLOAT2,
    'float3': C.DATA_TYPE.FLOAT3,
    'float4': C.DATA_TYPE.FLOAT4,
    'float3x3': C.DATA_TYPE.FLOAT3X3,
    'float4x4': C.DATA_TYPE.FLOAT4X4,
    'int': C.DATA_TYPE.INT,
    'int4': C.DATA_TYPE.INT4,
    'bool': C.DATA_TYPE.BOOL,
    'texture': C.DATA_TYPE.TEXTURE,
    'byte': C.DATA_TYPE.BYTE,
    'ubyte': C.DATA_TYPE.UBYTE
};

// Values are chosen to be in line with DATA_TYPE
C.TEXTURE_TYPE = {
    UNKNOWN: 0, FLOAT: 1, UBYTE: 60, USHORT_5_6_5: 70, USHORT_4_4_4_4: 71, USHORT_5_5_5_1: 72
};

C.TEXTURE_FORMAT = {
    UNKNOWN: 0, ALPHA: 100, RGB: 101, RGBA: 102, LUMINANCE: 103, LUMINANCE_ALPHA: 104
};

C.DATA_TYPE_TUPLE_SIZE = {};
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT2] = 2;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT3] = 3;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT4] = 4;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT3X3] = 9;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.FLOAT4X4] = 16;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.INT] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.INT4] = 4;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.BOOL] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.TEXTURE] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.BYTE] = 1;
C.DATA_TYPE_TUPLE_SIZE[C.DATA_TYPE.UBYTE] = 1;

C.TYPED_ARRAY_MAP = {};
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT2] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT3] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT4] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.FLOAT4X4] = Float32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.INT] = Int32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.INT4] = Int32Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.BOOL] = Int8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.BYTE] = Int8Array;
C.TYPED_ARRAY_MAP[C.DATA_TYPE.UBYTE] = Uint8Array;

// texture formats
// float and ubyte are mapped to DATA_TYPE values above
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_4_4_4_4] = Uint16Array;
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_5_6_5] = Uint16Array;
C.TYPED_ARRAY_MAP[C.TEXTURE_TYPE.USHORT_5_5_5_1] = Uint16Array;

C.TEXTURE_FORMAT_TUPLE_SIZE = {};
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.ALPHA] = 1;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.RGB] = 3;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.RGBA] = 4;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.LUMINANCE] = 1;
C.TEXTURE_FORMAT_TUPLE_SIZE[C.TEXTURE_FORMAT.LUMINANCE_ALPHA] = 2;

C.getTypeName = function (type) {
    var i;
    for (i in C.DATA_TYPE_MAP) {
        if (C.DATA_TYPE_MAP[i] === type) {
            return i;
        }
    }
};

/**
 * @enum {number}
 */
C.TEX_FILTER_TYPE = {
    NEAREST: 0x2600, LINEAR: 0x2601, MIPMAP_NEAREST: 0x2700, MIPMAP_LINEAR: 0x2701

};
/**
 * @enum {number}
 */
C.TEX_WRAP_TYPE = {
    CLAMP: 0x812F, REPEAT: 0x2901
};
/**
 * @enum {number}
 */
C.TEX_TYPE = {
    TEXTURE_2D: 0x0DE1
};

C.SHADER_CONSTANT_KEY = {
    WORLD_TRANSFORM: 1,
    VIEW_TRANSFORM: 2,
    SCREEN_TRANSFORM: 3,
    WORLD_TRANSFORM_NORMAL: 4,
    VIEW_TRANSFORM_NORMAL: 5,
    SCREEN_TRANSFORM_NORMAL: 6,
    OBJECT_ID: 7
};

C.VS_ATTRIB_TRANSFORM = {
    NONE: 0, VIEW_POINT: 1, WORLD_POINT: 2, VIEW_NORMAL: 3, WORLD_NORMAL: 4
};


/**
 * Filter Type of DataNode
 * KEEP - Keep only the provided names
 * REMOVE - Remove provided names (ignores name mapping)
 * RENAME - Only apply name mapping
 * @enum
 */
C.DATA_FILTER_TYPE = {
    NONE: 0, RENAME: 1, KEEP: 2, REMOVE: 3
};


/**
 * TODO: Maybe merge this structure with RESULT_STATE to avoid back and forth conversion within notification chain
 * @enum {number}
 */
C.DATA_ENTRY_STATE = {
    CHANGED_VALUE: 1,
    CHANGED_NEW: 2,
    LOAD_START: 3,
    LOAD_END: 4,
    CHANGED_SIZE: 5,
    CHANGED_REMOVED: 6, // Not just the size changed, but also qualifier
    // if we have 0, 1 or many tuples in value
    CHANGED_SIZE_TYPE: 7
};

/** TODO: Merge with C.PLATFORM? **/
C.RESULT_TYPE = {
    COMPUTE: 0, VS: 1
};


/**
 * Type of Modification, used internally only
 * Ordered by importance.
 * @enum
 */
C.RESULT_STATE = {
    NONE: 0, CHANGED_DATA_VALUE: 1, CHANGED_DATA_SIZE: 2, CHANGED_STRUCTURE: 3, // TODO: Felix: Still required?
    IMAGE_LOAD_START: 4, IMAGE_LOAD_END: 5
};


/**
 * Type of Sequence access - used by operators
 * @enum
 */
C.SEQUENCE = {
    NO_ACCESS: 0, PREV_BUFFER: 1, NEXT_BUFFER: 2, LINEAR_WEIGHT: 3
};


C.ITERATION_TYPE = {
    NULL: 0, ONE: 1, MANY: 2
};

/**
 * Type of Information Extraction - used by operators
 * @private
 * @enum
 */
//TODO: This seems to be unused, is it still needed?
C.EXTRACT = {
    NO_EXTRAC: 0, TEX_WIDTH: 1, TEX_HEIGHT: 2
};

C.ORIGIN = {
    CHILD: 1, COMPUTE: 2, PROTO: 3
};

/**
 * Types of platforms to perform computation on
 * @type {enum}
 */
C.PLATFORM = {
    JAVASCRIPT: 0, GLSL: 1, CL: 2, ASYNC: 3
};

/**
 * Possible states of a ProcessNode
 * @type {enum}
 */
C.PROCESS_STATE = {
    MODIFIED: 0, // We don't know (TODO Felix: Find out!)
    LOADING: 1, // Something still loading (blocked)
    INVALID: 3, // Input is invalid (might happen even after operator selection - e.g. because of empty array output etc.)
    UNPROCESSED: 4, // Process node is dirty
    PROCESSED: 5 // All data is up-to-date
};

//window.Xflow.PLATFORM = C.PLATFORM;

module.exports = C;

},{}],180:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./constants.js");
require("../../utils/array.js");

/**
 * Content of this file:
 * All Code for handling data entries connected to Xflow including:
 *  - BufferEntries: Typed value buffers (e.g float3 buffer, without name)
 *  - TextureEntries: e.g. images
 *
 *  This file also includes the DataChangeNotifier used to react to changes on Xflow data structures
 */

//----------------------------------------------------------------------------------------------------------------------
// SamplerConfig
//----------------------------------------------------------------------------------------------------------------------


/**
 * SamplerConfig is used to define sampler properties of a TextureEntry or ImageDataTextureEntry
 * @constructor
 */
var SamplerConfig = function(){
    this.minFilter = 0;
    this.magFilter = 0;
    this.mipFilter = 0;
    this.wrapS = 0;
    this.wrapT = 0;
    this.wrapU = 0;
    this.textureType = 0;
    this.colorR = 0;
    this.colorG = 0;
    this.colorB = 0;
    this.anisotropy = 0; // number of max samples for anisotropic filtering
    this.generateMipMap = 0;
};

SamplerConfig.prototype.setDefaults = function() {
    this.minFilter = C.TEX_FILTER_TYPE.LINEAR;
    this.magFilter = C.TEX_FILTER_TYPE.LINEAR;
    this.mipFilter = C.TEX_FILTER_TYPE.NEAREST;
    this.wrapS = C.TEX_WRAP_TYPE.CLAMP;
    this.wrapT = C.TEX_WRAP_TYPE.CLAMP;
    this.wrapU = C.TEX_WRAP_TYPE.CLAMP;
    this.textureType = C.TEX_TYPE.TEXTURE_2D;
    this.colorR = 0;
    this.colorG = 0;
    this.colorB = 0;
    this.anisotropy = 1; // number of max samples for anisotropic filtering
    this.generateMipMap = 0;
};

SamplerConfig.prototype.set = function(other) {
    this.minFilter = other.minFilter;
    this.magFilter = other.magFilter;
    this.mipFilter = other.mipFilter;
    this.wrapS = other.wrapS;
    this.wrapT = other.wrapT;
    this.wrapU = other.wrapU;
    this.textureType = other.textureType;
    this.colorR = other.colorR;
    this.colorG = other.colorG;
    this.colorB = other.colorB;
    this.generateMipMap = other.generateMipMap;
};


//----------------------------------------------------------------------------------------------------------------------
// DataEntry
//----------------------------------------------------------------------------------------------------------------------


/**
 * The abstract base class for all DataEntries connected to an xflow graph.
 * @abstract
 * @param {C.DATA_TYPE} type Type of DataEntry
 */
var DataEntry = function(type){
    this._type = type;
    /** @type {Array.<Function(DataEntry, C.DATA_ENTRY_STATE)>} **/
    this._listeners = [];
    /** Add related custom data (e.g. WebGL buffers) **/
    this.userData = {};
};

Object.defineProperty(DataEntry.prototype, "type", {
    set: function(){
        throw new Error("type is read-only");
    },
    /** @return {C.DATA_TYPE} */
    get: function(){ return this._type; }
});

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataEntry.prototype.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataEntry.prototype.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 */
DataEntry.prototype._notifyChanged = function(){
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
};

//----------------------------------------------------------------------------------------------------------------------
// BufferEntry
//----------------------------------------------------------------------------------------------------------------------

/**
 * A typed value buffer basically linking to a typed array.
 * @constructor
 * @extends {DataEntry}
 * @param {C.DATA_TYPE} type
 * @param {Object} value A typed array
 */
var BufferEntry = function(type, value){
    DataEntry.call(this, type);
    this._value = value;
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};
Base.createClass(BufferEntry, DataEntry);


/**
 *  Set value of entry. Triggers notification chain
 *  @param {Object} v Value to set (has to be a TypedArray)
 */
BufferEntry.prototype.setValue = function(v){
    this._setValue(v);
    Base._flushResultCallbacks();
};

/**
 * Are there no, one or many values?
 * @param size
 * @param tupleSize
 * @returns {number}
 */
function getSizeType(size, tupleSize){
    if(size >= tupleSize*2)
        return 2;
    else if(size >= tupleSize)
        return 1;
    else
        return 0;
}

BufferEntry.prototype._setValue = function(v){
    var oldSize = (this._value ? this._value.length : 0), newSize = (v ? v.length : 0), tupleSize = this.getTupleSize();
    var notification;
    if(getSizeType(oldSize, tupleSize) != getSizeType(newSize, tupleSize))
        notification = C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE;
    else if(oldSize != newSize){
        notification = C.DATA_ENTRY_STATE.CHANGED_SIZE;
    }
    else{
        notification = C.DATA_ENTRY_STATE.CHANGED_VALUE;
    }
    this._value = v;
    notifyListeners(this, notification);
};

/** @return {Object} */
BufferEntry.prototype.getValue = function(){
    return this._value;
};

/**
 * Returns the buffer length
 * @return {Object}
 */
BufferEntry.prototype.getLength = function(){
    return this._value ? this._value.length : 0;
};

/**
 * Returns tuple size (e.g 1, 2, 3, 4, 16)
 * @returns {number}
 */
BufferEntry.prototype.getTupleSize = function() {
    return C.DATA_TYPE_TUPLE_SIZE[this._type];
};

/**
 * Return tuple count
 * @return {number}
 */
BufferEntry.prototype.getIterateCount = function(){
    return this.getLength() / this.getTupleSize();
};

/**
 * Is value not set or the length of the buffer 0
 * @returns {boolean}
 */
BufferEntry.prototype.isEmpty = function(){
    return !this._value || !this.getLength();
};


//----------------------------------------------------------------------------------------------------------------------
// TextureEntry
//----------------------------------------------------------------------------------------------------------------------

function TexelSource(sourceOrWidth, height, format, type) {
    if (typeof sourceOrWidth === "object") {
        if (sourceOrWidth.nodeName) {
            var nodeName = sourceOrWidth.nodeName.toLowerCase();
            if (nodeName === "video" && (typeof sourceOrWidth.complete === "undefined")) {
                Object.defineProperties(sourceOrWidth, {
                    width: {
                        get: function () {
                            return this.videoWidth;
                        }
                    },
                    height: {
                        get: function () {
                            return this.videoHeight;
                        }
                    },
                    complete: {
                        get: function () {
                            return !(this.readyState == 0 || this.videoWidth <= 0 || this.videoHeight <= 0);
                        }
                    }
                });
            }
            sourceOrWidth.texelFormat = C.TEXTURE_FORMAT.RGBA;
            sourceOrWidth.texelType = C.TEXTURE_TYPE.UBYTE;
        }
        //assume source is a image data like object
        this._source = sourceOrWidth;
    } else {
        format = format || C.TEXTURE_FORMAT.RGBA;
        type =  type || C.TEXTURE_TYPE.UBYTE;
        //create a new texel source backed by type array
        this._source = {
            width: sourceOrWidth,
            height: height,
            texelFormat: format,
            texelType: type,
            data: new C.TYPED_ARRAY_MAP[type](sourceOrWidth * height * C.TEXTURE_FORMAT_TUPLE_SIZE[format])
        }
    }
}

Object.defineProperties(TexelSource.prototype, {
    imageData: {
        get: function () {
            if (this._source instanceof HTMLElement) {
                var canvas = document.createElement("canvas");
                canvas.width = this._source.width;
                canvas.height = this._source.height;
                var ctx = canvas.getContext("2d");
                ctx.drawImage(this._source, 0, 0);
                var source = ctx.getImageData(0, 0, this._source.width, this._source.height);
                source.texelFormat = this._source.texelFormat;
                source.texelType = this._source.texelType;
                this._source = source;
            }
            return this._source;
        }
    },
    // TODO this is very confusing. asGLTextureData is texelsource.source
    glTextureData: {
        get: function () {
            return this._source;
        }
    },
    complete: {
        get: function () {
            return typeof this._source.complete === "undefined" ? true : this._source.complete;
        }
    },
    width: {
        get: function () {
            return this._source ? this._source.width : -1;
        }
    },
    height: {
        get: function () {
            return this._source ? this._source.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._source ? this._source.texelFormat: C.TEXTURE_FORMAT.UNKNOWN;
        }
    },
    texelType: {
        get: function () {
            return this._source ? this._source.texelType: C.TEXTURE_TYPE.UNKNOWN;
        }
    }
});

/**
 * A data entry for a texture.
 * Note: each TextureEntry includes a samplerConfig.
 * @constructor
 * @extends {DataEntry}
 * @param {HTMLImageElement|HTMLVideoElement|HTMLCanvasElement} source //TODO: Which kinds are supported?
 */
var TextureEntry = function(source){
    DataEntry.call(this, C.DATA_TYPE.TEXTURE);
    this._samplerConfig = new SamplerConfig();
    this._loading = false;
    this.setImage(source);

    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};

Base.createClass(TextureEntry, DataEntry);

Object.defineProperties(TextureEntry.prototype, {
    width: {
        get: function () {
            return this._source ? this._source.width : -1;
        }
    },
    height: {
        get: function () {
            return this._source ? this._source.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._source ? this._source.texelFormat: C.TEXTURE_FORMAT.UNKNOWN;
        }
    },
    texelType: {
        get: function () {
            return this._source ? this._source.texelType: C.TEXTURE_TYPE.UNKNOWN;
        }
    }
});

TextureEntry.prototype.isLoading = function() {
    if (!this._source)
        return false;

    return !this._source.complete;
};

/**
 * @private
 */
TextureEntry.prototype._createImage = function(width, height, format, type, samplerConfig) {
    if (!this._source || this.width != width || this.height != height || this.format != format || this.type != type) {
        var source = new TexelSource(width, height, format, type);

        if (!samplerConfig) {
            samplerConfig = new SamplerConfig();
            samplerConfig.setDefaults();
        }

        this._samplerConfig.set(samplerConfig);
        this._setImage(source);
    } else {
        this._notifyChanged();
    }

    return this._source;
};

/**
 * Set image source of a Texture Entry
 * TODO: This is called even if image is just loaded (on XML3D side). Add a notifyImageLoaded method could
 * be helpful
 *
 * @param {HTMLImageElement|HTMLVideoElement|TexelSource|null} element
 * @param {boolean?} forceLoadCallback trigger load callback if data changes
 */
TextureEntry.prototype.setImage = function (element, forceLoadCallback) {
    this._setImage(element, forceLoadCallback);
    Base._flushResultCallbacks();
};

TextureEntry.prototype._setImage = function (element, forceLoadCallback) {
    if (!element)
        this._setSource(null, forceLoadCallback);
    else if (element instanceof TexelSource)
        this._setSource(element, forceLoadCallback);
    else
        this._setSource(new TexelSource(element), forceLoadCallback);
};

TextureEntry.prototype._setSource = function(s, forceLoadCallback) {
    var prevLoading = this.isLoading();
    this._source = s;
    var loading = this.isLoading();
    if(forceLoadCallback && !loading && !prevLoading){
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_START);
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_END);
    }
    else if(loading){
        this._loading = true;
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_START);
    }
    else if(this._loading){
        this._loading = false;
        notifyListeners(this, C.DATA_ENTRY_STATE.LOAD_END);
    }
    else
        notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
};

TextureEntry.prototype.asGLTextureValue = function () {
    return this._source && this._source.glTextureData;
};

/** @return {ImageData} */
TextureEntry.prototype.getValue = function() {
    if (!this._source)
        return null;
    if (!this.isLoading())
        return this._source.imageData;
    else
        return null;
};

/** @return {SamplerConfig} */
TextureEntry.prototype.getSamplerConfig = function(){
    return this._samplerConfig;
};

/** @return {number} */
TextureEntry.prototype.getLength = function(){
    return 1;
};
TextureEntry.prototype.isEmpty = function(){
    return false;
};

/** @return {number} */
TextureEntry.prototype.getIterateCount = function() {
    return 1;
};

//----------------------------------------------------------------------------------------------------------------------
// ImageDataTextureEntry
//----------------------------------------------------------------------------------------------------------------------

/**
 * Same as TextureEntry, only based on imageData.
 * This class is used for xflow running inside Web Workers (which don't support HTML images)
 * @param imageData
 * @extends{DataEntry}
 * @constructor
 */
var ImageDataTextureEntry = function(imageData){
    DataEntry.call(this, C.DATA_TYPE.TEXTURE);
    this._samplerConfig = new SamplerConfig();
    this._imageData = null;
    this._texelFormat = C.TEXTURE_FORMAT.RGBA;
    this._texelType = C.TEXTURE_TYPE.UBYTE;

    this._updateImageData(imageData);

    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_NEW);
};

Base.createClass(ImageDataTextureEntry, DataEntry);

Object.defineProperties(ImageDataTextureEntry.prototype, {
    width: {
        get: function () {
            return this._imageData ? this._imageData.width : -1;
        }
    },
    height: {
        get: function () {
            return this._imageData ? this._imageData.height : -1;
        }
    },
    texelFormat: {
        get: function () {
            return this._texelFormat;
        }
    },
    texelType: {
        get: function () {
            return this._texelType;
        }
    }
});



ImageDataTextureEntry.prototype.isLoading = function() {
    return !this._imageData;
};

ImageDataTextureEntry.prototype._updateImageData = function(imageData) {
    this._texelFormat = C.TEXTURE_FORMAT.RGBA;
    this._texelType = C.TEXTURE_TYPE.UBYTE;
    this._imageData = imageData;
};

/** Create new image
 * TODO: Jan: Write source documentation
 * @param width
 * @param height
 * @param format
 * @param type
 * @param samplerConfig
 * @return {HTMLImageElement|HTMLCanvasElement}
 */
ImageDataTextureEntry.prototype._createImage = function(width, height, format, type, samplerConfig) {
    if (!this._imageData || this.getWidth() != width || this.getHeight() != height || this._format != format || this._type != type) {
        if (!width || !height)
            throw new Error("Width or height is not specified");
        this._texelFormat = format;
        this._texelType = type;
        if (!samplerConfig) {
            samplerConfig = new SamplerConfig();
            samplerConfig.setDefaults();
        }
        this._samplerConfig.set(samplerConfig);

        /**
         * @type {{width: *, height: *, data: null|ArrayBufferView}}
         */
        var imageData = {
            width: width,
            height: height,
            data: null
        };
        if(type == C.TEXTURE_TYPE.FLOAT){
            imageData.data = new Float32Array(width*height*4);
        }
        else {
            // FIXME: We should allocate Uint8ClampedArray here instead
            // But Uint8ClampedArray can't be allocated in Chrome inside a Web Worker
            // See bug: http://code.google.com/p/chromium/issues/detail?id=176479
            // As a work around, we allocate Int16Array which results in correct clamping outside of web worker
            if(Uint8Array == Uint8ClampedArray)
                imageData.data = new Int16Array(width*height*4);
            else
                imageData.data = new Uint8ClampedArray(width*height*4);
        }
        this._imageData = imageData;
    }
    this._notifyChanged();
};

/** @param {Object} v */
ImageDataTextureEntry.prototype.setImageData = function(v) {
    this._updateImageData(v);
    notifyListeners(this, C.DATA_ENTRY_STATE.CHANGED_VALUE);
    Base._flushResultCallbacks();
};

ImageDataTextureEntry.prototype.getWidth = function() {
    return this._imageData && this._imageData.width || 0;
};

ImageDataTextureEntry.prototype.getHeight = function() {
    return this._imageData && this._imageData.height || 0;
};

/** @return {ImageData} */
ImageDataTextureEntry.prototype.getValue = function() {
    return this._imageData;
};

/** @return {SamplerConfig} */
ImageDataTextureEntry.prototype.getSamplerConfig = function(){
    return this._samplerConfig;
};

/** @return {number} */
ImageDataTextureEntry.prototype.getLength = function(){
    return 1;
};
ImageDataTextureEntry.prototype.isEmpty = function(){
    return false;
};


/** @return {number} */
ImageDataTextureEntry.prototype.getIterateCount = function() {
    return 1;
};

//----------------------------------------------------------------------------------------------------------------------
// DataChangeNotifier
//----------------------------------------------------------------------------------------------------------------------


/**
 * Used to listen to modifications of any DataEntry connected to an Xflow graph.
 * @constructor
 */
var DataChangeNotifier = {
    _listeners: []
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataChangeNotifier.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(DataEntry, C.DATA_ENTRY_STATE)} callback
 */
DataChangeNotifier.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 * @param {DataEntry} dataEntry
 * @param {C.DATA_ENTRY_STATE} notification
 */
function notifyListeners(dataEntry, notification){
    var i;
    // Global notifications
    for(i = 0; i < DataChangeNotifier._listeners.length; ++i){
        DataChangeNotifier._listeners[i](dataEntry, notification);
    }
    // Internal and external listeners
    for(i = 0; i < dataEntry._listeners.length; ++i){
        dataEntry._listeners[i](dataEntry, notification);
    }
}

module.exports = {
    DataEntry: DataEntry,
    BufferEntry: BufferEntry,
    TextureEntry: TextureEntry,
    ImageDataTextureEntry: ImageDataTextureEntry,
    SamplerConfig: SamplerConfig,
    DataChangeNotifier: DataChangeNotifier
};

},{"../../utils/array.js":170,"../base.js":178,"./constants.js":179}],181:[function(require,module,exports){
var C = require("./constants.js");
var Mapping = require("./../processing/mapping.js");
require("../../utils/array.js");

var Base = require("../base.js");
var ChannelNode = require("../processing/channel-node.js").ChannelNode;
var Utils = require("../utils/utils.js");

//----------------------------------------------------------------------------------------------------------------------
// GraphNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * Base class for other graph nodes
 * @constructor
 * @abstract
 * @param {Graph} graph Reference to parent graph
 */
var GraphNode = function(){
    /**
     * All nodes that add a dependency to this node
     * @type array<GraphNode>
     **/
    this._parents = [];
};


//----------------------------------------------------------------------------------------------------------------------
// InputNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * An InputNode include an DataEntry, a name and other information
 * This class mirrors XML3D elements such as <float3>, <int> or <texture>
 *
 * @constructor
 * @param {Graph} graph
 * @extends {GraphNode}
 */
var InputNode = function(){
    GraphNode.call(this);
    /**
     * Name of the input node
     * @type {string}
     * @private
     */
    this._name = "";
    /**
     * Sequence key
     * @type {number}
     * @private
     */
    this._key = 0;
    /**
     * DataEntry node that holds the value
     * @type {DataEntry}
     */
    this._data = null;
    /**
     * If this nodes is a parameter within a <dataflow>
     * this is set to the name of the parameter, otherwise null
     * @type {null|String}
     * @private
     */
    this._paramName = null;

    /**
     * Experimental! Apply different override logic in order
     * to propagate global parameters to the source of the graph
     * Could be used for instance for LOD concepts, where the
     * renderer propagates the distance along the graph
     * @type {boolean}
     * @private
     */
    this._paramGlobal = false;

    /**
     *  Cache listener for DataEntry
     *  @see {InputNode.onDataChange}
     */
    this._dataListener = this.onDataChange.bind(this);
};
Base.createClass(InputNode, GraphNode);

/**
 * Propagate events from DataEntry to parent nodes
 * @param {Object} newValue
 * @param {C.DATA_ENTRY_STATE} notification
 */
InputNode.prototype.onDataChange = function(newValue, notification) {
    var downNote;
    switch(notification){
        case C.DATA_ENTRY_STATE.CHANGED_VALUE: downNote = C.RESULT_STATE.CHANGED_DATA_VALUE; break;
        case C.DATA_ENTRY_STATE.LOAD_START: downNote = C.RESULT_STATE.IMAGE_LOAD_START; break;
        case C.DATA_ENTRY_STATE.LOAD_END: downNote = C.RESULT_STATE.IMAGE_LOAD_END; break;
        case C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE: downNote = C.RESULT_STATE.CHANGED_STRUCTURE; break;
        case C.DATA_ENTRY_STATE.CHANGED_SIZE: downNote = C.RESULT_STATE.CHANGED_DATA_SIZE; break;
        default: downNote = C.RESULT_STATE.CHANGED_DATA_SIZE; break;
    }
    notifyParentsOnChanged(this,downNote);
};

Object.defineProperty(InputNode.prototype, "name", {
    /** @param {string} v */
    set: function(v){
        this._name = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._name; }
});

Object.defineProperty(InputNode.prototype, "key", {
    /** @param {number} v */
    set: function(v){
        this._key = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {number} */
    get: function(){ return this._key; }
});

Object.defineProperty(InputNode.prototype, "paramName", {
    /** @param {string} v */
    set: function(v){
        this._paramName = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._paramName; }
});

Object.defineProperty(InputNode.prototype, "paramGlobal", {
    /** @param {boolean} v */
    set: function(v){
        this._paramGlobal = v;
        notifyParentsOnChanged(this, C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {boolean} */
    get: function(){ return this._paramGlobal; }
});

Object.defineProperty(InputNode.prototype, "data", {
    /** @param {DataEntry} dataEntry */
    set: function(dataEntry){
        var prevDataLoading = false;
        if(this._data) {
            prevDataLoading = this._data._loading;
            this._data.removeListener(this._dataListener);
        }
        this._data = dataEntry;
        if(this._data) {
            this._data.addListener(this._dataListener);
        }
        if(prevDataLoading != this._data._loading){
            notifyParentsOnChanged(this, this._data._loading ? C.RESULT_STATE.IMAGE_LOAD_START :
                C.RESULT_STATE.IMAGE_LOAD_END);
        }
        Base._flushResultCallbacks();
    },
    /** @return {DataEntry} */
    get: function(){ return this._data; }
});

/**
 * Getter for local parameter name, returns null if this is a global
 * parameter
 *
 * @returns {null|String}
 * @private
 */
InputNode.prototype._getParamNames = function(){
    return this._paramGlobal ? null : this._paramName;
};

/**
 * Getter for global parameter name, returns null if this is not a global
 * parameter
 *
 * @returns {null|String}
 * @private
 */
InputNode.prototype._getGlobalParamNames = function(){
    return this._paramGlobal ? this._paramName : null;
};

//----------------------------------------------------------------------------------------------------------------------
// DataNode
//----------------------------------------------------------------------------------------------------------------------
var c_xflowNodeId = 0;
function getXflowNodeId(){
    return ++c_xflowNodeId;
}

/**
 * The DataNode is the central structure of an Xflow Graph.
 * It is used to build a data composition graph as well as a data flow.
 * It mirror the <data> element of XML3D
 *
 * @constructor
 * @param {Graph} graph Context graph
 * @param {boolean} isDataFlow is this node a dataflow
 * @extends {GraphNode}
 */
var DataNode = function(isDataFlow){
    GraphNode.call(this);

    /**
     * Marker, if this data node is expecting data. Xflow
     * is not monitoring any load events. This must be set
     * from external
     * @type {boolean}
     */
    this._loading = false;

    /**
     * Experimental! Priority. How important is this data?
     * 0: Very important
     * @type {number}
     */
    this._loadLevel = 0;

    /**
     * Used for loading events: If progress level
     * reaches infinity, loading events are triggered
     * @type {Number}
     */
    this._progressLevel = Infinity;

    /**
     * Globally unique id
     */
    this.id = getXflowNodeId();

    /**
     * Is this node a proto node
     * @type {boolean}
     */
    this._isProtoNode = isDataFlow;

    /**
     * Children. InputNodes and DataNodes (as found in DOM)
     * @type {Array}
     */
    this._children = [];

    /**
     * The DataNode that has been reference via src
     * @type {DataNode}
     */
    this._sourceNode = null;

    /**
     * Field to attach custom data
     * @type {null|Object}
     */
    this._userData = null;

    /**
     * The filter type of this node (keep, rename, remove ...)
     * @type {DATA_FILTER_TYPE}
     */
    this._filterType = C.DATA_FILTER_TYPE.NONE;

    /**
     * Define the mapping
     * @type {Mapping.Mapping}
     */
    this._filterMapping = null;

    /**
     * String identifier for operator
     * TODO: Operator class
     * @type {string|Object}
     */
    this._computeOperator = "";

    /**
     * True, if compute is a dataflow reference
     * @type {boolean}
     */
    this._computeUsesDataflow = false;

    /**
     * Mapping for input of operator,
     * e.g. (position, texcoord) or ({position: pos, texcoord: uv})
     * @type {Mapping}
     */
    this._computeInputMapping = null;

    /**
     * Mapping for output of operator,
     * e.g. (position, texcoord) = ... or {position: pos, texcoord: uv} = ...
     * @type {Mapping}
     */
    this._computeOutputMapping = null;

    /**
     * If dataflow node has been resolved, this
     * entry is set
     * @type {DataNode}
     */
    this._dataflowNode = null;

    /**
     * Internal (optimized) version of this data node
     * @type {ChannelNode}
     */
    this._channelNode = new ChannelNode(this);

    /**
     * Map of cached channel nodes for dataflow instances with varying
     * input arguments (specialized nodes)
     * TODO: Use WeakMap?
     * @type {Object.<string, ChannelNode>}
     */
    this._substitutionNodes = {};

    /**
     * Cached version of local param names collected from
     * children
     * @type {Array.<string>}
     */
    this._paramNames = null;

    /**
     * Cached version of global param names collected from
     * children
     * @type {Array.<string>}
     */
    this._globalParamNames = null;

    /**
     * Platform, this data node should be executed on
     * TODO: This should be implicit, not explicit
     * @type {null}
     */
    this._platform = null;

    /**
     * Observers of the node's C.RESULT_STATE
     * @type {Array}
     */
    this._listeners = [];

    /**
     * Observers of the node's progress level
     * @type {Array}
     */
    this._loadListeners = [];

};
Base.createClass(DataNode, GraphNode);


Object.defineProperty(DataNode.prototype, "sourceNode", {
    /** @param {?DataNode} newSourceNode */
    set: function(newSourceNode){
        replaceNodeInHierarchy(this, "_sourceNode", newSourceNode);
        updateProgressLevel(this);
        this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {?DataNode} */
    get: function(){ return this._sourceNode; }
});

Object.defineProperty(DataNode.prototype, "dataflowNode", {
    /** @param {?DataNode} newDataflowNode */
    set: function(newDataflowNode){
        if(newDataflowNode && !this._computeUsesDataflow) {
            throw new Error("Cannot set dataflowNode when compute doesn't use dataflow.");
        }
        replaceNodeInHierarchy(this, "_dataflowNode", newDataflowNode);
        updateProgressLevel(this);
        this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {?DataNode} */
    get: function(){ return this._dataflowNode; }
});


Object.defineProperty(DataNode.prototype, "userData", {
    /** @param {?DataNode} v */
    set: function(v){
        this._userData = v;
    },
    /** @return {?DataNode} */
    get: function(){ return this._userData; }
});

/**
 * Set (from external) if more data is expected.
 * @param {boolean} loading
 */
DataNode.prototype.setLoading = function(loading){
    if(this._loading != loading){
        this._loading = loading;
        this._channelNode.setStructureOutOfSync();
        this._channelNode.loading = loading;
        for (var sub in this._substitutionNodes) {
            var subNode = this._substitutionNodes[sub];
            subNode.setStructureOutOfSync();
            subNode.loading = loading;
        }
        updateProgressLevel(this);
        Base._flushResultCallbacks();
    }
};

/**
 * Returns if this or any child node is loading
 * @returns {boolean}
 */
DataNode.prototype.isSubtreeLoading = function(){
    return this._progressLevel == 0;
};

/**
 * @returns {Number}
 */
DataNode.prototype.getProgressLevel = function(){
    return this._progressLevel;
};


Object.defineProperty(DataNode.prototype, "filterType", {
    /** @param {C.DATA_FILTER_TYPE} v */
    set: function(v){
        this._filterType = v;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {C.DATA_FILTER_TYPE} */
    get: function(){ return this._filterType; }
});

Object.defineProperty(DataNode.prototype, "filterMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_filterMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._filterMapping; }
});

Object.defineProperty(DataNode.prototype, "computeOperator", {
    /** @param {string} v */
    set: function(v){
        this._computeOperator = v;
        this._computeUsesDataflow = false;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._computeUsesDataflow ? null : this._computeOperator; }
});

Object.defineProperty(DataNode.prototype, "computeDataflowUrl", {
    /** @param {string} v */
    set: function(v){
        this._computeOperator = v;
        this._computeUsesDataflow = true;
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {string} */
    get: function(){ return this._computeUsesDataflow ? this._computeOperator : null; }
});

Object.defineProperty(DataNode.prototype, "computeInputMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_computeInputMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._computeInputMapping; }
});
Object.defineProperty(DataNode.prototype, "computeOutputMapping", {
    /** @param {Mapping} v */
    set: function(v){
        swapMapping(this, "_computeOutputMapping", v);
        this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
        Base._flushResultCallbacks();
    },
    /** @return {Mapping} */
    get: function(){ return this._computeOutputMapping; }
});

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.isProtoNode = function(){
    return this._isProtoNode;
};

/**
 * @param {GraphNode} child
 */
DataNode.prototype.appendChild = function(child){
    this._children.push(child);
    addParent(this, child);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};
/**
 * @param {GraphNode} child
 */
DataNode.prototype.removeChild = function(child){
    Array.erase(this._children, child);
    removeParent(this, child);
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * @param {GraphNode} child
 * @param {GraphNode} beforeNode
 */
DataNode.prototype.insertBefore = function(child, beforeNode){
    var idx = this._children.indexOf(beforeNode);
    if(idx == -1)
        this._children.push(child);
    else
        this._children.splice(idx, 0, child);
    addParent(this, child);
    // TODO: Next three calls on all structural changes. Add Method
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * remove all children of the DataNode
 */
DataNode.prototype.clearChildren = function(){
    for(var i =0; i < this._children.length; ++i){
        removeParent(this, this._children[i]);
    }
    this._children = [];
    updateProgressLevel(this);
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

//noinspection JSUnusedGlobalSymbols
/**
 * Detach this DataNode from all connections, including source- and proto-node references
 */
DataNode.prototype.detachFromParents = function(){
    for(var i =0; i < this._parents.length; ++i){
        var parent = this._parents[i];
        if(parent._sourceNode == this)
            parent.sourceNode = null;
        else if(parent._dataflowNode == this){
            parent.dataflowNode = null;
        }
        else{
            parent.removeChild(this);
        }
    }
    this._children = [];
};

/**
 * Sets platform of a DataNode. If _platform is defined, it will override the default platform setting of
 * an Xflow graph.
 *
 * @param {String|C.PLATFORM|null} platformSrc
 */
DataNode.prototype.setPlatform = function(platformSrc) {
    if (typeof platformSrc === 'string') {
        if (platformSrc === "cl") {
            this._platform = C.PLATFORM.CL;
        }
        else if (platformSrc === "gl") {
            this._platform = C.PLATFORM.GLSL;
        }
        else if (platformSrc === "js") {
            this._platform = C.PLATFORM.JAVASCRIPT;
        }
    } else if (!isNaN(parseFloat(platformSrc)) && isFinite(platformSrc)) {
        this._platform = platformSrc;
    } else {
        this._platform = null;
    }

    this.notify(C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * @const
 */
var filterParser = /^([A-Za-z\s]*)\(([^()]+)\)$/;

/**
 * Set filter by string
 * @param {string} filterString
 */
DataNode.prototype.setFilter = function(filterString){
    filterString = filterString || "";
    var newType = C.DATA_FILTER_TYPE.RENAME;
    var newMapping = null;
    if(filterString){
        var result = filterString.trim().match(filterParser);
        if(result){
            var type = result[1].trim();
            switch(type){
                case "keep": newType = C.DATA_FILTER_TYPE.KEEP; break;
                case "remove": newType = C.DATA_FILTER_TYPE.REMOVE; break;
                case "rename": newType = C.DATA_FILTER_TYPE.RENAME; break;
                default:
                    Base.notifyError("Unknown filter type:" + type, this);
            }
            newMapping = Mapping.Mapping.parse(result[2], this);
        }
        else{
            Base.notifyError("Could not parse filter '" + filterString + "'", this);
        }
    }
    if(!newMapping){
        // TODO Remove this? (Mapping can be null from now on)
        newMapping = new Mapping.OrderMapping();
    }
    swapMapping(this, "_filterMapping", newMapping);
    this._filterType = newType;
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

var computeParser = /^(([^=]+)\=)?([^'(]+('[^']+')?[^'(]+)(\(([^()]*)?\))?$/;
var bracketsParser = /^\(([^()]*)\)$/;
var dataflowParser = /^dataflow\['([^']+)'\]$/;

//noinspection JSUnusedGlobalSymbols
/**
 * If the compute string contains a reference to an external dataflow,
 * the parser returns its URL. Null, otherwise
 * @param computeString
 * @returns {string|null}
 */
var getComputeDataflowUrl = function(computeString){
    computeString = computeString || "";
    var result = computeString.trim().match(computeParser);
    if(result){
        if(result = result[3].trim().match(dataflowParser)){
            return result[1];
        }
    }
    return null;
};

/**
 * Set compute by string
 * @param {string} computeString
 */
DataNode.prototype.setCompute = function(computeString){
    computeString = computeString || "";
    var newOperator = "";
    var inputMapping = null, outputMapping = null;
    var result = computeString.trim().match(computeParser);
    if(result){
        var output = result[2] ? result[2].trim() : "";
        newOperator = result[3].trim();
        var input = result[6] ? result[6].trim() : "";
        if(result = output.match(bracketsParser)){
            output = result[1];
        }
        if(input)
            inputMapping = Mapping.Mapping.parse(input, this);
        if(output)
            outputMapping = Mapping.Mapping.parse(output, this);

        if(result = newOperator.match(dataflowParser)){
            this._computeUsesDataflow = true;
            newOperator = result[1];
        }
        else{
            this._computeUsesDataflow = false;
        }
        this._dataflowNode = null;
    }
    else if(computeString){
        Base.notifyError("Error parsing Compute value '" + computeString + "'", this);
    }
    swapMapping(this, "_computeInputMapping", inputMapping);
    swapMapping(this, "_computeOutputMapping", outputMapping);
    this._computeOperator = newOperator;
    this.notify( C.RESULT_STATE.CHANGED_STRUCTURE);
    Base._flushResultCallbacks();
};

/**
 * Notifies DataNode about a change. Notification will be forwarded to parents, if necessary
 * @param {C.RESULT_STATE} changeType
 * @param {GraphNode?} senderNode
 */
DataNode.prototype.notify = function(changeType, senderNode){
    //noinspection FallthroughInSwitchStatementJS
    switch(changeType) {
        case C.RESULT_STATE.CHANGED_STRUCTURE:
            this._paramNames = null;
            this._globalParamNames = null;
            this._channelNode.setStructureOutOfSync();
            clearSubstitutionNodes(this);
            notifyParentsOnChanged(this, changeType);
            break;

        case C.RESULT_STATE.IMAGE_LOAD_START:
        case C.RESULT_STATE.IMAGE_LOAD_END:
            updateProgressLevel(this);
            if(senderNode){
                this._channelNode.notifyDataChange(senderNode, changeType);
            }
            break;

        case C.RESULT_STATE.CHANGED_DATA_VALUE:
        case C.RESULT_STATE.CHANGED_DATA_SIZE:
            if(senderNode){
                this._channelNode.notifyDataChange(senderNode, changeType);
            }
            break;
    }
    // Inform listeners (e.g. Requests)
    for(var i = 0; i < this._listeners.length; ++i) {
        this._listeners[i](changeType);
    }
};

DataNode.prototype.addListener = function(listener){
    this._listeners.push(listener)
};

DataNode.prototype.removeListener = function(listener) {
    Array.erase(this._listeners, listener);
};

DataNode.prototype.addLoadListener = function(listener){
    this._loadListeners.push(listener);
};

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.removeLoadListener = function(listener){
    Array.erase(this._loadListeners, listener);
};

DataNode.prototype._callLoadListeners = function(newLevel, oldLevel){
    var len = this._loadListeners.length;
    for(var i = 0; i < len; ++i){
        this._loadListeners[i](this, newLevel, oldLevel);
    }
};

DataNode.prototype.getOutputNames = function(){
    return getForwardNode(this)._channelNode.getOutputNames();
};

DataNode.prototype.getOutputChannelInfo = function(name){
    return getForwardNode(this)._channelNode.getOutputChannelInfo(name);
};

//noinspection JSUnusedGlobalSymbols
DataNode.prototype.getParamNames = function(){
    return this._getParamNames();
};

/**
 * Delegate computation of the result to the channel node
 * of the first contributing DataNode.
 * @param type
 * @param filter
 * @returns {Result}
 */
DataNode.prototype._getResult = function(type, filter){
    return getForwardNode(this, filter)._channelNode.getResult(type, filter);
};

DataNode.prototype._getForwardNode = function(filter){
    return getForwardNode(this, filter);
};

DataNode.prototype._getParamNames = function(){
    if(!this._paramNames){
        this._paramNames = [];
        if(this._sourceNode)
            Utils.nameset.add(this._paramNames, this._sourceNode._getParamNames());
        else{
            for(var i = 0; i < this._children.length; ++i){
                Utils.nameset.add(this._paramNames, this._children[i]._getParamNames());
            }
        }
    }
    return this._paramNames;
};

DataNode.prototype._getGlobalParamNames = function(){
    if(!this._globalParamNames){
        this._globalParamNames = [];
        if(this._dataflowNode)
            Utils.nameset.add(this._globalParamNames, this._dataflowNode._getGlobalParamNames());

        if(this._sourceNode)
            Utils.nameset.add(this._globalParamNames, this._sourceNode._getGlobalParamNames());
        else{
            for(var i = 0; i < this._children.length; ++i){
                Utils.nameset.add(this._globalParamNames, this._children[i]._getGlobalParamNames());
            }
        }
    }
    return this._globalParamNames;
};

/**
 * @param {Substitution} substitution
 * @returns {ChannelNode}
 */
DataNode.prototype._getOrCreateChannelNode = function(substitution){
    if(!substitution)
        return this._channelNode;
    else{
        var key = substitution.getKey(this);
        if(!this._substitutionNodes[key]) {
            this._substitutionNodes[key] = new ChannelNode(this, substitution);
        } else {
            this._substitutionNodes[key].increaseRef();
        }
        return this._substitutionNodes[key];
    }
};

/**
 * Remove ChannelNode passed as argument from internal substitution nodes
 * Decreases reference counter of substitution node and deletes it if not
 * used by any other node.
 * @param {ChannelNode} substitutionNode
 */
DataNode.prototype._removeSubstitutionNode = function(substitutionNode){
    var key = substitutionNode.substitution.getKey(this);
    if(this._substitutionNodes[key] && this._substitutionNodes[key].decreaseRef())
        delete this._substitutionNodes[key];
};

/**
 * Calls clear of all substitutionNodes and clears the map
 * @param {DataNode} dataNode
 */
function clearSubstitutionNodes(dataNode){
    for(var name in dataNode._substitutionNodes){
        dataNode._substitutionNodes[name].clear();
    }
    dataNode._substitutionNodes = {};
}

/**
 * Skips nodes, if it does not contribute to the result (optimization)
 * @param {DataNode} dataNode
 * @param {array.<string>?} filter
 * @returns {DataNode}
 */
function getForwardNode(dataNode, filter){
    var hasFilter = (dataNode._filterMapping && !dataNode._filterMapping.isEmpty());
    if(hasFilter)
        return dataNode;

    if(!dataNode._computeOperator ){
        if(dataNode._sourceNode && dataNode._children.length == 0)
            return getForwardNode(dataNode._sourceNode);
        if(dataNode._children.length == 1 && dataNode._children[0] instanceof DataNode)
            return getForwardNode(dataNode._children[0]);
    }

    var idx = dataNode._channelNode.getChildDataIndex(filter);
    if(idx != -1 && idx != undefined){
        if(dataNode._sourceNode)
            return getForwardNode(dataNode._sourceNode);
        else
            return getForwardNode(dataNode._children[idx]);
    }
    return dataNode;
}


/**
 * Computes the progress level
 * @private
 * @param {DataNode} node
 */
function updateProgressLevel(node){
    var progressLevel = node._loading ? node._loadLevel : Infinity;
    var i;

    for(i = 0; progressLevel && i < node._children.length; ++i){
        var child = node._children[i];
        if(child instanceof DataNode){
            progressLevel = Math.min(progressLevel, Math.max(child._loadLevel, child._progressLevel) );
        }
        else if(child._data && child._data.isLoading && child._data.isLoading()){
            progressLevel = Math.min(progressLevel, 1);
        }
    }
    if(progressLevel && node._sourceNode){
        progressLevel = Math.min(progressLevel, Math.max(node._sourceNode._loadLevel, node._sourceNode._progressLevel));
    }
    if(progressLevel && node._dataflowNode){
        progressLevel = Math.min(progressLevel, Math.max(node._dataflowNode._loadLevel, node._dataflowNode._progressLevel));
    }
    var oldLevel = node._progressLevel;
    node._progressLevel = progressLevel;

    if(oldLevel != node._progressLevel){
        node._callLoadListeners(node._progressLevel, oldLevel);
        for(i = 0; i < node._parents.length; ++i)
            updateProgressLevel(node._parents[i]);
    }
}

//----------------------------------------------------------------------------------------------------------------------
// Helpers
//----------------------------------------------------------------------------------------------------------------------


/**
 * @private
 * @param {DataNode} parent
 * @param {GraphNode} child
 */
function addParent(parent, child){
    child._parents.push(parent);
}

/**
 * @private
 * @param {DataNode} parent
 * @param {GraphNode} child
 */
function removeParent(parent, child){
    Array.erase(child._parents, parent);
}

/**
 * Notify all parent nodes about a change
 * @param {GraphNode} node
 * @param {exports.C.RESULT_STATE} changeType
 * @private
 */
function notifyParentsOnChanged(node, changeType){
    for(var i = 0; i < node._parents.length; ++i){
        node._parents[i].notify(changeType, node);
    }
}

/**
 * Update the owners of the mappings
 * @param {DataNode} dataNode
 * @param {string} key
 * @param {Mapping} mapping
 */
function swapMapping(dataNode, key, mapping){
    dataNode[key] && dataNode[key]._removeOwner(dataNode);
    dataNode[key] = mapping;
    dataNode[key] && dataNode[key]._addOwner(dataNode);
}

function replaceNodeInHierarchy(node, field, newChild) {
    var oldChild = node[field];
    if(oldChild) {
        removeParent(node, oldChild);
    }
    node[field] = newChild;
    if(newChild) {
        addParent(node, newChild);
    }
}

module.exports = {
    InputNode: InputNode,
    DataNode: DataNode,
    getComputeDataflowUrl: getComputeDataflowUrl
};

},{"../../utils/array.js":170,"../base.js":178,"../processing/channel-node.js":222,"../utils/utils.js":230,"./../processing/mapping.js":226,"./constants.js":179}],182:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./constants.js");
var DataNode = require("./graph.js").DataNode;

/**
 * Content of this file:
 * Classes to request results from an Xflow graph.
 */

/**
 * Abstract Request class.
 * Any Request is created from a DataNode to receive the result of that DataNode.
 * To allow effective optimization, it is recommended to create only one Request per DataNode and receive all
 * results through that Request.
 * @abstract
 * @param {DataNode} dataNode The DataNode from which to request results
 * @param {?Array.<string>} filter A list of names filtering the values to be received (only return values with names inside the filter)
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var Request = function(dataNode, filter, callback){
    this._dataNode = dataNode;
    this._filter = filter ? filter.slice().sort() : null;
    this._listener = callback;

    /**
     * Cached result of this request
     * @type {Result}
     */
    this._result = null;

    /**
     * Cached callback function attached to data node
     * @private
     */
    this._dataNodeListener = this._onDataNodeChange.bind(this);

    this._dataNode.addListener(this._dataNodeListener);
};

Object.defineProperty(Request.prototype, "dataNode", {
    set: function(){
       throw new Error("dataNode is readonly");
    },
    get: function(){ return this._dataNode; }
});

Object.defineProperty(Request.prototype, "filter", {
    set: function(){
        throw new Error("filter is read-only");
    },
    get: function(){ return this._filter; }
});

/**
 * Call this function, whenever the request is not required anymore.
 * Cleans up cached data and listeners
 */
Request.prototype.clear = function(){
    this._listener = null;
    if(this._result) this._result._removeRequest(this);
    this._dataNode.removeListener(this._dataNodeListener);
};

/**
 * @param {C.RESULT_STATE} data
 * @private
 */
Request.prototype._onPostponedResultChanged = function(data){
    this._listener && this._listener(this, data);
};

/**
 * Change the result of the request and update request list of old and new
 * result.
 * @private
 * @param {Request} request
 * @param {Result?} newResult
 * @returns {Result}
 */
function swapResultRequest(request, newResult){
    if(request._result) request._result._removeRequest(request);
    request._result = newResult;
    if(newResult) newResult._addRequest(request);
    return newResult;
}

/**
 * @param {Request} request
 * @param {C.RESULT_STATE} notification
 * @private
 */
function notifyListeners(request, notification){
    Base._queueResultCallback(request, notification);
}

/**
 * @param {C.RESULT_STATE} notification
 */
Request.prototype._onDataNodeChange = function(notification){
    notifyListeners(this, notification);
};

/**
 * A ComputeRequest is a Request for a ComputeResult, which contains a named map of typed values.
 * @constructor
 * @extends {Request}
 * @param {DataNode} dataNode The DataNode from which to request results
 * @param {?Array.<string>} filter A list of names filtering the values to be received (only return values with names inside the filter)
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var ComputeRequest = function(dataNode, filter, callback){
    Request.call(this, dataNode, filter, callback);
};
Base.createClass(ComputeRequest, Request);

/**
 * @returns {Result}
 */
ComputeRequest.prototype.getResult = function(){
    // swapResultRequest is called here because the result object of the request may change, e.g.
    // different forward node.
    return swapResultRequest(this, this._dataNode._getResult(C.RESULT_TYPE.COMPUTE, this._filter));
};

ComputeRequest.prototype._onResultChanged = function(notification){
    this._onDataNodeChange(notification);
};


var c_vsConnectNodeCount = {},
    c_vsConnectNodeKey = {},
    c_vsConnectNodeCache = {};

/**
 * A VertexShaderRequest is a Request for a VSDataResult, used to generate a VertexShader that includes
 * dataflow processing.
 * @constructor
 * @extends {Request}
 * @param {DataNode} dataNode
 * @param {VSConfig} vsConfig Configuration for the output of the generated vertex shader
 * @param {?function} callback A callback function that gets called whenever the result of the Request changes
 */
var VertexShaderRequest = function(dataNode, vsConfig, callback){
    var filter = vsConfig.getFilter();
    if(filter.length == 0)
        throw new Error("vsConfig requires at least one attribute entry.");
    Request.call(this, dataNode, filter, callback);
    this._vsConfig = vsConfig;
    this._vsConnectNode = getVsConnectNode(dataNode, vsConfig);
};
Base.createClass(VertexShaderRequest, Request);

VertexShaderRequest.prototype.getConfig = function(){
    return this._vsConfig;
};

/**
 * @see ComputeRequest.getResult
 * @returns {Result}
 */
VertexShaderRequest.prototype.getResult = function(){
    return swapResultRequest(this, this._vsConnectNode._getResult(C.RESULT_TYPE.VS, this._filter));
};

VertexShaderRequest.prototype._onDataNodeChange = function(notification){
    if(notification == C.RESULT_STATE.CHANGED_STRUCTURE){
        var newVSConnectedNode = getVsConnectNode(this._dataNode, this._vsConfig, this._filter);
        if(newVSConnectedNode != this._vsConnectNode){
            clearVsConnectNode(this._vsConnectNode);
            this._vsConnectNode = newVSConnectedNode;
        }
    }
    Request.prototype._onDataNodeChange.call(this, notification);
};

VertexShaderRequest.prototype.getVertexShader = function(){
    this.getResult(); // Update the result first
    if(!this._vertexShader){
        this._vertexShader = this._result.getVertexShader(this._vsConfig);
    }
    return this._vertexShader;
};

VertexShaderRequest.prototype._onResultChanged = function(notification){
    this._onDataNodeChange(notification);
};

function getVsConnectNode(dataNode, vsConfig, filter){
    var forwardNode = dataNode._getForwardNode(filter);

    var key = getDataNodeShaderKey(forwardNode, vsConfig);
    var connectNode;
    if(!(connectNode = c_vsConnectNodeCache[key])){
        connectNode = new DataNode(false);
        connectNode.appendChild(forwardNode);

        connectNode.computeOperator = vsConfig.getOperator();
        connectNode.computeInputMapping = null;
        connectNode.computeOutputMapping = null;

        c_vsConnectNodeCache[key] = connectNode;
        c_vsConnectNodeCount[connectNode.id] = 1;
        c_vsConnectNodeKey[connectNode.id] = key;
    }
    else{
        c_vsConnectNodeCount[connectNode.id]++;
    }

    return connectNode;
}

function clearVsConnectNode(connectNode){
    c_vsConnectNodeCount[connectNode.id]--;
    if(!c_vsConnectNodeCount[connectNode.id]){
        var key = c_vsConnectNodeKey[connectNode.id];
        c_vsConnectNodeCache[key] = null;
        connectNode.clearChildren();
    }
}


function getDataNodeShaderKey(dataNode, vsConfig){
    return dataNode.id + "|" + vsConfig.getKey();
}

module.exports = {
    ComputeRequest:  ComputeRequest,
    VertexShaderRequest: VertexShaderRequest
};

},{"../base.js":178,"./constants.js":179,"./graph.js":181}],183:[function(require,module,exports){
var C =require("../interface/constants.js");

/**
 * CLProgram implements automatic Xflow input/output adaptive WebCL kernel and application code generation.
 *
 * @param operatorList
 * @constructor
 */

var CLProgram = function (operatorList) {
    this.cl = XML3D.webcl.cl; // CL wrapper

    if (!this.cl) {
        return;
    }

    this.list = operatorList;
    this.entry = operatorList.entries[0];
    this.operator = this.entry.operator;

    this.kernelParamMap = {inputs: [], outputs: []}; // Stores initialised KernelParam objects
    this.kernelFunctionParams = []; // Stores generated function parameters for kernel function header.
    this.kernelCode = null; // Generated kernel code
    this.kernelProgram = null; // Compiled kernel program
    this.mainProgram = null; // Main WebCL application code

};

/**
 * Map of helper kernel parameters required for certain input data types.
 *
 * @type Object
 */
var helperParamMap = {
    'texture': {type: "uint", params: ["width", "height"]}, 'buffer': {type: "uint", params: ["length"]}
};

/**
 * Utility prototype object for mapping Xflow inputs to kernel parameters and for generating kernel code.
 *
 * @param {Object} program
 * @param {String} name
 * @param {C.DATA_TYPE} xflowType
 * @param {String} clType
 * @param entryValue
 * @param {Boolean?} isInput
 * @name KernelParam
 * @constructor KernelParam
 */

function KernelParam(program, name, xflowType, clType, entryValue, isInput) {
    this.program = program;
    this.cl = program.cl;
    this.name = name;
    this.type = clType || null;
    this.isInput = !!isInput;
    this.needsMemObject = false;
    this.hasMemObject = false;
    this.byteSize = null;
    this.memObjectSize = null;
    this.arg = null;
    this.clFunctionParam = null;
    this.xflowType = xflowType;
    this.helperMap = null;
    this.helpers = [];
    this.entryValue = entryValue || null;
    this.val = null;

    this.prepareParam();
    this.initHelperParams();
    this.initKernelArg();
    this.updateValue(this.entryValue);

}

KernelParam.prototype = {
    /**
     * Prepares the kernel parameter data.
     * Maps the input xflow data type to webcl data type and creates a kernel function header parameter with proper
     * declarations.
     */
    prepareParam: function () {
        var helperMap;
        var xflowDataTypes = C.DATA_TYPE;
        var kernelFuncParam = [];
        var addressSpace = '';
        var declarations = '';

        if (!this.type) {
            switch (this.xflowType) {
                case xflowDataTypes.TEXTURE:
                {
                    helperMap = helperParamMap.texture;
                    this.type = "uchar4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.INT:
                {
                    this.type = "int";
                }
                    break;
                case xflowDataTypes.INT4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "int4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT:
                {
                    this.type = "float";
                }
                    break;
                case xflowDataTypes.FLOAT2:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float2*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT3:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float4*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                case xflowDataTypes.FLOAT4X4:
                {
                    helperMap = helperParamMap.buffer;
                    this.type = "float16*";
                    addressSpace = "__global";
                    this.needsMemObject = true;
                }
                    break;
                default:
                    return;
            }

            this.helperMap = helperMap;
        }

        // Arranging parameter parts
        if (addressSpace) {
            kernelFuncParam.push(addressSpace);
        }

        if (this.isInput) {
            declarations = 'const';
        }

        if (declarations) {
            kernelFuncParam.push(declarations);
        }

        kernelFuncParam.push(this.type);
        kernelFuncParam.push(this.name);
        this.clFunctionParam = kernelFuncParam.join(' ');
    },

    /**
     * Initialises helper parameters for an input parameter if needed.
     *
     */

    initHelperParams: function () {
        var helperVal;
        var self = this;
        var helperMap = this.helperMap;

        if (helperMap && this.isInput) {
            helperMap.params.forEach(function (p) {
                var pName = self.name + '_' + p;
                if (p === "width") {
                    helperVal = self.entryValue.width;
                } else if (p === "height") {
                    helperVal = self.entryValue.height;
                } else if (p === "length") {
                    helperVal = self.entryValue.length;
                    var type = self.xflowType;
                    switch (type) {
                        case C.DATA_TYPE.FLOAT2:
                        {
                            helperVal = helperVal / 2;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT3:
                        {
                            helperVal = helperVal / 3;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT4:
                        case C.DATA_TYPE.INT4:
                        {
                            helperVal = helperVal / 4;
                        }
                            break;
                        case C.DATA_TYPE.FLOAT4X4:
                        {
                            helperVal = helperVal / 16;
                        }
                            break;
                        default:
                            break;
                    }
                }
                self.helpers.push(new KernelParam(self.program, pName, null, helperMap.type, new Uint32Array([helperVal])));
            });
        }
    },

    /**
     * Initialises kernel argument that will be passed directly into the compiled kernel.
     * Creates a WebCL memory object if needed (e.g. for texture).
     */

    initKernelArg: function () {
        if (this.needsMemObject) {
            this.allocateMemObject();
        } else {
            this.arg = this.entryValue;
        }
    },

    allocateMemObject: function () {
        var clAPI = this.cl.API;
        var clCtx = this.cl.ctx;
        var paramType = this.type;
        var byteSize = parseInt(paramType.substring(paramType.length - 2, paramType.length - 1), 10);
        var memObjectMode = this.isInput ? 'r' : 'w';
        var entryValue = this.entryValue;
        var memObjectSize, memObject;

        if (this.hasMemObject) {
            this.arg.release();
        }

        this.byteSize = isNaN(byteSize) ? 1 : byteSize;

        if (this.xflowType === C.DATA_TYPE.TEXTURE) { // Texture is a special case
            memObjectSize = entryValue.width * entryValue.height * byteSize;
            this.byteSize = 4;
        } else {
            switch (this.xflowType) {
                case C.DATA_TYPE.INT4:
                {
                    memObjectSize = entryValue.length * Int32Array.BYTES_PER_ELEMENT;
                }
                    break;
                case C.DATA_TYPE.FLOAT2:
                case C.DATA_TYPE.FLOAT3:
                case C.DATA_TYPE.FLOAT4:
                case C.DATA_TYPE.FLOAT4x4:
                {
                    memObjectSize = entryValue.length * Float32Array.BYTES_PER_ELEMENT;
                }
                    break;
                default:
                    memObjectSize = entryValue.length * 4;
                    break;
            }
        }

        memObject = clAPI.createBuffer(memObjectSize, memObjectMode, clCtx);

        this.memObjectSize = memObjectSize;
        this.arg = memObject;

        this.hasMemObject = true;
        this.needsMemObject = false;

    },

    updateValue: function (entry) {
        if (this.hasMemObject) {
            this.val = entry.data === undefined ? entry : entry.data;
            this.entryValue = entry;
            this.checkEntrySize();
        } else {
            this.arg = this.entryValue = entry;
        }
    }, updateHelpers: function () {
        var helpers = this.helpers;
        var self = this;

        helpers.forEach(function (p) {
            var name = p.name;
            if (name.indexOf("width") !== -1) {
                p.updateValue(new Uint32Array([self.entryValue.width]));
            } else if (name.indexOf("height") !== -1) {
                p.updateValue(new Uint32Array([self.entryValue.height]));
            } else if (name.indexOf("length") !== -1) {
                var len = self.entryValue.length;
                if (self.xflowType === C.DATA_TYPE.FLOAT4 || self.xflowType === C.DATA_TYPE.INT4) {
                    len = len / 4;
                } else if (self.xflowType === C.DATA_TYPE.FLOAT4X4) {
                    len = len / 16;
                }
                p.updateValue(new Uint32Array([len]));
            }
        });
    }, checkEntrySize: function () {
        var newSize;
        var entryVal = this.entryValue;

        if (this.xflowType === C.DATA_TYPE.TEXTURE) {
            newSize = entryVal.width * entryVal.height * this.byteSize;
        } else if (this.xflowType === C.DATA_TYPE.FLOAT2 || this.xflowType === C.DATA_TYPE.FLOAT3 || this.xflowType === C.DATA_TYPE.FLOAT4 || this.xflowType === C.DATA_TYPE.FLOAT4X4) {
            newSize = entryVal.length * Float32Array.BYTES_PER_ELEMENT;
        } else if (this.xflowType === C.DATA_TYPE.INT4) {
            newSize = entryVal.length * Int32Array.BYTES_PER_ELEMENT;
        } else {
            newSize = entryVal.length * this.byteSize;
        }
        if (this.memObjectSize !== newSize) {
            this.allocateMemObject();
            this.updateHelpers();
            this.program.mainProgram = null; // Forcing CL application program update
        }
    }
};


/**
 * Runs CLProgram. WebCL related code initialised in the first run.
 *
 * @param programData
 */

CLProgram.prototype.run = function (programData) {
    var operatorData = prepareOperatorData(this.list, 0, programData);

    applyDefaultOperation(this.entry, programData, operatorData, this);

};

function prepareOperatorData(list, idx, programData) {
    var doIterate, i;
    var data = programData.operatorData[0];
    var entry = list.entries[idx];
    var mapping = entry.operator.mapping;

    data.iterFlag = {};

    for (i = 0; i < mapping.length; ++i) {
        doIterate = (entry.isTransferInput(i) || list.isInputIterate(entry.getDirectInputIndex(i)));
        data.iterFlag[i] = doIterate;
    }

    data.iterateCount = list.getIterateCount(programData);

    return data;
}

function applyDefaultOperation(entry, programData, operatorData, program) {
    if (program.operator.evaluate && program.operator.evaluate instanceof Array) {
        assembleFunctionArgs(entry, programData, program);

        if (program.kernelCode === null) {
            prepareWebCLKernel(programData, program);
        }
        //console.time('CLProgram (' + program.operator.name + ')');
        if (program.mainProgram === null) {
            program.mainProgram = createMainWebCLProgram(program);
        }
        program.mainProgram();
        //console.timeEnd('CLProgram (' + program.operator.name + ')');
    }
}

/**
 * Maps Xflow inputs and outputs into WebCL kernel inputs and outputs.
 *
 * @function assembleFunctionArgs
 * @param entry
 * @param programData
 * @param program
 */

function assembleFunctionArgs(entry, programData, program) {
    var d, dataEntry, i;
    var kernelFunctionParams = program.kernelFunctionParams;
    var outputs = program.operator.outputs;

    kernelFunctionParams.length = 0;

    for (i = 0; i < outputs.length; ++i) {
        d = outputs[i];
        dataEntry = programData.outputs[entry.getOutputIndex(i)].dataEntry;

        prepareKernelParameter(d, !!(d.source), program, kernelFunctionParams, dataEntry, i);
    }

    addInputToArgs(entry, programData, program, kernelFunctionParams);
}


function addInputToArgs(entry, programData, program, kernelFunctionParams) {
    var mapEntry, dataEntry, i;
    var mapping = entry.operator.mapping;

    for (i = 0; i < mapping.length; ++i) {
        mapEntry = mapping[i];
        dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));

        prepareKernelParameter(mapEntry, !!(mapEntry.source), program, kernelFunctionParams, dataEntry, i);
    }
}

/**
 * Creates a new KernelParam utility object or updates the existing object if input value has been changed.
 * Additionally, this is used for generating the WebCL kernel function header.
 *
 * @function prepareKernelParameter
 * @param param
 * @param input
 * @param program
 * @param functionParams
 * @param arg
 * @param i
 */

function prepareKernelParameter(param, input, program, functionParams, arg, i) {
    var kernelParams;
    var entryVal = arg ? arg.getValue() : null;

    if (input) {
        kernelParams = program.kernelParamMap.inputs;
    } else {
        kernelParams = program.kernelParamMap.outputs;
    }

    if (kernelParams[i]) {
        kernelParams[i].updateValue(entryVal);
        return;
    }

    kernelParams[i] = new KernelParam(program, param.name, param.type, null, entryVal, input);

    // Pushing generated kernel function params into array.
    // This array is later used in generating the WebCL kernel function header.
    functionParams.push(kernelParams[i].clFunctionParam);

    kernelParams[i].helpers.forEach(function (p) {
        functionParams.push(p.clFunctionParam);
    });
}


/** KERNEL CODE PREPARATION **/


/**
 * Compiles and registers the prepared WebCL kernel code.
 *
 * @function prepareWebCLKernel
 * @param programData
 * @param program
 * @returns {boolean}
 */

function prepareWebCLKernel(programData, program) {
    var kernelCode;
    var kernelManager = program.cl.kernelManager;
    var inputKernel = program.operator.evaluate;
    var kernelName = program.kernelName = program.operator.name.split('xflow.')[1];

    if (!inputKernel) {
        return false;
    }

    kernelCode = program.kernelCode = prepareKernelCode(kernelName, inputKernel, program);

    try {
        kernelManager.register(kernelName, kernelCode);
    } catch (e) {
        return false;
    }

    program.kernelProgram = kernelManager.getKernel(program.kernelName);

    return true;
}

/**
 *
 * Generates kernel function header and helper kernel code and combines it with user's input kernel code.
 *
 * @function prepareKernelCode
 * @param {String} kernelName
 * @param {Array} inputKernel
 * @param program
 * @returns {String}
 */

function prepareKernelCode(kernelName, inputKernel, program) {
    var result, innerKernelCode;

    result = createKernelHeader(kernelName, program);

    if (!result) {
        return false;
    }

    result += '{\n';

    innerKernelCode = createInnerKernelCode(program);

    if (!innerKernelCode) {
        return false;
    }

    result += innerKernelCode;
    result += inputKernel.join('\n');
    result += '\n}';

    return result;
}

/**
 * Generates a kernel function header from assembled kernel parameters.
 *
 * @function createKernelHeader
 * @param kernelName
 * @param program
 * @returns {string}
 */

function createKernelHeader(kernelName, program) {
    var functionHeader = [];

    functionHeader.push("__kernel void");
    functionHeader.push(kernelName + '(');
    functionHeader.push(program.kernelFunctionParams.join(', '));
    functionHeader.push(')');

    return functionHeader.join(' ');
}

/**
 * Generates helper kernel code.
 *
 * @function createInnerKernelCode
 * @param program
 * @returns {string}
 */

function createInnerKernelCode(program) {
    var codeLines = [];

    var firstInput = program.kernelParamMap.inputs[0];

    if (firstInput.type === "uchar4*") {
        // Add "iterators"
        codeLines.push("int x = get_global_id(0);");
        codeLines.push("int y = get_global_id(1);");

        // Add bounds checkers
        codeLines.push("if (x >= " + firstInput.name + "_width || y >= " + firstInput.name + "_height) return;");

        // Add input iterator
        codeLines.push("int " + firstInput.name + "_i = y * " + firstInput.name + "_width + x;");

    } else { // Else, assuming that the first input is an 1-dimensional buffer

        codeLines.push("int " + firstInput.name + "_i = get_global_id(0);");

        codeLines.push("if (" + firstInput.name + "_i >= " + firstInput.name + "_length) return;");
    }

    return codeLines.join('\n');

}


/** MAIN WEBCL PROGRAM INITIALISATION **/

/**
 * Initialises the main WebCL application code that executes the WebCL kernel
 *
 * @function createMainWebCLProgram
 * @param program
 * @returns {Function}
 */

function createMainWebCLProgram(program) {
    var cl = program.cl;
    var kernelManager = cl.kernelManager;
    var cmdQueue = cl.cmdQueue;
    var memObjects = {inputs: [], outputs: []};
    var assembledArgs = assembleKernelArguments(program.kernelParamMap, memObjects);
    var WSSizes = computeWorkGroupSize(program.kernelParamMap.inputs[0]);
    var kernel = program.kernelProgram;

    return function () {
        var i, len, memObj, args;
        var inputMemObjs = memObjects.inputs;
        var outputMemObjs = memObjects.outputs;

        if (!kernel) {
            return false;
        }

        args = assembledArgs.map(function (a) {
            return a.arg;
        });

        kernelManager.setArgs.apply(null, [kernel].concat(args));

        try {
            // Write the buffer to OpenCL device memory
            len = inputMemObjs.length;
            for (i = 0; i < len; i++) {
                memObj = inputMemObjs[i];
                cmdQueue.enqueueWriteBuffer(memObj.arg, false, 0, /*memObj.arg.getInfo(WebCL.MEM_SIZE)*/memObj.memObjectSize, memObj.val, []);
            }

            // Execute (enqueue) kernel
            cmdQueue.enqueueNDRangeKernel(kernel, WSSizes[1].length, [], WSSizes[1], WSSizes[0]);

            // Read the result buffer from OpenCL device
            len = outputMemObjs.length;
            for (i = 0; i < len; i++) {
                memObj = outputMemObjs[i];
                cmdQueue.enqueueReadBuffer(memObj.arg, false, 0, /*memObj.arg.getInfo(WebCL.MEM_SIZE)*/memObj.memObjectSize, memObj.val, []);
            }

            cmdQueue.finish(); //Finish all the operations

        } catch (e) {
            return false;
        }

        return true;
    };
}


/**
 * Arranges initialised kernel arguments into helper arrays so they are more easily available in
 * the main WebCL application.
 *
 * @function assembleKernelArguments
 * @param paramMap
 * @param memObjects
 * @returns {Array}
 */

function assembleKernelArguments(paramMap, memObjects) {
    var outputs = paramMap.outputs;
    var inputs = paramMap.inputs;
    var kernelArgs = [];

    outputs.forEach(function (p) {
        mapKernelArgument(p, kernelArgs, memObjects.outputs);
    });

    inputs.forEach(function (p) {
        mapKernelArgument(p, kernelArgs, memObjects.inputs);
    });

    return kernelArgs;
}

function mapKernelArgument(param, kernelArgs, memObjects) {
    kernelArgs.push(param);

    if (param.hasMemObject) {
        memObjects.push(param);
        param.helpers.forEach(function (p) {
            kernelArgs.push(p);
        });
    }
}

/**
 * Computes a proper WebCL kernel workgroup size for target input buffer
 *
 * @function computeWorkGroupSize
 * @param targetInput
 * @returns {Array}
 */

function computeWorkGroupSize(targetInput) {
    var localWS, globalWS;
    var entryVal = targetInput.entryValue;

    if (targetInput.xflowType === C.DATA_TYPE.TEXTURE) {
        localWS = [16, 4];
        globalWS = [Math.ceil(entryVal.width / localWS[0]) * localWS[0], Math.ceil(entryVal.height / localWS[1]) * localWS[1]];
    } else {
        var k = 1;
        switch (targetInput.xflowType) {
            case C.DATA_TYPE.INT4:
            case C.DATA_TYPE.FLOAT4:
            {
                k = 4;
            }
                break;
            case C.DATA_TYPE.FLOAT3:
            {
                k = 3;
            }
                break;
            case C.DATA_TYPE.FLOAT4X4:
            {
                k = 16;
            }
                break;
        }
        localWS = [16];
        globalWS = [Math.ceil(entryVal.length / (localWS[0] * k)) * localWS[0]];
    }

    return [localWS, globalWS];
}

module.exports = CLProgram;

},{"../interface/constants.js":179}],184:[function(require,module,exports){
Xflow.registerOperator("xflow.add", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value1'},
                {type: 'float3', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        throw new Error("Not used!");
    },
    evaluate_core: function(result, value1, value2){
        result[0] = value1[0] + value2[0];
        result[1] = value1[1] + value2[1];
        result[2] = value1[2] + value2[2];
    }
});

},{}],185:[function(require,module,exports){
Xflow.registerOperator("xflow.bufferSelect", {
    outputs: [  {type: 'float3', name: 'result', noAlloc: true}],
    params:  [  {type: 'float3', source: 'trueOption', array: true},
                {type: 'float3', source: 'falseOption', array: true},
                {type: 'bool', source: 'value', array: true}],
    evaluate: function(result, falseOption, trueOption, value) {
        result.assign = value[0] ? trueOption : falseOption;

        return true;
    }
});

},{}],186:[function(require,module,exports){
Xflow.registerOperator("xflow.clampImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image', formatType: 'ImageData'} ],
    params:  [ {type: 'texture', source : 'image'},
               {type: 'float', source : 'min'},
               {type: 'float', source : 'max'}
             ],
    evaluate: function(result, image, min, max) {
        var inpix = image.data;
        var outpix = result.data;
        var minv = min[0];
        var maxv = max[0];
        var len = image.data.length;
        for (var i = 0 ; i < len; i++) {
            var val = inpix[i];
            if (val < minv) val = minv;
            if (val > maxv) val = maxv;
            outpix[i] = val;
        }
        return true;
    }
});

},{}],187:[function(require,module,exports){
// Code portions from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/

(function() {

    function convolute(inpixels, outpixels, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side/2);
        var src = inpixels.data;
        var sw = inpixels.width;
        var sh = inpixels.height;
        // pad output by the convolution matrix
        var w = sw;
        var h = sh;
        var dst = outpixels.data;
        // go through the destination image pixels
        var alphaFac = opaque ? 1 : 0;
        for (var y=0; y<h; y++) {
            for (var x=0; x<w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y*w+x)*4;
                // calculate the weighed sum of the source image pixels that
                // fall under the convolution matrix
                var r=0, g=0, b=0, a=0;
                for (var cy=0; cy<side; cy++) {
                    for (var cx=0; cx<side; cx++) {
                        var scy = sy + cy - halfSide;
                        var scx = sx + cx - halfSide;
                        if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                            var srcOff = (scy*sw+scx)*4;
                            var wt = weights[cy*side+cx];
                            r += src[srcOff] * wt;
                            g += src[srcOff+1] * wt;
                            b += src[srcOff+2] * wt;
                            a += src[srcOff+3] * wt;
                        }
                    }
                }
                dst[dstOff] = r;
                dst[dstOff+1] = g;
                dst[dstOff+2] = b;
                dst[dstOff+3] = a + alphaFac*(255-a);
            }
        }
        return outpixels;
    };

    Xflow.registerOperator("xflow.convoluteImage", {
        outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
        params:  [
            {type: 'texture', source : 'image'},
            {type: 'float', source : 'kernel'}
        ],
        evaluate: function(result, image, kernel) {
            convolute(image, result, kernel, true);
            return true;
        }
    });

    Xflow.registerOperator("xflow.convoluteImageToFloat", {
        outputs: [ {type: 'texture', name : 'result', sizeof: 'image', formatType : 'float32'} ],
        params:  [
            {type: 'texture', source : 'image'},
            {type: 'float', source : 'kernel'}
        ],
        evaluate: function(result, image, kernel) {
            convolute(image, result, kernel, true);
            return true;
        }
    });

})();

},{}],188:[function(require,module,exports){
Xflow.registerOperator("xflow.createIGIndex", {
    outputs:[
        //{type:'int', name:'index', customAlloc:true },
        {type:'float2', name:'texcoord', customAlloc:true }
    ],
    params:[
        {type:'int', source:'vertexCount', optional:false},
        {type:'texture', source:'positionTex', optional: false}
    ],
    alloc:function (sizes, vertexCount, image) {
        sizes['texcoord'] = image.width * image.height;
        //sizes['index'] = vertexCount[0];
    },
    evaluate:function (texcoord, vertexCount, image, info) {
        // tex coords
        var halfPixel = {
            x: 0.5 / image.width,
            y: 0.5 / image.height
        };
        var i = 0;
        for (var y = 0, ylength = image.height; y < ylength; y++)
        {
            for (var x = 0, xlength = image.width; x < xlength; x++)
            {
                texcoord[i++] = (x / xlength) + halfPixel.x;
                texcoord[i++] = 1 - ((y / ylength) + halfPixel.y);
            }
        }

        // index creation
        /*for(var i = 0; i < vertexCount[0]; i++) {
            index[i] = i;
        }*/
        return true;
    }
});

},{}],189:[function(require,module,exports){
(function() {
    var TMP_MATRIX = XML3D.math.mat4.create();
    var TMP_VEC = XML3D.math.vec3.create();
    var TMP_QUAT = XML3D.math.quat.create();
    var mat4 = XML3D.math.mat4;

    Xflow.registerOperator("xflow.createTransform", {
        outputs: [{type: 'float4x4', name: 'result'}],
        params: [{type: 'float3', source: 'translation', optional: true},
            {type: 'float4', source: 'rotation', optional: true},
            {type: 'float3', source: 'scale', optional: true},
            {type: 'float3', source: 'center', optional: true},
            {type: 'float4', source: 'scaleOrientation', optional: true}],
        evaluate: function (result, translation, rotation, scale, center, scaleOrientation, info) {
            for (var i = 0; i < info.iterateCount; i++) {
                var dest = result.subarray(i * 16);
                mat4.identity(dest);
                translation && mat4.translate(dest, dest, info.iterFlag[0] ? translation.subarray(i*3) : translation);
                center && mat4.translate(dest, dest, info.iterFlag[0] ? center.subarray(i*3) : center);
                if (rotation) {
                    mat4.fromRotationTranslation(TMP_MATRIX, info.iterFlag[1] ? rotation.subarray(i*4) : rotation, [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                if (scaleOrientation) {
                    mat4.fromRotationTranslation(TMP_MATRIX, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation, [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                scale && mat4.scale(dest, dest, info.iterFlag[2] ? scale.subarray(i*3) : scale);
                if (scaleOrientation) {
                    XML3D.math.quat.copy(TMP_QUAT, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation)
                    mat4.fromRotationTranslation(TMP_MATRIX, XML3D.math.quat.negate(TMP_QUAT, TMP_QUAT), [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }

                center && mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, info.iterFlag[3] ? center.subarray(i*3) : center));

            }
            return true;
        }
    });

})();
},{}],190:[function(require,module,exports){
(function() {
    var TMP_MATRIX = XML3D.math.mat4.create();
    var TMP_VEC = XML3D.math.vec3.create();
    var TMP_QUAT = XML3D.math.quat.create();
    var mat4 = XML3D.math.mat4;

    Xflow.registerOperator("xflow.createTransformInv", {
        outputs: [{type: 'float4x4', name: 'result'}],
        params: [{type: 'float3', source: 'translation', optional: true},
            {type: 'float4', source: 'rotation', optional: true},
            {type: 'float3', source: 'scale', optional: true},
            {type: 'float3', source: 'center', optional: true},
            {type: 'float4', source: 'scaleOrientation', optional: true}],
        evaluate: function (result, translation, rotation, scale, center, scaleOrientation, info) {
            for (var i = 0; i < info.iterateCount; i++) {
                var dest = result.subarray(i * 16);
                mat4.identity(dest);
                center && mat4.translate(dest, dest, info.iterFlag[3] ? center.subarray(i*3) : center);

                if (scaleOrientation) {
                    mat4.fromRotationTranslation(TMP_MATRIX, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation, [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                scale && mat4.scale(dest, dest, XML3D.math.vec3.reciprocal(TMP_VEC, info.iterFlag[2] ? scale.subarray(i*3) : scale));
                if (scaleOrientation) {
                    XML3D.math.quat.copy(TMP_QUAT, info.iterFlag[4] ? scaleOrientation.subarray(i*4) : scaleOrientation);
                    mat4.fromRotationTranslation(TMP_MATRIX, XML3D.math.quat.invert(TMP_QUAT, TMP_QUAT), [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                if (rotation) {
                    XML3D.math.quat.copy(TMP_QUAT, info.iterFlag[1] ? rotation.subarray(i*4) : rotation);
                    mat4.fromRotationTranslation(TMP_MATRIX, XML3D.math.quat.invert(TMP_QUAT, TMP_QUAT), [0, 0, 0]);
                    mat4.multiply(dest, dest, TMP_MATRIX);
                }
                center && mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, info.iterFlag[3] ? center.subarray(i*3) : center));
                translation && mat4.translate(dest, dest, XML3D.math.vec3.negate(TMP_VEC, info.iterFlag[0] ? translation.subarray(i*3) : translation));

            }
        }
    });
})();

},{}],191:[function(require,module,exports){
(function(){

var c_CubePositions =  [
    [-1,-1,-1], [1,-1,-1], [-1,1,-1], [1,1,-1], // front
    [-1,-1,-1], [-1,-1,1], [-1,1,-1], [-1,1,1], // left
    [-1,-1,-1], [1,-1,-1], [-1,-1,1], [1,-1,1], // top
    [1,-1,-1], [1,1,-1], [1,-1,1], [1,1,1],     // right
    [-1,1,-1], [1,1,-1], [-1,1,1], [1,1,1],     // bottom
    [-1,-1,1], [1,-1,1], [-1,1,1], [1,1,1]      // back
];
var c_CubeNormals =  [
    [0,0,-1], [0,0,-1], [0,0,-1], [0,0,-1], // front
    [-1,0,0], [-1,0,0], [-1,0,0], [-1,0,0], // left
    [0,-1,0], [0,-1,0], [0,-1,0], [0,-1,0], // top
    [1,0,0], [1,0,0], [1,0,0], [1,0,0],     // right
    [0,1,0], [0,1,0], [0,1,0], [0,1,0],     // bottom
    [0,0,1], [0,0,1], [0,0,1], [0,0,1]      // back
];
var c_CubeIndex = [
    [0,1,2,1,2,3],
    [4,5,6,5,6,7],
    [8,9,10,9,10,11],
    [12,13,14,13,14,15],
    [16,17,18,17,18,19],
    [20,21,22,21,22,23]
]

/**
 * Grid Generation
 */
Xflow.registerOperator("xflow.debug.createSkinCubes", {
    outputs: [	{type: 'int', name: 'index', customAlloc: true},
                {type: 'float3', name: 'position', customAlloc: true},
                {type: 'float3', name: 'normal', customAlloc: true},
                {type: 'int4', name: 'boneIndices', customAlloc: true},
                {type: 'float4', name: 'boneWeights', customAlloc: true}],
    params:  [{type: 'float4x4', source: 'bindTransforms', array: true},
              {type: 'float', source: 'size', array: true, optional: true}],
    alloc: function(sizes, bindTransforms)
    {
        var s = bindTransforms.length / 16;
        sizes['position'] = s * 4 * 6;
        sizes['normal'] = s * 4 * 6;
        sizes['boneIndices'] = s * 4 * 6;
        sizes['boneWeights'] = s * 4 * 6;
        sizes['index'] = s * 6 * 6;
    },
    evaluate: function(index, position, normal, boneIdx, boneWeight, bindTransforms, size) {
        var cubeCount = bindTransforms.length / 16;
        var size = (size && size[0] || 1) / 2;

        var tmpPosition = XML3D.math.vec3.create(),
            tmpNormal = XML3D.math.vec3.create();

        for(var i = 0; i < cubeCount; ++i){
            for(var j = 0; j < 6; ++j){
                for(var k = 0; k < 4; k++){
                    var localIdx = j*4+ k, globalIdx = i*6*4 + localIdx;

                    XML3D.math.vec3.copy(tmpPosition, c_CubePositions[localIdx]);
                    XML3D.math.vec3.scale(tmpPosition, tmpPosition, size);
                    XML3D.math.mat4.multiplyOffsetVec3(bindTransforms, i*16, tmpPosition, 0);
                    XML3D.math.vec3.copy(tmpNormal, c_CubeNormals[localIdx]);
                    XML3D.math.mat4.multiplyOffsetDirection(bindTransforms, i*16, tmpNormal, 0);

                    position[globalIdx*3+0] = tmpPosition[0];
                    position[globalIdx*3+1] = tmpPosition[1];
                    position[globalIdx*3+2] = tmpPosition[2];
                    normal[globalIdx*3+0] = tmpNormal[0];
                    normal[globalIdx*3+1] = tmpNormal[1];
                    normal[globalIdx*3+2] = tmpNormal[2];
                    boneIdx[globalIdx*4+0] = i;
                    boneIdx[globalIdx*4+1] = boneIdx[globalIdx*4+2] = boneIdx[globalIdx*4+3]= 0;
                    boneWeight[globalIdx*4+0] = 1;
                    boneWeight[globalIdx*4+1] = boneWeight[globalIdx*4+2] = boneWeight[globalIdx*4+3]= 0;
                }
                var globalIndexIdx = i*6*6 + j*6;
                for(var k = 0; k < 6; ++k){
                    index[globalIndexIdx+k] = i*6*4 + c_CubeIndex[j][k];
                }
            }
        }
        // We are done!
        position = position;
    }
});

}());

},{}],192:[function(require,module,exports){
Xflow.registerOperator("xflow.flipNormal", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value'}],
    evaluate: function(result, value, info) {
        for(var i = 0; i<info.iterateCount*3; i++)
            result[i] = -value[i];
    }
});

},{}],193:[function(require,module,exports){
Xflow.registerOperator("xflow.flipVerticalImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        var destpix = result.data;
        var srcpix = image.data;

        for (var y = 0; y < height; ++y) {
            for (var x = 0; x < width; ++x) {
                var rowOffset = y * width;
                var srcOffset = (rowOffset + x) * 4;
                var dstOffset = (rowOffset + ((width-1) - x)) * 4;
                destpix[dstOffset] =  srcpix[srcOffset];
                destpix[dstOffset+1] = srcpix[srcOffset+1];
                destpix[dstOffset+2] = srcpix[srcOffset+2];
                destpix[dstOffset+3] = srcpix[srcOffset+3];
            }
        }
        return true;
    }
});

},{}],194:[function(require,module,exports){
Xflow.registerOperator("xflow.forwardKinematics", {
    outputs: [  {type: 'float4x4',  name: 'result', customAlloc: true}],
    params:  [  {type: 'int',       source: 'parent', array: true },
                {type: 'float4x4',  source: 'xform', array: true }],
    alloc: function(sizes, parent, xform)
    {
        var length = Math.min(parent.length, xform.length / 16);
        sizes['result'] = length;
    },
    evaluate: function(result, parent,xform, info) {

        var boneCount = result.length / 16;

        var computed = [];
        //For each bone do:
        for(var i = 0; i < boneCount;){
            if(!computed[i]) {
                var p = parent[i];
                if(p >= 0){
                    //This bone has a parent bone
                    if(!computed[p]){
                        //The parent bone's transformation matrix hasn't been computed yet
                        while(parent[p] >= 0 && !computed[parent[p]]) p = parent[p];

                        if(parent[p] >= 0)
                            XML3D.math.mat4.multiplyOffset(result, p*16, xform, p*16, result, parent[p]*16);
                        else
                            for(var j = 0; j < 16; j++) {
                                result[p*16+j] = xform[p*16+j];
                            }
                        computed[p] = true;
                        continue;
                    }
                    else {
                        XML3D.math.mat4.multiplyOffset(result, i*16, xform, i*16, result,  p*16);
                    }
                }
                else{
                    for(var j = 0; j < 16; j++) {
                        result[i*16+j] = xform[i*16+j];
                    }
                }
                computed[i] = true;
            }
            i++;
        }
    }
});

},{}],195:[function(require,module,exports){
Xflow.registerOperator("xflow.forwardKinematicsInv", {
    outputs: [  {type: 'float4x4',  name: 'result', customAlloc: true}],
    params:  [  {type: 'int',       source: 'parent', array: true },
                {type: 'float4x4',  source: 'xform', array: true }],
    alloc: function(sizes, parent, xform)
    {
        var length = Math.min(parent.length, xform.length / 16);
        sizes['result'] = length;
    },
    evaluate: function(result, parent,xform, info) {
        var boneCount = xform.length / 16;

        var computed = [];
        //For each bone do:
        for(var i = 0; i < boneCount;){
            if(!computed[i]) {
                var p = parent[i];
                if(p >= 0){
                    //This bone has a parent bone
                    if(!computed[p]){
                        //The parent bone's transformation matrix hasn't been computed yet
                        while(parent[p] >= 0 && !computed[parent[p]]) p = parent[p];
                        //The current bone has a parent and its transform hasn't been computed yet

                        if(parent[p] >= 0)
                            XML3D.math.mat4.multiplyOffset(result, p*16, result, parent[p]*16, xform, p*16);
                        else
                            for(var j = 0; j < 16; j++) {
                                result[p*16+j] = xform[p*16+j];
                            }
                        computed[p] = true;
                        continue;

                    }
                    else {
                        XML3D.math.mat4.multiplyOffset(result, i*16,  result,  p*16, xform, i*16);
                    }
                }
                else{
                    for(var j = 0; j < 16; j++) {
                        result[i*16+j] = xform[i*16+j];
                    }
                }
                computed[i] = true;
            }
            i++;
        }
    }
});

},{}],196:[function(require,module,exports){
// Based on: http://web.archive.org/web/20100310063925/http://dem.ocracy.org/libero/photobooth/

Xflow.registerOperator("xflow.funMirrorImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'},
               {type: 'float', source : 'time'} ],
    evaluate: function(result, image, time) {
        var width = result.width;
        var height = result.height;
        var time = time[0];

        var s = image.data;
        var d = result.data;

        for (var y = 0; y < height; ++y) {
            for (var x = 0; x < width; ++x) {

                /*original coordinates*/
                // [0.0 ,1.0] x [0.0, 1.0]
                var coordX = x / width;
                var coordY = y / height;

                // [-1.0 ,1.0] x [-1.0, 1.0]
                var normCoordX = 2.0 * coordX - 1.0;
                var normCoordY = 2.0 * coordY - 1.0;

                /*go to polar coordinates*/
                var r = Math.sqrt(normCoordX*normCoordX + normCoordY*normCoordY); // length(normCoord)
                var phi = Math.atan2(normCoordY, normCoordX);

                /*squeeze and vary it over time*/
                r = Math.pow(r, 1.0/1.8) * time;

                /*back to cartesian coordinates*/
                normCoordX = r * Math.cos(phi);
                normCoordY = r * Math.sin(phi);
                // [0.0 ,1.0] x [0.0, 1.0]
                coordX = normCoordX / 2.0 + 0.5;
                coordY = normCoordY / 2.0 + 0.5;

                var sX = Math.round(coordX * width);
                var sY = Math.round(coordY * height);

                var i = (sY * width + sX)*4;
                var r = s[i];
                var g = s[i + 1];
                var b = s[i + 2];
                var a = s[i + 3];

                /*color the fragment with calculated texture*/
                var i = (y * width + x)*4;
                d[i] = r;
                d[i + 1] = g;
                d[i + 2] = b;
                d[i + 3] = a;
            }
        }
        return true;
    }
});

},{}],197:[function(require,module,exports){

function fetch(result, value, index, components){
    for(var i = 0; i < index.length; ++i) {
        var offset = index[i] * components;
        var j = components;
        while(j--) {
            result[i*components + j] = value[offset + j];
        }
    }
}

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float', name: 'result'}],
    params:  [  {type: 'float', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float2', name: 'result'}],
    params:  [  {type: 'float2', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 2);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 4);
    }
});


Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float4', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 4);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float4x4', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 16);
    }
});


Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'int', name: 'result'}],
    params:  [  {type: 'int', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'bool', name: 'result'}],
    params:  [  {type: 'bool', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'byte', name: 'result'}],
    params:  [  {type: 'byte', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});



Xflow.registerOperator("xflow.get", {
    outputs: [  {type: 'ubyte', name: 'result'}],
    params:  [  {type: 'ubyte', source: 'value', array: true},
                {type: 'int', source: 'index'}],
    evaluate: function(result, value, index, info) {
        fetch(result, value, index, 1);
    }
});

},{}],198:[function(require,module,exports){
Xflow.registerOperator("xflow.grayscaleImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        var s = image.data;
        var d = result.data;
        for (var i = 0; i < s.length; i += 4) {
            var r = s[i];
            var g = s[i + 1];
            var b = s[i + 2];
            var a = s[i + 3];
            // CIE luminance for the RGB
            // The human eye is bad at seeing red and blue, so we de-emphasize them.
            var v = 0.2126 * r + 0.7152 * g + 0.0722 * b;
            d[i] = d[i + 1] = d[i + 2] = v
            d[i + 3] = a;
        }
        return true;
    }
});

},{}],199:[function(require,module,exports){
require("./add.js");
require("./bufferSelect.js");
require("./clampImage.js");
require("./convoluteImage.js");
require("./createIGIndex.js");
require("./createTransform.js");
require("./createTransformInv.js");
require("./debug.js");
require("./flipNormal.js");
require("./flipVerticalImage.js");
require("./forwardKinematics.js");
require("./forwardKinematicsInv.js");
require("./funMirrorImage.js");
require("./get.js");
require("./grayscaleImage.js");
require("./lerp3seq.js");
require("./magnitudeImage.js");
require("./merge3.js");
require("./morph3.js");
require("./mul4x4.js");
require("./noiseImage.js");
require("./normalize3.js");
require("./popartImage.js");
require("./rgbePNGtoFloat.js");
require("./selectBool.js");
require("./selectTransform.js");
require("./sepiaImage.js");
require("./skinDirection.js");
require("./skinPosition.js");
require("./slerpseq.js");
require("./sobelImage.js");
require("./sub3.js");

},{"./add.js":184,"./bufferSelect.js":185,"./clampImage.js":186,"./convoluteImage.js":187,"./createIGIndex.js":188,"./createTransform.js":189,"./createTransformInv.js":190,"./debug.js":191,"./flipNormal.js":192,"./flipVerticalImage.js":193,"./forwardKinematics.js":194,"./forwardKinematicsInv.js":195,"./funMirrorImage.js":196,"./get.js":197,"./grayscaleImage.js":198,"./lerp3seq.js":200,"./magnitudeImage.js":201,"./merge3.js":202,"./morph3.js":203,"./mul4x4.js":204,"./noiseImage.js":205,"./normalize3.js":206,"./popartImage.js":207,"./rgbePNGtoFloat.js":208,"./selectBool.js":209,"./selectTransform.js":210,"./sepiaImage.js":211,"./skinDirection.js":212,"./skinPosition.js":213,"./slerpseq.js":214,"./sobelImage.js":215,"./sub3.js":216}],200:[function(require,module,exports){
var binarySearch = require("../../utils/utils").binarySearch;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.lerpSeq", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'sequence'},
        {type: 'float', source: 'key'}],
    mapping: [  { name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
        { name: 'value2', source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
        { name: 'weight', source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate_core: function(result, value1, value2, weight){
        var invWeight = 1 - weight[0];
        result[0] = invWeight*value1[0] + weight[0]*value2[0];
        result[1] = invWeight*value1[1] + weight[0]*value2[1];
        result[2] = invWeight*value1[2] + weight[0]*value2[2];
    }
});


Xflow.registerOperator("xflow.lerpSeqAsync", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'sequence'},
        {type: 'float', source: 'key'}],
    mapping: [  { name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
        { name: 'value2', source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
        { name: 'weight', source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate_async: function(result, value1, value2, weight, info, callback){
        var i = info.iterateCount, off0, off1, off2;
        while(i--){
            off0 = (info.iterFlag[0] ? i : 0)*3;
            off1 = (info.iterFlag[1] ? i : 0)*3;
            off2 = info.iterFlag[2] ? i : 0;
            var invWeight = 1 - weight[off2];
            result[i*3] = invWeight*value1[off0] + weight[off2]*value2[off1];
            result[i*3+1] = invWeight*value1[off0+1] + weight[off2]*value2[off1+1];
            result[i*3+2] = invWeight*value1[off0+2] + weight[off2]*value2[off1+2];
        }
        window.setTimeout(callback, 200);
    }
});


Xflow.registerOperator("xflow.lerpKeys", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float', source: 'keys', array: true},
        {type: 'float3', source: 'values', array: true},
        {type: 'float', source: 'key'}],
    alloc: function(sizes, keys, values, key)
    {
        sizes['result'] = 3;
    },
    evaluate: function(result, keys, values, key) {
        var maxIdx = Math.min(keys.length, Math.floor(values.length / 3));
        var idx = binarySearch(keys, key[0], maxIdx);

        if(idx < 0 || idx == maxIdx - 1){
            idx = Math.max(0,idx);
            result[0] = values[3*idx];
            result[1] = values[3*idx+1];
            result[2] = values[3*idx+2];
        }
        else{
            var weight = (key[0] - keys[idx]) / (keys[idx+1] - keys[idx]);
            var invWeight = 1 - weight;
            result[0] = invWeight*values[3*idx] + weight*values[3*idx + 3];
            result[1] = invWeight*values[3*idx+1] + weight*values[3*idx + 4];
            result[2] = invWeight*values[3*idx+2] + weight*values[3*idx + 5];
        }
    }
});






},{"../../interface/constants.js":179,"../../utils/utils":230}],201:[function(require,module,exports){
Xflow.registerOperator("xflow.magnitudeImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image1'} ],
    params:  [
        {type: 'texture', source : 'image1'},
        {type: 'texture', source : 'image2'}
    ],
    evaluate: function(result, image1, image2) {
        var inpix1 = image1.data;
        var inpix2 = image2.data;
        var outpix = result.data;

        var len = inpix1.length;
        for (var i = 0 ; i < len; i+=1) {
            var val1 = inpix1[i];
            var val2 = inpix2[i];
            outpix[i] = Math.sqrt(val1*val1 + val2*val2);
        }
        return true;
    }
});

},{}],202:[function(require,module,exports){

Xflow.registerOperator("xflow.merge3", {
    outputs: [{name: 'result', tupleSize: '16'}],
    params:  ['value1','value2','value3'],
    evaluate: function(value1, value2, value3) {
        if(!(value1 && value2 && value3))
            throw "Xflow::morph3: Not all parameters are set";

        var overallLength = value1.length + value2.length + value3.length;
        if (!this.tmp || this.tmp.length != overallLength)
            this.tmp = new Float32Array(overallLength);

        this.tmp.set(value1);
        this.tmp.set(value2, value1.length);
        this.tmp.set(value3, value1.length + value2.length);
        this.result.result = this.tmp;
        return true;
    }
});
Xflow.registerOperator("xflow.merge8", {
    outputs: [{name: 'result', tupleSize: '16'}],
    params:  ['value1','value2','value3','value4','value5','value6','value7','value8'],
    evaluate: function(value1, value2, value3,value4,value5,value6,value7,value8) {
        if(!(value1 && value2 && value3 && value4 && value5 && value6 && value7 && value8))
            throw "Xflow::morph3: Not all parameters are set";

        var overallLength = value1.length + value2.length + value3.length + value4.length + value5.length + value6.length + value7.length + value8.length;
        if (!this.tmp || this.tmp.length != overallLength)
            this.tmp = new Float32Array(overallLength);

        var offset = 0;
        this.tmp.set(value1, offset);
        this.tmp.set(value2, (offset+=value1.length));
        this.tmp.set(value3, (offset+=value2.length));
        this.tmp.set(value4, (offset+=value3.length));
        this.tmp.set(value5, (offset+=value4.length));
        this.tmp.set(value6, (offset+=value5.length));
        this.tmp.set(value7, (offset+=value6.length));
        this.tmp.set(value8, (offset+=value7.length));
        this.result.result = this.tmp;
        return true;
    }
});

},{}],203:[function(require,module,exports){

Xflow.registerOperator("xflow.morph", {
    outputs: [{type: 'float3', name: 'result'}],
    params:  [
        { type: 'float3', source: 'value' },
        { type: 'float3', source: 'valueAdd'},
        { type: 'float', source: 'weight'}
    ],
    evaluate: function(result, value, valueAdd, weight, info) {
        for(var i = 0; i < info.iterateCount; i++){
            var w = weight[info.iterFlag[2] ? i : 0];
            result[3*i] = value[ info.iterFlag[0] ? 3*i : 0] + w * valueAdd[info.iterFlag[1] ? 3*i : 0];
            result[3*i+1] = value[ info.iterFlag[0] ? 3*i+1 : 1] + w * valueAdd[info.iterFlag[1] ? 3*i+1 : 1];
            result[3*i+2] = value[ info.iterFlag[0] ? 3*i+2 : 2] + w * valueAdd[info.iterFlag[1] ? 3*i+2 : 2];
        }
        return true;
    },
    evaluate_core: function(result, value, valueAdd, weight){
        result[0] = value[0] + weight[0] * valueAdd[0];
        result[1] = value[1] + weight[0] * valueAdd[1];
        result[2] = value[2] + weight[0] * valueAdd[2];
    }
});

},{}],204:[function(require,module,exports){
Xflow.registerOperator("xflow.mul", {
    outputs: [  {type: 'float4x4', name: 'result'}],
    params:  [  {type: 'float4x4', source: 'value1'},
                {type: 'float4x4', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        for(var i = 0; i < info.iterateCount; i++)
        {
            XML3D.math.mat4.multiplyOffset(result, i*16,
                value1,  info.iterFlag[0] ? i*16 : 0,
                value2, info.iterFlag[1] ? i*16 : 0);
        }
    }
});

},{}],205:[function(require,module,exports){

Xflow.registerOperator("xflow.noiseImage", {
    outputs: [ {type: 'texture', name : 'image', customAlloc: true} ],
    params:  [ {type: 'int', source: 'width'},
               {type: 'int', source:'height'},
               {type: 'float2', source: 'scale'},
               {type: 'float', source: 'minFreq'},
               {type: 'float', source: 'maxFreq'} ],
    alloc: function(sizes, width, height, scale, minFreq, maxFreq) {
        var samplerConfig = new Xflow.SamplerConfig;
        samplerConfig.setDefaults();
        sizes['image'] = {
            imageFormat : {width: width[0], height :height[0]},
            samplerConfig : samplerConfig
        };
    },
    evaluate: function(image, width, height, scale, minFreq, maxFreq) {
        width = width[0];
        height = height[0];
        minFreq = minFreq[0];
        maxFreq = maxFreq[0];

        var id = image;
        var pix = id.data;
        this.noise = this.noise || new SimplexNoise();
        var noise = this.noise;

        var useTurbulence = minFreq != 0.0 && maxFreq != 0.0 && minFreq < maxFreq;

        var snoise = function(x,y) {
            return noise.noise(x, y); // noise.noise returns values in range [-1,1]
            //return 2.0 * noise.noise(x, y) - 1.0; // this code is for noise value in range [0,1]
        };

        var turbulence = function(minFreq, maxFreq, s, t) {
            var value = 0;
            for (var f = minFreq; f < maxFreq; f *= 2)
            {
                value += Math.abs(snoise(s * f, t * f))/f;
            }
            return value;
        };

        for (var y = 0; y < height; ++y)
        {
            var t = y / height * scale[1];
            var invWidth = 1.0 / width;

            for (var x = 0; x < width; ++x)
            {
                var s = x * invWidth * scale[0];
                var v = useTurbulence ? turbulence(minFreq, maxFreq, s, t) : snoise(s, t);
                var offset = (x * width + y) * 4;
                pix[offset] =  Math.floor(v * 255);
                pix[offset+1] = Math.floor(v * 255);
                pix[offset+2] = Math.floor(v * 255);
                pix[offset+3] = 255;
            }
        }

        /* Fill with green color
        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                var offset = (x * width + y) * 4;
                pix[offset] =  0
                pix[offset+1] = 255;
                pix[offset+2] = 0;
                pix[offset+3] = 255;
            }
        }
        */

        return true;
    }
});

},{}],206:[function(require,module,exports){

Xflow.registerOperator("xflow.normalize", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value'}],
    evaluate: function(result, value, info) {
        for(var i = 0; i < info.iterateCount; i++) {
            var offset = 3*i;
            var x = value[offset];
            var y = value[offset+1];
            var z = value[offset+2];
            var l = 1.0/Math.sqrt(x*x+y*y+z*z);
            result[offset] = x*l;
            result[offset+1] = y*l;
            result[offset+2] = z*l;
        }
    }
});

},{}],207:[function(require,module,exports){

// Based on http://kodemongki.blogspot.de/2011/06/kameraku-custom-shader-effects-example.html
Xflow.registerOperator("xflow.popartImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'},
        {type: 'float', source : 'time'} ],
    evaluate: function(result, image, time) {
        var width = image.width;
        var height = image.height;

        var s = image.data;
        var d = result.data;
        for (var i = 0; i < s.length; i += 4) {
            var r = s[i] / 255;
            var g = s[i + 1] / 255;
            var b = s[i + 2] / 255;
            var a = s[i + 3] / 255;

            var y = 0.3 * r + 0.59 * g + 0.11 * b;
            y = y < 0.3 ? 0.0 : (y < 0.6 ? 0.5 : 1.0);
            if (y == 0.5) {
                d[i]   = 0.8 * 255;
                d[i+1] = 0;
                d[i+2] = 0;
            } else if (y == 1.0) {
                d[i]   = 0.9 * 255;
                d[i+1] = 0.9 * 255;
                d[i+2] = 0;
            } else {
                d[i] = 0;
                d[i+1] = 0;
                d[i+2] = 0;
            }
            d[i+3] = s[i+3];
        }
        return true;
    }
});

},{}],208:[function(require,module,exports){
var SamplerConfig = require("../../interface/data.js").SamplerConfig;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.rgbePNGtoFloat", {
    outputs: [ {type: 'texture', name : 'result', customAlloc: true } ],
    params:  [
        {type: 'texture', source : 'image'}
    ],
    alloc: function (sizes, image) {
        var samplerConfig = new SamplerConfig;
        samplerConfig.setDefaults();
        samplerConfig.minFilter = XC.TEX_FILTER_TYPE.NEAREST;
        samplerConfig.magFilter = XC.TEX_FILTER_TYPE.NEAREST;
        sizes["result"] = {
            imageFormat : {
                width: image.width,
                height: image.height,
                texelType: XC.TEXTURE_TYPE.FLOAT,
                texelFormat: XC.TEXTURE_FORMAT.RGB
            },
            samplerConfig: samplerConfig
        }
    },

    evaluate: function(result, image) {
        for (var idx = 0; idx < image.data.length; idx += 4) {
            var rgbe = image.data.subarray(idx, idx + 4);
            var f = 0.0;
            var e = rgbe[3];

            if (e > 0.0)
                f = Math.pow(2.0, e - (128.0 + 8.0));

            var rgb = new Float32Array(3);
            rgb[0] = rgbe[0] * f;
            rgb[1] = rgbe[1] * f;
            rgb[2] = rgbe[2] * f;
            result.data.set(rgb, idx / 4 * 3);
        }
        return true;
    }
});

},{"../../interface/constants.js":179,"../../interface/data.js":180}],209:[function(require,module,exports){

Xflow.registerOperator("xflow.selectBool", {
    outputs: [ {type: 'bool', name : 'result', customAlloc: true} ],
    params:  [ {type: 'int', source : 'index'},
               {type: 'bool', source: 'value'} ],
    alloc: function(sizes, index, value) {
        sizes['result'] = 1;
    },
    evaluate: function(result, index, value) {
        var i = index[0];
        if (i < value.length) {
            result[0] = value[i];
        } else {
            result[0] = false;
        }
    }
});

},{}],210:[function(require,module,exports){

Xflow.registerOperator("xflow.selectTransform", {
    outputs: [ {type: 'float4x4', name : 'result', customAlloc: true} ],
    params:  [ {type: 'int', source : 'index'},
               {type: 'float4x4', source: 'transform'} ],
    alloc: function(sizes, index, transform) {
        sizes['result'] = 1;
    },
    evaluate: function(result, index, transform) {
        var i = 16 * index[0];
        if (i < transform.length && i+15 < transform.length) {
            result[0] = transform[i+0];
            result[1] = transform[i+1];
            result[2] = transform[i+2];
            result[3] = transform[i+3];
            result[4] = transform[i+4];
            result[5] = transform[i+5];
            result[6] = transform[i+6];
            result[7] = transform[i+7];
            result[8] = transform[i+8];
            result[9] = transform[i+9];
            result[10] = transform[i+10];
            result[11] = transform[i+11];
            result[12] = transform[i+12];
            result[13] = transform[i+13];
            result[14] = transform[i+14];
            result[15] = transform[i+15];
        } else {
            result[0] = 1;
            result[1] = 0;
            result[2] = 0;
            result[3] = 0;
            result[4] = 0;
            result[5] = 1;
            result[6] = 0;
            result[7] = 0;
            result[8] = 0;
            result[9] = 0;
            result[10] = 1;
            result[11] = 0;
            result[12] = 0;
            result[13] = 0;
            result[14] = 0;
            result[15] = 1;
        }
    }
});

},{}],211:[function(require,module,exports){

Xflow.registerOperator("xflow.sepiaImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var s = image.data;
        var d = result.data;
        var r = 0, g = 0, b = 0;
        for(var i = 0 ; i < s.length; i += 4) {
            r = (s[i] * 0.393 + s[i+1] * 0.769 + s[i+2] * 0.189);
            g = (s[i] * 0.349 + s[i+1] * 0.686 + s[i+2] * 0.168);
            b = (s[i] * 0.272 + s[i+1] * 0.534 + s[i+2] * 0.131);
            if (r>255) r = 255;
            if (g>255) g = 255;
            if (b>255) b = 255;
            if (r<0) r = 0;
            if (g<0) g = 0;
            if (b<0) b = 0;
            d[i] = r;
            d[i+1] = g;
            d[i+2] = b;
            d[i+3] = 255;
        }
        return true;
    }
});

},{}],212:[function(require,module,exports){

Xflow.registerOperator("xflow.skinDirection", {
    outputs: [  {type: 'float3', name: 'result' }],
    params:  [  {type: 'float3', source: 'dir' },
                {type: 'int4', source: 'boneIdx' },
                {type: 'float4', source: 'boneWeight' },
                {type: 'float4x4', source: 'boneXform', array: true } ],
    evaluate: function(result, dir,boneIdx,boneWeight,boneXform, info) {
        var vec3 = XML3D.math.vec3,
            mat4 = XML3D.math.mat4;
        var r = vec3.create();
        var tmp =  vec3.create();

        for(var i = 0; i< info.iterateCount;++i) {
            var offset = i*3;
            r[0] = r[1] = r[2] = +0;
            for(var j = 0; j < 4; j++) {
                var weight = boneWeight[info.iterFlag[2] ? i*4+j : j];
                if (weight) {
                    var mo = boneIdx[info.iterFlag[1] ? i*4+j : j]*16;

                    mat4.multiplyOffsetDirection(boneXform, mo, dir, offset, tmp);
                    vec3.scale(tmp, tmp, weight);
                    vec3.add(r, r, tmp);
                }
            }
            vec3.normalize(r, r);
            result[offset] = r[0];
            result[offset+1] = r[1];
            result[offset+2] = r[2];
        }
    }
});

},{}],213:[function(require,module,exports){

Xflow.registerOperator("xflow.skinPosition", {
    outputs: [  {type: 'float3', name: 'result' }],
    params:  [  {type: 'float3', source: 'pos' },
                {type: 'int4', source: 'boneIdx' },
                {type: 'float4', source: 'boneWeight' },
                {type: 'float4x4', source: 'boneXform', array: true } ],
    evaluate: function(result, pos,boneIdx,boneWeight,boneXform, info) {
        var vec3 = XML3D.math.vec3,
            mat4 = XML3D.math.mat4;
        var r = vec3.create();
        var tmp =  vec3.create();

        for(var i = 0; i< info.iterateCount;++i) {
            var offset = i*3;
            r[0] = r[1] = r[2] = +0;
            for(var j = 0; j < 4; j++) {
                var weight = boneWeight[info.iterFlag[2] ? i*4+j : j];
                if (weight) {
                    var mo = boneIdx[info.iterFlag[1] ? i*4+j : j]*16;

                    mat4.multiplyOffsetVec3(boneXform, mo, pos, offset, tmp);
                    vec3.scale(tmp, tmp, weight);
                    vec3.add(r, r, tmp);
                }
            }
            result[offset] = r[0];
            result[offset+1] = r[1];
            result[offset+2] = r[2];
        }
    }
});

},{}],214:[function(require,module,exports){
var binarySearch = require("../../utils/utils").binarySearch;
var XC = require("../../interface/constants.js");

Xflow.registerOperator("xflow.slerpSeq", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float4', source: 'sequence'},
                {type: 'float', source: 'key'}],
    mapping: [  {name: 'value1', source: 'sequence', sequence: XC.SEQUENCE.PREV_BUFFER, keySource: 'key'},
                {name: 'value2',  source: 'sequence', sequence: XC.SEQUENCE.NEXT_BUFFER, keySource: 'key'},
                {name: 'weight',  source: 'sequence', sequence: XC.SEQUENCE.LINEAR_WEIGHT, keySource: 'key'}],
    evaluate: function(result, value1, value2, weight, info) {
        for(var i = 0; i < info.iterateCount; ++i){
            XML3D.math.quat.slerpOffset(  value1,info.iterFlag[0] ? i*4 : 0,
                                          value2,info.iterFlag[1] ? i*4 : 0,
                                          weight[0],
                                          result, i*4, true);
        }
    }
});


Xflow.registerOperator("xflow.slerpKeys", {
    outputs: [  {type: 'float4', name: 'result'}],
    params:  [  {type: 'float', source: 'keys', array: true},
        {type: 'float4', source: 'values', array: true},
        {type: 'float', source: 'key'}],
    alloc: function(sizes, keys, values, key)
    {
        sizes['result'] = 4;
    },
    evaluate: function(result, keys, values, key) {
        var maxIdx = Math.min(keys.length, Math.floor(values.length / 4));
        var idx = binarySearch(keys, key[0], maxIdx);

        if(idx < 0 || idx == maxIdx - 1){
            idx = Math.max(0,idx);
            result[0] = values[4*idx];
            result[1] = values[4*idx+1];
            result[2] = values[4*idx+2];
            result[3] = values[4*idx+3];
        }
        else{
            var weight = (key[0] - keys[idx]) / (keys[idx+1] - keys[idx]);
            XML3D.math.quat.slerpOffset(  values, idx*4,
                values,(idx+1)*4, weight,
                result, 0, true);
        }
    }
});

},{"../../interface/constants.js":179,"../../utils/utils":230}],215:[function(require,module,exports){

// Code portions from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
(function() {
    Xflow.Filters = {};

    var tmpCanvas = null;
    var tmpCtx = null;

    Xflow.Filters.createImageData = function(w,h) {
        if (!tmpCanvas)
            tmpCanvas = document.createElement('canvas');
        if (!tmpCtx)
            tmpCtx = tmpCanvas.getContext('2d');
        return tmpCtx.createImageData(w, h);
    };

    Xflow.Filters.createImageDataFloat32 = function(w, h) {
        return {width: w, height: h, data: new Float32Array(w * h * 4)};
    };

    Xflow.Filters.grayscale = function(inpixels, outpixels, args) {
            var s = inpixels.data;
            var d = outpixels.data;
            for (var i=0; i<s.length; i+=4) {
                var r = s[i];
                var g = s[i+1];
                var b = s[i+2];
                var a = s[i+3];
                // CIE luminance for the RGB
                // The human eye is bad at seeing red and blue, so we de-emphasize them.
                var v = 0.2126*r + 0.7152*g + 0.0722*b;
                d[i] = d[i+1] = d[i+2] = v
                d[i+3] = a;
            }
            return inpixels;
    };

    Xflow.Filters.convolute = function(inpixels, outpixels, weights, opaque) {
            var side = Math.round(Math.sqrt(weights.length));
            var halfSide = Math.floor(side/2);
            var src = inpixels.data;
            var sw = inpixels.width;
            var sh = inpixels.height;
            // pad output by the convolution matrix
            var w = sw;
            var h = sh;
            var dst = outpixels.data;
            // go through the destination image pixels
            var alphaFac = opaque ? 1 : 0;
            for (var y=0; y<h; y++) {
                for (var x=0; x<w; x++) {
                    var sy = y;
                    var sx = x;
                    var dstOff = (y*w+x)*4;
                    // calculate the weighed sum of the source image pixels that
                    // fall under the convolution matrix
                    var r=0, g=0, b=0, a=0;
                    for (var cy=0; cy<side; cy++) {
                        for (var cx=0; cx<side; cx++) {
                            var scy = sy + cy - halfSide;
                            var scx = sx + cx - halfSide;
                            if (scy >= 0 && scy < sh && scx >= 0 && scx < sw) {
                                var srcOff = (scy*sw+scx)*4;
                                var wt = weights[cy*side+cx];
                                r += src[srcOff] * wt;
                                g += src[srcOff+1] * wt;
                                b += src[srcOff+2] * wt;
                                a += src[srcOff+3] * wt;
                            }
                        }
                    }
                    dst[dstOff] = r;
                    dst[dstOff+1] = g;
                    dst[dstOff+2] = b;
                    dst[dstOff+3] = a + alphaFac*(255-a);
                }
            }
            return outpixels;
        };
/*
    Xflow.Filters.convoluteFloat32 = function(pixels, weights, opaque) {
        var side = Math.round(Math.sqrt(weights.length));
        var halfSide = Math.floor(side / 2);

        var src = pixels.data;
        var sw = pixels.width;
        var sh = pixels.height;

        var w = sw;
        var h = sh;
        var output = {
            width: w, height: h, data: new Float32Array(w * h * 4)
        };
        var dst = output.data;

        var alphaFac = opaque ? 1 : 0;

        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                var sy = y;
                var sx = x;
                var dstOff = (y * w + x) * 4;
                var r = 0, g = 0, b = 0, a = 0;
                for (var cy = 0; cy < side; cy++) {
                    for (var cx = 0; cx < side; cx++) {
                        var scy = Math.min(sh - 1, Math.max(0, sy + cy - halfSide));
                        var scx = Math.min(sw - 1, Math.max(0, sx + cx - halfSide));
                        var srcOff = (scy * sw + scx) * 4;
                        var wt = weights[cy * side + cx];
                        r += src[srcOff] * wt;
                        g += src[srcOff + 1] * wt;
                        b += src[srcOff + 2] * wt;
                        a += src[srcOff + 3] * wt;
                    }
                }
                dst[dstOff] = r;
                dst[dstOff + 1] = g;
                dst[dstOff + 2] = b;
                dst[dstOff + 3] = a + alphaFac * (255 - a);
            }
        }
        return output;
    }
*/
}());

function float4(x,y,z,w) {
    var v = new Float32Array(4);
    switch (arguments.length) {
        case 0:
            v[0] = 0;
            v[1] = 0;
            v[2] = 0;
            v[3] = 0;
            break;
        case 1:
            v[0] = x;
            v[1] = x;
            v[2] = x;
            v[3] = x;
            break;
        case 2:
            v[0] = x;
            v[1] = y;
            v[2] = 0;
            v[3] = 0;
            break;
        case 3:
            v[0] = x;
            v[1] = y;
            v[2] = z;
            v[3] = 0;
            break;
        default:
            v[0] = x;
            v[1] = y;
            v[2] = z;
            v[3] = w;
    }
    return v;
}

function hypot(a, b)
{
    return Math.sqrt(a*a + b*b);
}

function hypot4(a, b)
{
    return float4(hypot(a[0], b[0]),
                  hypot(a[1], b[1]),
                  hypot(a[2], b[2]),
                  hypot(a[3], b[3]));
}

function hypot4To(r, a, b)
{
    r[0] = hypot(a[0], b[0]);
    r[1] = hypot(a[1], b[1]);
    r[2] = hypot(a[2], b[2]);
    r[3] = hypot(a[3], b[3]);
}

function getTexel2D(imagedata, x, y) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    var color = new Float32Array(4);
    color[0] = data[offset] / 255.0;
    color[1] = data[offset+1] / 255.0;
    color[2] = data[offset+2] / 255.0;
    color[3] = data[offset+3] / 255.0;
    return color;
}

function getTexel2DTo(color, imagedata, x, y) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    color[0] = data[offset] / 255.0;
    color[1] = data[offset+1] / 255.0;
    color[2] = data[offset+2] / 255.0;
    color[3] = data[offset+3] / 255.0;
    return color;
}

function setTexel2D(imagedata, x, y, color) {
    var offset = (y * imagedata.width + x) * 4;
    var data = imagedata.data;
    data[offset] = color[0] * 255.0 ;
    data[offset+1] = color[1] * 255.0;
    data[offset+2] = color[2] * 255.0;
    data[offset+3] = color[3] * 255.0;
}

Xflow.registerOperator("xflow.sobelImage", {
    outputs: [ {type: 'texture', name : 'result', sizeof : 'image'} ],
    params:  [ {type: 'texture', source : 'image'} ],
    evaluate: function(result, image) {
        var width = image.width;
        var height = image.height;

        // Sobel filter, AnySL method
        var gx = float4(0.0);
        var gy = float4(0.0);
        var i00 = float4();
        var i00 = float4();
        var i10 = float4();
        var i20 = float4();
        var i01 = float4();
        var i11 = float4();
        var i21 = float4();
        var i02 = float4();
        var i12 = float4();
        var i22 = float4();
        var color = float4();

        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                /* Read each texel component and calculate the filtered value using neighbouring texel components */
                if ( x >= 1 && x < (width-1) && y >= 1 && y < height - 1)
                {
                    getTexel2DTo(i00, image, x-1, y-1);
                    getTexel2DTo(i10, image, x, y-1);
                    getTexel2DTo(i20, image, x+1, y-1);
                    getTexel2DTo(i01, image, x-1, y);
                    getTexel2DTo(i11, image, x, y);
                    getTexel2DTo(i21, image, x+1, y);
                    getTexel2DTo(i02, image, x-1, y+1);
                    getTexel2DTo(i12, image, x, y+1);
                    getTexel2DTo(i22, image, x+1, y+1);

                    gx[0] = i00[0] + 2 * i10[0] + i20[0] - i02[0]  - 2 * i12[0] - i22[0];
                    gx[1] = i00[1] + 2 * i10[1] + i20[1] - i02[1]  - 2 * i12[1] - i22[1];
                    gx[2] = i00[2] + 2 * i10[2] + i20[2] - i02[2]  - 2 * i12[2] - i22[2];

                    gy[0] = i00[0] - i20[0]  + 2*i01[0] - 2*i21[0] + i02[0]  -  i22[0];
                    gy[1] = i00[1] - i20[1]  + 2*i01[1] - 2*i21[1] + i02[1]  -  i22[1];
                    gy[2] = i00[2] - i20[2]  + 2*i01[2] - 2*i21[2] + i02[2]  -  i22[2];

                    /* taking root of sums of squares of Gx and Gy */
                    hypot4To(color, gx, gy);
                    color[0]/=2;
                    color[1]/=2;
                    color[2]/=2;
                    color[3]=1.0;
                    setTexel2D(result, x, y, color);
                }
            }
        }



// Sobel filter with separate steps
//
//        var vertical = Xflow.Filters.createImageDataFloat32(width, height);
//        Xflow.Filters.convolute(result, vertical,
//            [ -1, 0, 1,
//              -2, 0, 2,
//              -1, 0, 1 ]);
//        var horizontal = Xflow.Filters.createImageDataFloat32(width, height);
//        Xflow.Filters.convolute(result, horizontal,
//            [ -1, -2, -1,
//               0,  0,  0,
//               1,  2,  1 ]);
//
//        for (var i=0; i<result.data.length; i+=4) {
//            // make the vertical gradient red
//            var v = Math.abs(vertical.data[i]);
//            result.data[i] = v;
//            // make the horizontal gradient green
//            var h = Math.abs(horizontal.data[i]);
//            result.data[i+1] = h;
//            // and mix in some blue for aesthetics
//            result.data[i+2] = (v+h)/4;
//            result.data[i+3] = 255; // opaque alpha
//        }

        /* Copy image
        var destpix = result.data;
        var srcpix = image.data;

        for (var y = 0; y < height; ++y)
        {
            for (var x = 0; x < width; ++x)
            {
                var offset = (y * width + x) * 4;
                destpix[offset] =  srcpix[offset];
                destpix[offset+1] = srcpix[offset+1];
                destpix[offset+2] = srcpix[offset+2];
                destpix[offset+3] = srcpix[offset+3];
            }
        }
        */
        return true;
    }
});

},{}],216:[function(require,module,exports){

Xflow.registerOperator("xflow.sub", {
    outputs: [  {type: 'float3', name: 'result'}],
    params:  [  {type: 'float3', source: 'value1'},
                {type: 'float3', source: 'value2'}],
    evaluate: function(result, value1, value2, info) {
        throw "Not used!";

        for(var i = 0; i< info.iterateCount*3; i++)
            result[i] = value1[i] - value2[i];

        return true;
    },

    evaluate_core: function(result, value1, value2){
        result[0] = value1[0] - value2[0];
        result[1] = value1[1] - value2[1];
        result[2] = value1[2] - value2[2];
    }
});

},{}],217:[function(require,module,exports){
/**
 * One operator execution within the @see{OperatorList}.
 * @param operator
 * @constructor
 */
var OperatorEntry = function (operator) {
    /**
     * Position in OperatorList
     * @type {number}
     */
    this.index = 0;

    /**
     * Operator object
     * @type {{}}
     */
    this.operator = operator;

    /**
     * operatorIndex: Position of the input's operator in the OperatorList if the input comes from
     * previously executed operator otherwise undefined
     * outputIndex: References the outputs of the operator object defined by the operatorIndex
     * mappedName: Original name as defined in operator invocation in DataNode (currently not used)
     * inputIndex: Only set if this is direct input and references into the inputs defined in @see{ProgramData}
     * @type {Array.<{operatorIndex: number?, outputIndex: number?, mappedName: string?, inputIndex: number?}>}
     */
    this.inputInfo = [];
    /**
     * finalOut: {number} Is set, if this output a final output (e.g. a varying in a vertex shader). References the outputs of the ProgramData.
     * transfer: {boolean} Is true if this is a transfer output i.e. this output is used as input by another operator,
     * lost: Data that is lost, i.e. not used in next executor. Reference to ProgramData's outputs
     * @type {Array.<{finalOut: number?, transfer: boolean?, lost: number?}>}
     */
    this.outputInfo = [];
};

/**
 * Is the input the result of a previously executed operator
 * @param mappingIndex Input index of the operator (can be mapped using a mapping declaration)
 * @returns {boolean}
 */
OperatorEntry.prototype.isTransferInput = function (mappingIndex) {
    return this.inputInfo[mappingIndex].operatorIndex !== undefined;
};

OperatorEntry.prototype.getTransferInputOperatorIndex = function (mappingIndex) {
    return this.inputInfo[mappingIndex].operatorIndex;
};
OperatorEntry.prototype.getTransferInputOutputIndex = function (mappingIndex) {
    return this.inputInfo[mappingIndex].outputIndex;
};

/**
 * Generate unique name for a specified transfer input
 * @param mappingIdx
 * @returns {string}
 */
OperatorEntry.prototype.getTransferInputId = function (mappingIdx) {
    var info = this.inputInfo[mappingIdx];
    return info.operatorIndex + "_" + info.outputIndex;
};

/**
 * Generate unique name for transfer output
 * @param outputIndex
 * @returns {string}
 */
OperatorEntry.prototype.getTransferOutputId = function (outputIndex) {
    return this.index + "_" + outputIndex;
};

/**
 * TODO: remove or integrate for debugging purposes
 * @unused
 * @param mappingIdx
 * @returns {string|*}
 */
OperatorEntry.prototype.getInputMappingName = function (mappingIdx) {
    return this.inputInfo[mappingIdx].mappedName;
};
OperatorEntry.prototype.getDirectInputIndex = function (mappingIdx) {
    return this.inputInfo[mappingIdx].inputIndex;
};

OperatorEntry.prototype.getOutputIndex = function (operatorOutputIdx) {
    return this.outputInfo[operatorOutputIdx].finalOut || this.outputInfo[operatorOutputIdx].lost || 0;
};


OperatorEntry.prototype.isFinalOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].finalOut !== undefined;
};
OperatorEntry.prototype.isTransferOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].transfer;
};
OperatorEntry.prototype.isLostOutput = function (outputIndex) {
    return this.outputInfo[outputIndex] && this.outputInfo[outputIndex].lost !== undefined;
};


OperatorEntry.prototype.setTransferInput = function (mappingIndex, operatorIndex, outputIndex) {
    this.inputInfo[mappingIndex] = {operatorIndex: operatorIndex, outputIndex: outputIndex};
};

OperatorEntry.prototype.setDirectInput = function (mappingIndex, inputIndex, mappedName) {
    this.inputInfo[mappingIndex] = {inputIndex: inputIndex, mappedName: mappedName};
};

OperatorEntry.prototype.setFinalOutput = function (operatorOutputIndex, globalOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {finalOut: globalOutputIndex};
};
OperatorEntry.prototype.setTransferOutput = function (operatorOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {transfer: true};
};
OperatorEntry.prototype.setLostOutput = function (operatorOutputIndex, globalOutputIndex) {
    this.outputInfo[operatorOutputIndex] = {lost: globalOutputIndex};
};

/**
 * Generate hash-able key for the entry
 * @returns {string}
 */
OperatorEntry.prototype.getKey = function () {
    var key = this.operator.name + "*O";
    for (var i = 0; i < this.outputInfo.length; ++i) {
        var info = this.outputInfo[i];
        key += "*" + ( info.transfer ? "_" : info.finalOut || (info.lost + "?"));
    }
    key += +"*I";
    for (i = 0; i < this.inputInfo.length; ++i) {
        info = this.inputInfo[i];
        key += "*" + (info.inputIndex ? info.inputInfo : info.operatorIndex + ">" + info.outputIndex);
    }
    return key;
};

module.exports = OperatorEntry;

},{}],218:[function(require,module,exports){
var C = require("../interface/constants.js");
var Base = require("../base.js");


/**
 * List of platform-specific operators, ordered by execution (last entry is last operator
 * executed).
 *
 * @param {C.PLATFORM} platform
 * @constructor
 */
var OperatorList = function (platform) {
    this.platform = platform;
    /**
     * @type {Array.<OperatorEntry>}
     */
    this.entries = [];

    /**
     * Map from position of input parameter to size and iterator type of parameters.
     * Size is only specified for uniform array input, required for programs that
     * have the array size specified.
     * @type {Object.<number,{size: number, iterate: C.ITERATION_TYPE}>}
     */
    this.inputInfo = {};
};

OperatorList.prototype.addEntry = function (entry) {
    entry.index = this.entries.length;
    this.entries.push(entry);
};

/**
 * Hashable key for whole list
 * @returns {string}
 */
OperatorList.prototype.getKey = function () {
    var keys = [];
    for (var i = 0; i < this.entries.length; ++i) {
        keys.push(this.entries[i].getKey());
    }
    var result = this.platform + ">" + keys.join("!") + "|";
    for (var i in this.inputInfo) {
        result += i + ">" + (this.inputInfo[i].iterate || 0) + "x" + (this.inputInfo[i].size || 0);
    }
    return result;
};

OperatorList.prototype.setInputIterateType = function (inputIndex, type) {
    if (!this.inputInfo[inputIndex]) this.inputInfo[inputIndex] = {};
    this.inputInfo[inputIndex].iterate = type;
};
OperatorList.prototype.setInputSize = function (inputIndex, size) {
    if (!this.inputInfo[inputIndex]) this.inputInfo[inputIndex] = {};
    this.inputInfo[inputIndex].size = size;
};


OperatorList.prototype.isInputIterate = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.MANY;
};
OperatorList.prototype.isInputUniform = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.ONE;
};
OperatorList.prototype.isInputNull = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate == C.ITERATION_TYPE.NULL;
};
OperatorList.prototype.getInputIterateType = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].iterate;
};

OperatorList.prototype.getInputSize = function (inputIndex) {
    return this.inputInfo[inputIndex] && this.inputInfo[inputIndex].size || 0;
};

OperatorList.prototype.getIterateCount = function (programData) {
    var count = -1;
    for (var i = 0; i < programData.inputs.length; ++i) {
        if (this.isInputIterate(i)) {
            var dataEntry = programData.getDataEntry(i);
            if (dataEntry && dataEntry.getIterateCount) {
                var size = dataEntry.getIterateCount();
                count = count < 0 ? size : Math.min(size, count);
            }
        }
    }
    return count < 0 ? 1 : count;
};

var c_sizes = {};

OperatorList.prototype.allocateOutput = function (programData, async) {
    for (var i = 0; i < this.entries.length; ++i) {
        var entry = this.entries[i];
        var operator = entry.operator;
        var operatorData = programData.operatorData[i];
        var iterateCount = this.getIterateCount(programData);
        if (operator.alloc) {
            var args = [c_sizes];
            addInputToArgs(args, entry, programData);
            args.push(iterateCount);
            operator.alloc.apply(operatorData, args);
        }
        for (var j = 0; j < operator.outputs.length; ++j) {
            var d = operator.outputs[j];
            var dataSlot = programData.outputs[entry.getOutputIndex(j)], dataEntry;
            dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;

            if (d.noAlloc)
                continue;

            if (dataEntry.type == C.DATA_TYPE.TEXTURE) {
                // texture entry
                if (d.customAlloc) {
                    var texParams = c_sizes[d.name];
                    var newWidth = texParams.imageFormat.width;
                    var newHeight = texParams.imageFormat.height;
                    var newType = texParams.imageFormat.texelType;
                    var newFormat = texParams.imageFormat.texelFormat;
                    var newSamplerConfig = texParams.samplerConfig;
                    dataEntry._createImage(newWidth, newHeight, newFormat, newType, newSamplerConfig);
                } else if (d.sizeof) {
                    var srcEntry = null;
                    for (var k = 0; k < operator.mapping.length; ++k) {
                        if (operator.mapping[k].source == d.sizeof) {
                            srcEntry = programData.getDataEntry(entry.getDirectInputIndex(k));
                            break;
                        }
                    }
                    if (srcEntry) {
                        var newWidth = Math.max(srcEntry.width, 1);
                        var newHeight = Math.max(srcEntry.height, 1);
                        var newFormat = d.texelFormat || srcEntry.texelFormat;
                        var newType = d.texelType || srcEntry.texelType;
                        var newSamplerConfig = d.samplerConfig || srcEntry.getSamplerConfig();
                        dataEntry._createImage(newWidth, newHeight, newFormat, newType, newSamplerConfig);
                    } else
                        throw new Error("Unknown texture input parameter '" + d.sizeof + "' in operator '" + operator.name + "'");
                } else
                    throw new Error("Cannot create texture. Use customAlloc or sizeof parameter attribute");
            } else {

                var size = (d.customAlloc ? c_sizes[d.name] : iterateCount) * dataEntry.getTupleSize();

                if (!dataEntry._value || dataEntry._value.length != size) {
                    switch (dataEntry.type) {
                        case C.DATA_TYPE.FLOAT:
                        case C.DATA_TYPE.FLOAT2:
                        case C.DATA_TYPE.FLOAT3:
                        case C.DATA_TYPE.FLOAT4:
                        case C.DATA_TYPE.FLOAT4X4:
                            dataEntry._setValue(new Float32Array(size));
                            break;
                        case C.DATA_TYPE.INT:
                        case C.DATA_TYPE.INT4:
                        case C.DATA_TYPE.BOOL:
                            dataEntry._setValue(new Int32Array(size));
                            break;
                        default:
                            XML3D.debug.logWarning("Could not allocate output buffer of TYPE: " + dataEntry.type);
                    }
                } else {
                    dataEntry._notifyChanged();
                }
            }
        }
    }
};

/*
 OperatorList.prototype.checkInput = function(programData){
 for(var i = 0; i < this.entries.length; ++i){
 var entry = this.entries[i];
 var mapping = entry.operator.mapping;
 for(var j = 0; j < mapping.length; ++j){
 if(entry.isTransferInput(j)){
 var outputType = this.entries[entry.getTransferInputOperatorIndex(j)].operator.outputs[
 entry.getTransferInputOutputIndex(j)].type;

 if(outputType != entry.type){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Input for " + entry.source +
 " has wrong type. Expected: " + C.getTypeName(entry.type)
 + ", but got: " +  C.getTypeName(outputType) );
 return false;
 }

 }
 else{
 var mappingName = entry.getInputMappingName(j);
 if(!entry.optional && !mappingName){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Missing input argument for "
 + entry.source);
 return false;
 }
 if(mappingName){
 var channel = programData.getChannel(entry.getDirectInputIndex(j));
 if(!channel){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Input of name '" + mappingName +
 "' not found. Used for parameter " + entry.source);
 return false;
 }
 var dataEntry = channel.getDataEntry();
 if(!entry.optional && (!dataEntry || dataEntry.getLength() == 0)){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Input for " + entry.source +
 ' contains no data.');
 return false;
 }
 if(dataEntry && dataEntry.type != entry.type){
 XML3D.debug.logError("Xflow: operator " + entry.operator.name + ": Input for " + entry.source +
 " has wrong type. Expected: " + C.getTypeName(entry.type)
 + ", but got: " +  C.getTypeName(dataEntry.type) );
 return false;
 }
 }
 }
 }
 }
 }
 */

    // TODO: This function appears in multiple units
    function addInputToArgs(args, entry, programData){
        var mapping = entry.operator.mapping;
        for(var i = 0; i < mapping.length; ++i){
            var mapEntry = mapping[i];
            var dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));
            args.push(dataEntry ? dataEntry.getValue() : null);
        }
    };

module.exports = OperatorList;

},{"../base.js":178,"../interface/constants.js":179}],219:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");

//----------------------------------------------------------------------------------------------------------------------
// registerOperator && getOperator
//----------------------------------------------------------------------------------------------------------------------

var operators = {};

    /**
     * Registers Xflow operator.
     * The operators are stored in collections using their platform as a key. If no platform is defined, the operator
     * will be registered as a JavaScript-based operator.
     *
     * @param name
     * @param data
     */

var registerOperator = function(name, data){
    var opCollection, platform;

    initOperator(data);
    if(!operators[name]) {
        operators[name] = {};
    }

    platform = data['platform'] || C.PLATFORM.JAVASCRIPT;

    opCollection = operators[name];

    if (!name) {
        XML3D.logWarning("Xflow.registerOperator: Operator name undefined.");
        return;
    }

    if (!data) {
        XML3D.logWarning("Xflow.registerOperator: Operator data undefined.");
        return;
    }

    data.name = name;
    if(!opCollection[platform])
        opCollection[platform] = [];

    opCollection[platform].push(data);
};

var initAnonymousOperator = function(name, data){
    initOperator(data);
    data.name = name;
    return data;
};

var isOperatorAsync = function(operator){
    return !!operator.evaluate_async;
};

var getOperators = function(name, platform){
    platform = platform || C.PLATFORM.JAVASCRIPT;

    if (name && !operators[name]) {
        return null;
    }

    if(!operators[name][platform] || operators[name][platform].length == 0) {
        return null;
    }

    return operators[name][platform];
};

function initOperator(operator){
    var indexMap = {};
    // Init types of outputs and params
    for(var i= 0; i < operator.outputs.length; ++i){
        operator.outputs[i].type = C.DATA_TYPE_MAP[operator.outputs[i].type];
    }
    for(var i= 0; i < operator.params.length; ++i){
        operator.params[i].type = C.DATA_TYPE_MAP[operator.params[i].type];
        indexMap[operator.params[i].source] = i;
    }
    if(!operator.mapping)
        operator.mapping = operator.params;

    // Init interTypes of mapping
    for(var i = 0; i < operator.mapping.length; ++i){
        var mapping = operator.mapping[i];
        var paramIdx = indexMap[mapping.source];
        mapping.paramIdx = paramIdx;
        var type = operator.params[paramIdx].type;
        if(mapping.sequence)
            mapping.keyParamIdx = indexMap[mapping.keySource];
        if(mapping.sequence == C.SEQUENCE.LINEAR_WEIGHT)
            type = C.DATA_TYPE.FLOAT;
        mapping.internalType = type;
        mapping.name = mapping.name || mapping.source;
    }

    //Check/init platform
    operator.platform = operator.platform || C.PLATFORM.JAVASCRIPT;
}

//window.Xflow.registerOperator = registerOperator;

module.exports = {
    registerOperator: registerOperator,
    initAnonymousOperator: initAnonymousOperator,
    isOperatorAsync: isOperatorAsync,
    getOperators: getOperators
};

},{"../base.js":178,"../interface/constants.js":179}],220:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var VSProgram = require("./vs-program.js");
var CLProgram = require("./cl-program.js");

/**
 * Data for a OperatorList, generated by an Executor
 * @constructor
 */
var ProgramData = function(){
    /**
     * @type {Array.<ProgramInputConnection>}
     */
    this.inputs = [];

    /**
     *
     * @type {Array.<DataSlot>}
     */
    this.outputs = [];

    /**
     * iterateCount: How often we iterate with the default execution model
     * iterFlag: Per input: true if the input can be iterated, otherwise false
     * customData: Per instance data that users can persist between operator invocations
     * @type {Array.<{iterateCount: number, iterFlag: Array, customData: {}}>}
     */
    this.operatorData = [];
};

ProgramData.prototype.getChannel = function(index){
    return this.inputs[index].channel;
};

ProgramData.prototype.getDataEntry = function(index){
    var entry = this.inputs[index];
    var channel = entry.channel;
    if(!channel) return null;
    var key = 0;
    if(entry.sequenceKeySourceChannel){
        var keyDataEntry = entry.sequenceKeySourceChannel.getDataEntry();
        key = keyDataEntry && keyDataEntry._value ? keyDataEntry._value[0] : 0;
    }

    return channel.getDataEntry(entry.sequenceAccessType, key);
};

/**
 * @constructor
 */
var ProgramInputConnection = function(){
    /**
     * @type {Channel}
     */
    this.channel = null;

    /**
     * Is this input a uniform array
     * @type {boolean}
     */
    this.arrayAccess = false;

    /**
     * @type {C.SEQUENCE}
     */
    this.sequenceAccessType = C.SEQUENCE.NO_ACCESS;

    /**
     *
     * @type {Channel|null}
     */
    this.sequenceKeySourceChannel = null;
};

/**
 * Hash-able key to identify equal inputs within executor
 * @returns {string}
 */
ProgramInputConnection.prototype.getKey = function(){
    return (this.channel ? this.channel.id : "NULL") + ";" + this.arrayAccess + ";" + this.sequenceAccessType + ";" +
    ( this.sequenceKeySourceChannel ? this.sequenceKeySourceChannel.id : "");
};


var c_program_cache = {};

var createProgram = function(operatorList){
    var firstOperator;

    if(operatorList.entries.length === 0) {
        return null;
    }

    firstOperator = operatorList.entries[0].operator;

    var key = operatorList.getKey();
    if(!c_program_cache[key]){
        // GLSL operators are implemented in a different way, so platform information is fetched from the operatorList
        // as a fallback mode to not break the old implementations
        if(operatorList.platform === C.PLATFORM.GLSL){
            c_program_cache[key] = new VSProgram(operatorList);

        } else if (firstOperator.platform === C.PLATFORM.CL) {
            c_program_cache[key] = new CLProgram(operatorList);

        }else if(firstOperator.platform === C.PLATFORM.JAVASCRIPT && operatorList.entries.length === 1 ) {
            c_program_cache[key] = new SingleProgram(operatorList);

        }else {
            Base.notifyError("Could not create program from operatorList");
        }
    }
    return c_program_cache[key];
};



var SingleProgram = function(operatorList){
    this.list = operatorList;
    this.entry = operatorList.entries[0];
    this.operator = this.entry.operator;
    this._inlineLoop = null;
};

SingleProgram.prototype.run = function(programData, asyncCallback){
    var operatorData = prepareOperatorData(this.list, 0, programData);

    if(asyncCallback)
        applyAsyncOperator(this.entry, programData, operatorData, asyncCallback);
    else if(this.operator.evaluate_core){
        applyCoreOperation(this, programData, operatorData);
    }
    else{
        applyDefaultOperation(this.entry, programData, operatorData);
    }
};

function applyDefaultOperation(entry, programData, operatorData){
    var args = assembleFunctionArgs(entry, programData);
    args.push(operatorData);
    entry.operator.evaluate.apply(operatorData, args);
    handlePostProcessOutput(entry, programData, args, false);
}

function applyAsyncOperator(entry, programData, operatorData, asyncCallback){
    var args = assembleFunctionArgs(entry, programData, true);
    args.push(operatorData);
    args.push(function(){
        handlePostProcessOutput(entry, programData, args, true);
        asyncCallback();
    });
    entry.operator.evaluate_async.apply(operatorData, args);
}

function applyCoreOperation(program, programData, operatorData){
    var args = assembleFunctionArgs(program.entry, programData);
    args.push(operatorData.iterateCount);

    if(!program._inlineLoop){
        program._inlineLoop = createOperatorInlineLoop(program.operator, operatorData);
    }
    program._inlineLoop.apply(operatorData, args);
}

var c_VarPattern = /var\s+(.)+[;\n]/;
var c_InnerVarPattern = /[^=,\s]+\s*(=[^,]+)?(,)?/;
function createOperatorInlineLoop(operator, operatorData){

    var code = "function (";
    var funcData = parseFunction(operator.evaluate_core);
    code += funcData.args.join(",") + ",__xflowMax) {\n";
    code += "    var __xflowI = __xflowMax\n" +
        "    while(__xflowI--){\n";

    var body = funcData.body;
    body = replaceArrayAccess(body, funcData.args, operator, operatorData);
    code += body + "\n  }\n}";

    var inlineFunc = eval("(" + code + ")");
    return inlineFunc;
}

    var c_FunctionPattern = /function\s*([^(]*)\(([^)]*)\)\s*\{([\s\S]*)\}/;

function parseFunction(func){
    var result = {};
    var matches = func.toString().match(c_FunctionPattern);
    if(!matches){
        Base.notifyError("Xflow Internal: Could not parse function: " + func);
        return null;
    }
    result.args = matches[2].split(",");
    for(var i in result.args) result.args[i] = result.args[i].trim();
    result.body = matches[3];
    return result;
}

var c_bracketPattern = /([a-zA-Z_$][\w$]*)(\[)/;

function replaceArrayAccess(code, args, operator, operatorData){
    var result = "";
    var index = 0, bracketIndex = code.indexOf("[", index);
    while(bracketIndex != -1){
        var key = code.substr(index).match(c_bracketPattern)[1];

        var argIdx = args.indexOf(key);
        var addIndex = false, tupleCnt = 0;
        if(argIdx != -1){
            if(argIdx < operator.outputs.length){
                addIndex = true;
                tupleCnt = C.DATA_TYPE_TUPLE_SIZE[[operator.outputs[argIdx].type]];
            }
            else{
                var i = argIdx - operator.outputs.length;
                addIndex = operatorData.iterFlag[i];
                tupleCnt = C.DATA_TYPE_TUPLE_SIZE[operator.mapping[i].internalType];
            }
        }

        result += code.substring(index, bracketIndex) + "[";
        if(addIndex){
            result += tupleCnt + "*__xflowI + ";
        }
        index = bracketIndex + 1;
        bracketIndex = code.indexOf("[", index);
    }
    result +=  code.substring(index);
    return result;
}


function prepareOperatorData(list, idx, programData){
    var data = programData.operatorData[0];
    var entry = list.entries[idx];
    var mapping = entry.operator.mapping;
    data.iterFlag = {};
    for(var i = 0; i < mapping.length; ++i){
        var doIterate = (entry.isTransferInput(i) || list.isInputIterate(entry.getDirectInputIndex(i)));
        data.iterFlag[i] = doIterate;
    }
    data.iterateCount = list.getIterateCount(programData);
    if(!data.customData)
        data.customData = {};
    return data;
}

function assembleFunctionArgs(entry, programData, async){
    var args = [];
    var outputs = entry.operator.outputs;
    for(var i = 0; i < outputs.length; ++i){
        if(outputs[i].noAlloc){
            args.push({assign: null});
        }
        else{
            var dataSlot = programData.outputs[entry.getOutputIndex(i)];
            var dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;
            args.push(dataEntry ? dataEntry.getValue() : null);
        }
    }
    addInputToArgs(args, entry, programData);
    return args;
}
function handlePostProcessOutput(entry, programData, parameters, async){
    var outputs = entry.operator.outputs;
    for(var i = 0; i < outputs.length; ++i){
        var dataSlot = programData.outputs[entry.getOutputIndex(i)];
        if(outputs[i].noAlloc){
            var dataEntry = async ? dataSlot.asyncDataEntry : dataSlot.dataEntry;
            if(dataEntry.type == C.DATA_TYPE.TEXTURE ){
                dataEntry._setImage(parameters[i].assign);
            }
            else{
                dataEntry._setValue(parameters[i].assign);
            }
        }
        if(async){
            dataSlot.swapAsync();
        }
    }
}


function addInputToArgs(args, entry, programData){
    var mapping = entry.operator.mapping;
    for(var i = 0; i < mapping.length; ++i){
        var mapEntry = mapping[i];
        var dataEntry = programData.getDataEntry(entry.getDirectInputIndex(i));
        args.push(dataEntry ? dataEntry.getValue() : null);
    }
}

module.exports = {
    createProgram: createProgram,
    ProgramData: ProgramData,
    ProgramInputConnection: ProgramInputConnection
};

},{"../base.js":178,"../interface/constants.js":179,"./cl-program.js":183,"./vs-program.js":221}],221:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var Utils = require("../utils/utils.js");
var VertexShader = require("../processing/vs-connect.js").VertexShader;

//----------------------------------------------------------------------------------------------------------------------
// OperatorList
//----------------------------------------------------------------------------------------------------------------------

var c_SHADER_CONSTANT_TYPES = {};
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.OBJECT_ID] = 'int';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL] = 'mat3';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL] = 'mat3';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM] = 'mat4';
c_SHADER_CONSTANT_TYPES[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM_NORMAL] = 'mat3';

var VSProgram = function(operatorList){
    this.list = operatorList;
    this._outputInfo = {};
    setOutputIterate(this);
};

VSProgram.prototype.getOutputNames = function(){
    return Object.keys(this._outputInfo);
};

VSProgram.prototype.getOutputType = function(name){
    return this._outputInfo[name].type;
};

VSProgram.prototype.isOutputUniform = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.ONE;
};

VSProgram.prototype.isOutputNull = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.NULL;
};

VSProgram.prototype.createVertexShader = function(programData, vsConfig){
    var result = new VertexShader(programData);
    constructVS(result, this, vsConfig);
    return result;
};

function setOutputIterate(program){
    var operatorList = program.list, entries = operatorList.entries;

    var baseEntry = entries[entries.length - 1], baseOperator = baseEntry.operator;

    for( var i = 0; i < baseOperator.params.length; ++i){
        var entry = baseOperator.params[i],
            name = entry.source,
            inputIndex = i,
            directInputIndex = baseEntry.getDirectInputIndex(inputIndex);
        program._outputInfo[name] = {type: entry.type};
        if( baseEntry.isTransferInput(inputIndex) ||
            operatorList.isInputIterate(directInputIndex))
        {
            program._outputInfo[name].iteration = C.ITERATION_TYPE.MANY;
        }
        else if(operatorList.isInputUniform(directInputIndex)){
            program._outputInfo[name].iteration = C.ITERATION_TYPE.ONE;
        }
        else{
            program._outputInfo[name].iteration = C.ITERATION_TYPE.NULL;
        }
    }
}

function constructVS(vs, program, vsConfig){
    var operatorList = program.list, entries = operatorList.entries;

    var usedNames = [],
        directInputNames = {},
        transferNames = {};

    var baseEntry = entries[entries.length - 1], acceptedBaseShaderInput = [], baseOperator = baseEntry.operator;

    if(!vsConfig)
        throw new Error("Could not find vsConfig! Attempt to create vertex shader programm without VS operator?");

    Utils.nameset.add(usedNames, vsConfig.getBlockedNames());

    var code = "";
    code += "// OUTPUT\n";
    // First: collect output names
    for(var name in vsConfig._addOutput){
        var entry = vsConfig._addOutput[name];
        code += "varying " + getGLSLType(entry.type) + " " + name + ";\n";
        Utils.nameset.add(usedNames, name);
    }
    var inputIndex = 0;
    for( var name in vsConfig._attributes){
        var configAttr = vsConfig._attributes[name],
            directInputIndex = baseEntry.getDirectInputIndex(inputIndex);
        for(var i = 0; i < configAttr.channeling.length; ++i){
            var channeling = configAttr.channeling[i];
            var outputInfo = {type: configAttr.type, iteration: 0, index: 0, sourceName: name},
                outputName = channeling.outputName;
            if( channeling.code ||
                baseEntry.isTransferInput(inputIndex) ||
                operatorList.isInputIterate(directInputIndex))
            {
                acceptedBaseShaderInput[inputIndex] = true;
                outputInfo.iteration = C.ITERATION_TYPE.MANY;
                var type = baseOperator.outputs[inputIndex].type;
                code += "varying " + getGLSLType(type) + " " + outputName + ";\n";
                Utils.nameset.add(usedNames, outputName);
                transferNames[baseEntry.getTransferOutputId(i)] = outputName;
            }
            else if(operatorList.isInputUniform(directInputIndex)){
                outputInfo.iteration = C.ITERATION_TYPE.ONE;
                outputInfo.index = directInputIndex;
            }
            else{
                outputInfo.iteration = C.ITERATION_TYPE.NULL;
            }
            Utils.nameset.add(vs._outputNames, outputName);
            vs._outputInfo[outputName] = outputInfo;
        }
        inputIndex++;
    }
    code += "\n";
    code += "// INPUT\n";
    // Add additional input
    for(var name in vsConfig._addInput){
        var entry = vsConfig._addInput[name];
        code += (entry.uniform ? "uniform " : "attribute " ) + getGLSLType(entry.type) + " " + name + ";\n";
        Utils.nameset.add(usedNames, name);
    }
    // Second: collect input names
    for(var i = 0; i < entries.length; ++i){
        var entry = entries[i], operator = entry.operator;
        for(var j = 0; j < operator.mapping.length; ++j){
            if( (i < entries.length - 1 || acceptedBaseShaderInput[j]) &&
                    !entry.isTransferInput(j) && !directInputNames[entry.getDirectInputIndex(j)])
            {
                var mapEntry = operator.mapping[j];
                var name = getFreeName(mapEntry.name, usedNames), inputIndex = entry.getDirectInputIndex(j),
                    uniform = !operatorList.isInputIterate(inputIndex);
                vs._inputInfo[name] = { index: inputIndex, uniform: uniform };
                Utils.nameset.add(vs._inputNames, name);
                directInputNames[inputIndex] = name;
                code += (uniform ? "uniform " : "attribute ") + getGLSLType(mapEntry.internalType) + " " + name;
                if(mapEntry.array)
                    code += "[" + operatorList.getInputSize(inputIndex) + "]";
                code += ";\n";
            }
        }
    }

    // Start main
    code += "\n// CODE\n";
    code += "void main(void){\n";

    // Create Code
    for(var i = 0; i < entries.length; ++i){
        var entry = entries[i], operator = entry.operator;
        // Declare transfer output names
        for(var j = 0; j < operator.outputs.length; ++j){
            if(!entry.isFinalOutput(j)){
                var name = getFreeName(operator.outputs[j].name, usedNames);
                transferNames[entry.getTransferOutputId(j)] = name;
                code += "\t" + getGLSLType(operator.outputs[j].type) + " " + name + ";\n";
            }
        }
        // Take Code Fragment
        var codeFragment = convertCodeFragment(operator.evaluate_glsl, entry,
                                transferNames, directInputNames, usedNames);
        code += codeFragment + "\n";
    }

    // Add attribute channeling code
    var mappingIndex = 0, conversionCode = "";
    for( var name in vsConfig._attributes){
        var entry = vsConfig._attributes[name];
        for(var i = 0; i < entry.channeling.length; ++i){
            var channeling = entry.channeling[i], outputName = channeling.outputName;
            if(vs._outputInfo[outputName].iteration == C.ITERATION_TYPE.MANY){
                if(channeling.code)
                    conversionCode += "\t" + channeling.code + "\n";
                else
                    conversionCode += "\t" + outputName + " = #I{" + name + "};\n";
            }
        }
        mappingIndex++;
    }
    for( var i = 0; i < vsConfig._codeFragments.length; ++i){
        conversionCode += "\t" + vsConfig._codeFragments[i] + "\n";
    }
    code += convertCodeFragment(conversionCode, baseEntry, transferNames, directInputNames, usedNames) + "\n";

    code += "}\n";
    vs._glslCode = code;
}

function convertCodeFragment(codeFragment, entry, transferNames, directInputNames, usedNames){
    var index, operator = entry.operator;
    while((index = codeFragment.indexOf("#I{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var mappingIndex = getMappingIndex(operator, codeFragment.substring(index+3,end));
        var replaceName = entry.isTransferInput(mappingIndex) ?
            transferNames[entry.getTransferInputId(mappingIndex)] :
            directInputNames[entry.getDirectInputIndex(mappingIndex)];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    while((index = codeFragment.indexOf("#O{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var outputIndex = getOutputIndex(operator, codeFragment.substring(index+3,end));
        var replaceName = transferNames[entry.getTransferOutputId(outputIndex)];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    var localNames = [];
    while((index = codeFragment.indexOf("#L{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var key = codeFragment.substring(index+3,end);
        if(!localNames[key]){
            localNames[key] = getFreeName(key, usedNames);
        }
        var replaceName = localNames[key];
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    while((index = codeFragment.indexOf("#G{")) != -1){
        var end = codeFragment.indexOf("}",index);
        var replaceName = codeFragment.substring(index+3,end);
        codeFragment = codeFragment.substring(0, index) + replaceName + codeFragment.substring(end+1);
    }
    return codeFragment;
}

function getFreeName(name, usedNames){
    var result = name, i = 1;
    while(usedNames.indexOf(result) != -1){
        result = name + "_" + (++i);
    }
    Utils.nameset.add(usedNames, result);
    return result;
}

function getMappingIndex(operator, name){
    for(var i = 0; i < operator.mapping.length; ++i){
        if(operator.mapping[i].name == name)
            return i;
    }
    throw new Error("Invalid input name '" + name  + "' inside of code fragment" );
}

function getOutputIndex(operator, name){
    for(var i = 0; i < operator.outputs.length; ++i){
        if(operator.outputs[i].name == name)
            return i;
    }
}

function getGLSLType(xflowType){
    switch(xflowType){
        case C.DATA_TYPE.BOOL : return 'bool';
        case C.DATA_TYPE.BYTE : return 'uint';
        case C.DATA_TYPE.FLOAT : return 'float';
        case C.DATA_TYPE.FLOAT2 : return 'vec2';
        case C.DATA_TYPE.FLOAT3 : return 'vec3';
        case C.DATA_TYPE.FLOAT4 : return 'vec4';
        case C.DATA_TYPE.FLOAT3X3 : return 'mat3';
        case C.DATA_TYPE.FLOAT4X4 : return 'mat4';
        case C.DATA_TYPE.INT : return 'int';
        case C.DATA_TYPE.INT4 : return 'ivec4';
    }
    throw new Error("Type not supported for GLSL " + C.getTypeName(xflowType) );
}

module.exports = VSProgram;

},{"../base.js":178,"../interface/constants.js":179,"../processing/vs-connect.js":229,"../utils/utils.js":230}],222:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var Channels = require("./channel.js");
var RequestNode = require("./process-node.js").RequestNode;
var ProcessNode = require("./process-node.js").ProcessNode;
var DataSlot = require("./data-slot.js");
var Operator = require("../operator/operator.js");

var ChannelMap = Channels.ChannelMap;

//----------------------------------------------------------------------------------------------------------------------
// ChannelNode
//----------------------------------------------------------------------------------------------------------------------

/**
 * Is created for each substitution (via dataflow) of a DataNode.
 * Stores an optimized representation of the data with ChannelMaps and Channels
 * On construction a ChannelNode is marked outOfSync and synchronized only once data is requested.
 * When the structure of a DataNode is changed in any way (e.g. rename InputNode, add/remove children) a channelNode
 * is marked outOfSync.
 * @param {DataNode} dataNode
 * @param {Substitution} substitution
 * @constructor
 */
var ChannelNode = function(dataNode, substitution){
    this.owner = dataNode;
    this.platform = C.PLATFORM.JAVASCRIPT;
    this.substitution = substitution;   // Substitution is defined by the dataflow instance
    this.loading = false;   // is true if any value in the sub tree is loading and the result can't be calculated
    this.inputSlots = {};   // DataEntries from direct InputNode children of the DataNode
    this.inputChannels = new ChannelMap();    // channel map for input data prio to operator execution
    this.computedChannels = new ChannelMap(); // channel map extend by operator output
    this.outputChannels = new ChannelMap();   // channel map with applied filter => final output

    /**
     * Operator attached to DataNode (guaranteed to be resolved)
     * @type {Object}
     */
    this.operator = null;
    /**
     * Channel node of the dataflowNode (analogue to dataflowNode of DataNode)
     * @type {ChannelNode}
     */
    this.dataflowChannelNode = null;
    /**
     * Process node - only constructed if an operator/dataflow is defined
     * @type {ProcessNode}
     */
    this.processNode = null;
    /**
     * Request Nodes created for each result request on this dataNode.
     * @type {Object.<String,RequestNode>}
     */
    this.requestNodes = {};
    /**
     * Number of uses of channel node. This is only relevant for channel nodes created with substitution.
     * These nodes are cached and the useCount is used to clean this cache.
     * TODO: Use weakmap here to avoid explicit reference count
     * @type {number}
     */
    this.useCount = 1;
    /**
     * True if the channel node is out of sync and internal channel maps need to be reconstructed
     * @type {boolean}
     */
    this.outOfSync = true;
};

/**
 * If node is out of sync, reconstruct all channels
 */
ChannelNode.prototype.synchronize = function(){

    if(this.outOfSync){
        updatePlatform(this);
        synchronizeChildren(this);
        updateInputChannels(this);
        updateComputedChannels(this);
        updateOutputChannels(this);
        this.outOfSync = false;
    }
};

ChannelNode.prototype.clear = function(){
    this.useCount = 0;
     this.inputChannels.clear();
     this.outputChannels.clear();
     // TODO: Make sure everything is cleaned up there!
    return true;
};

ChannelNode.prototype.increaseRef = function(){
    this.useCount++;
};

ChannelNode.prototype.decreaseRef = function(){
    this.useCount--;
    if(this.useCount == 0){
        this.clear();
        return true;
    }
    return false;
};

ChannelNode.prototype.getOutputNames = function(){
    this.synchronize();
    return this.outputChannels.getNames();
};

ChannelNode.prototype.getChildDataIndex = function(filter){
    this.synchronize();
    return this.outputChannels.getChildDataIndexForFilter(filter);
};

ChannelNode.prototype.setStructureOutOfSync = function()
{
    if(!this.outOfSync){
        this.outOfSync = true;
        this.inputChannels.clear();
        this.computedChannels.clear();
        this.outputChannels.clear();
        this.processNode && this.processNode.clear();
        for(var key in this.requestNodes){
            this.requestNodes[key].setStructureOutOfSync();
        }
    }
};

ChannelNode.prototype.notifyDataChange = function(inputNode, changeType){
    var key = inputNode._name + ";" + inputNode._key;
    if(this.inputSlots[key])
        this.inputSlots[key].setDataEntry(inputNode._data, changeType);
};

ChannelNode.prototype.getResult = function(type, filter) {
    this.synchronize();

    var key = filter ? filter.join(";") : "[null]";
    if(!this.requestNodes[key]){
        this.requestNodes[key] = new RequestNode(this, filter);
    }
    return this.requestNodes[key].getResult(type);
};


ChannelNode.prototype.getOutputChannelInfo = function(name){
    this.synchronize();

    var channel = this.outputChannels.getChannel(name);
    if(!channel)
        return null;
    var result = {
        type: channel.getType(),
        seqLength: channel.getSequenceLength(),
        seqMinKey: channel.getSequenceMinKey(),
        seqMaxKey: channel.getSequenceMaxKey(),
        origin: 0,
        originalName: ""
    };
    var preFilterName = this.owner._filterMapping ? this.owner._filterMapping.getRenameSrcName(name) : name;
    var dataEntry = channel.getDataEntry();
    if(this.dataflowChannelNode){
        var protoInputChannel = this.inputChannels.getChannel(preFilterName);
        if(!protoInputChannel || dataEntry != protoInputChannel.getDataEntry()){
            result.origin = C.ORIGIN.PROTO;
            result.originalName = preFilterName;
            return result;
        }
    }
    if(this.operator){
        var inputChannel = this.inputChannels.getChannel(preFilterName);
        if(!inputChannel || dataEntry != inputChannel.getDataEntry()){
            result.origin = C.ORIGIN.COMPUTE;
            result.originalName = this.owner._computeOutputMapping.getScriptOutputNameInv(preFilterName, this.operator.outputs);
            return result;
        }
    }
    result.origin = C.ORIGIN.CHILD;
    result.originalName = preFilterName;
    return result;
};

/**
 * Select the platform to compute the attached platform
 * @param {ChannelNode} channelNode
 */
function updatePlatform(channelNode) {
    var platform;
    var owner = channelNode.owner;
    var graph = owner._graph;

    // Platforms other than JavaScript are available only for computing operators
    if(!channelNode.owner._computeOperator) {
        return;
    }

    //TODO: Improve platform selection logic.
    // Currently we use forced platform if graph platform is something other than JavaScript
    // and forced platform (owner._platform) is defined
    platform = owner._platform !== null ? owner._platform : C.PLATFORM.JAVASCRIPT;

    channelNode.platform = platform;
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function synchronizeChildren(channelNode){
    var dataNode = channelNode.owner;
    channelNode.loading = dataNode.isSubtreeLoading();

    /**
     * If the channel node represents a substitution, we also need to
     * synchronize the main ChannelNode of the DataNode
     */
    if(channelNode.substitution) {
        dataNode._channelNode.synchronize();
    }

    // Now synchronize all children (either referenced data node, or real children)
    // TODO: Change here if we change behaviour of src attribute
    if(dataNode._sourceNode){
        dataNode._sourceNode._getOrCreateChannelNode(channelNode.substitution).synchronize();
    }
    else{
        for(var i = 0; i < dataNode._children.length; ++i){
            if(dataNode._children[i]._getOrCreateChannelNode){
                dataNode._children[i]._getOrCreateChannelNode(channelNode.substitution).synchronize();
            }
        }
    }
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function updateInputChannels(channelNode){
    var owner = channelNode.owner;
    // TODO: Change here if we change behaviour of src attribute
    if(owner._sourceNode){
        channelNode.inputChannels.merge(owner._sourceNode._getOrCreateChannelNode(channelNode.substitution).outputChannels, 0);
    }
    else{
        var children = owner._children;
        // First the DataNodes than the input nodes in order to override the DataNode channels
        mergeInputChannelDataNodes(channelNode, children);
        mergeInputChannelInputNodes(channelNode, children);
    }
}

/**
 * @param {ChannelNode} channelNode
 * @param {Array.<GraphNode>} children
 */
function mergeInputChannelInputNodes(channelNode, children) {
    for (var i = 0; i < children.length; ++i) {
        if (!children[i]._getOrCreateChannelNode) {  // Child is an InputNode
            var child = children[i];
            var key = child._name + ";" + child._key;
            if (!channelNode.substitution) {  // No dataflow
                var slot = new DataSlot(child._data, child._key);
                channelNode.inputSlots[key] = slot;
                channelNode.inputChannels.addDataEntry(child._name, slot);
            } else {
                if (child._paramName && channelNode.substitution.hasChannel(child._paramName)) {
                    channelNode.inputChannels.addChannel(child._name, channelNode.substitution.getChannel(child._paramName));
                } else {
                    channelNode.inputChannels.addDataEntry(child._name, channelNode.owner._channelNode.inputSlots[key]);
                }
            }
        }
    }
}

/**
 * @param {ChannelNode} channelNode
 * @param {Array.<GraphNode>} children
 */
function mergeInputChannelDataNodes(channelNode, children) {
    for (var i = 0; i < children.length; ++i) {
        if (children[i]._getOrCreateChannelNode) {  // Child is a DataNode
            channelNode.inputChannels.merge(children[i]._getOrCreateChannelNode(channelNode.substitution).outputChannels, i);
        }
    }
}

function updateComputedChannels(channelNode){
    var owner = channelNode.owner;
    channelNode.computedChannels.merge(channelNode.inputChannels);

    var oldDataflowChannelNode = channelNode.dataflowChannelNode;

    if( owner._computeUsesDataflow && owner._dataflowNode){
        channelNode.operator = null;
        updateDataflowChannelNode(channelNode);
        updateComputedChannelsFromDataflow(channelNode);
    }
    else if(!owner._computeUsesDataflow && owner._computeOperator){
        channelNode.dataflowChannelNode = null;
        updateOperator(channelNode);
        updateComputedChannelsFromOperator(channelNode);
    }

    if(oldDataflowChannelNode && oldDataflowChannelNode != channelNode.dataflowChannelNode){
        oldDataflowChannelNode.owner._removeSubstitutionNode(oldDataflowChannelNode);
    }
}

/**
 * Find and set the operator for the given ChannelNode
 * @param channelNode
 */
function updateOperator(channelNode){
    var operatorName, operator;
    var owner = channelNode.owner;

    if(channelNode.loading){
        channelNode.operator = null;
        return;
    }
    if(typeof owner._computeOperator == "string"){
        operatorName = owner._computeOperator;
        operator = null;

        // Getting a correct operator for the selected platform. If operator is not available, we'll try to get
        // the default JavaScript platform operator
        if(operatorName){
            operator = findOperatorByName(channelNode, owner);
            if(operator) { // TODO: Is this good? We calculated the platform before, now it just gets overriden
                channelNode.platform = operator.platform;
            }
        }
        channelNode.operator = operator;
    }else{
        channelNode.operator = owner._computeOperator;
    }
}

var c_typeComparisons = [];

/**
 * Find operator based on name in dataNode, platform and input mapping (signature)
 * @param {ChannelNode} channelNode
 * @param {DataNode} dataNode
 * @returns {Object|null}
 */
function findOperatorByName(channelNode, dataNode){
    var operatorName = dataNode._computeOperator,
        inputMapping = dataNode._computeInputMapping,
        inputChannels = channelNode.inputChannels;

    var operators = Operator.getOperators(operatorName, channelNode.platform) ||
                Operator.getOperators(operatorName, C.PLATFORM.JAVASCRIPT);
    if(!operators){
        Base.notifyError("No operator with name '" + operatorName+"' found", channelNode.owner);
    }

    var i = operators.length;
    while(i--){
        if(checkOperator(operators[i], inputMapping, inputChannels)){
            return operators[i];
        }
    }
    c_typeComparisons.length = 0;
    i = operators.length;
    while(i--){
        checkOperator(operators[i], inputMapping, inputChannels, c_typeComparisons);
    }
    var errorMessage = "No operator '" + operatorName+"' with matching type signature found:\n\n"
                        + c_typeComparisons.join("\n");
    Base.notifyError(errorMessage, channelNode.owner);
    return null;
}

/**
 *
 * @param operator
 * @param inputMapping
 * @param inputChannels
 * @param {Array?} typeComparisonsOutput If array is give, save error information
 * @returns {boolean}
 */
function checkOperator(operator, inputMapping, inputChannels, typeComparisonsOutput){
    var inputs, errors;
    if(typeComparisonsOutput){
        inputs = []; errors = [];
    }
    for(var i = 0; i < operator.params.length; ++i){
        var inputEntry = operator.params[i], sourceName = inputEntry.source;
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, sourceName) : sourceName;
        var errorHeader;
        if(typeComparisonsOutput){
            errorHeader = "For " + (i+1) + ". argument '" + sourceName + "': ";
            inputs.push( C.getTypeName(inputEntry.type) + " " + sourceName + (inputEntry.optional ? " [optional]" : ""));
        }
        if(dataName){
            var channel = inputChannels.getChannel(dataName);
            if(!channel && !inputEntry.optional){
                if(!typeComparisonsOutput)
                    return false;
                else{
                    errors.push(errorHeader + "DataEntry '" + dataName + "' does not exist");
                }
            }
            if(channel && channel.getType() != inputEntry.type){
                if(!typeComparisonsOutput)
                    return false;
                else{
                    errors.push(errorHeader + "DataEntry '" + dataName + "' has wrong type '" + C.getTypeName(channel.getType()) + "'");
                }
            }
        }
    }
    if(typeComparisonsOutput){
        typeComparisonsOutput.push(operator.name + "(" + inputs.join(", ") + ")\n\t * " + errors.join("\n\t * "));
    }
    return true;
}

/**
 *
 * @param channelNode
 */
function updateComputedChannelsFromOperator(channelNode){
    var owner = channelNode.owner;
    if(channelNode.operator){
        var procNode = channelNode.processNode = new ProcessNode(channelNode);
        var index = 0;
        for(var name in procNode.outputDataSlots){
            var destName = name;
            if(owner._computeOutputMapping) destName = owner._computeOutputMapping.getScriptOutputName(index, name);
            if(destName){
                channelNode.computedChannels.addOutputDataSlot(destName, procNode.outputDataSlots[name], procNode);
            }
            index++;
        }
    }
}

/**
 *
 * @param {ChannelNode} channelNode
 */
function updateDataflowChannelNode(channelNode){
    var owner = channelNode.owner;
    var subSubstitution = new Substitution(owner._dataflowNode, channelNode);
    channelNode.dataflowChannelNode = owner._dataflowNode._getOrCreateChannelNode(subSubstitution);
}

/**
 * @param {ChannelNode} channelNode
 */
function updateComputedChannelsFromDataflow(channelNode){
    var owner = channelNode.owner;
    if(channelNode.dataflowChannelNode){
        var dataflowCNode = channelNode.dataflowChannelNode;
        dataflowCNode.synchronize();
        // TODO: We have to make sure to get outputNames in the right order to apply output mapping correctly
        var outputNames = dataflowCNode.outputChannels.getNames();
        for(var i = 0; i < outputNames.length; ++i){
            var srcName = outputNames[i], destName = srcName;
            if(owner._computeOutputMapping)
                destName = owner._computeOutputMapping.getScriptOutputName(i, srcName);
            if(destName)
                channelNode.computedChannels.addChannel(destName, dataflowCNode.outputChannels.getChannel(srcName));
        }
    }
}

function updateOutputChannels(channelNode){
    var dataNode = channelNode.owner;
    if(dataNode._filterMapping) {
        // TODO: This is the only location where applyFilterOnChannelMap is used. Can be simplified (e.g. without callback)
        dataNode._filterMapping.applyFilterOnChannelMap(channelNode.outputChannels, channelNode.computedChannels, dataNode._filterType, setChannelFilterCallback);
    }
    else
        channelNode.outputChannels.merge(channelNode.computedChannels);
}

function setChannelFilterCallback(destMap, destName, srcMap, srcName){
    var channel = srcMap.getChannel(srcName);
    destMap.addChannel(destName, channel, srcMap.getChildDataIndex(srcName));
}

//----------------------------------------------------------------------------------------------------------------------
// Substitution
//----------------------------------------------------------------------------------------------------------------------

/**
 * TODO: Think of replacing this with a channel map
 * @param dataflowNode
 * @param userChannelNode
 * @constructor
 */
var Substitution = function(dataflowNode, userChannelNode){
    this.map = {};

    createSubstitution(this, dataflowNode, userChannelNode);
};

Substitution.prototype.hasChannel = function(name){
    return !!this.map[name];
};
Substitution.prototype.getChannel = function(name){
    return this.map[name];
};

/**
 * Create a hashable key for the substiution
 * @param subDataflowNode
 * @returns {string}
 */
Substitution.prototype.getKey = function(subDataflowNode){
    var key = "";
    var globalParamNames = subDataflowNode._getGlobalParamNames();
    for(var i = 0; i < globalParamNames.length; ++i){
        var channel = this.map[globalParamNames[i]];
        key+= (channel && channel.id || "-") + "!";
    }
    var paramNames = subDataflowNode._getParamNames();
    for(i = 0; i < paramNames.length; ++i){
        channel = this.map[paramNames[i]];
        key+= (channel && channel.id || "-") + ".";
    }
    return key;
};

/**
 *
 * @param {Substitution} substitution
 * @param {DataNode} dataflowNode
 * @param {ChannelNode} userChannelNode
 */
function createSubstitution(substitution, dataflowNode, userChannelNode){
    var userOwner = userChannelNode.owner;

    // Find channels for global parameters
    var globalParamNames = dataflowNode._getGlobalParamNames();
    for(var i = 0; i < globalParamNames.length; ++i){
        substitution.map[globalParamNames[i]] = userChannelNode.inputChannels.getChannel(globalParamNames[i]);
    }

    // Find channels for local parameters. These will override existing global parameters
    var paramNames = dataflowNode._getParamNames();
    for(i = 0; i < paramNames.length; ++i){
        var destName = paramNames[i], srcName = destName;
        if(userOwner._computeInputMapping){
            srcName = userOwner._computeInputMapping.getScriptInputName(i, destName);
        }
        substitution.map[destName] = userChannelNode.inputChannels.getChannel(srcName);
    }
}

module.exports = {
    ChannelNode:  ChannelNode,
    Substitution: Substitution
};

},{"../base.js":178,"../interface/constants.js":179,"../operator/operator.js":219,"./channel.js":223,"./data-slot.js":224,"./process-node.js":227}],223:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var BufferEntry = require("../interface/data.js").BufferEntry;


//----------------------------------------------------------------------------------------------------------------------
// DataSlot
//----------------------------------------------------------------------------------------------------------------------


//----------------------------------------------------------------------------------------------------------------------
// ChannelMap
//----------------------------------------------------------------------------------------------------------------------

/**
 * A map with channels.
 * @constructor
 */
var ChannelMap = function(){
    /**
     * A map of channels.
     * @type {Object.<string, {channel: Channel, childDataIndex: Number}>}
     */
    this.map = {};
};


/**
 * Return a list of all keys.
 * @returns {Array.<string>}
 */
ChannelMap.prototype.getNames = function()
{
    return Object.keys(this.map);
};

/**
 *
 * @param name
 * @returns {Channel}
 */
ChannelMap.prototype.getChannel = function(name)
{
    if(!this.map[name])
        return null;
    return this.map[name].channel;
};

ChannelMap.prototype.getChildDataIndex = function(name)
{
    if(!this.map[name])
        return undefined;
    return this.map[name].childDataIndex;
};
ChannelMap.prototype.getChildDataIndexForFilter = function(filter){
    var result;
    filter = filter || this.getNames();
    for(var i = 0; i < filter.length; ++i){
        var idx = this.getChildDataIndex(filter[i]);
        if(idx == undefined) continue;
        if(result != undefined && result != idx)
            result = -1;
        else
            result = idx;
    }
    return result;
};

/**
 * TODO: Add a mergeWithChildIndex method?
 * @param {ChannelMap} otherChannelMap
 * @param {number?} childDataIndex Index relative to DataNode. Used to mark if channel comes
 * from a specific child DataNode, undefined if ChannelMap should take over child index from otherChannelMap
 */
ChannelMap.prototype.merge = function(otherChannelMap, childDataIndex){
    for(var name in otherChannelMap.map){
        // Either use provided child index, otherwise use child index from ChannelMap to merge
        // For input channel map we define the childDataIndex directly, for applied filters we use the
        // childDataIndex of the provided ChannelMap (it's just a renaming)
        var index = childDataIndex == undefined ? otherChannelMap.getChildDataIndex(name) : childDataIndex;
        this.addChannel(name, otherChannelMap.getChannel(name), index);
    }
};
/**
 * Add a channel with a childDataIndex
 * The childDataIndex defines the origin of the channel.
 * If childDataIndex is undefined the value of the channel can't be determined from one single DataNode
 * @param {String} name
 * @param {Channel} channel
 * @param {Number?} childDataIndex
 */
ChannelMap.prototype.addChannel = function(name, channel, childDataIndex){
    // TODO: Check if this is ever called with a proper childDataIndex value
    if(!channel) return;
    if(childDataIndex == undefined) childDataIndex = -1;
    mergeChannelIntoChannel(this, name, channel, childDataIndex);
};

/**
 * Add DataSlot to the Channel
 * @param name
 * @param dataSlot
 */
ChannelMap.prototype.addDataEntry = function(name, dataSlot)
{
    mergeDataSlotIntoChannel(this, name, dataSlot, -1);
};
/**
 * Add an output DataSlot that originates from an operator
 * @param {String} name
 * @param {DataSlot} dataSlot
 * @param {ProcessNode} creatorNode
 */
ChannelMap.prototype.addOutputDataSlot = function(name, dataSlot, creatorNode){
    var finalChannel = mergeDataSlotIntoChannel(this, name, dataSlot, -1);
    finalChannel.creatorProcessNode = creatorNode;
};

/**
 * Empty the channel map.
 */
ChannelMap.prototype.clear = function(){
    for(var name in this.map){
        var channel = this.map[name];
        if(channel && channel.map == this)
            channel.clear();
    }
    this.map = {};
};

function initChannelSlot(channelMap, name){
    if(!channelMap.map[name]){
        channelMap.map[name] = {
            channel: null,
            childDataIndex: undefined
        }
    }
}

function mergeChannelIntoChannel(channelMap, name, newChannel, childDataIndex){
    initChannelSlot(channelMap, name);
    var currentChannel = channelMap.map[name].channel;
    if(!currentChannel || !currentChannel.willMergeWithChannel(newChannel)) {
        channelMap.map[name].channel = newChannel;
        channelMap.map[name].childDataIndex = childDataIndex;
        return newChannel;
    }
    currentChannel = getMapOwnedChannel(channelMap, currentChannel);
    currentChannel.addChannelEntries(newChannel);
    channelMap.map[name].channel = currentChannel;
    channelMap.map[name].childDataIndex = -1;
    return currentChannel;
}

function mergeDataSlotIntoChannel(channelMap, name, dataSlot, childDataIndex){
    initChannelSlot(channelMap, name);
    var currentChannel = channelMap.map[name].channel;
    if(!currentChannel || !currentChannel.willMergeWithDataSlot(dataSlot)){
        var channel = new Channel(channelMap, dataSlot);
        channelMap.map[name].channel = channel;
        channelMap.map[name].childDataIndex = childDataIndex;
        return channel;
    }
    currentChannel = getMapOwnedChannel(channelMap, currentChannel);
    currentChannel.addDataSlot(dataSlot);
    channelMap.map[name].channel = currentChannel;
    channelMap.map[name].childDataIndex = -1;
    return currentChannel;
}


function getMapOwnedChannel(map, channel){
    if(channel.map != map){
        var newChannel = new Channel(map);
        newChannel.addChannelEntries(channel);
        newChannel.creatorProcessNode = channel.creatorProcessNode;
        return newChannel
    }
    return channel;
}


//----------------------------------------------------------------------------------------------------------------------
// Channel
//----------------------------------------------------------------------------------------------------------------------


/**
 * A channel may inclue several DataSlots/DataEntries
 * A declared Sequence will result in on channel with multiple DataEntries.
 * @constructor
 * @param {ChannelMap} map Owner of the channel
 * @param {DataSlot=} dataSlot Optional DataSlot added to the channel
 */
var Channel = function(map, dataSlot){
    /**
     * DataSlot entries sorted by key value
     * @type {Array.<DataSlot>}
     */
    this.entries = [];
    /**
     * Owner ChannelMap that created with channel.
     * Note: a channel can still exist in several ChannelMaps
     * @type {ChannelMap}
     */
    this.map = map;
    /**
     * Unique ID for this channel. Is used for several optimizations.
     */
    this.id = generateChannelId();
    /**
     * Listeners of this channels (usually ProcessNodes and RequestNodes)
     * @type {Array}
     */
    this.listeners = [];
    /**
     * The ProcessNode that created/extended the content of this channel
     * There can be only one creatorProcessNode per channel because
     * then ouput DataSlots of an operator will always have key "0"
     * If two operators influence the same sequence, the second operator'
     * output will replace the first operator's output, effectively removing the dependency.
     * @type {null}
     */
    this.creatorProcessNode = null;

    if(dataSlot){
        this.addDataSlot(dataSlot);
    }
};

/**
 * Add a dataSlot to the channel, adding dependencies.
 * No notifications send etc.
 * Makes sure that resulting channel has dataSlots ordered by key
 * @param dataSlot
 */
Channel.prototype.addDataSlot = function(dataSlot){
    dataSlot.addChannel(this);
    for(var i = 0; i < this.entries.length; ++i){
        var entry = this.entries[i];
        // We use epsilon here to detect data entries with "equal" key
        if(entry.key >= dataSlot.key - C.EPSILON ){
            if(Math.abs(entry.key - dataSlot.key) <= C.EPSILON){
                entry.removeChannel(this);
                this.entries.splice(i, 1, dataSlot);
            }
            else{
                this.entries.splice(i, 0, dataSlot);
            }
            break;
        }
    }
    this.entries.push(dataSlot);
};

Channel.prototype.getSequenceLength = function(){
    return this.entries.length;
};
Channel.prototype.getSequenceMinKey = function(){
    return this.entries[0].key;
};
Channel.prototype.getSequenceMaxKey = function(){
    return this.entries[this.entries.length - 1].key;
};
/**
 * The DataType of the channel.
 * Since all DataEntries within a channel have the same type, we can simply return the type of the first entry.
 * @returns {DATA_TYPE}
 */
Channel.prototype.getType = function(){
    if(this.entries.length == 0)
        return C.DATA_TYPE.UNKNOWN;
    else
        return this.entries[0].dataEntry._type;
};
/**
 * Merge another channel into this channel.
 */
Channel.prototype.addChannelEntries = function(otherChannel){
    for(var i = 0; i < otherChannel.entries.length; ++i){
        var slot = otherChannel.entries[i];
        this.addDataSlot(slot);
    }
    // FIXME: otherChannel might be without creatorProcessNode but still define a DataSlot with key 0
    // In this case we have to set creatorProcessNode to null
    if(otherChannel.creatorProcessNode)
        this.creatorProcessNode = otherChannel.creatorProcessNode;
    //else
    //    this.creatorProcessNode = null;
};
/**
 * Return a DataEntry from this channel depending on sequenceKey.
 * @param {C.SEQUENCE?} sequenceAccessType
 * @param {number?} sequenceKey
 * @returns {DataEntry}
 */
Channel.prototype.getDataEntry = function(sequenceAccessType, sequenceKey){
    if(this.entries.length == 0)
        return null;
    if(!sequenceAccessType){
        return this.entries[0].dataEntry;
    }


    var i = 0, max = this.entries.length;
    // TODO: Do binary search here?
    while(i < max && this.entries[i].key < sequenceKey) ++i;
    if(sequenceAccessType == C.SEQUENCE.PREV_BUFFER){
        return this.entries[i ? i -1 : 0].dataEntry;
    }
    else if(sequenceAccessType == C.SEQUENCE.NEXT_BUFFER){
        return this.entries[i < max ? i : max - 1].dataEntry;
    }
    else if(sequenceAccessType == C.SEQUENCE.LINEAR_WEIGHT){
        var weight1 = this.entries[i ? i - 1 : 0].key;
        var weight2 = this.entries[i < max ? i : max - 1].key;
        var value = new Float32Array(1);
        value[0] = weight2 == weight1 ? 0 : (sequenceKey - weight1) / (weight2 - weight1);
        // TODO: Check if repeated BufferEntry and Float32Array allocation is a serious bottleneck
        return new BufferEntry(C.DATA_TYPE.FLOAT, value);
    }
    return null;
};

/**
 * Return true of the two channels need to be merged (instead of replacing this channel with otherChannel)
 * @param otherChannel
 * @returns {boolean}
 */
Channel.prototype.willMergeWithChannel = function(otherChannel){
    if(this.entries.length != otherChannel.entries.length) return true;
    if(this.getType() != otherChannel.getType())
        return false;
    for(var i = 0; i < this.entries.length; i++){
        if(Math.abs(this.entries[i].key - otherChannel.entries[i].key) > C.EPSILON)
            return true;
    }
    return false;
};
/**
 * Return true if we need to merge the channel with this dataSlot
 * (instead of creating a new channel fromthis dataSlot)
 * @param dataSlot
 * @returns {boolean}
 */
Channel.prototype.willMergeWithDataSlot = function(dataSlot){
    if(this.entries.length > 1) return true;
    if(this.getType() != dataSlot.dataEntry._type) return false;
    return (Math.abs(this.entries[0].key - dataSlot.key) > C.EPSILON);
};

Channel.prototype.notifyOnChange = function(state){
    for(var i = 0; i < this.listeners.length; i++){
        this.listeners[i].onXflowChannelChange(this, state);
    }
};

Channel.prototype.addListener = function(processNode){
    this.listeners.push(processNode);
};
Channel.prototype.removeListener = function(processNode){
    var idx = this.listeners.indexOf(processNode);
    if(idx != -1) this.listeners.splice(idx, 1);
};

Channel.prototype.clear = function(){
    for(var i = 0; i < this.entries.length; ++i){
        this.entries[i].removeChannel(this);
    }
};

var c_channelKeyIdx = 0;
function generateChannelId(){
    return ++c_channelKeyIdx;
}

module.exports = {
    Channel: Channel,
    ChannelMap: ChannelMap
};

},{"../base.js":178,"../interface/constants.js":179,"../interface/data.js":180}],224:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");

/**
 * A DataSlot wraps a dataEntry and adds a key value for sequences.
 * This structure is used internally within channels and process nodes
 * @constructor
 * @param {DataEntry} dataEntry
 * @param {number=} key
 */
var DataSlot = function(dataEntry, key){
    this.key = key || 0;            // sequence key
    this.dataEntry = dataEntry;     // dataEntry of the slot
    /**
     * alternative dataEntry for asynchronous processing
     * only used for output DataSlots of asynchronous operators
     * @type {DataEntry}
     */
    this.asyncDataEntry = null;
    /**
     * list of all channels that contain this DataSlot
     * @type {Array.<Channel>}
     */
    this.parentChannels = [];

};
DataSlot.prototype.addChannel = function(channel){
    this.parentChannels.push(channel);
};
DataSlot.prototype.removeChannel = function(channel){
    var idx = this.parentChannels.indexOf(channel);
    if(idx != -1) this.parentChannels.splice(idx, 1);
};
DataSlot.prototype.swapAsync = function(){
    var tmp = this.dataEntry;
    this.dataEntry = this.asyncDataEntry;
    this.asyncDataEntry = tmp;
};

DataSlot.prototype.setDataEntry = function(dataEntry, changeType){
    this.dataEntry = dataEntry;
    var state = changeType == C.RESULT_STATE.CHANGED_DATA_VALUE ? C.DATA_ENTRY_STATE.CHANGED_VALUE :
        C.DATA_ENTRY_STATE.CHANGED_SIZE;
    this.notifyOnChange(state);
};

DataSlot.prototype.notifyOnChange = function(state){
    for(var i = 0; i < this.parentChannels.length; ++i){
        this.parentChannels[i].notifyOnChange(state);
    }
};

module.exports = DataSlot;

},{"../base.js":178,"../interface/constants.js":179}],225:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var OperatorList = require("../operator/operator-list.js");
var Utils = require("../utils/utils.js");
var Operator = require("../operator/operator.js");
var OperatorEntry = require("../operator/operator-entry.js");
var Program = require("../operator/program.js");

//----------------------------------------------------------------------------------------------------------------------
// Executor
//----------------------------------------------------------------------------------------------------------------------

/**
 * Tries to combine multiple ProcessNodes into a Program. Currently only used for vertex shaders.
 *
 * @param {RequestNode|ProcessNode} ownerNode
 * @param {C.PLATFORM} platform
 * @constructor
 */
var Executor = function(ownerNode, platform){
    this.platform = platform;

    /**
     * Nodes that are merged by this executor
     * @type {Array.<ProcessNode|RequestNode>}
     */
    this.mergedNodes = [];

    /**
     * Subset of this.mergedNodes that directly provide results of the executor
     * @type {Array.<ProcessNode>}
     */
    this.mergedOutputNodes = [];

    /**
     * ProcessNodes to be executed before this executor can be
     * executed
     * @type {Array.<ProcessNode>}
     */
    this.subNodes = [];

    /**
     * TODO: Unused. Remove?
     * @type {Array}
     */
    this.unprocessedDataNames = [];

    /**
     *  TODO: Maybe we should just store the cl-platform objects in global object so they are more easily available and
     *  to avoid long prototype chains. Or we could pass the graph context to each node of the graph.
     *  However, it would be good to allow each Graph object to have at least own context, cmdQueue and kernelManager.
     *  e.g. passing graph information here requires a long prototype chain
     */
    this.operatorList =  new OperatorList(platform);
    this.programData =  new Program.ProgramData();

    /**
     *
     * @type {Program}
     */
    this.program = null;

    constructExecutor(this, ownerNode);
};

    Executor.prototype.isProcessed = function(){
        var i = this.mergedOutputNodes.length;
        while(i--){
            if(this.mergedOutputNodes[i].status != C.PROCESS_STATE.PROCESSED)
                return false;
        }
        return true;
    };


    Executor.prototype.run = function(asyncCallback){
        runSubNodes(this);
        updateIterateState(this); // TODO check if iterate State has changes in any way and only refetch program in that case

        this.program = Program.createProgram(this.operatorList);

        if(this.program){
            this.operatorList.allocateOutput(this.programData, !!asyncCallback);
            this.program.run(this.programData, asyncCallback);
        }
        if(this.platform != C.PLATFORM.ASYNC){
            var i = this.mergedOutputNodes.length;
            while(i--){
                this.mergedOutputNodes[i].status = C.PROCESS_STATE.PROCESSED;
            }
        }


    };

    Executor.prototype.getVertexShader = function(){
        runSubNodes(this);
        updateIterateState(this);

        this.program = Program.createProgram(this.operatorList);

        return this.program;
    };

/**
 * Construct Executor
 * @param executer
 * @param ownerNode
 */
function constructExecutor(executer, ownerNode){
    var cData = {
        blockedNodes: [],   // Bad Nodes that cannot be merge. Filled during pre scan
        doneNodes: [],      // Nodes that have been signed up for merging. TODO: Redundant with constructionOrder and subNodes? - maybe yes!
        constructionOrder: [], // Store nodes in order of construction of OperatorEntries.
        inputSlots: {},     // Collected input channels of all merged nodes. Used to avoid assigning same input buffer twice
        finalOutput: null,  // finalOutput channes in case we have a RequestNode
        firstOperator: null // Set to first operator that has been merged (will be executed last)
    };
    var requestNode = initRequestNode(cData, executer, ownerNode);

    var noOperators = false; // TODO: Remove this?
    constructPreScan(cData, ownerNode, executer.platform, noOperators);

    setConstructionOrderAndSubNodes(cData, executer, ownerNode);

    constructFromData(executer, cData);
}
/**
 * Only relevant if ownerNodes is a RequestNode
 * Sets finalOutput of construction data and unprocessedDataNames
 * @param cData
 * @param executer
 * @param ownerNode
 * @returns {boolean}
 */
function initRequestNode(cData, executer, ownerNode){
    if(true) { // FIXME: ownerNode instanceof RequestNode){
        cData.finalOutput = {};
        var filter = ownerNode.filter || ownerNode.owner.outputChannels.getNames();
        for(var i = 0; i < filter.length; ++i){
            var name = filter[i];
            var channel = ownerNode.owner.outputChannels.getChannel(name);
            if(channel && channel.creatorProcessNode)
                cData.finalOutput[name] = channel.getDataEntry();
        }
        Utils.nameset.add(executer.unprocessedDataNames, filter);
        return true;
    }
    return false;
}
/**
 * Goes to processing subtree at filled blockedNodes array in construction data.
 * All nodes that cannot be merged or have parents that can't be merged will be blocked
 * @param cData
 * @param node
 * @param platform
 * @param noOperators
 */
function constructPreScan(cData, node, platform, noOperators){
    if(cData.blockedNodes.indexOf(node) != -1)
        return;

    if(node.operator){
        if(noOperators || !canOperatorMerge(cData, node.operator, platform)){
            blockSubtree(cData, node);
            return;
        }
        else{
            if(!cData.firstOperator) cData.firstOperator = node.operator;
            var mapping = node.operator.mapping;
            for(var i = 0; i < mapping.length; ++i){
                if(mapping[i].sequence){
                    blockInput(cData, node, mapping[i].source);
                    blockInput(cData, node, mapping[i].keySource);
                }
                else if(mapping[i].array){
                    // TODO: Rename .array to .randomAccess
                    blockInput(cData, node, mapping[i].source);
                }
            }
        }
    }
    for(var i = 0; i < node.children.length; ++i){
        constructPreScan(cData, node.children[i], platform, noOperators);
    }
}

function canOperatorMerge(cData, operator, platform){
    // TODO: Detect merge support
    return (platform == C.PLATFORM.ASYNC || !Operator.isOperatorAsync(operator)) &&
        (!cData.firstOperator ||
        (platform == C.PLATFORM.GLSL && cData.firstOperator.evaluate_glsl && operator.evaluate_glsl));
}

function blockSubtree(cData, node){
    if(cData.blockedNodes.indexOf(node) != -1)
        return;

    cData.blockedNodes.push(node);
    for(var i = 0; i < node.children.length; ++i){
        blockSubtree(cData, node.children[i]);
    }
}
/**
 * Block all processNodes assigned to an input channel
 * @param cData
 * @param node
 * @param inputName
 */
    function blockInput(cData, node, inputName){
        var channel = node.inputChannels[inputName];
        if(channel && channel.creatorProcessNode){
            blockSubtree(cData, channel.creatorProcessNode);
        }
    }
/**
 * Fill doneNodes and constructionOrder arrays of construction data.
 * It also fills the subNodes array of the executer
 * @param cData construction data
 * @param executer
 * @param node
 */
    function setConstructionOrderAndSubNodes(cData, executer, node){
        if(cData.doneNodes.indexOf(node) != -1)
            return;

        cData.doneNodes.push(node);

        if(cData.blockedNodes.indexOf(node) != -1){
            executer.subNodes.push(node);
        }
        else{
            for(var i = 0; i < node.children.length; ++i){
                setConstructionOrderAndSubNodes(cData, executer, node.children[i]);
            }

            if(node.operator){ // RequestNodes don't have an operator. Consider this case.
                cData.constructionOrder.push(node);
            }
        }
    }
/**
 * Last step of construction: create OperatorList from constructionOrder array
 * Also fill mergedNodes and programData
 * @param executer
 * @param cData
 */
    function constructFromData(executer, cData){

        for(var i = 0; i < cData.constructionOrder.length; ++i){
            var node = cData.constructionOrder[i];

            var entry = new OperatorEntry(node.operator);

            constructInputConnection(executer, entry, cData, node);

            var isOutputNode = constructOutputConnection(executer, entry, cData, node);

            executer.programData.operatorData.push({});
            executer.operatorList.addEntry(entry);
            executer.mergedNodes.push(node);
            if(isOutputNode || (i == cData.constructionOrder.length-1))
                executer.mergedOutputNodes.push(node)

        }

        constructLostOutput(executer, cData);
    }
/**
 * Construct input info for OperatorEntry.
 * Will implicitly create ProgramInputConnections for ProgramData
 * @param {Executor} executer
 * @param {OperatorEntry} entry
 * @param {{}} cData
 * @param {ProcessNode} node
 */
    function constructInputConnection(executer, entry, cData, node){
        var mapping = node.operator.mapping;
        for(var j = 0; j < mapping.length; ++j){
            var channel = node.inputChannels[mapping[j].source];
            var operatorIndex;
            if(channel && channel.creatorProcessNode && (operatorIndex =
                executer.mergedNodes.indexOf(channel.creatorProcessNode) ) != -1 )
            {
                // it's transfer input
                var outputIndex = getOperatorOutputIndex(channel.creatorProcessNode, channel);
                entry.setTransferInput(j, operatorIndex, outputIndex);
                var prevOperator = executer.operatorList.entries[operatorIndex];
                if(!prevOperator.isFinalOutput(outputIndex)){
                    prevOperator.setTransferOutput(outputIndex);
                }
                continue;
            }
            // Handle direct input

            var mappedInputName = mapping[j].source;
            if(node.owner.owner._computeInputMapping)
                mappedInputName = node.owner.owner._computeInputMapping.getScriptInputName(mapping[j].paramIdx, mapping[j].source);

            var connection = new Program.ProgramInputConnection();
            connection.channel = channel;
            connection.arrayAccess = mapping[j].array || false; // TODO: rename to randomAccess
            connection.sequenceAccessType = mapping[j].sequence || 0;
            if(connection.sequenceAccessType)
                connection.sequenceKeySourceChannel = node.inputChannels[mapping[j].keySource];

            var connectionKey = connection.getKey();
            var inputSlotIdx = cData.inputSlots[connectionKey];
            if(channel && inputSlotIdx != undefined){
                // Direct input already exists
                entry.setDirectInput(j, inputSlotIdx, mappedInputName);
            }
            else{
                // new direct input
                inputSlotIdx = executer.programData.inputs.length;
                cData.inputSlots[connectionKey] = inputSlotIdx;
                executer.programData.inputs.push(connection);
                entry.setDirectInput(j, inputSlotIdx, mappedInputName);
            }
        }
    }

/**
 * Construct output info of OperatorEntry
 * @param {Executor} executer
 * @param {OperatorEntry} entry
 * @param {{}} cData
 * @param {ProcessNode} node
 */
    function constructOutputConnection(executer, entry, cData, node){
        var outputs = node.operator.outputs;
        var isOutputNode = true;
        for(var i = 0; i < outputs.length; ++i){
            var slot = node.outputDataSlots[outputs[i].name];
            var finalOutputName = getFinalOutputName(slot, cData);
            if(finalOutputName){
                var index =  executer.programData.outputs.length;
                executer.programData.outputs.push(slot);
                entry.setFinalOutput(i, index);
                if(finalOutputName !== true){
                    Utils.nameset.remove(executer.unprocessedDataNames, finalOutputName);
                }
            }
            else{
                isOutputNode = false;
            }
        }
        return isOutputNode; // TODO: Check if computation of isOutputNode is really correct?
    }


    function getOperatorOutputIndex(processNode, channel){
        var outputs = processNode.operator.outputs;
        for(var i = 0; i < outputs.length; ++i){
            if(channel.getDataEntry() == processNode.outputDataSlots[outputs[i].name].dataEntry){
                return i;
            }
        }
        return null;
    }

    function getFinalOutputName(dataSlot, cData){
        if(!cData.finalOutput) // If root of Executor is a ProcessNode we don't have finalOutput defined and all outputs are final.
            return true;
        for(var name in cData.finalOutput){
            if(cData.finalOutput[name] == dataSlot.dataEntry){
                return name;
            }
        }
        return false;
    }

    function constructLostOutput(executer, cData){
        for(var i = 0; i < cData.constructionOrder.length; ++i){
            var node = cData.constructionOrder[i];
            var entry = executer.operatorList.entries[i];

            var outputs = node.operator.outputs;
            for(var j = 0; j < outputs.length; ++j){
                if(!entry.isFinalOutput(j) && ! entry.isTransferOutput(j)){
                    var index = executer.programData.outputs.length;
                    executer.programData.outputs.push(node.outputDataSlots[outputs[j].name]);
                    entry.setLostOutput(j, index);
                }
            }
        }
    }


    function updateIterateState(executer){
        var inputs = executer.programData.inputs;
        for(var i = 0; i < executer.programData.inputs.length; ++i){
            var entry = executer.programData.getDataEntry(i);
            var iterateCount = entry ? entry.getIterateCount ? entry.getIterateCount() : 1 : 0;
            if(!iterateCount)
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.NULL);
            else if(!inputs[i].arrayAccess && iterateCount > 1)
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.MANY);
            else
                executer.operatorList.setInputIterateType(i, C.ITERATION_TYPE.ONE);

            if(inputs[i].arrayAccess && platformRequiresArraySize(executer. platform)){
                executer.operatorList.setInputSize(i, iterateCount);
            }
        }
    }
/**
 * Determine if the platform needs to declare uniform array sizes in the source code.
 * @param platform
 * @returns {boolean}
 */
    function platformRequiresArraySize(platform){
        return platform == C.PLATFORM.GLSL;
    }


    function runSubNodes(executer){
        for(var i = 0; i < executer.subNodes.length; ++i){
            executer.subNodes[i].process();
        }
    }

module.exports = Executor;

},{"../base.js":178,"../interface/constants.js":179,"../operator/operator-entry.js":217,"../operator/operator-list.js":218,"../operator/operator.js":219,"../operator/program.js":220,"../utils/utils.js":230}],226:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./../interface/constants.js");


var orderMappingParser = /^([^:,{}]+)(,[^:{},]+)*$/;
var nameMappingParser = /^\{(([^:,{}]+:[^:{},]+)(,[^:{},]+:[^:},]+)*)}$/;

/**
 * A mapping used for a filter or a compute properties of a DataNode
 * @abstract
 */
var Mapping = function(){
    /**
     * @type {Array<DataNode>}
     */
    this._owners = [];
};

/**
 * Parse a Mapping (both C.OrderMapping or C.ComputeMapping) from a syntax string.
 * @param {string} string The syntax string.
 * @param {C.DataNode} dataNode DataNode of the Mapping
 * @returns {?C.Mapping}
 */
Mapping.parse = function(string, dataNode){
    string = string.trim();
    var results = string.trim().match(orderMappingParser);
    if(results)
        return OrderMapping.parse(string, dataNode);
    results = string.trim().match(nameMappingParser);
    if(results)
        return NameMapping.parse(results[1], dataNode);
    Base.notifyError("Cannot parse name mapping '" + string + "'", dataNode);
    return null;
};

/**
 *
 * @param {DataNode} owner
 * @private
 */
Mapping.prototype._addOwner = function(owner){
    var idx = this._owners.indexOf(owner);
    if(idx == -1)
        this._owners.push(owner);
};

/**
 *
 * @param {DataNode} owner
 * @private
 */
Mapping.prototype._removeOwner = function(owner){
    var idx = this._owners.indexOf(owner);
    if(idx != -1)
        this._owners.splice(idx, -1);
};


//----------------------------------------------------------------------------------------------------------------------
// OrderMapping
//----------------------------------------------------------------------------------------------------------------------

/**
 * An OrderMapping used for a filter or compute properties of a DataNode
 * It describes a mapping of names referring to the order of arguments / output values.
 * OrderMapping syntax examples in compute:
 * position = C.morph(position, posAdd, weight)
 * @constructor
 * @extends {Mapping}
 */
var OrderMapping = function(){
    Mapping.call(this);
    this._names = [];
};
Base.createClass(OrderMapping, Mapping);

OrderMapping.parse = function(string, dataNode){
    var mapping = new OrderMapping(dataNode);
    var token = string.split(",");
    for(var i = 0; i < token.length; i++){
        mapping._names.push(token[i].trim());
    }
    return mapping;
};


Object.defineProperty(OrderMapping.prototype, "length", {
    set: function(){ throw new Error("length is read-only");
    },
    get: function(){ return this._names.length; }
});

OrderMapping.prototype.getName = function(idx){
    return this._names[idx];
};

OrderMapping.prototype.clear = function(){
    this._names = [];
    mappingNotifyOwner(this);
};

OrderMapping.prototype.setName = function(index, name){
    this._names[index] = name;
    mappingNotifyOwner(this);
};


//noinspection JSUnusedGlobalSymbols
OrderMapping.prototype.removeName = function(index){
    this._names.splice(index);
    mappingNotifyOwner(this);
};

OrderMapping.prototype.isEmpty = function(){
    return this._names.length == 0;
};

/**
 *
 * @param {ChannelMap} destMap
 * @param {ChannelMap} sourceMap
 * @param {exports.C.DATA_FILTER_TYPE} filterType
 * @param {function(ChannelMap, string, ChannelMap, string)} callback
 */
OrderMapping.prototype.applyFilterOnChannelMap = function(destMap, sourceMap, filterType, callback){
    var i;
    if(filterType == C.DATA_FILTER_TYPE.KEEP){
        for(i = 0; i < this._names.length; ++i){
            var name = this._names[i];
            if(sourceMap.map[name]) {
                callback(destMap, name, sourceMap, name);
            }
        }
    }
    else{
        for(i in sourceMap.map){
            var idx = this._names.indexOf(i);
            if(filterType == C.DATA_FILTER_TYPE.RENAME ||
                (filterType == C.DATA_FILTER_TYPE.REMOVE && idx == -1))
                callback(destMap, i, sourceMap, i);
        }
    }
};

/**
 * Return the name of the input value assigned to operator argument.
 * Returns null, if no mapping is defined.
 * @param {number} index Position of the operator argument
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptInputName = function(index /*, destName */){
    if(this._names[index])
        return this._names[index];
    else
        return null;
};

/**
 * Returns the name of the output parameter as it should be used for the
 * following dataflow. Returns null, if no mapping is defined.
 * @param index
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptOutputName = function(index /*, srcName */){
    if(this._names[index])
        return this._names[index];
    else
        return null;
};

/**
 * Returns the inverse name of the output parameter as it should be used for the
 * following dataflow. Returns null, if no mapping is defined.
 * @param {string} destName
 * @param {array<object>} operatorOutputs
 * @returns {string|null}
 */
OrderMapping.prototype.getScriptOutputNameInv = function(destName, operatorOutputs){
    var index = this._names.indexOf(destName);
    if(index == -1)
        return null;
    return operatorOutputs[index].name;
};

/**
 * Identity function. Used to implement interface. Usually you don't rename with order
 * mapping.
 * @param name
 * @returns {string}
 */
OrderMapping.prototype.getRenameSrcName = function(name){
    return name;
};

//----------------------------------------------------------------------------------------------------------------------
// NameMapping
//----------------------------------------------------------------------------------------------------------------------

/**
 * An NameMapping used for a filter or compute properties of a DataNode
 * It describes a mapping of names referring to the original names of the arguments / output values.
 * NameMapping syntax examples in compute:
 * {position: result} = C.morph({value: position, valueAdd: posAdd, weight: weight})
 * @constructor
 * @extends {Mapping}
 */
var NameMapping = function(){
    Mapping.call(this);
    this._destNames = [];
    this._srcNames = [];

};
Base.createClass(NameMapping, Mapping);

NameMapping.parse = function(string, dataNode)  {
    var mapping = new NameMapping(dataNode);
    var token = string.split(",");
    for(var i = 0; i < token.length; i++){
        var pair = token[i].split(":");
        var dest = pair[0].trim(); var src = pair[1].trim();
        mapping.setNamePair(dest, src);
    }
    return mapping;
};

Object.defineProperty(NameMapping.prototype, "length", {
    set: function(){ throw new Error("length is read-only");
    },
    get: function(){ return this._srcNames.length; }
});

NameMapping.prototype.getDestName = function(idx){
    return this._destNames[idx];
};
NameMapping.prototype.getSrcName = function(idx){
    return this._srcNames[idx];
};

NameMapping.prototype.getSrcNameFromDestName = function(destName){
    var idx = this._destNames.indexOf(destName);
    return idx == -1 ? null : this._srcNames[idx];
};
NameMapping.prototype.getDestNameFromSrcName = function(srcName){
    var idx = this._srcNames.indexOf(srcName);
    return idx == -1 ? null : this._destNames[idx];
};

NameMapping.prototype.clear = function(){
    this._srcNames = [];
    this._destNames = [];
    mappingNotifyOwner(this);
};

NameMapping.prototype.setNamePair = function(destName, srcName){
    var idx = this._destNames.indexOf(destName);
    if(idx != -1){
        this._destNames.splice(idx,1);
        this._srcNames.splice(idx,1);
    }
    this._destNames.push(destName);
    this._srcNames.push(srcName);
    mappingNotifyOwner(this);
};

//noinspection JSUnusedGlobalSymbols
NameMapping.prototype.removeNamePair = function(destName){
    var idx = this._destNames.indexOf(destName);
    if(idx != -1){
        this._destNames.splice(idx,1);
        this._srcNames.splice(idx,1);
    }
    mappingNotifyOwner(this);
};

NameMapping.prototype.isEmpty = function(){
    return this._destNames.length == 0;
};

/**
 * @see OrderMapping.applyFilterOnChannelMap
 * @param {ChannelMap} destMap
 * @param {ChannelMap} sourceMap
 * @param {C.DATA_FILTER_TYPE} filterType
 * @param {function} callback
 */
NameMapping.prototype.applyFilterOnChannelMap = function(destMap, sourceMap, filterType, callback) {
    var i;
    if(filterType == C.DATA_FILTER_TYPE.REMOVE){
        for(i in sourceMap.map)
            if(this._srcNames.indexOf(i) == -1)
                callback(destMap, i, sourceMap, i);
    }
    else{
        if(filterType == C.DATA_FILTER_TYPE.RENAME){
            for(i in sourceMap.map)
                if(this._srcNames.indexOf(i) == -1)
                    callback(destMap, i, sourceMap, i);
        }
        for(i in this._destNames){
            callback(destMap, this._destNames[i], sourceMap, this._srcNames[i]);
        }
    }
};

/**
 * Renames: Look-up the destination name and return the source name
 * @param {string} name
 * @returns {string}
 */
NameMapping.prototype.getRenameSrcName = function(name){
    return this.getSrcNameFromDestName(name) || name;
};

/**
 * Return the name of the input value assigned to operator argument
 * @param {number} index Position of the operator argument
 * @param {string} destinationName Name of the operator argument
 * @returns {string|null}
 */
NameMapping.prototype.getScriptInputName= function(index, destinationName){
    return this.getSrcNameFromDestName(destinationName);
};

/**
 * @see OrderMapping.getScriptOutputName
 */
NameMapping.prototype.getScriptOutputName = function(index, srcName){
    return this.getDestNameFromSrcName(srcName);
};

/**
 * @see OrderMapping.getScriptOutputNameInv
 */
NameMapping.prototype.getScriptOutputNameInv = function(destName /*, operatorOutputs */){
    var index = this._destNames.indexOf(destName);
    if(index == -1)
        return null;
    return this._srcNames[index];
};

/**
 * Notify all DataNodes that use the mapping passed to the function
 * @param {Mapping} mapping
 */
function mappingNotifyOwner(mapping){
    for(var i = 0; i < mapping._owners.length; ++i) {
        mapping._owners[i].notify(C.RESULT_STATE.CHANGED_STRUCTURE);
    }
    Base._flushResultCallbacks();
}
module.exports = {
    NameMapping: NameMapping,
    OrderMapping: OrderMapping,
    Mapping: Mapping
};

},{"../base.js":178,"./../interface/constants.js":179}],227:[function(require,module,exports){
var Base = require("../base.js");
var C = require("../interface/constants.js");
var utils = require("../utils/utils.js");
var Executor = require("./executor.js");
var Result = require("./result.js");
var Operator = require("../operator/operator.js");
var Data = require("../interface/data.js");
var DataSlot = require("../processing/data-slot.js");

var BufferEntry = Data.BufferEntry;
var TextureEntry = Data.TextureEntry;
var ImageDataTextureEntry = Data.ImageDataTextureEntry;

//----------------------------------------------------------------------------------------------------------------------
// C.ProcessNode
//----------------------------------------------------------------------------------------------------------------------

var ASYNC_PROCESS_STATE = {
    IDLE : 0,
    RUNNING : 1,
    RESCHEDULED : 2,
    INIT: 3
};


/**
 * Optimized representation for the processing graph. Only created for ChannelNodes with operators.
 * Is connected directly to other ProcessNodes, ignoring channels that are not relevant for processing
 * @param {ChannelNode} channelNode
 * @constructor
 * @extends {GraphNode}
 */
var ProcessNode = function(channelNode){
    this.owner = channelNode;
    this.operator = channelNode.operator;

    /**
     * Input channels for the operator
     * @type {Object.<string, Channel>}
     */
    this.inputChannels = {};

    /**
     * Outputs of operator
     * @type {Object.<string, DataSlot>}
     */
    this.outputDataSlots = {};

    /**
     * @type {exports.C.PROCESS_STATE}
     */
    this.status = C.PROCESS_STATE.MODIFIED;

    /**
     * @type {ASYNC_PROCESS_STATE}
     */
    this.asyncProcessState = ASYNC_PROCESS_STATE.INIT;

    /**
     * Direct Children without transitive children of children
     * TODO: Use Set()?
     * @type {Array.<ProcessNode>}
     */
    this.children = [];

    /**
     * Children with transitive dependencies
     * TODO: Use Set()?
     * @type {Array.<ProcessNode>}
     */
    this.descendants = [];

    /**
     * Callback, the executor needs to call when the computation is ready
     * @type {Function}
     * @private
     */
    this._bindedAsyncCallback = null;

    /**
     * Index of array matches platform id (C.PLATFORM)
     * @type {Array.<Executor>}
     */
    this.executers = [];

    constructProcessNode(this, channelNode);

    if(Operator.isOperatorAsync(this.operator)){
        this._bindedAsyncCallback = this.receiveAsyncProcessing.bind(this);
    }
};

ProcessNode.prototype.onXflowChannelChange = function(channel, state){
    if (Operator.isOperatorAsync(this.operator)) {
        if (this.status == C.PROCESS_STATE.LOADING || this.asyncProcessState != ASYNC_PROCESS_STATE.INIT) {
            this.status = C.PROCESS_STATE.MODIFIED;
            this.updateState();
        }
    }
    else {

        if (state == C.DATA_ENTRY_STATE.CHANGED_VALUE && this.status > C.PROCESS_STATE.UNPROCESSED) {
            this.status = C.PROCESS_STATE.UNPROCESSED;
        } else {
            this.status = C.PROCESS_STATE.MODIFIED;
        }
        this.notifyOutputChanged(state);
    }
};

ProcessNode.prototype.startAsyncProcessing = function(){
    if(this.asyncProcessState == ASYNC_PROCESS_STATE.IDLE || this.asyncProcessState == ASYNC_PROCESS_STATE.INIT){
        this.asyncProcessState = ASYNC_PROCESS_STATE.RUNNING;
        var executer = getOrCreateExecuter(this, C.PLATFORM.ASYNC);
        executer.run(this._bindedAsyncCallback);
    }
    else{
        this.asyncProcessState = ASYNC_PROCESS_STATE.RESCHEDULED;
    }
};
ProcessNode.prototype.receiveAsyncProcessing = function(){
    this.status = C.PROCESS_STATE.PROCESSED;
    this.notifyOutputChanged(C.DATA_ENTRY_STATE.CHANGED_SIZE_TYPE);
    if(this.asyncProcessState == ASYNC_PROCESS_STATE.RESCHEDULED){
        this.asyncProcessState = ASYNC_PROCESS_STATE.IDLE;
        this.status = C.PROCESS_STATE.MODIFIED;
        this.updateState();
    }
    else{
        this.asyncProcessState = ASYNC_PROCESS_STATE.IDLE;
    }
    Base._flushResultCallbacks();
};



ProcessNode.prototype.notifyOutputChanged = function(state){
    for(var name in this.outputDataSlots){
        this.outputDataSlots[name].notifyOnChange(state);
    }
};


ProcessNode.prototype.clear = function(){
    for(var name in this.inputChannels){
        this.inputChannels[name] && this.inputChannels[name].removeListener(this);
    }
};

ProcessNode.prototype.updateState = function(){
    if(this.status == C.PROCESS_STATE.MODIFIED){
        this.status = C.PROCESS_STATE.UNPROCESSED;

        XML3D.debug.assert(!this.owner.loading, "This should never happen");

        if(this.owner.loading)
            this.status = C.PROCESS_STATE.LOADING;
        else{
            for(var i = 0; i < this.children.length; ++i){
                this.status = Math.min(this.status, this.children[i].updateState());
            }
            if(this.status > C.PROCESS_STATE.LOADING && isInputLoading(this.operator, this.inputChannels))
                this.status = C.PROCESS_STATE.LOADING;

            if(this.status > C.PROCESS_STATE.INVALID &&
                !checkInput(this, this.operator, this.owner.owner._computeInputMapping, this.inputChannels))
                this.status = C.PROCESS_STATE.INVALID;

            if(this.status == C.PROCESS_STATE.UNPROCESSED && Operator.isOperatorAsync(this.operator)){
                this.status = this.asyncProcessState == ASYNC_PROCESS_STATE.INIT ? C.PROCESS_STATE.LOADING
                    : C.PROCESS_STATE.PROCESSED;
                this.startAsyncProcessing();
            }

        }
    }
    return this.status;
};

ProcessNode.prototype.process = function(){

    if(this.status == C.PROCESS_STATE.UNPROCESSED){
        var executer = getOrCreateExecuter(this, this.owner.platform);
        executer.run();
        this.status = C.PROCESS_STATE.PROCESSED;
    }
};

/**
 *
 * @param {ProcessNode} processNode
 * @param {ChannelNode} channelNode
 */
function constructProcessNode(processNode, channelNode){
    var dataNode = channelNode.owner;
    synchronizeInputChannels(processNode, channelNode, dataNode);
    synchronizeChildrenAndDescendants(processNode.children, processNode.descendants, processNode.inputChannels);
    synchronizeOutput(processNode.operator, processNode.outputDataSlots);
}

/**
 *
 * @param processNode
 * @param channelNode
 * @param dataNode
 */
function synchronizeInputChannels(processNode, channelNode, dataNode){
    var operator = processNode.operator, inputMapping = dataNode._computeInputMapping;
    for(var i = 0; i < operator.params.length; ++i){
        var sourceName = operator.params[i].source;
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, sourceName) : sourceName;
        if(dataName){
            var channel = channelNode.inputChannels.getChannel(dataName);
            if(channel) channel.addListener(processNode);
            processNode.inputChannels[sourceName] = channel;
        }
    }
}

function isInputLoading(operator, inputChannels){
    for(var i in operator.params){
        var entry = operator.params[i];
        var channel = inputChannels[entry.source];
        if(!channel) continue;
        var dataEntry = channel.getDataEntry();
        if(!dataEntry) continue;
        if(dataEntry.isLoading && dataEntry.isLoading()) return true;
    }
    return false;
}

function checkInput(processNode, operator, inputMapping, inputChannels){
    var dataNode = processNode.owner.owner;
    for(var i in operator.params){
        var entry = operator.params[i];
        var dataName = inputMapping ? inputMapping.getScriptInputName(i, entry.source) : entry.source;
        if(!entry.optional && !dataName){
            Base.notifyError("Xflow: operator " + operator.name + ": Missing input argument for "
                + entry.source, dataNode);
            return false;
        }
        if(dataName){
            var channel = inputChannels[entry.source];
            if(!channel){
                if(!inputMapping) continue;
                Base.notifyError("Xflow: operator " + operator.name + ": Input of name '" + dataName +
                    "' not found. Used for parameter " + entry.source, dataNode);
                return false;
            }
            var dataEntry = channel.getDataEntry();

            if(!channel.creatorProcessNode){
                if(!entry.optional && (!dataEntry || dataEntry.isEmpty())){
                    Base.notifyError("Xflow: operator " + operator.name + ": Input for " + entry.source +
                        ' contains no data.', dataNode);
                    return false;
                }
            }
            if(dataEntry && dataEntry.type != entry.type){
                Base.notifyError("Xflow: operator " + operator.name + ": Input for " + entry.source +
                    " has wrong type. Expected: " + C.getTypeName(entry.type)
                    + ", but got: " +  C.getTypeName(dataEntry.type), dataNode);
                return false;
            }
        }
    }
    return true;
}

function synchronizeChildrenAndDescendants(children, descendants, inputChannels){
    var channel;
    for(var name in inputChannels){
        channel = inputChannels[name];
        if(channel && channel.creatorProcessNode){
            utils.set.add(children, channel.creatorProcessNode);
            utils.set.add(descendants, channel.creatorProcessNode.descendants);
        }
    }
    utils.set.remove(children, descendants);
    utils.set.add(descendants, children);
}

function synchronizeOutput(operator, outputs){
    var async = Operator.isOperatorAsync(operator);
    for(var i in operator.outputs){
        var dataEntry = operator.outputs[i];

        var entry, asyncEntry;
        var type = dataEntry.type;
        if(type != C.DATA_TYPE.TEXTURE){
            entry = new BufferEntry(type, null);
            if(async) asyncEntry = new BufferEntry(type, null);
        }
        else{
            entry = window.document ? new TextureEntry(null) : new ImageDataTextureEntry(null);
            if(async) asyncEntry = window.document ? new TextureEntry(null) : new ImageDataTextureEntry(null);
        }
        outputs[dataEntry.name] = new DataSlot(entry, 0);
        if(async) outputs[dataEntry.name].asyncDataEntry = asyncEntry;
    }
}

function getOrCreateExecuter(node, platform){
    if(!node.executers[platform]){
        node.executers[platform] = new Executor(node, platform);
    }
    return node.executers[platform];
}


//----------------------------------------------------------------------------------------------------------------------
// RequestNode
//----------------------------------------------------------------------------------------------------------------------
/**
 *
 * FIXME: RequestNodes are never deleted.
 * @param {ChannelNode} channelNode
 * @param {Array.<string>} filter
 * @constructor
 */
var RequestNode = function(channelNode, filter){
    this.owner = channelNode;
    this.filter = filter;

    /**
     *
     * @type {Object<C.PLATFORM, exports.Result>}
     */
    this.results = {};

    /**
     * @type {exports.C.PROCESS_STATE}
     */
    this.status = C.PROCESS_STATE.MODIFIED;

    /**
     * @type {Object.<string, Channel>}
     */
    this.channels = {};

    /**
     * @see ProcessNode.children
     * @type {Array}
     */
    this.children = [];

    /**
     * @see ProcessNode.executers
     * @type {Array}
     */
    this.executers = [];

    /**
     * @see ProcessNode.outOfSync
     * @type {boolean}
     */
    this.outOfSync = true;
};

RequestNode.prototype.synchronize = function(){
    if(this.outOfSync){
        this.outOfSync = false;
        synchronizeRequestChannels(this, this.owner);
        synchronizeChildrenAndDescendants(this.children, [], this.channels);
    }
};

RequestNode.prototype.updateState = function(){
    this.synchronize();
    if(this.status == C.PROCESS_STATE.MODIFIED){
        this.status = C.PROCESS_STATE.UNPROCESSED;

        if(this.owner.loading) {
            this.status = C.PROCESS_STATE.LOADING;
        } else {
            for(var i = 0; i < this.children.length; ++i){
                this.status = Math.min(this.status, this.children[i].updateState());
            }
        }
    }
    return this.status;
};

RequestNode.prototype.getResult = function(resultType){
    this.updateState();

    // TODO: This could be in getRequestComputeResult
    if(this.status == C.PROCESS_STATE.UNPROCESSED){
        if(resultType == C.RESULT_TYPE.COMPUTE){
            var executer = getOrCreateExecuter(this, this.owner.platform);
            if(!executer.isProcessed())
                executer.run();
        }
        this.status = C.PROCESS_STATE.PROCESSED;
    }
    var result = null;
    if (resultType == C.RESULT_TYPE.COMPUTE) {
        result = getRequestComputeResult(this);
    } else if (resultType == C.RESULT_TYPE.VS) {
        result = getRequestVSResult(this);
    }
    result.loading = (this.status == C.PROCESS_STATE.LOADING);
    return result;
};

RequestNode.prototype.setStructureOutOfSync = function(){
    this.outOfSync = true;
    this.status = C.PROCESS_STATE.MODIFIED;
    for(var type in this.results){
        this.results[type]._notifyChanged(C.RESULT_STATE.CHANGED_STRUCTURE);
    }
    for(var name in this.channels){
        this.channels[name].removeListener(this);
    }
    this.channels = [];
    this.children = [];
    this.executers = [];
};

RequestNode.prototype.onXflowChannelChange = function(channel, state){
    if(channel.creatorProcessNode)
        this.status = C.PROCESS_STATE.MODIFIED;
    var notifyState = (state == C.DATA_ENTRY_STATE.CHANGED_VALUE ? C.RESULT_STATE.CHANGED_DATA_VALUE
            : C.RESULT_STATE.CHANGED_DATA_SIZE);

    for(var type in this.results){
        this.results[type]._notifyChanged(notifyState);
    }
};

/**
 *
 * @param requestNode
 * @param channelNode
 */
function synchronizeRequestChannels(requestNode, channelNode){
    var names = requestNode.filter;
    if(!names){
        names = channelNode.outputChannels.getNames();
    }

    for(var i = 0; i < names.length; ++i){
        var name = names[i];
        var channel = channelNode.outputChannels.getChannel(name);
        if(channel){
            requestNode.channels[name] = channel;
            channel.addListener(requestNode);
        }
    }
}

/**
 *
 * @param {RequestNode} requestNode
 * @returns {Result}
 */
function getRequestComputeResult(requestNode)
{
    if(!requestNode.results[C.RESULT_TYPE.COMPUTE])
        requestNode.results[C.RESULT_TYPE.COMPUTE] = new Result.ComputeResult();

    var result = requestNode.results[C.RESULT_TYPE.COMPUTE];
    result._dataEntries = {}; result._outputNames = [];

    for(var name in requestNode.channels){
        var entry = requestNode.channels[name].getDataEntry();
        result._dataEntries[name] = entry && !entry.isEmpty() ? entry : null;
        result._outputNames.push(name);
    }
    return result;
}

/**
 *
 * @param requestNode
 * @returns {exports.VSDataResult}
 */
function getRequestVSResult(requestNode)
{
    var executer = getOrCreateExecuter(requestNode, C.PLATFORM.GLSL);
    if(!requestNode.results[C.RESULT_TYPE.VS])
        requestNode.results[C.RESULT_TYPE.VS] = new Result.VSDataResult();
    var result = requestNode.results[C.RESULT_TYPE.VS];

    var program = executer.getVertexShader();
    result._program = program;
    result._programData = executer.programData;
    return result;
}


module.exports = {
    RequestNode: RequestNode,
    ProcessNode: ProcessNode
};


},{"../base.js":178,"../interface/constants.js":179,"../interface/data.js":180,"../operator/operator.js":219,"../processing/data-slot.js":224,"../utils/utils.js":230,"./executor.js":225,"./result.js":228}],228:[function(require,module,exports){
var Base = require("../base.js");
require("../../utils/array.js");

var queueResultCallback = Base._queueResultCallback;

/**
 * Content of this file:
 * Result classes of an Xflow graph which are received through Requests.
 */

/**
 * Abstract Result structure containing a (processed) result of the Xflow graph.
 * @abstract
 */
var Result = function(){
    this.loading = false;
    /** Valid is false if an error occurred during the processing of the result */
    this.valid = false;
    this._listeners = [];
    this._requests = [];
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype.addListener = function(callback){
    this._listeners.push(callback);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype.removeListener = function(callback){
    Array.erase(this._listeners, callback);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype._addRequest = function(request){
    this._requests.push(request);
};

/**
 * @param {function(Result, C.RESULT_STATE)} callback
 */
Result.prototype._removeRequest = function(request){
    Array.erase(this._requests, request);
};


Result.prototype._notifyChanged = function(state){
    this.valid = false;
    for(var i = 0; i < this._requests.length; ++i){
        this._requests[i]._onResultChanged(state);
    }
    queueResultCallback(this, state);
}

Result.prototype._onPostponedResultChanged = function(state){
    for(var i = 0; i < this._listeners.length; ++i){
        this._listeners[i](this, state);
    }
}



/**
 * ComputeResult contains a named map of typed values.
 * @constructor
 * @extends {Result}
 */
var ComputeResult = function(){
    Result.call(this);
    this._outputNames = [];
    /** @type {Object.<string,DataEntry>} */
    this._dataEntries = {};
};
Base.createClass(ComputeResult, Result);

Object.defineProperty(ComputeResult.prototype, "outputNames", {
    set: function(v){
        throw new Error("outputNames is readonly");
    },
    get: function(){ return this._outputNames; }
});

ComputeResult.prototype.getOutputData = function(name){
    return this._dataEntries[name];
};

/**
 * @returns {Object.<string,DataEntry>}
 */
ComputeResult.prototype.getOutputMap = function() {
    return this._dataEntries;
};



/**
 * VSDataResult is used to analyse the output of a VertexShader
 * Note that the VSDataResult is not used to generate the VertexShader directly.
 * For that, the VertexShader structure must be created from VertexShaderRequest
 * @constructor
 * @extends {Result}
 */
var VSDataResult = function(){
    Result.call(this);
    this._program = null;
    this._programData = null;
};
Base.createClass(VSDataResult, Result);

Object.defineProperty(VSDataResult.prototype, "outputNames", {
    set: function(v){
        throw new Error("shaderOutputNames is readonly");
    },
    get: function(){ return this._program.getOutputNames(); }
});

VSDataResult.prototype.isOutputUniform = function(name){
    return this._program.isOutputUniform(name);
}
VSDataResult.prototype.isOutputNull = function(name){
    return this._program.isOutputNull(name);
}
VSDataResult.prototype.getOutputType = function(name){
    return this._program.getOutputType(name);
}
VSDataResult.prototype.getVertexShader = function(vsConfig){
    return this._program.createVertexShader(this._programData, vsConfig);
}

module.exports = {
    ComputeResult:  ComputeResult,
    VSDataResult: VSDataResult
};

},{"../../utils/array.js":170,"../base.js":178}],229:[function(require,module,exports){
var Base = require("../base.js");
var C = require("./../interface/constants.js");

var initAnonymousOperator = require("../operator/operator.js").initAnonymousOperator;

var shaderConstant = {};
shaderConstant[C.SHADER_CONSTANT_KEY.OBJECT_ID] = "objectID";
shaderConstant[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM] = "screenTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.SCREEN_TRANSFORM_NORMAL] = "screenTransformNormal";
shaderConstant[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM] = "viewTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.VIEW_TRANSFORM_NORMAL] = "viewTransformNormal";
shaderConstant[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM] = "worldTransform";
shaderConstant[C.SHADER_CONSTANT_KEY.WORLD_TRANSFORM_NORMAL] = "worldTransformNormal";

var setShaderConstant = function(type, name){
    shaderConstant[type] = name;
};


/**
 * The output configuration of a VertexShader generated by Xflow
 * @constructor
 */
var VSConfig = function(){
    this._attributes = {};
    this._blockedNames = [];
    this._addInput = {};
    this._addOutput = {};
    this._codeFragments = [];
    this._outputChanneling = {};
};

VSConfig.prototype.addAttribute = function(type, name, optional){
    if(this._attributes[name]){
        if(this._attributes[name].type != type)
            throw new Error("Tries to add two attributes with different types of name '" + name + '"');
        this._attributes[name].optional = this._attributes[name].optional && optional;
        return;
    }
    this._attributes[name] = {type: type, optional: optional, channeling: []};
};

VSConfig.prototype.channelAttribute = function(inputName, outputName, code){
    this._attributes[inputName].channeling.push( { outputName : outputName, code : code });
};

VSConfig.prototype.addInputParameter = function(type, name, uniform){
    if(this._addInput[name])
        return;
    this._addInput[name] = { type: type, uniform: uniform };
    this._blockedNames.push(name);
};
VSConfig.prototype.addOutputParameter = function(type, name){
    if(this._addOutput[name])
        return;
    this._addOutput[name] = { type: type };
    this._blockedNames.push(name);
};
VSConfig.prototype.addCodeFragment = function(codeFragment){
    this._codeFragments.push(codeFragment);
};

VSConfig.prototype.addBlockedName = function(name){
    this._blockedNames.push(name);
};

VSConfig.prototype.getBlockedNames = function(){
    return this._blockedNames;
};

VSConfig.prototype.getFilter = function(){
    return Object.keys(this._attributes);
};
VSConfig.prototype.getKey = function(){
    var key = "";
    for(var name in this._attributes){
        var attr = this._attributes[name];
        key += ";" + attr.type + "," + name + "," + attr.optional;
    }
    return key;
};

var c_vs_operator_cache = {};

VSConfig.prototype.getOperator = function(){
    var key = this.getKey();
    if(c_vs_operator_cache[key])
        return c_vs_operator_cache[key];

    var outputs = [], params = [], glslCode = "\t// VS Connector\n";
    name = "VSConnect";
    for(var name in this._attributes){
        var attr = this._attributes[name];
        var type = C.getTypeName(attr.type);
        outputs.push( { type: type, name: name} );
        params.push( { type: type, source: name, optional: attr.optional} );
        name += "T" + type + "N" + name + "O" + attr.optional + ".";
    }
    var operator = initAnonymousOperator(name,
    {
        outputs: outputs,
        params:  params,
        evaluate_glsl: glslCode
    });
    c_vs_operator_cache[key] = operator;
    return operator;
};

var VertexShader = function(programData){
    this._programData = programData;
    this._glslCode = null;
    this._inputNames = [];
    this._outputNames = [];
    this._inputInfo = {};
    this._outputInfo = {};
};

Object.defineProperty(VertexShader.prototype, "inputNames", {
    set: function(v){
        throw new Error("inputNames is readonly");
    },
    get: function(){ return this._inputNames; }
});

Object.defineProperty(VertexShader.prototype, "outputNames", {
    set: function(v){
        throw new Error("outputNames is readonly");
    },
    get: function(){ return this._outputNames; }
});

VertexShader.prototype.isInputUniform = function(name){
    return this._inputInfo[name].uniform;
};
VertexShader.prototype.getInputData = function(name){
    return this._programData.getDataEntry(this._inputInfo[name].index);
};

VertexShader.prototype.isOutputNull = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.NULL;
};
VertexShader.prototype.isOutputFragmentUniform = function(name){
    return this._outputInfo[name].iteration == C.ITERATION_TYPE.ONE;
};
VertexShader.prototype.getUniformOutputData = function(name){
    return this._programData.getDataEntry(this._outputInfo[name].index);
};
VertexShader.prototype.getOutputType = function(name){
    return this._outputInfo[name].type;
};
VertexShader.prototype.getOutputSourceName = function(name){
    return this._outputInfo[name].sourceName;
};
VertexShader.prototype.getGLSLCode = function(){
    return this._glslCode;
};

module.exports = {
    shaderConstant: shaderConstant,
    setShaderConstant: setShaderConstant,
    VSConfig: VSConfig,
    VertexShader: VertexShader
};

},{"../base.js":178,"../operator/operator.js":219,"./../interface/constants.js":179}],230:[function(require,module,exports){
var set = {};


set.add = function(setArray, setToAdd){
    if(Array.isArray(setToAdd)){
        for(var i = 0; i < setToAdd.length; ++i){
            if(setArray.indexOf(setToAdd[i]) == -1)
                setArray.push(setToAdd[i]);
        }
    }
    else{
        if(setArray.indexOf(setToAdd) == -1)
            setArray.push(setToAdd);
    }
}
set.remove = function(setArray, setToRemove){
    var idx;
    if(Array.isArray(setToRemove)){
        for(var i = 0; i < setToRemove.length; ++i){
            if( (idx = setArray.indexOf(setToRemove[i])) != -1)
                setArray.splice(idx,1);
        }
    }
    else{
        if( (idx = setArray.indexOf(setToRemove)) != -1)
            setArray.splice(idx,1);
    }
}

set.intersection = function(dest, setA, setB){
    var size = setA.length;
    for(var i = 0; i < size; ++i){
        if(setB.indexOf(setA[i]) != -1)
            dest.push(setA[i]);
    }
}

set.isIntersecting = function(setA, setB){
    var i = setA.length;
    while(i--){
        if(setB.indexOf(setA[i]) != -1)
            return true;
    }
    return false;
}

set.isSubset = function(smallerSet, largerSet){
    var i = smallerSet.length;
    while(i--){
        if(largerSet.indexOf(smallerSet[i]) == -1)
            return false;
    }
    return true;
}

/**
 * Nameset Utilities for Xflow
 */
var nameset = {};

nameset.add = function(nameSet, toAdd){
    if(!toAdd) return;
    if(typeof toAdd == "string"){
        if(nameSet.indexOf(toAdd) == -1)
            nameSet.push(toAdd);
    }
    else{
        for(var i = 0; i < toAdd.length; ++i){
            if(nameSet.indexOf(toAdd[i]) == -1)
                nameSet.push(toAdd[i]);
        }
    }
}

nameset.remove = function(nameSet, toRemove){
    if(!toRemove) return;
    if(typeof toRemove == "string"){
        var removeIdx = nameSet.indexOf(toRemove);
        if(removeIdx != -1)
            nameSet.splice(removeIdx, 1);
    }
    else{
        for(var i = 0; i < toRemove.length; ++i){
            var removeIdx = nameSet.indexOf(toRemove[i]);
            if(removeIdx != -1)
                nameSet.splice(removeIdx, 1);
        }
    }
}

nameset.intersection = function(nameSetA, nameSetB){
    var i = nameSetA.length;
    while(i--){
        if(nameSetB.indexOf(nameSetA[i]) == -1){
            nameSetA.splice(i,1);
        }
    }
}


var binarySearch = function(keys, key, maxIndex){
    var min = 0, max = maxIndex - 1;
    while(min <= max){
        var i = Math.floor((min + max) / 2);
        if(keys[i] == key){
            return i;
        }
        else if(keys[i] < key)
            min = i + 1;
        else
            max = i - 1;
    }
    return max;
}

module.exports = {
    set: set,
    nameset: nameset,
    binarySearch: binarySearch
}

},{}],231:[function(require,module,exports){

module.exports = require("./init.js");
},{"./init.js":65}]},{},[231])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L21hdDIuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0MmQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvbWF0My5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC9tYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3F1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0cml4L3NyYy9nbC1tYXRyaXgvdmVjMi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXRyaXgvc3JjL2dsLW1hdHJpeC92ZWMzLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdHJpeC9zcmMvZ2wtbWF0cml4L3ZlYzQuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYXNzZXJ0L2Fzc2VydC5qcyIsIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlckJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvdXRpbC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmFzZWFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9iYXNlY29weS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2guX2NyZWF0ZWFzc2lnbmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fY3JlYXRlYXNzaWduZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC5fYmluZGNhbGxiYWNrL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5hc3NpZ24vbm9kZV9tb2R1bGVzL2xvZGFzaC5fY3JlYXRlYXNzaWduZXIvbm9kZV9tb2R1bGVzL2xvZGFzaC5faXNpdGVyYXRlZWNhbGwvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLl9jcmVhdGVhc3NpZ25lci9ub2RlX21vZHVsZXMvbG9kYXNoLnJlc3RwYXJhbS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2gua2V5cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2gua2V5cy9ub2RlX21vZHVsZXMvbG9kYXNoLl9nZXRuYXRpdmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmFzc2lnbi9ub2RlX21vZHVsZXMvbG9kYXNoLmtleXMvbm9kZV9tb2R1bGVzL2xvZGFzaC5pc2FyZ3VtZW50cy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guYXNzaWduL25vZGVfbW9kdWxlcy9sb2Rhc2gua2V5cy9ub2RlX21vZHVsZXMvbG9kYXNoLmlzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmNyZWF0ZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2guY3JlYXRlL25vZGVfbW9kdWxlcy9sb2Rhc2guX2Jhc2VjcmVhdGUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmRlZmF1bHRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RleHR1cmUtbWFuYWdlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90ZXh0dXJlLW1hbmFnZXIvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3RleHR1cmUtbWFuYWdlci9ub2RlX21vZHVsZXMvcGVyZm9ybWFuY2Utbm93L2xpYi9wZXJmb3JtYW5jZS1ub3cuanMiLCJzcmMvYXNzZXQvYXNzZXQuanMiLCJzcmMvYmFzZS9hZGFwdGVyLmpzIiwic3JjL2Jhc2UvYWRhcHRlcmhhbmRsZS5qcyIsInNyYy9iYXNlL2Zvcm1hdGhhbmRsZXIuanMiLCJzcmMvYmFzZS9yZXNvdXJjZW1hbmFnZXIuanMiLCJzcmMvY29udHJpYi9nbHUuanMiLCJzcmMvY29udHJpYi9zdGFja3RyYWNlLTAuNC5qcyIsInNyYy9jb250cmliL3N0YXRlLW1hY2hpbmUuanMiLCJzcmMvZGF0YS9hZGFwdGVyL2Fzc2V0LmpzIiwic3JjL2RhdGEvYWRhcHRlci9iYXNlLmpzIiwic3JjL2RhdGEvYWRhcHRlci9jb21wdXRlLmpzIiwic3JjL2RhdGEvYWRhcHRlci9kYXRhLmpzIiwic3JjL2RhdGEvYWRhcHRlci9kYXRhZmxvdy5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvZmFjdG9yeS5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvamF2YXNjcmlwdC9mYWN0b3J5LmpzIiwic3JjL2RhdGEvYWRhcHRlci9qc29uL2ZhY3RvcnkuanMiLCJzcmMvZGF0YS9hZGFwdGVyL21pc2MuanMiLCJzcmMvZGF0YS9hZGFwdGVyL3NjcmlwdC5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvdGV4dHVyZS5qcyIsInNyYy9kYXRhL2FkYXB0ZXIvdHJhbnNmb3JtLmpzIiwic3JjL2RhdGEvYWRhcHRlci92YWx1ZXMuanMiLCJzcmMvZGF0YS90cmFuc2Zvcm0tZmV0Y2hlci5qcyIsInNyYy9nbG9iYWwuanMiLCJzcmMvaW5pdC5qcyIsInNyYy9pbnRlcmZhY2UvYXR0cmlidXRlcy5qcyIsInNyYy9pbnRlcmZhY2UvY29uZmlndXJhdGlvbi5qcyIsInNyYy9pbnRlcmZhY2UvZG9tLmpzIiwic3JjL2ludGVyZmFjZS9lbGVtZW50cy5qcyIsInNyYy9pbnRlcmZhY2UvbWV0aG9kcy5qcyIsInNyYy9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzIiwic3JjL2ludGVyZmFjZS9wcm9wZXJ0aWVzLmpzIiwic3JjL21hdGgvYmJveC5qcyIsInNyYy9tYXRoL21hdGguanMiLCJzcmMvbWF0aC9yYXkuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9iYXNlLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvZGVmcy5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL2ZhY3RvcnkuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9ncm91cC5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL2xpZ2h0LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIvbGlnaHRzaGFkZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9tYXRlcmlhbC5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL21lc2guanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci9tb2RlbC5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9hZGFwdGVyL3RyYW5zZm9ybWFibGUuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvYWRhcHRlci92aWV3LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2FkYXB0ZXIveG1sM2QuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvY2FudmFzLWhhbmRsZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvY29uZmlndXJlLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL2V2ZW50cy9tb3VzZS5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9ldmVudHMvdG91Y2guanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvbGlnaHRzL2xpZ2h0LW1hbmFnZXIuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvbGlnaHRzL2xpZ2h0LW1vZGVscy5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9yZW5kZXJlci1mYWN0b3J5LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL2NvbnN0YW50cy5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9zY2VuZS9kcmF3YWJsZWNsb3N1cmUuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvbGlnaHQtY29uZmlndXJhdGlvbi5qcyIsInNyYy9yZW5kZXJlci9yZW5kZXJlci9zY2VuZS9tYXRlcmlhbC1jb25maWd1cmF0aW9uLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3BhZ2VyLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3JlbmRlcmdyb3VwLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3JlbmRlcmxpZ2h0LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3JlbmRlcm5vZGUuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvcmVuZGVyb2JqZWN0LmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3NjZW5lL3JlbmRlcnZpZXcuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvc2NlbmUvc2NlbmUuanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvdG9vbHMvZGF0YWNoYW5nZWxpc3RlbmVyLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3Rvb2xzL2ZydXN0dW0uanMiLCJzcmMvcmVuZGVyZXIvcmVuZGVyZXIvdG9vbHMvb2JqZWN0c29ydGVyLmpzIiwic3JjL3JlbmRlcmVyL3JlbmRlcmVyL3V0aWxzLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL2Jhc2UvY29udGV4dC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9iYXNlL2Z1bGxzY3JlZW5xdWFkLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL2Jhc2UvbWVzaC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9iYXNlL3Byb2dyYW0uanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvYmFzZS9yZW5kZXJ0YXJnZXQuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvYmFzZS90ZXh0dXJlLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL2Jhc2UvdXRpbHMuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvY2FudmFzLWhhbmRsZXIuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL2Fic3RyYWN0c2hhZGVyY2xvc3VyZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvYWJzdHJhY3RzaGFkZXJjb21wb3Nlci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvZXZlbnRzLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy9qcy9qc3NoYWRlcmNsb3N1cmUuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL2pzL2pzc2hhZGVyY29tcG9zZXIuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL2pzL2pzc3lzdGVtY29uZmlndXJhdGlvbi5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvc2hhZGVyY29tcG9zZXJmYWN0b3J5LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy9zaGFkb3dtYXAtc2VydmljZS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL2RlZmF1bHQuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi9kaWZmdXNlLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy91cm4vbWF0dGUuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi9waG9uZy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL3BvaW50LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy91cm4vcmVnaXN0ZXJ5LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy91cm4vc2hhZGVyLWRlc2NyaXB0b3IuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi91cm5zaGFkZXJjbG9zdXJlLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL21hdGVyaWFscy91cm4vdXJuc2hhZGVyY29tcG9zZXIuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvbWF0ZXJpYWxzL3Vybi91dGlsaXR5LmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlci1pbnRlcmZhY2UuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9iYXNlLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlci1wYXNzZXMvYm94Ymx1ci5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL2ZvcndhcmQuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9saWdodC1wYXNzLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlci1wYXNzZXMvcGljay1ub3JtYWwuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9waWNrLW9iamVjdC5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9yZW5kZXItcGFzc2VzL3BpY2stcG9zaXRpb24uanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9wb2ludGxpZ2h0LXBhc3MuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXBhc3Nlcy9zY2VuZS1wYXNzLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlci1wYXNzZXMvc3Nhby1wYXNzLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3JlbmRlci1wYXNzZXMvdmVydGV4YXR0cmlidXRlLXBhc3MuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXRyZWVzL2Jhc2UuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyLXRyZWVzL2ZvcndhcmQuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvcmVuZGVyZXIuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wvc2NlbmUvZHJhd2FibGUtZmFjdG9yeS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9zY2VuZS9nbGxpZ2h0cy5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9zY2VuZS9nbHNjZW5lLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3NoYWRlci9wcm9ncmFtZmFjdG9yeS5qcyIsInNyYy9yZW5kZXJlci93ZWJnbC9zaGFkZXIvc2hhZGVyLXV0aWxzLmpzIiwic3JjL3JlbmRlcmVyL3dlYmdsL3N5c3RlbS9zeXN0ZW0tbm90aWZpZXIuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wveGZsb3cvdXRpbHMuanMiLCJzcmMvcmVuZGVyZXIvd2ViZ2wveGZsb3cveGZsb3ctbWVzaC5qcyIsInNyYy90eXBlcy9heGlzYW5nbGUuanMiLCJzcmMvdHlwZXMvYm94LmpzIiwic3JjL3R5cGVzL2RhdGEtb2JzZXJ2ZXIuanMiLCJzcmMvdHlwZXMvbWF0Mi5qcyIsInNyYy90eXBlcy9tYXQzLmpzIiwic3JjL3R5cGVzL21hdDQuanMiLCJzcmMvdHlwZXMvcXVhdC5qcyIsInNyYy90eXBlcy9yYXkuanMiLCJzcmMvdHlwZXMvdmVjMi5qcyIsInNyYy90eXBlcy92ZWMzLmpzIiwic3JjL3R5cGVzL3ZlYzQuanMiLCJzcmMvdXRpbHMvYXJyYXkuanMiLCJzcmMvdXRpbHMvY3NzLmpzIiwic3JjL3V0aWxzL2Nzc01hdHJpeC5qcyIsInNyYy91dGlscy9kZWJ1Zy5qcyIsInNyYy91dGlscy9taXNjLmpzIiwic3JjL3V0aWxzL29wdGlvbnMuanMiLCJzcmMvdXRpbHMvdXJpLmpzIiwic3JjL3V0aWxzL3dlYmNsLmpzIiwic3JjL3hmbG93L2Jhc2UuanMiLCJzcmMveGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qcyIsInNyYy94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qcyIsInNyYy94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanMiLCJzcmMveGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvY2wtcHJvZ3JhbS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2FkZC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2J1ZmZlclNlbGVjdC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2NsYW1wSW1hZ2UuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9jb252b2x1dGVJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2NyZWF0ZUlHSW5kZXguanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9jcmVhdGVUcmFuc2Zvcm0uanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9jcmVhdGVUcmFuc2Zvcm1JbnYuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9kZWJ1Zy5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2ZsaXBOb3JtYWwuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9mbGlwVmVydGljYWxJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2ZvcndhcmRLaW5lbWF0aWNzLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvZm9yd2FyZEtpbmVtYXRpY3NJbnYuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9mdW5NaXJyb3JJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2dldC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L2dyYXlzY2FsZUltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvaW5kZXguanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9sZXJwM3NlcS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L21hZ25pdHVkZUltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvbWVyZ2UzLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvbW9ycGgzLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvbXVsNHg0LmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvbm9pc2VJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L25vcm1hbGl6ZTMuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9wb3BhcnRJbWFnZS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L3JnYmVQTkd0b0Zsb2F0LmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc2VsZWN0Qm9vbC5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L3NlbGVjdFRyYW5zZm9ybS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9kZWZhdWx0L3NlcGlhSW1hZ2UuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9za2luRGlyZWN0aW9uLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc2tpblBvc2l0aW9uLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc2xlcnBzZXEuanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvZGVmYXVsdC9zb2JlbEltYWdlLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL2RlZmF1bHQvc3ViMy5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9vcGVyYXRvci1lbnRyeS5qcyIsInNyYy94Zmxvdy9vcGVyYXRvci9vcGVyYXRvci1saXN0LmpzIiwic3JjL3hmbG93L29wZXJhdG9yL29wZXJhdG9yLmpzIiwic3JjL3hmbG93L29wZXJhdG9yL3Byb2dyYW0uanMiLCJzcmMveGZsb3cvb3BlcmF0b3IvdnMtcHJvZ3JhbS5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL2NoYW5uZWwtbm9kZS5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL2NoYW5uZWwuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy9kYXRhLXNsb3QuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy9leGVjdXRvci5qcyIsInNyYy94Zmxvdy9wcm9jZXNzaW5nL21hcHBpbmcuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy9wcm9jZXNzLW5vZGUuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy9yZXN1bHQuanMiLCJzcmMveGZsb3cvcHJvY2Vzc2luZy92cy1jb25uZWN0LmpzIiwic3JjL3hmbG93L3V0aWxzL3V0aWxzLmpzIiwic3JjL3htbDNkLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ253Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDL0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1eEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoY0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaGpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDenpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbDJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzc5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL2lCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hIQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogQGZpbGVvdmVydmlldyBnbC1tYXRyaXggLSBIaWdoIHBlcmZvcm1hbmNlIG1hdHJpeCBhbmQgdmVjdG9yIG9wZXJhdGlvbnNcbiAqIEBhdXRob3IgQnJhbmRvbiBKb25lc1xuICogQGF1dGhvciBDb2xpbiBNYWNLZW56aWUgSVZcbiAqIEB2ZXJzaW9uIDIuMy4xXG4gKi9cblxuLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cbi8vIEVORCBIRUFERVJcblxuZXhwb3J0cy5nbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9jb21tb24uanNcIik7XG5leHBvcnRzLm1hdDIgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0Mi5qc1wiKTtcbmV4cG9ydHMubWF0MmQgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0MmQuanNcIik7XG5leHBvcnRzLm1hdDMgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvbWF0My5qc1wiKTtcbmV4cG9ydHMubWF0NCA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC9tYXQ0LmpzXCIpO1xuZXhwb3J0cy5xdWF0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3F1YXQuanNcIik7XG5leHBvcnRzLnZlYzIgPSByZXF1aXJlKFwiLi9nbC1tYXRyaXgvdmVjMi5qc1wiKTtcbmV4cG9ydHMudmVjMyA9IHJlcXVpcmUoXCIuL2dsLW1hdHJpeC92ZWMzLmpzXCIpO1xuZXhwb3J0cy52ZWM0ID0gcmVxdWlyZShcIi4vZ2wtbWF0cml4L3ZlYzQuanNcIik7IiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxuLyoqXG4gKiBAY2xhc3MgQ29tbW9uIHV0aWxpdGllc1xuICogQG5hbWUgZ2xNYXRyaXhcbiAqL1xudmFyIGdsTWF0cml4ID0ge307XG5cbi8vIENvbnN0YW50c1xuZ2xNYXRyaXguRVBTSUxPTiA9IDAuMDAwMDAxO1xuZ2xNYXRyaXguQVJSQVlfVFlQRSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9PSAndW5kZWZpbmVkJykgPyBGbG9hdDMyQXJyYXkgOiBBcnJheTtcbmdsTWF0cml4LlJBTkRPTSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFNldHMgdGhlIHR5cGUgb2YgYXJyYXkgdXNlZCB3aGVuIGNyZWF0aW5nIG5ldyB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xuICpcbiAqIEBwYXJhbSB7VHlwZX0gdHlwZSBBcnJheSB0eXBlLCBzdWNoIGFzIEZsb2F0MzJBcnJheSBvciBBcnJheVxuICovXG5nbE1hdHJpeC5zZXRNYXRyaXhBcnJheVR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgR0xNQVRfQVJSQVlfVFlQRSA9IHR5cGU7XG59XG5cbnZhciBkZWdyZWUgPSBNYXRoLlBJIC8gMTgwO1xuXG4vKipcbiogQ29udmVydCBEZWdyZWUgVG8gUmFkaWFuXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSBBbmdsZSBpbiBEZWdyZWVzXG4qL1xuZ2xNYXRyaXgudG9SYWRpYW4gPSBmdW5jdGlvbihhKXtcbiAgICAgcmV0dXJuIGEgKiBkZWdyZWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xNYXRyaXg7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDJ4MiBNYXRyaXhcbiAqIEBuYW1lIG1hdDJcbiAqL1xudmFyIG1hdDIgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJcbiAqXG4gKiBAcmV0dXJucyB7bWF0Mn0gYSBuZXcgMngyIG1hdHJpeFxuICovXG5tYXQyLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0MiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyfSBhIG5ldyAyeDIgbWF0cml4XG4gKi9cbm1hdDIuY2xvbmUgPSBmdW5jdGlvbihhKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGExID0gYVsxXTtcbiAgICAgICAgb3V0WzFdID0gYVsyXTtcbiAgICAgICAgb3V0WzJdID0gYTE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVsyXTtcbiAgICAgICAgb3V0WzJdID0gYVsxXTtcbiAgICAgICAgb3V0WzNdID0gYVszXTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGEwICogYTMgLSBhMiAqIGExO1xuXG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcbiAgICBcbiAgICBvdXRbMF0gPSAgYTMgKiBkZXQ7XG4gICAgb3V0WzFdID0gLWExICogZGV0O1xuICAgIG91dFsyXSA9IC1hMiAqIGRldDtcbiAgICBvdXRbM10gPSAgYTAgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDJcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuYWRqb2ludCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIENhY2hpbmcgdGhpcyB2YWx1ZSBpcyBuZXNzZWNhcnkgaWYgb3V0ID09IGFcbiAgICB2YXIgYTAgPSBhWzBdO1xuICAgIG91dFswXSA9ICBhWzNdO1xuICAgIG91dFsxXSA9IC1hWzFdO1xuICAgIG91dFsyXSA9IC1hWzJdO1xuICAgIG91dFszXSA9ICBhMDtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQyLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYVswXSAqIGFbM10gLSBhWzJdICogYVsxXTtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0MidzXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDJ9IG91dFxuICovXG5tYXQyLm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMCA9IGFbMF0sIGExID0gYVsxXSwgYTIgPSBhWzJdLCBhMyA9IGFbM107XG4gICAgdmFyIGIwID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0Mi5tdWwgPSBtYXQyLm11bHRpcGx5O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQyIGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGEwICogIGMgKyBhMiAqIHM7XG4gICAgb3V0WzFdID0gYTEgKiAgYyArIGEzICogcztcbiAgICBvdXRbMl0gPSBhMCAqIC1zICsgYTIgKiBjO1xuICAgIG91dFszXSA9IGExICogLXMgKyBhMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQyIGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMyXG4gKlxuICogQHBhcmFtIHttYXQyfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0Mn0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqKi9cbm1hdDIuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICB2MCA9IHZbMF0sIHYxID0gdlsxXTtcbiAgICBvdXRbMF0gPSBhMCAqIHYwO1xuICAgIG91dFsxXSA9IGExICogdjA7XG4gICAgb3V0WzJdID0gYTIgKiB2MTtcbiAgICBvdXRbM10gPSBhMyAqIHYxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0Mi5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0Mn0gb3V0IG1hdDIgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0Mn0gb3V0XG4gKi9cbm1hdDIuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIG91dFswXSA9IGM7XG4gICAgb3V0WzFdID0gcztcbiAgICBvdXRbMl0gPSAtcztcbiAgICBvdXRbM10gPSBjO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHNjYWxpbmdcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDIuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJ9IG91dCBtYXQyIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyfSBvdXRcbiAqL1xubWF0Mi5mcm9tU2NhbGluZyA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IHZbMF07XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IHZbMV07XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7bWF0Mn0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDIuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDIoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQyXG4gKlxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQyLmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikpKVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIEwsIEQgYW5kIFUgbWF0cmljZXMgKExvd2VyIHRyaWFuZ3VsYXIsIERpYWdvbmFsIGFuZCBVcHBlciB0cmlhbmd1bGFyKSBieSBmYWN0b3JpemluZyB0aGUgaW5wdXQgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJ9IEwgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBEIHRoZSBkaWFnb25hbCBtYXRyaXggXG4gKiBAcGFyYW0ge21hdDJ9IFUgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IFxuICogQHBhcmFtIHttYXQyfSBhIHRoZSBpbnB1dCBtYXRyaXggdG8gZmFjdG9yaXplXG4gKi9cblxubWF0Mi5MRFUgPSBmdW5jdGlvbiAoTCwgRCwgVSwgYSkgeyBcbiAgICBMWzJdID0gYVsyXS9hWzBdOyBcbiAgICBVWzBdID0gYVswXTsgXG4gICAgVVsxXSA9IGFbMV07IFxuICAgIFVbM10gPSBhWzNdIC0gTFsyXSAqIFVbMV07IFxuICAgIHJldHVybiBbTCwgRCwgVV07ICAgICAgIFxufTsgXG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQyO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyAyeDMgTWF0cml4XG4gKiBAbmFtZSBtYXQyZFxuICogXG4gKiBAZGVzY3JpcHRpb24gXG4gKiBBIG1hdDJkIGNvbnRhaW5zIHNpeCBlbGVtZW50cyBkZWZpbmVkIGFzOlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eV1cbiAqIDwvcHJlPlxuICogVGhpcyBpcyBhIHNob3J0IGZvcm0gZm9yIHRoZSAzeDMgbWF0cml4OlxuICogPHByZT5cbiAqIFthLCBjLCB0eCxcbiAqICBiLCBkLCB0eSxcbiAqICAwLCAwLCAxXVxuICogPC9wcmU+XG4gKiBUaGUgbGFzdCByb3cgaXMgaWdub3JlZCBzbyB0aGUgYXJyYXkgaXMgc2hvcnRlciBhbmQgb3BlcmF0aW9ucyBhcmUgZmFzdGVyLlxuICovXG52YXIgbWF0MmQgPSB7fTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdDJkXG4gKlxuICogQHJldHVybnMge21hdDJkfSBhIG5ldyAyeDMgbWF0cml4XG4gKi9cbm1hdDJkLmNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDJkIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQyZH0gYSBuZXcgMngzIG1hdHJpeFxuICovXG5tYXQyZC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDJkIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQyZCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5pZGVudGl0eSA9IGZ1bmN0aW9uKG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQyZFxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGFhID0gYVswXSwgYWIgPSBhWzFdLCBhYyA9IGFbMl0sIGFkID0gYVszXSxcbiAgICAgICAgYXR4ID0gYVs0XSwgYXR5ID0gYVs1XTtcblxuICAgIHZhciBkZXQgPSBhYSAqIGFkIC0gYWIgKiBhYztcbiAgICBpZighZGV0KXtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IGFkICogZGV0O1xuICAgIG91dFsxXSA9IC1hYiAqIGRldDtcbiAgICBvdXRbMl0gPSAtYWMgKiBkZXQ7XG4gICAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGFjICogYXR5IC0gYWQgKiBhdHgpICogZGV0O1xuICAgIG91dFs1XSA9IChhYiAqIGF0eCAtIGFhICogYXR5KSAqIGRldDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQyZC5kZXRlcm1pbmFudCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBhWzNdIC0gYVsxXSAqIGFbMl07XG59O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDJkJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0MmR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICovXG5tYXQyZC5tdWx0aXBseSA9IGZ1bmN0aW9uIChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgYjAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdLCBiNCA9IGJbNF0sIGI1ID0gYls1XTtcbiAgICBvdXRbMF0gPSBhMCAqIGIwICsgYTIgKiBiMTtcbiAgICBvdXRbMV0gPSBhMSAqIGIwICsgYTMgKiBiMTtcbiAgICBvdXRbMl0gPSBhMCAqIGIyICsgYTIgKiBiMztcbiAgICBvdXRbM10gPSBhMSAqIGIyICsgYTMgKiBiMztcbiAgICBvdXRbNF0gPSBhMCAqIGI0ICsgYTIgKiBiNSArIGE0O1xuICAgIG91dFs1XSA9IGExICogYjQgKyBhMyAqIGI1ICsgYTU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQyZC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5tYXQyZC5tdWwgPSBtYXQyZC5tdWx0aXBseTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MmQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDJkfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDJkfSBvdXRcbiAqL1xubWF0MmQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBhMCAqICBjICsgYTIgKiBzO1xuICAgIG91dFsxXSA9IGExICogIGMgKyBhMyAqIHM7XG4gICAgb3V0WzJdID0gYTAgKiAtcyArIGEyICogYztcbiAgICBvdXRbM10gPSBhMSAqIC1zICsgYTMgKiBjO1xuICAgIG91dFs0XSA9IGE0O1xuICAgIG91dFs1XSA9IGE1O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0MmQgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0MmR9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB0aGUgdmVjMiB0byBzY2FsZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIHYpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLCBhNCA9IGFbNF0sIGE1ID0gYVs1XSxcbiAgICAgICAgdjAgPSB2WzBdLCB2MSA9IHZbMV07XG4gICAgb3V0WzBdID0gYTAgKiB2MDtcbiAgICBvdXRbMV0gPSBhMSAqIHYwO1xuICAgIG91dFsyXSA9IGEyICogdjE7XG4gICAgb3V0WzNdID0gYTMgKiB2MTtcbiAgICBvdXRbNF0gPSBhNDtcbiAgICBvdXRbNV0gPSBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGVzIHRoZSBtYXQyZCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjMlxuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMyfSB2IHRoZSB2ZWMyIHRvIHRyYW5zbGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0MmR9IG91dFxuICoqL1xubWF0MmQudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwID0gYVswXSwgYTEgPSBhWzFdLCBhMiA9IGFbMl0sIGEzID0gYVszXSwgYTQgPSBhWzRdLCBhNSA9IGFbNV0sXG4gICAgICAgIHYwID0gdlswXSwgdjEgPSB2WzFdO1xuICAgIG91dFswXSA9IGEwO1xuICAgIG91dFsxXSA9IGExO1xuICAgIG91dFsyXSA9IGEyO1xuICAgIG91dFszXSA9IGEzO1xuICAgIG91dFs0XSA9IGEwICogdjAgKyBhMiAqIHYxICsgYTQ7XG4gICAgb3V0WzVdID0gYTEgKiB2MCArIGEzICogdjEgKyBhNTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0MmR9IG91dCBtYXQyZCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmZyb21Sb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLCBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBvdXRbMF0gPSBjO1xuICAgIG91dFsxXSA9IHM7XG4gICAgb3V0WzJdID0gLXM7XG4gICAgb3V0WzNdID0gYztcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDJkLmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDJkLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQyZH0gb3V0IG1hdDJkIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzJ9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmZyb21TY2FsaW5nID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gdlswXTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gdlsxXTtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQyZC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQyZC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDJkfSBvdXQgbWF0MmQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQyZH0gb3V0XG4gKi9cbm1hdDJkLmZyb21UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKG91dCwgdikge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgb3V0WzRdID0gdlswXTtcbiAgICBvdXRbNV0gPSB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSBtYXRyaXggdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeFxuICovXG5tYXQyZC5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiAnbWF0MmQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcpJztcbn07XG5cbi8qKlxuICogUmV0dXJucyBGcm9iZW5pdXMgbm9ybSBvZiBhIG1hdDJkXG4gKlxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0MmQuZnJvYiA9IGZ1bmN0aW9uIChhKSB7IFxuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgMSkpXG59OyBcblxubW9kdWxlLmV4cG9ydHMgPSBtYXQyZDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgM3gzIE1hdHJpeFxuICogQG5hbWUgbWF0M1xuICovXG52YXIgbWF0MyA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0M1xuICpcbiAqIEByZXR1cm5zIHttYXQzfSBhIG5ldyAzeDMgbWF0cml4XG4gKi9cbm1hdDMuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDkpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMTtcbiAgICBvdXRbNV0gPSAwO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcGllcyB0aGUgdXBwZXItbGVmdCAzeDMgdmFsdWVzIGludG8gdGhlIGdpdmVuIG1hdDMuXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyAzeDMgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgICB0aGUgc291cmNlIDR4NCBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbNF07XG4gICAgb3V0WzRdID0gYVs1XTtcbiAgICBvdXRbNV0gPSBhWzZdO1xuICAgIG91dFs2XSA9IGFbOF07XG4gICAgb3V0WzddID0gYVs5XTtcbiAgICBvdXRbOF0gPSBhWzEwXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IG1hdDMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IGEgbWF0cml4IHRvIGNsb25lXG4gKiBAcmV0dXJucyB7bWF0M30gYSBuZXcgM3gzIG1hdHJpeFxuICovXG5tYXQzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg5KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0MyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmNvcHkgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQzIHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAxO1xuICAgIG91dFs1XSA9IDA7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNwb3NlIHRoZSB2YWx1ZXMgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMTIgPSBhWzVdO1xuICAgICAgICBvdXRbMV0gPSBhWzNdO1xuICAgICAgICBvdXRbMl0gPSBhWzZdO1xuICAgICAgICBvdXRbM10gPSBhMDE7XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGEwMjtcbiAgICAgICAgb3V0WzddID0gYTEyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbM107XG4gICAgICAgIG91dFsyXSA9IGFbNl07XG4gICAgICAgIG91dFszXSA9IGFbMV07XG4gICAgICAgIG91dFs0XSA9IGFbNF07XG4gICAgICAgIG91dFs1XSA9IGFbN107XG4gICAgICAgIG91dFs2XSA9IGFbMl07XG4gICAgICAgIG91dFs3XSA9IGFbNV07XG4gICAgICAgIG91dFs4XSA9IGFbOF07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmludmVydCA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIGIwMSA9IGEyMiAqIGExMSAtIGExMiAqIGEyMSxcbiAgICAgICAgYjExID0gLWEyMiAqIGExMCArIGExMiAqIGEyMCxcbiAgICAgICAgYjIxID0gYTIxICogYTEwIC0gYTExICogYTIwLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYTAwICogYjAxICsgYTAxICogYjExICsgYTAyICogYjIxO1xuXG4gICAgaWYgKCFkZXQpIHsgXG4gICAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgb3V0WzBdID0gYjAxICogZGV0O1xuICAgIG91dFsxXSA9ICgtYTIyICogYTAxICsgYTAyICogYTIxKSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTEyICogYTAxIC0gYTAyICogYTExKSAqIGRldDtcbiAgICBvdXRbM10gPSBiMTEgKiBkZXQ7XG4gICAgb3V0WzRdID0gKGEyMiAqIGEwMCAtIGEwMiAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzVdID0gKC1hMTIgKiBhMDAgKyBhMDIgKiBhMTApICogZGV0O1xuICAgIG91dFs2XSA9IGIyMSAqIGRldDtcbiAgICBvdXRbN10gPSAoLWEyMSAqIGEwMCArIGEwMSAqIGEyMCkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGExMSAqIGEwMCAtIGEwMSAqIGExMCkgKiBkZXQ7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIG91dFswXSA9IChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpO1xuICAgIG91dFsxXSA9IChhMDIgKiBhMjEgLSBhMDEgKiBhMjIpO1xuICAgIG91dFsyXSA9IChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpO1xuICAgIG91dFszXSA9IChhMTIgKiBhMjAgLSBhMTAgKiBhMjIpO1xuICAgIG91dFs0XSA9IChhMDAgKiBhMjIgLSBhMDIgKiBhMjApO1xuICAgIG91dFs1XSA9IChhMDIgKiBhMTAgLSBhMDAgKiBhMTIpO1xuICAgIG91dFs2XSA9IChhMTAgKiBhMjEgLSBhMTEgKiBhMjApO1xuICAgIG91dFs3XSA9IChhMDEgKiBhMjAgLSBhMDAgKiBhMjEpO1xuICAgIG91dFs4XSA9IChhMDAgKiBhMTEgLSBhMDEgKiBhMTApO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5tYXQzLmRldGVybWluYW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSxcbiAgICAgICAgYTEwID0gYVszXSwgYTExID0gYVs0XSwgYTEyID0gYVs1XSxcbiAgICAgICAgYTIwID0gYVs2XSwgYTIxID0gYVs3XSwgYTIyID0gYVs4XTtcblxuICAgIHJldHVybiBhMDAgKiAoYTIyICogYTExIC0gYTEyICogYTIxKSArIGEwMSAqICgtYTIyICogYTEwICsgYTEyICogYTIwKSArIGEwMiAqIChhMjEgKiBhMTAgLSBhMTEgKiBhMjApO1xufTtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byBtYXQzJ3NcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge21hdDN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMubXVsdGlwbHkgPSBmdW5jdGlvbiAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG5cbiAgICAgICAgYjAwID0gYlswXSwgYjAxID0gYlsxXSwgYjAyID0gYlsyXSxcbiAgICAgICAgYjEwID0gYlszXSwgYjExID0gYls0XSwgYjEyID0gYls1XSxcbiAgICAgICAgYjIwID0gYls2XSwgYjIxID0gYls3XSwgYjIyID0gYls4XTtcblxuICAgIG91dFswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgICBvdXRbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gICAgb3V0WzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuXG4gICAgb3V0WzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICAgIG91dFs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgICBvdXRbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG5cbiAgICBvdXRbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gICAgb3V0WzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICAgIG91dFs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIG1hdDMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xubWF0My5tdWwgPSBtYXQzLm11bHRpcGx5O1xuXG4vKipcbiAqIFRyYW5zbGF0ZSBhIG1hdDMgYnkgdGhlIGdpdmVuIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDN9IGEgdGhlIG1hdHJpeCB0byB0cmFuc2xhdGVcbiAqIEBwYXJhbSB7dmVjMn0gdiB2ZWN0b3IgdG8gdHJhbnNsYXRlIGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMudHJhbnNsYXRlID0gZnVuY3Rpb24ob3V0LCBhLCB2KSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbM10sIGExMSA9IGFbNF0sIGExMiA9IGFbNV0sXG4gICAgICAgIGEyMCA9IGFbNl0sIGEyMSA9IGFbN10sIGEyMiA9IGFbOF0sXG4gICAgICAgIHggPSB2WzBdLCB5ID0gdlsxXTtcblxuICAgIG91dFswXSA9IGEwMDtcbiAgICBvdXRbMV0gPSBhMDE7XG4gICAgb3V0WzJdID0gYTAyO1xuXG4gICAgb3V0WzNdID0gYTEwO1xuICAgIG91dFs0XSA9IGExMTtcbiAgICBvdXRbNV0gPSBhMTI7XG5cbiAgICBvdXRbNl0gPSB4ICogYTAwICsgeSAqIGExMCArIGEyMDtcbiAgICBvdXRbN10gPSB4ICogYTAxICsgeSAqIGExMSArIGEyMTtcbiAgICBvdXRbOF0gPSB4ICogYTAyICsgeSAqIGExMiArIGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0MyBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICovXG5tYXQzLnJvdGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLFxuICAgICAgICBhMTAgPSBhWzNdLCBhMTEgPSBhWzRdLCBhMTIgPSBhWzVdLFxuICAgICAgICBhMjAgPSBhWzZdLCBhMjEgPSBhWzddLCBhMjIgPSBhWzhdLFxuXG4gICAgICAgIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcblxuICAgIG91dFswXSA9IGMgKiBhMDAgKyBzICogYTEwO1xuICAgIG91dFsxXSA9IGMgKiBhMDEgKyBzICogYTExO1xuICAgIG91dFsyXSA9IGMgKiBhMDIgKyBzICogYTEyO1xuXG4gICAgb3V0WzNdID0gYyAqIGExMCAtIHMgKiBhMDA7XG4gICAgb3V0WzRdID0gYyAqIGExMSAtIHMgKiBhMDE7XG4gICAgb3V0WzVdID0gYyAqIGExMiAtIHMgKiBhMDI7XG5cbiAgICBvdXRbNl0gPSBhMjA7XG4gICAgb3V0WzddID0gYTIxO1xuICAgIG91dFs4XSA9IGEyMjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgdGhlIG1hdDMgYnkgdGhlIGRpbWVuc2lvbnMgaW4gdGhlIGdpdmVuIHZlYzJcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzJ9IHYgdGhlIHZlYzIgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDN9IG91dFxuICoqL1xubWF0My5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV07XG5cbiAgICBvdXRbMF0gPSB4ICogYVswXTtcbiAgICBvdXRbMV0gPSB4ICogYVsxXTtcbiAgICBvdXRbMl0gPSB4ICogYVsyXTtcblxuICAgIG91dFszXSA9IHkgKiBhWzNdO1xuICAgIG91dFs0XSA9IHkgKiBhWzRdO1xuICAgIG91dFs1XSA9IHkgKiBhWzVdO1xuXG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQzLnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjMn0gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqL1xubWF0My5mcm9tVHJhbnNsYXRpb24gPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDE7XG4gICAgb3V0WzVdID0gMDtcbiAgICBvdXRbNl0gPSB2WzBdO1xuICAgIG91dFs3XSA9IHZbMV07XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIGdpdmVuIGFuZ2xlXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQzLnJvdGF0ZShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0M30gb3V0IG1hdDMgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbVJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksIGMgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYztcbiAgICBvdXRbMV0gPSBzO1xuICAgIG91dFsyXSA9IDA7XG5cbiAgICBvdXRbM10gPSAtcztcbiAgICBvdXRbNF0gPSBjO1xuICAgIG91dFs1XSA9IDA7XG5cbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0My5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQzLnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQzfSBvdXQgbWF0MyByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMyfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0M30gb3V0XG4gKi9cbm1hdDMuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcblxuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gdlsxXTtcbiAgICBvdXRbNV0gPSAwO1xuXG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBmcm9tIGEgbWF0MmQgaW50byBhIG1hdDNcbiAqXG4gKiBAcGFyYW0ge21hdDN9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQyZH0gYSB0aGUgbWF0cml4IHRvIGNvcHlcbiAqIEByZXR1cm5zIHttYXQzfSBvdXRcbiAqKi9cbm1hdDMuZnJvbU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IDA7XG5cbiAgICBvdXRbM10gPSBhWzJdO1xuICAgIG91dFs0XSA9IGFbM107XG4gICAgb3V0WzVdID0gMDtcblxuICAgIG91dFs2XSA9IGFbNF07XG4gICAgb3V0WzddID0gYVs1XTtcbiAgICBvdXRbOF0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiogQ2FsY3VsYXRlcyBhIDN4MyBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gcXVhdGVybmlvblxuKlxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4qIEBwYXJhbSB7cXVhdH0gcSBRdWF0ZXJuaW9uIHRvIGNyZWF0ZSBtYXRyaXggZnJvbVxuKlxuKiBAcmV0dXJucyB7bWF0M30gb3V0XG4qL1xubWF0My5mcm9tUXVhdCA9IGZ1bmN0aW9uIChvdXQsIHEpIHtcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHl4ID0geSAqIHgyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgenggPSB6ICogeDIsXG4gICAgICAgIHp5ID0geiAqIHkyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSB5eSAtIHp6O1xuICAgIG91dFszXSA9IHl4IC0gd3o7XG4gICAgb3V0WzZdID0genggKyB3eTtcblxuICAgIG91dFsxXSA9IHl4ICsgd3o7XG4gICAgb3V0WzRdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzddID0genkgLSB3eDtcblxuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzVdID0genkgKyB3eDtcbiAgICBvdXRbOF0gPSAxIC0geHggLSB5eTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiogQ2FsY3VsYXRlcyBhIDN4MyBub3JtYWwgbWF0cml4ICh0cmFuc3Bvc2UgaW52ZXJzZSkgZnJvbSB0aGUgNHg0IG1hdHJpeFxuKlxuKiBAcGFyYW0ge21hdDN9IG91dCBtYXQzIHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4qIEBwYXJhbSB7bWF0NH0gYSBNYXQ0IHRvIGRlcml2ZSB0aGUgbm9ybWFsIG1hdHJpeCBmcm9tXG4qXG4qIEByZXR1cm5zIHttYXQzfSBvdXRcbiovXG5tYXQzLm5vcm1hbEZyb21NYXQ0ID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcblxuICAgIG91dFszXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFs0XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuXG4gICAgb3V0WzZdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgb3V0WzddID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgb3V0WzhdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0M1xuICpcbiAqIEBwYXJhbSB7bWF0M30gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzNdICsgJywgJyArIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBcbiAgICAgICAgICAgICAgICAgICAgYVs2XSArICcsICcgKyBhWzddICsgJywgJyArIGFbOF0gKyAnKSc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgRnJvYmVuaXVzIG5vcm0gb2YgYSBtYXQzXG4gKlxuICogQHBhcmFtIHttYXQzfSBhIHRoZSBtYXRyaXggdG8gY2FsY3VsYXRlIEZyb2Jlbml1cyBub3JtIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBGcm9iZW5pdXMgbm9ybVxuICovXG5tYXQzLmZyb2IgPSBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybihNYXRoLnNxcnQoTWF0aC5wb3coYVswXSwgMikgKyBNYXRoLnBvdyhhWzFdLCAyKSArIE1hdGgucG93KGFbMl0sIDIpICsgTWF0aC5wb3coYVszXSwgMikgKyBNYXRoLnBvdyhhWzRdLCAyKSArIE1hdGgucG93KGFbNV0sIDIpICsgTWF0aC5wb3coYVs2XSwgMikgKyBNYXRoLnBvdyhhWzddLCAyKSArIE1hdGgucG93KGFbOF0sIDIpKSlcbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSBtYXQzO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyA0eDQgTWF0cml4XG4gKiBAbmFtZSBtYXQ0XG4gKi9cbnZhciBtYXQ0ID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xubWF0NC5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMTYpO1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmlkZW50aXR5ID0gZnVuY3Rpb24ob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQudHJhbnNwb3NlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgIGlmIChvdXQgPT09IGEpIHtcbiAgICAgICAgdmFyIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgICAgICBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGEwMTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGEwMjtcbiAgICAgICAgb3V0WzldID0gYTEyO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhMDM7XG4gICAgICAgIG91dFsxM10gPSBhMTM7XG4gICAgICAgIG91dFsxNF0gPSBhMjM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgb3V0WzBdID0gYVswXTtcbiAgICAgICAgb3V0WzFdID0gYVs0XTtcbiAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgb3V0WzNdID0gYVsxMl07XG4gICAgICAgIG91dFs0XSA9IGFbMV07XG4gICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhWzJdO1xuICAgICAgICBvdXRbOV0gPSBhWzZdO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbM107XG4gICAgICAgIG91dFsxM10gPSBhWzddO1xuICAgICAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogSW52ZXJ0cyBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuaW52ZXJ0ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmFkam9pbnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIG91dFswXSAgPSAgKGExMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzFdICA9IC0oYTAxICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbMl0gID0gIChhMDEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFszXSAgPSAtKGEwMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTExICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzRdICA9IC0oYTEwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbNV0gID0gIChhMDAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFs2XSAgPSAtKGEwMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTEwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzddICA9ICAoYTAwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbOF0gID0gIChhMTAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkpO1xuICAgIG91dFs5XSAgPSAtKGEwMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSk7XG4gICAgb3V0WzEwXSA9ICAoYTAwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTFdID0gLShhMDAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMl0gPSAtKGExMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSk7XG4gICAgb3V0WzEzXSA9ICAoYTAwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpKTtcbiAgICBvdXRbMTRdID0gLShhMDAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIG91dFsxNV0gPSAgKGEwMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbm1hdDQuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzI7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgcmV0dXJuIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbn07XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm11bHRpcGx5ID0gZnVuY3Rpb24gKG91dCwgYSwgYikge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107ICBcbiAgICBvdXRbMF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzFdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsyXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbM10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbNF07IGIxID0gYls1XTsgYjIgPSBiWzZdOyBiMyA9IGJbN107XG4gICAgb3V0WzRdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs1XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbNl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzddID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzhdOyBiMSA9IGJbOV07IGIyID0gYlsxMF07IGIzID0gYlsxMV07XG4gICAgb3V0WzhdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFs5XSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTBdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxMV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbMTJdOyBiMSA9IGJbMTNdOyBiMiA9IGJbMTRdOyBiMyA9IGJbMTVdO1xuICAgIG91dFsxMl0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzEzXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMTRdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFsxNV0gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBtYXQ0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbm1hdDQubXVsID0gbWF0NC5tdWx0aXBseTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIChvdXQsIGEsIHYpIHtcbiAgICB2YXIgeCA9IHZbMF0sIHkgPSB2WzFdLCB6ID0gdlsyXSxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMztcblxuICAgIGlmIChhID09PSBvdXQpIHtcbiAgICAgICAgb3V0WzEyXSA9IGFbMF0gKiB4ICsgYVs0XSAqIHkgKyBhWzhdICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxXSAqIHggKyBhWzVdICogeSArIGFbOV0gKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzJdICogeCArIGFbNl0gKiB5ICsgYVsxMF0gKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzNdICogeCArIGFbN10gKiB5ICsgYVsxMV0gKiB6ICsgYVsxNV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICAgICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICAgICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFswXSA9IGEwMDsgb3V0WzFdID0gYTAxOyBvdXRbMl0gPSBhMDI7IG91dFszXSA9IGEwMztcbiAgICAgICAgb3V0WzRdID0gYTEwOyBvdXRbNV0gPSBhMTE7IG91dFs2XSA9IGExMjsgb3V0WzddID0gYTEzO1xuICAgICAgICBvdXRbOF0gPSBhMjA7IG91dFs5XSA9IGEyMTsgb3V0WzEwXSA9IGEyMjsgb3V0WzExXSA9IGEyMztcblxuICAgICAgICBvdXRbMTJdID0gYTAwICogeCArIGExMCAqIHkgKyBhMjAgKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhMDEgKiB4ICsgYTExICogeSArIGEyMSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGEwMiAqIHggKyBhMTIgKiB5ICsgYTIyICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYTAzICogeCArIGExMyAqIHkgKyBhMjMgKiB6ICsgYVsxNV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xubWF0NC5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBnaXZlbiBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0LFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxuICAgICAgICBiMDAsIGIwMSwgYjAyLFxuICAgICAgICBiMTAsIGIxMSwgYjEyLFxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCBnbE1hdHJpeC5FUFNJTE9OKSB7IHJldHVybiBudWxsOyB9XG4gICAgXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gICAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQucm90YXRlWCA9IGZ1bmN0aW9uIChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5yb3RhdGVZID0gZnVuY3Rpb24gKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFs0XSAgPSBhWzRdO1xuICAgICAgICBvdXRbNV0gID0gYVs1XTtcbiAgICAgICAgb3V0WzZdICA9IGFbNl07XG4gICAgICAgIG91dFs3XSAgPSBhWzddO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgLSBhMjAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgLSBhMjEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgLSBhMjIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgLSBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEwMCAqIHMgKyBhMjAgKiBjO1xuICAgIG91dFs5XSA9IGEwMSAqIHMgKyBhMjEgKiBjO1xuICAgIG91dFsxMF0gPSBhMDIgKiBzICsgYTIyICogYztcbiAgICBvdXRbMTFdID0gYTAzICogcyArIGEyMyAqIGM7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICAgIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgVHJhbnNsYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVRyYW5zbGF0aW9uID0gZnVuY3Rpb24ob3V0LCB2KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYyk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFNjYWxpbmcgdmVjdG9yXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVNjYWxpbmcgPSBmdW5jdGlvbihvdXQsIHYpIHtcbiAgICBvdXRbMF0gPSB2WzBdO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gdlsxXTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSB2WzJdO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGUoZGVzdCwgZGVzdCwgcmFkLCBheGlzKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdDtcbiAgICBcbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IGdsTWF0cml4LkVQU0lMT04pIHsgcmV0dXJuIG51bGw7IH1cbiAgICBcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuICAgIFxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcbiAgICBcbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IHggKiB4ICogdCArIGM7XG4gICAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gICAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjO1xuICAgIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHM7XG4gICAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHM7XG4gICAgb3V0WzEwXSA9IHogKiB6ICogdCArIGM7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21YUm90YXRpb24gPSBmdW5jdGlvbihvdXQsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSAgPSAxO1xuICAgIG91dFsxXSAgPSAwO1xuICAgIG91dFsyXSAgPSAwO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gYztcbiAgICBvdXRbNl0gPSBzO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAtcztcbiAgICBvdXRbMTBdID0gYztcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQucm90YXRlWShkZXN0LCBkZXN0LCByYWQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVlSb3RhdGlvbiA9IGZ1bmN0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICBcbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdICA9IGM7XG4gICAgb3V0WzFdICA9IDA7XG4gICAgb3V0WzJdICA9IC1zO1xuICAgIG91dFszXSAgPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gcztcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSBjO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZCk7XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5mcm9tWlJvdGF0aW9uID0gZnVuY3Rpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIFxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gID0gYztcbiAgICBvdXRbMV0gID0gcztcbiAgICBvdXRbMl0gID0gMDtcbiAgICBvdXRbM10gID0gMDtcbiAgICBvdXRbNF0gPSAtcztcbiAgICBvdXRbNV0gPSBjO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uID0gZnVuY3Rpb24gKG91dCwgcSwgdikge1xuICAgIC8vIFF1YXRlcm5pb24gbWF0aFxuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeHkgPSB4ICogeTIsXG4gICAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgICB5eSA9IHkgKiB5MixcbiAgICAgICAgeXogPSB5ICogejIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtICh5eSArIHp6KTtcbiAgICBvdXRbMV0gPSB4eSArIHd6O1xuICAgIG91dFsyXSA9IHh6IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4eSAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSAoeHggKyB6eik7XG4gICAgb3V0WzZdID0geXogKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHh6ICsgd3k7XG4gICAgb3V0WzldID0geXogLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtICh4eCArIHl5KTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gdlswXTtcbiAgICBvdXRbMTNdID0gdlsxXTtcbiAgICBvdXRbMTRdID0gdlsyXTtcbiAgICBvdXRbMTVdID0gMTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uLCB2ZWN0b3IgdHJhbnNsYXRpb24gYW5kIHZlY3RvciBzY2FsZVxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICB2YXIgcXVhdE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gKiAgICAgcXVhdDQudG9NYXQ0KHF1YXQsIHF1YXRNYXQpO1xuICogICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5zY2FsZShkZXN0LCBzY2FsZSlcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uU2NhbGUgPSBmdW5jdGlvbiAob3V0LCBxLCB2LCBzKSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejIsXG4gICAgICAgIHN4ID0gc1swXSxcbiAgICAgICAgc3kgPSBzWzFdLFxuICAgICAgICBzeiA9IHNbMl07XG5cbiAgICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgICBvdXRbMV0gPSAoeHkgKyB3eikgKiBzeDtcbiAgICBvdXRbMl0gPSAoeHogLSB3eSkgKiBzeDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9ICh4eSAtIHd6KSAqIHN5O1xuICAgIG91dFs1XSA9ICgxIC0gKHh4ICsgenopKSAqIHN5O1xuICAgIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHh6ICsgd3kpICogc3o7XG4gICAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gICAgb3V0WzEwXSA9ICgxIC0gKHh4ICsgeXkpKSAqIHN6O1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24sIHZlY3RvciB0cmFuc2xhdGlvbiBhbmQgdmVjdG9yIHNjYWxlLCByb3RhdGluZyBhbmQgc2NhbGluZyBhcm91bmQgdGhlIGdpdmVuIG9yaWdpblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdCk7XG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgdmVjKTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBvcmlnaW4pO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIHNjYWxlKVxuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIG5lZ2F0aXZlT3JpZ2luKTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gcyBTY2FsaW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBvIFRoZSBvcmlnaW4gdmVjdG9yIGFyb3VuZCB3aGljaCB0byBzY2FsZSBhbmQgcm90YXRlXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb25TY2FsZU9yaWdpbiA9IGZ1bmN0aW9uIChvdXQsIHEsIHYsIHMsIG8pIHtcbiAgLy8gUXVhdGVybmlvbiBtYXRoXG4gIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgIHgyID0geCArIHgsXG4gICAgICB5MiA9IHkgKyB5LFxuICAgICAgejIgPSB6ICsgeixcblxuICAgICAgeHggPSB4ICogeDIsXG4gICAgICB4eSA9IHggKiB5MixcbiAgICAgIHh6ID0geCAqIHoyLFxuICAgICAgeXkgPSB5ICogeTIsXG4gICAgICB5eiA9IHkgKiB6MixcbiAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgd3ggPSB3ICogeDIsXG4gICAgICB3eSA9IHcgKiB5MixcbiAgICAgIHd6ID0gdyAqIHoyLFxuICAgICAgXG4gICAgICBzeCA9IHNbMF0sXG4gICAgICBzeSA9IHNbMV0sXG4gICAgICBzeiA9IHNbMl0sXG5cbiAgICAgIG94ID0gb1swXSxcbiAgICAgIG95ID0gb1sxXSxcbiAgICAgIG96ID0gb1syXTtcbiAgICAgIFxuICBvdXRbMF0gPSAoMSAtICh5eSArIHp6KSkgKiBzeDtcbiAgb3V0WzFdID0gKHh5ICsgd3opICogc3g7XG4gIG91dFsyXSA9ICh4eiAtIHd5KSAqIHN4O1xuICBvdXRbM10gPSAwO1xuICBvdXRbNF0gPSAoeHkgLSB3eikgKiBzeTtcbiAgb3V0WzVdID0gKDEgLSAoeHggKyB6eikpICogc3k7XG4gIG91dFs2XSA9ICh5eiArIHd4KSAqIHN5O1xuICBvdXRbN10gPSAwO1xuICBvdXRbOF0gPSAoeHogKyB3eSkgKiBzejtcbiAgb3V0WzldID0gKHl6IC0gd3gpICogc3o7XG4gIG91dFsxMF0gPSAoMSAtICh4eCArIHl5KSkgKiBzejtcbiAgb3V0WzExXSA9IDA7XG4gIG91dFsxMl0gPSB2WzBdICsgb3ggLSAob3V0WzBdICogb3ggKyBvdXRbNF0gKiBveSArIG91dFs4XSAqIG96KTtcbiAgb3V0WzEzXSA9IHZbMV0gKyBveSAtIChvdXRbMV0gKiBveCArIG91dFs1XSAqIG95ICsgb3V0WzldICogb3opO1xuICBvdXRbMTRdID0gdlsyXSArIG96IC0gKG91dFsyXSAqIG94ICsgb3V0WzZdICogb3kgKyBvdXRbMTBdICogb3opO1xuICBvdXRbMTVdID0gMTtcbiAgICAgICAgXG4gIHJldHVybiBvdXQ7XG59O1xuXG5tYXQ0LmZyb21RdWF0ID0gZnVuY3Rpb24gKG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFszXSA9IDA7XG5cbiAgICBvdXRbNF0gPSB5eCAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgb3V0WzddID0gMDtcblxuICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgb3V0WzldID0genkgLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gICAgb3V0WzExXSA9IDA7XG5cbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0LmZydXN0dW0gPSBmdW5jdGlvbiAob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBybCA9IDEgLyAocmlnaHQgLSBsZWZ0KSxcbiAgICAgICAgdGIgPSAxIC8gKHRvcCAtIGJvdHRvbSksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAobmVhciAqIDIpICogcmw7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAobmVhciAqIDIpICogdGI7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IChyaWdodCArIGxlZnQpICogcmw7XG4gICAgb3V0WzldID0gKHRvcCArIGJvdHRvbSkgKiB0YjtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhciAqIDIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uIChvdXQsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIGYgPSAxLjAgLyBNYXRoLnRhbihmb3Z5IC8gMiksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSBmIC8gYXNwZWN0O1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gZjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9ICgyICogZmFyICogbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xubWF0NC5wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldyA9IGZ1bmN0aW9uIChvdXQsIGZvdiwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHVwVGFuID0gTWF0aC50YW4oZm92LnVwRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBkb3duVGFuID0gTWF0aC50YW4oZm92LmRvd25EZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGxlZnRUYW4gPSBNYXRoLnRhbihmb3YubGVmdERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgcmlnaHRUYW4gPSBNYXRoLnRhbihmb3YucmlnaHREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHhTY2FsZSA9IDIuMCAvIChsZWZ0VGFuICsgcmlnaHRUYW4pLFxuICAgICAgICB5U2NhbGUgPSAyLjAgLyAodXBUYW4gKyBkb3duVGFuKTtcblxuICAgIG91dFswXSA9IHhTY2FsZTtcbiAgICBvdXRbMV0gPSAwLjA7XG4gICAgb3V0WzJdID0gMC4wO1xuICAgIG91dFszXSA9IDAuMDtcbiAgICBvdXRbNF0gPSAwLjA7XG4gICAgb3V0WzVdID0geVNjYWxlO1xuICAgIG91dFs2XSA9IDAuMDtcbiAgICBvdXRbN10gPSAwLjA7XG4gICAgb3V0WzhdID0gLSgobGVmdFRhbiAtIHJpZ2h0VGFuKSAqIHhTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzldID0gKCh1cFRhbiAtIGRvd25UYW4pICogeVNjYWxlICogMC41KTtcbiAgICBvdXRbMTBdID0gZmFyIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxMV0gPSAtMS4wO1xuICAgIG91dFsxMl0gPSAwLjA7XG4gICAgb3V0WzEzXSA9IDAuMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIpIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFsxNV0gPSAwLjA7XG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBvcnRob2dvbmFsIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5tYXQ0Lm9ydGhvID0gZnVuY3Rpb24gKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICAgIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gLTIgKiBscjtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IC0yICogYnQ7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMiAqIG5mO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICAgIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICAgIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbm1hdDQubG9va0F0ID0gZnVuY3Rpb24gKG91dCwgZXllLCBjZW50ZXIsIHVwKSB7XG4gICAgdmFyIHgwLCB4MSwgeDIsIHkwLCB5MSwgeTIsIHowLCB6MSwgejIsIGxlbixcbiAgICAgICAgZXlleCA9IGV5ZVswXSxcbiAgICAgICAgZXlleSA9IGV5ZVsxXSxcbiAgICAgICAgZXlleiA9IGV5ZVsyXSxcbiAgICAgICAgdXB4ID0gdXBbMF0sXG4gICAgICAgIHVweSA9IHVwWzFdLFxuICAgICAgICB1cHogPSB1cFsyXSxcbiAgICAgICAgY2VudGVyeCA9IGNlbnRlclswXSxcbiAgICAgICAgY2VudGVyeSA9IGNlbnRlclsxXSxcbiAgICAgICAgY2VudGVyeiA9IGNlbnRlclsyXTtcblxuICAgIGlmIChNYXRoLmFicyhleWV4IC0gY2VudGVyeCkgPCBnbE1hdHJpeC5FUFNJTE9OICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IGdsTWF0cml4LkVQU0lMT04gJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgZ2xNYXRyaXguRVBTSUxPTikge1xuICAgICAgICByZXR1cm4gbWF0NC5pZGVudGl0eShvdXQpO1xuICAgIH1cblxuICAgIHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuXG4gICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeDAgPSAwO1xuICAgICAgICB4MSA9IDA7XG4gICAgICAgIHgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB4MCAqPSBsZW47XG4gICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgeDIgKj0gbGVuO1xuICAgIH1cblxuICAgIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeTAgPSAwO1xuICAgICAgICB5MSA9IDA7XG4gICAgICAgIHkyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgeTIgKj0gbGVuO1xuICAgIH1cblxuICAgIG91dFswXSA9IHgwO1xuICAgIG91dFsxXSA9IHkwO1xuICAgIG91dFsyXSA9IHowO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geDE7XG4gICAgb3V0WzVdID0geTE7XG4gICAgb3V0WzZdID0gejE7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4MjtcbiAgICBvdXRbOV0gPSB5MjtcbiAgICBvdXRbMTBdID0gejI7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbm1hdDQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIEZyb2Jlbml1cyBub3JtIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSBGcm9iZW5pdXMgbm9ybSBvZlxuICogQHJldHVybnMge051bWJlcn0gRnJvYmVuaXVzIG5vcm1cbiAqL1xubWF0NC5mcm9iID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4oTWF0aC5zcXJ0KE1hdGgucG93KGFbMF0sIDIpICsgTWF0aC5wb3coYVsxXSwgMikgKyBNYXRoLnBvdyhhWzJdLCAyKSArIE1hdGgucG93KGFbM10sIDIpICsgTWF0aC5wb3coYVs0XSwgMikgKyBNYXRoLnBvdyhhWzVdLCAyKSArIE1hdGgucG93KGFbNl0sIDIpICsgTWF0aC5wb3coYVs3XSwgMikgKyBNYXRoLnBvdyhhWzhdLCAyKSArIE1hdGgucG93KGFbOV0sIDIpICsgTWF0aC5wb3coYVsxMF0sIDIpICsgTWF0aC5wb3coYVsxMV0sIDIpICsgTWF0aC5wb3coYVsxMl0sIDIpICsgTWF0aC5wb3coYVsxM10sIDIpICsgTWF0aC5wb3coYVsxNF0sIDIpICsgTWF0aC5wb3coYVsxNV0sIDIpICkpXG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0NDtcbiIsIi8qIENvcHlyaWdodCAoYykgMjAxNSwgQnJhbmRvbiBKb25lcywgQ29saW4gTWFjS2VuemllIElWLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuICovXG5cbnZhciBnbE1hdHJpeCA9IHJlcXVpcmUoXCIuL2NvbW1vbi5qc1wiKTtcbnZhciBtYXQzID0gcmVxdWlyZShcIi4vbWF0My5qc1wiKTtcbnZhciB2ZWMzID0gcmVxdWlyZShcIi4vdmVjMy5qc1wiKTtcbnZhciB2ZWM0ID0gcmVxdWlyZShcIi4vdmVjNC5qc1wiKTtcblxuLyoqXG4gKiBAY2xhc3MgUXVhdGVybmlvblxuICogQG5hbWUgcXVhdFxuICovXG52YXIgcXVhdCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgcXVhdFxuICpcbiAqIEByZXR1cm5zIHtxdWF0fSBhIG5ldyBxdWF0ZXJuaW9uXG4gKi9cbnF1YXQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2V0cyBhIHF1YXRlcm5pb24gdG8gcmVwcmVzZW50IHRoZSBzaG9ydGVzdCByb3RhdGlvbiBmcm9tIG9uZVxuICogdmVjdG9yIHRvIGFub3RoZXIuXG4gKlxuICogQm90aCB2ZWN0b3JzIGFyZSBhc3N1bWVkIHRvIGJlIHVuaXQgbGVuZ3RoLlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvbi5cbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgaW5pdGlhbCB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgZGVzdGluYXRpb24gdmVjdG9yXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQucm90YXRpb25UbyA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdG1wdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgdmFyIHhVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygxLDAsMCk7XG4gICAgdmFyIHlVbml0VmVjMyA9IHZlYzMuZnJvbVZhbHVlcygwLDEsMCk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgICAgIHZhciBkb3QgPSB2ZWMzLmRvdChhLCBiKTtcbiAgICAgICAgaWYgKGRvdCA8IC0wLjk5OTk5OSkge1xuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB4VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgaWYgKHZlYzMubGVuZ3RoKHRtcHZlYzMpIDwgMC4wMDAwMDEpXG4gICAgICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXB2ZWMzLCB5VW5pdFZlYzMsIGEpO1xuICAgICAgICAgICAgdmVjMy5ub3JtYWxpemUodG1wdmVjMywgdG1wdmVjMyk7XG4gICAgICAgICAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQsIHRtcHZlYzMsIE1hdGguUEkpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSBlbHNlIGlmIChkb3QgPiAwLjk5OTk5OSkge1xuICAgICAgICAgICAgb3V0WzBdID0gMDtcbiAgICAgICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgICAgICBvdXRbMl0gPSAwO1xuICAgICAgICAgICAgb3V0WzNdID0gMTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcHZlYzMsIGEsIGIpO1xuICAgICAgICAgICAgb3V0WzBdID0gdG1wdmVjM1swXTtcbiAgICAgICAgICAgIG91dFsxXSA9IHRtcHZlYzNbMV07XG4gICAgICAgICAgICBvdXRbMl0gPSB0bXB2ZWMzWzJdO1xuICAgICAgICAgICAgb3V0WzNdID0gMSArIGRvdDtcbiAgICAgICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIG91dCk7XG4gICAgICAgIH1cbiAgICB9O1xufSkoKTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzcGVjaWZpZWQgcXVhdGVybmlvbiB3aXRoIHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlblxuICogYXhlcy4gRWFjaCBheGlzIGlzIGEgdmVjMyBhbmQgaXMgZXhwZWN0ZWQgdG8gYmUgdW5pdCBsZW5ndGggYW5kXG4gKiBwZXJwZW5kaWN1bGFyIHRvIGFsbCBvdGhlciBzcGVjaWZpZWQgYXhlcy5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IHZpZXcgIHRoZSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSB2aWV3aW5nIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSByaWdodCB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJyaWdodFwiIGRpcmVjdGlvblxuICogQHBhcmFtIHt2ZWMzfSB1cCAgICB0aGUgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWwgXCJ1cFwiIGRpcmVjdGlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnNldEF4ZXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdHIgPSBtYXQzLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKG91dCwgdmlldywgcmlnaHQsIHVwKSB7XG4gICAgICAgIG1hdHJbMF0gPSByaWdodFswXTtcbiAgICAgICAgbWF0clszXSA9IHJpZ2h0WzFdO1xuICAgICAgICBtYXRyWzZdID0gcmlnaHRbMl07XG5cbiAgICAgICAgbWF0clsxXSA9IHVwWzBdO1xuICAgICAgICBtYXRyWzRdID0gdXBbMV07XG4gICAgICAgIG1hdHJbN10gPSB1cFsyXTtcblxuICAgICAgICBtYXRyWzJdID0gLXZpZXdbMF07XG4gICAgICAgIG1hdHJbNV0gPSAtdmlld1sxXTtcbiAgICAgICAgbWF0cls4XSA9IC12aWV3WzJdO1xuXG4gICAgICAgIHJldHVybiBxdWF0Lm5vcm1hbGl6ZShvdXQsIHF1YXQuZnJvbU1hdDMob3V0LCBtYXRyKSk7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBxdWF0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgcXVhdGVybmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0ZXJuaW9uIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7cXVhdH0gYSBuZXcgcXVhdGVybmlvblxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY2xvbmUgPSB2ZWM0LmNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgcXVhdCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3F1YXR9IGEgbmV3IHF1YXRlcm5pb25cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmZyb21WYWx1ZXMgPSB2ZWM0LmZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHF1YXQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBzb3VyY2UgcXVhdGVybmlvblxuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuY29weSA9IHZlYzQuY29weTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSBxdWF0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3IFcgY29tcG9uZW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zZXQgPSB2ZWM0LnNldDtcblxuLyoqXG4gKiBTZXQgYSBxdWF0IHRvIHRoZSBpZGVudGl0eSBxdWF0ZXJuaW9uXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuaWRlbnRpdHkgPSBmdW5jdGlvbihvdXQpIHtcbiAgICBvdXRbMF0gPSAwO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldHMgYSBxdWF0IGZyb20gdGhlIGdpdmVuIGFuZ2xlIGFuZCByb3RhdGlvbiBheGlzLFxuICogdGhlbiByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIGFyb3VuZCB3aGljaCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqKi9cbnF1YXQuc2V0QXhpc0FuZ2xlID0gZnVuY3Rpb24ob3V0LCBheGlzLCByYWQpIHtcbiAgICByYWQgPSByYWQgKiAwLjU7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIG91dFswXSA9IHMgKiBheGlzWzBdO1xuICAgIG91dFsxXSA9IHMgKiBheGlzWzFdO1xuICAgIG91dFsyXSA9IHMgKiBheGlzWzJdO1xuICAgIG91dFszXSA9IE1hdGguY29zKHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gcXVhdCdzXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LmFkZCA9IHZlYzQuYWRkO1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICBvdXRbMF0gPSBheCAqIGJ3ICsgYXcgKiBieCArIGF5ICogYnogLSBheiAqIGJ5O1xuICAgIG91dFsxXSA9IGF5ICogYncgKyBhdyAqIGJ5ICsgYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYnogKyBheCAqIGJ5IC0gYXkgKiBieDtcbiAgICBvdXRbM10gPSBhdyAqIGJ3IC0gYXggKiBieCAtIGF5ICogYnkgLSBheiAqIGJ6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgcXVhdC5tdWx0aXBseX1cbiAqIEBmdW5jdGlvblxuICovXG5xdWF0Lm11bCA9IHF1YXQubXVsdGlwbHk7XG5cbi8qKlxuICogU2NhbGVzIGEgcXVhdCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zY2FsZSA9IHZlYzQuc2NhbGU7XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVggPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ4ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF3ICogYng7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF6ICogYng7XG4gICAgb3V0WzJdID0gYXogKiBidyAtIGF5ICogYng7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF4ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBZIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVkgPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ5ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXkgKiBidyArIGF3ICogYnk7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF4ICogYnk7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF5ICogYnk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUm90YXRlcyBhIHF1YXRlcm5pb24gYnkgdGhlIGdpdmVuIGFuZ2xlIGFib3V0IHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCBxdWF0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXR9IGEgcXVhdCB0byByb3RhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWQgYW5nbGUgKGluIHJhZGlhbnMpIHRvIHJvdGF0ZVxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LnJvdGF0ZVogPSBmdW5jdGlvbiAob3V0LCBhLCByYWQpIHtcbiAgICByYWQgKj0gMC41OyBcblxuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLCBhdyA9IGFbM10sXG4gICAgICAgIGJ6ID0gTWF0aC5zaW4ocmFkKSwgYncgPSBNYXRoLmNvcyhyYWQpO1xuXG4gICAgb3V0WzBdID0gYXggKiBidyArIGF5ICogYno7XG4gICAgb3V0WzFdID0gYXkgKiBidyAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXogKiBidyArIGF3ICogYno7XG4gICAgb3V0WzNdID0gYXcgKiBidyAtIGF6ICogYno7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgVyBjb21wb25lbnQgb2YgYSBxdWF0IGZyb20gdGhlIFgsIFksIGFuZCBaIGNvbXBvbmVudHMuXG4gKiBBc3N1bWVzIHRoYXQgcXVhdGVybmlvbiBpcyAxIHVuaXQgaW4gbGVuZ3RoLlxuICogQW55IGV4aXN0aW5nIFcgY29tcG9uZW50IHdpbGwgYmUgaWdub3JlZC5cbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSBxdWF0IHRvIGNhbGN1bGF0ZSBXIGNvbXBvbmVudCBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNhbGN1bGF0ZVcgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG5cbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSBNYXRoLnNxcnQoTWF0aC5hYnMoMS4wIC0geCAqIHggLSB5ICogeSAtIHogKiB6KSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHF1YXQnc1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQuZG90ID0gdmVjNC5kb3Q7XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0J3NcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IG91dCB0aGUgcmVjZWl2aW5nIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7cXVhdH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHtxdWF0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3F1YXR9IG91dFxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVycCA9IHZlYzQubGVycDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge3F1YXR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5zbGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICAvLyBiZW5jaG1hcmtzOlxuICAgIC8vICAgIGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tc2xlcnAtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSwgYXcgPSBhWzNdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdLCBidyA9IGJbM107XG5cbiAgICB2YXIgICAgICAgIG9tZWdhLCBjb3NvbSwgc2lub20sIHNjYWxlMCwgc2NhbGUxO1xuXG4gICAgLy8gY2FsYyBjb3NpbmVcbiAgICBjb3NvbSA9IGF4ICogYnggKyBheSAqIGJ5ICsgYXogKiBieiArIGF3ICogYnc7XG4gICAgLy8gYWRqdXN0IHNpZ25zIChpZiBuZWNlc3NhcnkpXG4gICAgaWYgKCBjb3NvbSA8IDAuMCApIHtcbiAgICAgICAgY29zb20gPSAtY29zb207XG4gICAgICAgIGJ4ID0gLSBieDtcbiAgICAgICAgYnkgPSAtIGJ5O1xuICAgICAgICBieiA9IC0gYno7XG4gICAgICAgIGJ3ID0gLSBidztcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIGNvZWZmaWNpZW50c1xuICAgIGlmICggKDEuMCAtIGNvc29tKSA+IDAuMDAwMDAxICkge1xuICAgICAgICAvLyBzdGFuZGFyZCBjYXNlIChzbGVycClcbiAgICAgICAgb21lZ2EgID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgICAgc2lub20gID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICBzY2FsZTAgPSBNYXRoLnNpbigoMS4wIC0gdCkgKiBvbWVnYSkgLyBzaW5vbTtcbiAgICAgICAgc2NhbGUxID0gTWF0aC5zaW4odCAqIG9tZWdhKSAvIHNpbm9tO1xuICAgIH0gZWxzZSB7ICAgICAgICBcbiAgICAgICAgLy8gXCJmcm9tXCIgYW5kIFwidG9cIiBxdWF0ZXJuaW9ucyBhcmUgdmVyeSBjbG9zZSBcbiAgICAgICAgLy8gIC4uLiBzbyB3ZSBjYW4gZG8gYSBsaW5lYXIgaW50ZXJwb2xhdGlvblxuICAgICAgICBzY2FsZTAgPSAxLjAgLSB0O1xuICAgICAgICBzY2FsZTEgPSB0O1xuICAgIH1cbiAgICAvLyBjYWxjdWxhdGUgZmluYWwgdmFsdWVzXG4gICAgb3V0WzBdID0gc2NhbGUwICogYXggKyBzY2FsZTEgKiBieDtcbiAgICBvdXRbMV0gPSBzY2FsZTAgKiBheSArIHNjYWxlMSAqIGJ5O1xuICAgIG91dFsyXSA9IHNjYWxlMCAqIGF6ICsgc2NhbGUxICogYno7XG4gICAgb3V0WzNdID0gc2NhbGUwICogYXcgKyBzY2FsZTEgKiBidztcbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHNwaGVyaWNhbCBsaW5lYXIgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3F1YXR9IGMgdGhlIHRoaXJkIG9wZXJhbmRcbiAqIEBwYXJhbSB7cXVhdH0gZCB0aGUgZm91cnRoIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKi9cbnF1YXQuc3FsZXJwID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRlbXAxID0gcXVhdC5jcmVhdGUoKTtcbiAgdmFyIHRlbXAyID0gcXVhdC5jcmVhdGUoKTtcbiAgXG4gIHJldHVybiBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gICAgcXVhdC5zbGVycCh0ZW1wMSwgYSwgZCwgdCk7XG4gICAgcXVhdC5zbGVycCh0ZW1wMiwgYiwgYywgdCk7XG4gICAgcXVhdC5zbGVycChvdXQsIHRlbXAxLCB0ZW1wMiwgMiAqIHQgKiAoMSAtIHQpKTtcbiAgICBcbiAgICByZXR1cm4gb3V0O1xuICB9O1xufSgpKTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBpbnZlcnNlIG9mIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGludmVyc2Ugb2ZcbiAqIEByZXR1cm5zIHtxdWF0fSBvdXRcbiAqL1xucXVhdC5pbnZlcnQgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgYTAgPSBhWzBdLCBhMSA9IGFbMV0sIGEyID0gYVsyXSwgYTMgPSBhWzNdLFxuICAgICAgICBkb3QgPSBhMCphMCArIGExKmExICsgYTIqYTIgKyBhMyphMyxcbiAgICAgICAgaW52RG90ID0gZG90ID8gMS4wL2RvdCA6IDA7XG4gICAgXG4gICAgLy8gVE9ETzogV291bGQgYmUgZmFzdGVyIHRvIHJldHVybiBbMCwwLDAsMF0gaW1tZWRpYXRlbHkgaWYgZG90ID09IDBcblxuICAgIG91dFswXSA9IC1hMCppbnZEb3Q7XG4gICAgb3V0WzFdID0gLWExKmludkRvdDtcbiAgICBvdXRbMl0gPSAtYTIqaW52RG90O1xuICAgIG91dFszXSA9IGEzKmludkRvdDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBjb25qdWdhdGUgb2YgYSBxdWF0XG4gKiBJZiB0aGUgcXVhdGVybmlvbiBpcyBub3JtYWxpemVkLCB0aGlzIGZ1bmN0aW9uIGlzIGZhc3RlciB0aGFuIHF1YXQuaW52ZXJzZSBhbmQgcHJvZHVjZXMgdGhlIHNhbWUgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXQgdG8gY2FsY3VsYXRlIGNvbmp1Z2F0ZSBvZlxuICogQHJldHVybnMge3F1YXR9IG91dFxuICovXG5xdWF0LmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIChvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3F1YXR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5sZW5ndGggPSB2ZWM0Lmxlbmd0aDtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHF1YXQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnF1YXQubGVuID0gcXVhdC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSBxdWF0XG4gKlxuICogQHBhcmFtIHtxdWF0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqIEBmdW5jdGlvblxuICovXG5xdWF0LnNxdWFyZWRMZW5ndGggPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayBxdWF0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5zcXJMZW4gPSBxdWF0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7cXVhdH0gb3V0IHRoZSByZWNlaXZpbmcgcXVhdGVybmlvblxuICogQHBhcmFtIHtxdWF0fSBhIHF1YXRlcm5pb24gdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5ub3JtYWxpemUgPSB2ZWM0Lm5vcm1hbGl6ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgcXVhdGVybmlvbiBmcm9tIHRoZSBnaXZlbiAzeDMgcm90YXRpb24gbWF0cml4LlxuICpcbiAqIE5PVEU6IFRoZSByZXN1bHRhbnQgcXVhdGVybmlvbiBpcyBub3Qgbm9ybWFsaXplZCwgc28geW91IHNob3VsZCBiZSBzdXJlXG4gKiB0byByZW5vcm1hbGl6ZSB0aGUgcXVhdGVybmlvbiB5b3Vyc2VsZiB3aGVyZSBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtxdWF0fSBvdXQgdGhlIHJlY2VpdmluZyBxdWF0ZXJuaW9uXG4gKiBAcGFyYW0ge21hdDN9IG0gcm90YXRpb24gbWF0cml4XG4gKiBAcmV0dXJucyB7cXVhdH0gb3V0XG4gKiBAZnVuY3Rpb25cbiAqL1xucXVhdC5mcm9tTWF0MyA9IGZ1bmN0aW9uKG91dCwgbSkge1xuICAgIC8vIEFsZ29yaXRobSBpbiBLZW4gU2hvZW1ha2UncyBhcnRpY2xlIGluIDE5ODcgU0lHR1JBUEggY291cnNlIG5vdGVzXG4gICAgLy8gYXJ0aWNsZSBcIlF1YXRlcm5pb24gQ2FsY3VsdXMgYW5kIEZhc3QgQW5pbWF0aW9uXCIuXG4gICAgdmFyIGZUcmFjZSA9IG1bMF0gKyBtWzRdICsgbVs4XTtcbiAgICB2YXIgZlJvb3Q7XG5cbiAgICBpZiAoIGZUcmFjZSA+IDAuMCApIHtcbiAgICAgICAgLy8gfHd8ID4gMS8yLCBtYXkgYXMgd2VsbCBjaG9vc2UgdyA+IDEvMlxuICAgICAgICBmUm9vdCA9IE1hdGguc3FydChmVHJhY2UgKyAxLjApOyAgLy8gMndcbiAgICAgICAgb3V0WzNdID0gMC41ICogZlJvb3Q7XG4gICAgICAgIGZSb290ID0gMC41L2ZSb290OyAgLy8gMS8oNHcpXG4gICAgICAgIG91dFswXSA9IChtWzVdLW1bN10pKmZSb290O1xuICAgICAgICBvdXRbMV0gPSAobVs2XS1tWzJdKSpmUm9vdDtcbiAgICAgICAgb3V0WzJdID0gKG1bMV0tbVszXSkqZlJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gfHd8IDw9IDEvMlxuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGlmICggbVs0XSA+IG1bMF0gKVxuICAgICAgICAgIGkgPSAxO1xuICAgICAgICBpZiAoIG1bOF0gPiBtW2kqMytpXSApXG4gICAgICAgICAgaSA9IDI7XG4gICAgICAgIHZhciBqID0gKGkrMSklMztcbiAgICAgICAgdmFyIGsgPSAoaSsyKSUzO1xuICAgICAgICBcbiAgICAgICAgZlJvb3QgPSBNYXRoLnNxcnQobVtpKjMraV0tbVtqKjMral0tbVtrKjMra10gKyAxLjApO1xuICAgICAgICBvdXRbaV0gPSAwLjUgKiBmUm9vdDtcbiAgICAgICAgZlJvb3QgPSAwLjUgLyBmUm9vdDtcbiAgICAgICAgb3V0WzNdID0gKG1baiozK2tdIC0gbVtrKjMral0pICogZlJvb3Q7XG4gICAgICAgIG91dFtqXSA9IChtW2oqMytpXSArIG1baSozK2pdKSAqIGZSb290O1xuICAgICAgICBvdXRba10gPSAobVtrKjMraV0gKyBtW2kqMytrXSkgKiBmUm9vdDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHF1YXRlbmlvblxuICpcbiAqIEBwYXJhbSB7cXVhdH0gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnF1YXQuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3F1YXQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnKSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHF1YXQ7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDIgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMyXG4gKi9cbnZhciB2ZWMyID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjMlxuICpcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5jbG9uZSA9IGZ1bmN0aW9uKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMiBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBhIG5ldyAyRCB2ZWN0b3JcbiAqL1xudmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgyKTtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzIgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzIgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHkpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuc3ViID0gdmVjMi5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5tdWwgPSB2ZWMyLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzIuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGl2ID0gdmVjMi5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMyIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzIncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzInc1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzIuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzIuZGlzdCA9IHZlYzIuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMyLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWREaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWMyLnNxckRpc3QgPSB2ZWMyLnNxdWFyZWREaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMyXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG52ZWMyLmxlbmd0aCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMi5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5sZW4gPSB2ZWMyLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMyLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgcmV0dXJuIHgqeCArIHkqeTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMyLnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5zcXJMZW4gPSB2ZWMyLnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzJcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjMlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV07XG4gICAgdmFyIGxlbiA9IHgqeCArIHkqeTtcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW47XG4gICAgICAgIG91dFsxXSA9IGFbMV0gKiBsZW47XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byB2ZWMyJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjMn0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRvdCBwcm9kdWN0IG9mIGEgYW5kIGJcbiAqL1xudmVjMi5kb3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdO1xufTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMidzXG4gKiBOb3RlIHRoYXQgdGhlIGNyb3NzIHByb2R1Y3QgbXVzdCBieSBkZWZpbml0aW9uIHByb2R1Y2UgYSAzRCB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzJ9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzIuY3Jvc3MgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICB2YXIgeiA9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gICAgb3V0WzBdID0gb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMidzXG4gKlxuICogQHBhcmFtIHt2ZWMyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjMn0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMyfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLmxlcnAgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCB0KSB7XG4gICAgdmFyIGF4ID0gYVswXSxcbiAgICAgICAgYXkgPSBhWzFdO1xuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpO1xuICAgIG91dFsxXSA9IGF5ICsgdCAqIChiWzFdIC0gYXkpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIucmFuZG9tID0gZnVuY3Rpb24gKG91dCwgc2NhbGUpIHtcbiAgICBzY2FsZSA9IHNjYWxlIHx8IDEuMDtcbiAgICB2YXIgciA9IGdsTWF0cml4LlJBTkRPTSgpICogMi4wICogTWF0aC5QSTtcbiAgICBvdXRbMF0gPSBNYXRoLmNvcyhyKSAqIHNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogc2NhbGU7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MlxuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0Mn0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQyID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5O1xuICAgIG91dFsxXSA9IG1bMV0gKiB4ICsgbVszXSAqIHk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMiB3aXRoIGEgbWF0MmRcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDJkfSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzJ9IG91dFxuICovXG52ZWMyLnRyYW5zZm9ybU1hdDJkID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQzXG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcxJ1xuICpcbiAqIEBwYXJhbSB7dmVjMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzJ9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0M30gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMyfSBvdXRcbiAqL1xudmVjMi50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXTtcbiAgICBvdXRbMF0gPSBtWzBdICogeCArIG1bM10gKiB5ICsgbVs2XTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNF0gKiB5ICsgbVs3XTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMyIHdpdGggYSBtYXQ0XG4gKiAzcmQgdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMyfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjMn0gb3V0XG4gKi9cbnZlYzIudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgXG4gICAgICAgIHkgPSBhWzFdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzEyXTtcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVsxM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybSBzb21lIG9wZXJhdGlvbiBvdmVyIGFuIGFycmF5IG9mIHZlYzJzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGEgdGhlIGFycmF5IG9mIHZlY3RvcnMgdG8gaXRlcmF0ZSBvdmVyXG4gKiBAcGFyYW0ge051bWJlcn0gc3RyaWRlIE51bWJlciBvZiBlbGVtZW50cyBiZXR3ZWVuIHRoZSBzdGFydCBvZiBlYWNoIHZlYzIuIElmIDAgYXNzdW1lcyB0aWdodGx5IHBhY2tlZFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBOdW1iZXIgb2YgZWxlbWVudHMgdG8gc2tpcCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIHtOdW1iZXJ9IGNvdW50IE51bWJlciBvZiB2ZWMycyB0byBpdGVyYXRlIG92ZXIuIElmIDAgaXRlcmF0ZXMgb3ZlciBlbnRpcmUgYXJyYXlcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggdmVjdG9yIGluIHRoZSBhcnJheVxuICogQHBhcmFtIHtPYmplY3R9IFthcmddIGFkZGl0aW9uYWwgYXJndW1lbnQgdG8gcGFzcyB0byBmblxuICogQHJldHVybnMge0FycmF5fSBhXG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMi5mb3JFYWNoID0gKGZ1bmN0aW9uKCkge1xuICAgIHZhciB2ZWMgPSB2ZWMyLmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbDtcbiAgICAgICAgaWYoIXN0cmlkZSkge1xuICAgICAgICAgICAgc3RyaWRlID0gMjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbCA9IGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXTsgdmVjWzFdID0gYVtpKzFdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzJ9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWMyLnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWMyKCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnKSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZlYzI7XG4iLCIvKiBDb3B5cmlnaHQgKGMpIDIwMTUsIEJyYW5kb24gSm9uZXMsIENvbGluIE1hY0tlbnppZSBJVi5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLiAqL1xuXG52YXIgZ2xNYXRyaXggPSByZXF1aXJlKFwiLi9jb21tb24uanNcIik7XG5cbi8qKlxuICogQGNsYXNzIDMgRGltZW5zaW9uYWwgVmVjdG9yXG4gKiBAbmFtZSB2ZWMzXG4gKi9cbnZhciB2ZWMzID0ge307XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xudmVjMy5jcmVhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IGdsTWF0cml4LkFSUkFZX1RZUEUoMyk7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSgzKTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG52ZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDMpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENvcHkgdGhlIHZhbHVlcyBmcm9tIG9uZSB2ZWMzIHRvIGFub3RoZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBzb3VyY2UgdmVjdG9yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuY29weSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzMgdG8gdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuc2V0ID0gZnVuY3Rpb24ob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geDtcbiAgICBvdXRbMV0gPSB5O1xuICAgIG91dFsyXSA9IHo7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gKyBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0cyB2ZWN0b3IgYiBmcm9tIHZlY3RvciBhXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnN1YnRyYWN0ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAtIGJbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLnN1YnRyYWN0fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3ViID0gdmVjMy5zdWJ0cmFjdDtcblxuLyoqXG4gKiBNdWx0aXBsaWVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubXVsdGlwbHkgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICogYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMubXVsdGlwbHl9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5tdWwgPSB2ZWMzLm11bHRpcGx5O1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5kaXZpZGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdIC8gYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuZGl2aWRlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGl2ID0gdmVjMy5kaXZpZGU7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLm1pbiA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWluKGFbMF0sIGJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5tYXggPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1heChhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5zY2FsZSA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKiBiO1xuICAgIG91dFsxXSA9IGFbMV0gKiBiO1xuICAgIG91dFsyXSA9IGFbMl0gKiBiO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMncyBhZnRlciBzY2FsaW5nIHRoZSBzZWNvbmQgb3BlcmFuZCBieSBhIHNjYWxhciB2YWx1ZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgYW1vdW50IHRvIHNjYWxlIGIgYnkgYmVmb3JlIGFkZGluZ1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnNjYWxlQW5kQWRkID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKTtcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSk7XG4gICAgb3V0WzJdID0gYVsyXSArIChiWzJdICogc2NhbGUpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLmRpc3RhbmNlID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdO1xuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KTtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWMzLmRpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZGlzdCA9IHZlYzMuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG52ZWMzLnNxdWFyZWREaXN0YW5jZSA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzMuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyRGlzdCA9IHZlYzMuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzMubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5sZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjMy5sZW4gPSB2ZWMzLmxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG52ZWMzLnNxdWFyZWRMZW5ndGggPSBmdW5jdGlvbiAoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdO1xuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Kno7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjMy5zcXVhcmVkTGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuc3FyTGVuID0gdmVjMy5zcXVhcmVkTGVuZ3RoO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubmVnYXRlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gLWFbMF07XG4gICAgb3V0WzFdID0gLWFbMV07XG4gICAgb3V0WzJdID0gLWFbMl07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5pbnZlcnNlID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gIG91dFswXSA9IDEuMCAvIGFbMF07XG4gIG91dFsxXSA9IDEuMCAvIGFbMV07XG4gIG91dFsyXSA9IDEuMCAvIGFbMl07XG4gIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIE5vcm1hbGl6ZSBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBub3JtYWxpemVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5ub3JtYWxpemUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIC8vVE9ETzogZXZhbHVhdGUgdXNlIG9mIGdsbV9pbnZzcXJ0IGhlcmU/XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0gYVsyXSAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWMzLmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5jcm9zcyA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIHZhciBheCA9IGFbMF0sIGF5ID0gYVsxXSwgYXogPSBhWzJdLFxuICAgICAgICBieCA9IGJbMF0sIGJ5ID0gYlsxXSwgYnogPSBiWzJdO1xuXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnk7XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYno7XG4gICAgb3V0WzJdID0gYXggKiBieSAtIGF5ICogYng7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogUGVyZm9ybXMgYSBsaW5lYXIgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMubGVycCA9IGZ1bmN0aW9uIChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXTtcbiAgICBvdXRbMF0gPSBheCArIHQgKiAoYlswXSAtIGF4KTtcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KTtcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGhlcm1pdGUgaW50ZXJwb2xhdGlvbiB3aXRoIHR3byBjb250cm9sIHBvaW50c1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYyB0aGUgdGhpcmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBkIHRoZSBmb3VydGggb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLmhlcm1pdGUgPSBmdW5jdGlvbiAob3V0LCBhLCBiLCBjLCBkLCB0KSB7XG4gIHZhciBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBmYWN0b3JUaW1lczIgKiAoMiAqIHQgLSAzKSArIDEsXG4gICAgICBmYWN0b3IyID0gZmFjdG9yVGltZXMyICogKHQgLSAyKSArIHQsXG4gICAgICBmYWN0b3IzID0gZmFjdG9yVGltZXMyICogKHQgLSAxKSxcbiAgICAgIGZhY3RvcjQgPSBmYWN0b3JUaW1lczIgKiAoMyAtIDIgKiB0KTtcbiAgXG4gIG91dFswXSA9IGFbMF0gKiBmYWN0b3IxICsgYlswXSAqIGZhY3RvcjIgKyBjWzBdICogZmFjdG9yMyArIGRbMF0gKiBmYWN0b3I0O1xuICBvdXRbMV0gPSBhWzFdICogZmFjdG9yMSArIGJbMV0gKiBmYWN0b3IyICsgY1sxXSAqIGZhY3RvcjMgKyBkWzFdICogZmFjdG9yNDtcbiAgb3V0WzJdID0gYVsyXSAqIGZhY3RvcjEgKyBiWzJdICogZmFjdG9yMiArIGNbMl0gKiBmYWN0b3IzICsgZFsyXSAqIGZhY3RvcjQ7XG4gIFxuICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGJlemllciBpbnRlcnBvbGF0aW9uIHdpdGggdHdvIGNvbnRyb2wgcG9pbnRzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBjIHRoZSB0aGlyZCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGQgdGhlIGZvdXJ0aCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gdCBpbnRlcnBvbGF0aW9uIGFtb3VudCBiZXR3ZWVuIHRoZSB0d28gaW5wdXRzXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMuYmV6aWVyID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgYywgZCwgdCkge1xuICB2YXIgaW52ZXJzZUZhY3RvciA9IDEgLSB0LFxuICAgICAgaW52ZXJzZUZhY3RvclRpbWVzVHdvID0gaW52ZXJzZUZhY3RvciAqIGludmVyc2VGYWN0b3IsXG4gICAgICBmYWN0b3JUaW1lczIgPSB0ICogdCxcbiAgICAgIGZhY3RvcjEgPSBpbnZlcnNlRmFjdG9yVGltZXNUd28gKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yMiA9IDMgKiB0ICogaW52ZXJzZUZhY3RvclRpbWVzVHdvLFxuICAgICAgZmFjdG9yMyA9IDMgKiBmYWN0b3JUaW1lczIgKiBpbnZlcnNlRmFjdG9yLFxuICAgICAgZmFjdG9yNCA9IGZhY3RvclRpbWVzMiAqIHQ7XG4gIFxuICBvdXRbMF0gPSBhWzBdICogZmFjdG9yMSArIGJbMF0gKiBmYWN0b3IyICsgY1swXSAqIGZhY3RvcjMgKyBkWzBdICogZmFjdG9yNDtcbiAgb3V0WzFdID0gYVsxXSAqIGZhY3RvcjEgKyBiWzFdICogZmFjdG9yMiArIGNbMV0gKiBmYWN0b3IzICsgZFsxXSAqIGZhY3RvcjQ7XG4gIG91dFsyXSA9IGFbMl0gKiBmYWN0b3IxICsgYlsyXSAqIGZhY3RvcjIgKyBjWzJdICogZmFjdG9yMyArIGRbMl0gKiBmYWN0b3I0O1xuICBcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgdmFyIHIgPSBnbE1hdHJpeC5SQU5ET00oKSAqIDIuMCAqIE1hdGguUEk7XG4gICAgdmFyIHogPSAoZ2xNYXRyaXguUkFORE9NKCkgKiAyLjApIC0gMS4wO1xuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZTtcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlO1xuICAgIG91dFsxXSA9IE1hdGguc2luKHIpICogelNjYWxlO1xuICAgIG91dFsyXSA9IHogKiBzY2FsZTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtTWF0NCA9IGZ1bmN0aW9uKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdO1xuICAgIHcgPSB3IHx8IDEuMDtcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gdztcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gdztcbiAgICBvdXRbMl0gPSAobVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdKSAvIHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy50cmFuc2Zvcm1NYXQzID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdO1xuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XTtcbiAgICBvdXRbMl0gPSB4ICogbVsyXSArIHkgKiBtWzVdICsgeiAqIG1bOF07XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbnZlYzMudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKG91dCwgYSwgcSkge1xuICAgIC8vIGJlbmNobWFya3M6IGh0dHA6Ly9qc3BlcmYuY29tL3F1YXRlcm5pb24tdHJhbnNmb3JtLXZlYzMtaW1wbGVtZW50YXRpb25zXG5cbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB4LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xudmVjMy5yb3RhdGVYID0gZnVuY3Rpb24ob3V0LCBhLCBiLCBjKXtcbiAgIHZhciBwID0gW10sIHI9W107XG5cdCAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuXHQgIHBbMF0gPSBhWzBdIC0gYlswXTtcblx0ICBwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuXG5cdCAgLy9wZXJmb3JtIHJvdGF0aW9uXG5cdCAgclswXSA9IHBbMF07XG5cdCAgclsxXSA9IHBbMV0qTWF0aC5jb3MoYykgLSBwWzJdKk1hdGguc2luKGMpO1xuXHQgIHJbMl0gPSBwWzFdKk1hdGguc2luKGMpICsgcFsyXSpNYXRoLmNvcyhjKTtcblxuXHQgIC8vdHJhbnNsYXRlIHRvIGNvcnJlY3QgcG9zaXRpb25cblx0ICBvdXRbMF0gPSByWzBdICsgYlswXTtcblx0ICBvdXRbMV0gPSByWzFdICsgYlsxXTtcblx0ICBvdXRbMl0gPSByWzJdICsgYlsyXTtcblxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVkgPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFsyXSpNYXRoLnNpbihjKSArIHBbMF0qTWF0aC5jb3MoYyk7XG4gIFx0clsxXSA9IHBbMV07XG4gIFx0clsyXSA9IHBbMl0qTWF0aC5jb3MoYykgLSBwWzBdKk1hdGguc2luKGMpO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHotYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG52ZWMzLnJvdGF0ZVogPSBmdW5jdGlvbihvdXQsIGEsIGIsIGMpe1xuICBcdHZhciBwID0gW10sIHI9W107XG4gIFx0Ly9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICBcdHBbMF0gPSBhWzBdIC0gYlswXTtcbiAgXHRwWzFdID0gYVsxXSAtIGJbMV07XG4gIFx0cFsyXSA9IGFbMl0gLSBiWzJdO1xuICBcbiAgXHQvL3BlcmZvcm0gcm90YXRpb25cbiAgXHRyWzBdID0gcFswXSpNYXRoLmNvcyhjKSAtIHBbMV0qTWF0aC5zaW4oYyk7XG4gIFx0clsxXSA9IHBbMF0qTWF0aC5zaW4oYykgKyBwWzFdKk1hdGguY29zKGMpO1xuICBcdHJbMl0gPSBwWzJdO1xuICBcbiAgXHQvL3RyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gIFx0b3V0WzBdID0gclswXSArIGJbMF07XG4gIFx0b3V0WzFdID0gclsxXSArIGJbMV07XG4gIFx0b3V0WzJdID0gclsyXSArIGJbMl07XG4gIFxuICBcdHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzMuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjMy5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDM7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdO1xuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZyk7XG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdOyBhW2krMV0gPSB2ZWNbMV07IGFbaSsyXSA9IHZlY1syXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbnZlYzMuYW5nbGUgPSBmdW5jdGlvbihhLCBiKSB7XG4gICBcbiAgICB2YXIgdGVtcEEgPSB2ZWMzLmZyb21WYWx1ZXMoYVswXSwgYVsxXSwgYVsyXSk7XG4gICAgdmFyIHRlbXBCID0gdmVjMy5mcm9tVmFsdWVzKGJbMF0sIGJbMV0sIGJbMl0pO1xuIFxuICAgIHZlYzMubm9ybWFsaXplKHRlbXBBLCB0ZW1wQSk7XG4gICAgdmVjMy5ub3JtYWxpemUodGVtcEIsIHRlbXBCKTtcbiBcbiAgICB2YXIgY29zaW5lID0gdmVjMy5kb3QodGVtcEEsIHRlbXBCKTtcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKTtcbiAgICB9ICAgICBcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gdmVjIHZlY3RvciB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yXG4gKi9cbnZlYzMuc3RyID0gZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gJ3ZlYzMoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJyknO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWMzO1xuIiwiLyogQ29weXJpZ2h0IChjKSAyMDE1LCBCcmFuZG9uIEpvbmVzLCBDb2xpbiBNYWNLZW56aWUgSVYuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbm9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbmluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbnRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbmNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbmFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG5JTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbk9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cblRIRSBTT0ZUV0FSRS4gKi9cblxudmFyIGdsTWF0cml4ID0gcmVxdWlyZShcIi4vY29tbW9uLmpzXCIpO1xuXG4vKipcbiAqIEBjbGFzcyA0IERpbWVuc2lvbmFsIFZlY3RvclxuICogQG5hbWUgdmVjNFxuICovXG52YXIgdmVjNCA9IHt9O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlYzRcbiAqXG4gKiBAcmV0dXJucyB7dmVjNH0gYSBuZXcgNEQgdmVjdG9yXG4gKi9cbnZlYzQuY3JlYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IDA7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWM0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgdmVjdG9yXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjbG9uZVxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmNsb25lID0gZnVuY3Rpb24oYSkge1xuICAgIHZhciBvdXQgPSBuZXcgZ2xNYXRyaXguQVJSQVlfVFlQRSg0KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjNCBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0gdyBXIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzR9IGEgbmV3IDREIHZlY3RvclxuICovXG52ZWM0LmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6LCB3KSB7XG4gICAgdmFyIG91dCA9IG5ldyBnbE1hdHJpeC5BUlJBWV9UWVBFKDQpO1xuICAgIG91dFswXSA9IHg7XG4gICAgb3V0WzFdID0geTtcbiAgICBvdXRbMl0gPSB6O1xuICAgIG91dFszXSA9IHc7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5jb3B5ID0gZnVuY3Rpb24ob3V0LCBhKSB7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWM0IHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVyBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zZXQgPSBmdW5jdGlvbihvdXQsIHgsIHksIHosIHcpIHtcbiAgICBvdXRbMF0gPSB4O1xuICAgIG91dFsxXSA9IHk7XG4gICAgb3V0WzJdID0gejtcbiAgICBvdXRbM10gPSB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5hZGQgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgYlswXTtcbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXTtcbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXTtcbiAgICBvdXRbM10gPSBhWzNdICsgYlszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdO1xuICAgIG91dFsxXSA9IGFbMV0gLSBiWzFdO1xuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdO1xuICAgIG91dFszXSA9IGFbM10gLSBiWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5zdWJ0cmFjdH1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LnN1YiA9IHZlYzQuc3VidHJhY3Q7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjNCdzXG4gKlxuICogQHBhcmFtIHt2ZWM0fSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm11bHRpcGx5ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAqIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAqIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0Lm11bHRpcGx5fVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubXVsID0gdmVjNC5tdWx0aXBseTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuZGl2aWRlID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAvIGJbMF07XG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV07XG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl07XG4gICAgb3V0WzNdID0gYVszXSAvIGJbM107XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LmRpdmlkZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpdiA9IHZlYzQuZGl2aWRlO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1pbmltdW0gb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5taW4gPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICBvdXRbMl0gPSBNYXRoLm1pbihhWzJdLCBiWzJdKTtcbiAgICBvdXRbM10gPSBNYXRoLm1pbihhWzNdLCBiWzNdKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWM0J3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQubWF4ID0gZnVuY3Rpb24ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5tYXgoYVswXSwgYlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgb3V0WzNdID0gTWF0aC5tYXgoYVszXSwgYlszXSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogU2NhbGVzIGEgdmVjNCBieSBhIHNjYWxhciBudW1iZXJcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBiIGFtb3VudCB0byBzY2FsZSB0aGUgdmVjdG9yIGJ5XG4gKiBAcmV0dXJucyB7dmVjNH0gb3V0XG4gKi9cbnZlYzQuc2NhbGUgPSBmdW5jdGlvbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYjtcbiAgICBvdXRbMV0gPSBhWzFdICogYjtcbiAgICBvdXRbMl0gPSBhWzJdICogYjtcbiAgICBvdXRbM10gPSBhWzNdICogYjtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWM0J3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzR9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5zY2FsZUFuZEFkZCA9IGZ1bmN0aW9uKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSk7XG4gICAgb3V0WzFdID0gYVsxXSArIChiWzFdICogc2NhbGUpO1xuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKTtcbiAgICBvdXRbM10gPSBhWzNdICsgKGJbM10gKiBzY2FsZSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gKi9cbnZlYzQuZGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeiArIHcqdyk7XG59O1xuXG4vKipcbiAqIEFsaWFzIGZvciB7QGxpbmsgdmVjNC5kaXN0YW5jZX1cbiAqIEBmdW5jdGlvblxuICovXG52ZWM0LmRpc3QgPSB2ZWM0LmRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xudmVjNC5zcXVhcmVkRGlzdGFuY2UgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl0sXG4gICAgICAgIHcgPSBiWzNdIC0gYVszXTtcbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQuc3F1YXJlZERpc3RhbmNlfVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuc3FyRGlzdCA9IHZlYzQuc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGxlbmd0aCBvZiBhXG4gKi9cbnZlYzQubGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnogKyB3KncpO1xufTtcblxuLyoqXG4gKiBBbGlhcyBmb3Ige0BsaW5rIHZlYzQubGVuZ3RofVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQubGVuID0gdmVjNC5sZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWM0XG4gKlxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xudmVjNC5zcXVhcmVkTGVuZ3RoID0gZnVuY3Rpb24gKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXSxcbiAgICAgICAgdyA9IGFbM107XG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqeiArIHcqdztcbn07XG5cbi8qKlxuICogQWxpYXMgZm9yIHtAbGluayB2ZWM0LnNxdWFyZWRMZW5ndGh9XG4gKiBAZnVuY3Rpb25cbiAqL1xudmVjNC5zcXJMZW4gPSB2ZWM0LnNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5uZWdhdGUgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXTtcbiAgICBvdXRbMV0gPSAtYVsxXTtcbiAgICBvdXRbMl0gPSAtYVsyXTtcbiAgICBvdXRbM10gPSAtYVszXTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LmludmVyc2UgPSBmdW5jdGlvbihvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXTtcbiAgb3V0WzFdID0gMS4wIC8gYVsxXTtcbiAgb3V0WzJdID0gMS4wIC8gYVsyXTtcbiAgb3V0WzNdID0gMS4wIC8gYVszXTtcbiAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjNFxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0Lm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKG91dCwgYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdLFxuICAgICAgICB3ID0gYVszXTtcbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6ICsgdyp3O1xuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgb3V0WzBdID0geCAqIGxlbjtcbiAgICAgICAgb3V0WzFdID0geSAqIGxlbjtcbiAgICAgICAgb3V0WzJdID0geiAqIGxlbjtcbiAgICAgICAgb3V0WzNdID0gdyAqIGxlbjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWM0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG52ZWM0LmRvdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXSArIGFbM10gKiBiWzNdO1xufTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzQnc1xuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjNH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5sZXJwID0gZnVuY3Rpb24gKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdLFxuICAgICAgICBhdyA9IGFbM107XG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheCk7XG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSk7XG4gICAgb3V0WzJdID0gYXogKyB0ICogKGJbMl0gLSBheik7XG4gICAgb3V0WzNdID0gYXcgKyB0ICogKGJbM10gLSBhdyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcmFuZG9tIHZlY3RvciB3aXRoIHRoZSBnaXZlbiBzY2FsZVxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlcn0gW3NjYWxlXSBMZW5ndGggb2YgdGhlIHJlc3VsdGluZyB2ZWN0b3IuIElmIG9tbWl0dGVkLCBhIHVuaXQgdmVjdG9yIHdpbGwgYmUgcmV0dXJuZWRcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC5yYW5kb20gPSBmdW5jdGlvbiAob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wO1xuXG4gICAgLy9UT0RPOiBUaGlzIGlzIGEgcHJldHR5IGF3ZnVsIHdheSBvZiBkb2luZyB0aGlzLiBGaW5kIHNvbWV0aGluZyBiZXR0ZXIuXG4gICAgb3V0WzBdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgb3V0WzFdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgb3V0WzJdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgb3V0WzNdID0gZ2xNYXRyaXguUkFORE9NKCk7XG4gICAgdmVjNC5ub3JtYWxpemUob3V0LCBvdXQpO1xuICAgIHZlYzQuc2NhbGUob3V0LCBvdXQsIHNjYWxlKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWM0IHdpdGggYSBtYXQ0LlxuICpcbiAqIEBwYXJhbSB7dmVjNH0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzR9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWM0fSBvdXRcbiAqL1xudmVjNC50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24ob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sIHcgPSBhWzNdO1xuICAgIG91dFswXSA9IG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdICogdztcbiAgICBvdXRbMV0gPSBtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSAqIHc7XG4gICAgb3V0WzJdID0gbVsyXSAqIHggKyBtWzZdICogeSArIG1bMTBdICogeiArIG1bMTRdICogdztcbiAgICBvdXRbM10gPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV0gKiB3O1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIHZlYzQgd2l0aCBhIHF1YXRcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWM0fSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge3F1YXR9IHEgcXVhdGVybmlvbiB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzR9IG91dFxuICovXG52ZWM0LnRyYW5zZm9ybVF1YXQgPSBmdW5jdGlvbihvdXQsIGEsIHEpIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXSxcbiAgICAgICAgcXggPSBxWzBdLCBxeSA9IHFbMV0sIHF6ID0gcVsyXSwgcXcgPSBxWzNdLFxuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBxdWF0ICogdmVjXG4gICAgICAgIGl4ID0gcXcgKiB4ICsgcXkgKiB6IC0gcXogKiB5LFxuICAgICAgICBpeSA9IHF3ICogeSArIHF6ICogeCAtIHF4ICogeixcbiAgICAgICAgaXogPSBxdyAqIHogKyBxeCAqIHkgLSBxeSAqIHgsXG4gICAgICAgIGl3ID0gLXF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5O1xuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXo7XG4gICAgb3V0WzJdID0gaXogKiBxdyArIGl3ICogLXF6ICsgaXggKiAtcXkgLSBpeSAqIC1xeDtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWM0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWM0LiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjNHMgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbnZlYzQuZm9yRWFjaCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgdmVjID0gdmVjNC5jcmVhdGUoKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihhLCBzdHJpZGUsIG9mZnNldCwgY291bnQsIGZuLCBhcmcpIHtcbiAgICAgICAgdmFyIGksIGw7XG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihjb3VudCkge1xuICAgICAgICAgICAgbCA9IE1hdGgubWluKChjb3VudCAqIHN0cmlkZSkgKyBvZmZzZXQsIGEubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV07IHZlY1sxXSA9IGFbaSsxXTsgdmVjWzJdID0gYVtpKzJdOyB2ZWNbM10gPSBhW2krM107XG4gICAgICAgICAgICBmbih2ZWMsIHZlYywgYXJnKTtcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF07IGFbaSsxXSA9IHZlY1sxXTsgYVtpKzJdID0gdmVjWzJdOyBhW2krM10gPSB2ZWNbM107XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhO1xuICAgIH07XG59KSgpO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzR9IHZlYyB2ZWN0b3IgdG8gcmVwcmVzZW50IGFzIGEgc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3RvclxuICovXG52ZWM0LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuICd2ZWM0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJyknO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB2ZWM0O1xuIiwiLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHdoZW4gdXNlZCBpbiBub2RlLCB0aGlzIHdpbGwgYWN0dWFsbHkgbG9hZCB0aGUgdXRpbCBtb2R1bGUgd2UgZGVwZW5kIG9uXG4vLyB2ZXJzdXMgbG9hZGluZyB0aGUgYnVpbHRpbiB1dGlsIG1vZHVsZSBhcyBoYXBwZW5zIG90aGVyd2lzZVxuLy8gdGhpcyBpcyBhIGJ1ZyBpbiBub2RlIG1vZHVsZSBsb2FkaW5nIGFzIGZhciBhcyBJIGFtIGNvbmNlcm5lZFxudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsLycpO1xuXG52YXIgcFNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIDEuIFRoZSBhc3NlcnQgbW9kdWxlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0aGF0IHRocm93XG4vLyBBc3NlcnRpb25FcnJvcidzIHdoZW4gcGFydGljdWxhciBjb25kaXRpb25zIGFyZSBub3QgbWV0LiBUaGVcbi8vIGFzc2VydCBtb2R1bGUgbXVzdCBjb25mb3JtIHRvIHRoZSBmb2xsb3dpbmcgaW50ZXJmYWNlLlxuXG52YXIgYXNzZXJ0ID0gbW9kdWxlLmV4cG9ydHMgPSBvaztcblxuLy8gMi4gVGhlIEFzc2VydGlvbkVycm9yIGlzIGRlZmluZWQgaW4gYXNzZXJ0LlxuLy8gbmV3IGFzc2VydC5Bc3NlcnRpb25FcnJvcih7IG1lc3NhZ2U6IG1lc3NhZ2UsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsOiBhY3R1YWwsXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkIH0pXG5cbmFzc2VydC5Bc3NlcnRpb25FcnJvciA9IGZ1bmN0aW9uIEFzc2VydGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgdGhpcy5uYW1lID0gJ0Fzc2VydGlvbkVycm9yJztcbiAgdGhpcy5hY3R1YWwgPSBvcHRpb25zLmFjdHVhbDtcbiAgdGhpcy5leHBlY3RlZCA9IG9wdGlvbnMuZXhwZWN0ZWQ7XG4gIHRoaXMub3BlcmF0b3IgPSBvcHRpb25zLm9wZXJhdG9yO1xuICBpZiAob3B0aW9ucy5tZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gb3B0aW9ucy5tZXNzYWdlO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE1lc3NhZ2UodGhpcyk7XG4gICAgdGhpcy5nZW5lcmF0ZWRNZXNzYWdlID0gdHJ1ZTtcbiAgfVxuICB2YXIgc3RhY2tTdGFydEZ1bmN0aW9uID0gb3B0aW9ucy5zdGFja1N0YXJ0RnVuY3Rpb24gfHwgZmFpbDtcblxuICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIG5vbiB2OCBicm93c2VycyBzbyB3ZSBjYW4gaGF2ZSBhIHN0YWNrdHJhY2VcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCk7XG4gICAgaWYgKGVyci5zdGFjaykge1xuICAgICAgdmFyIG91dCA9IGVyci5zdGFjaztcblxuICAgICAgLy8gdHJ5IHRvIHN0cmlwIHVzZWxlc3MgZnJhbWVzXG4gICAgICB2YXIgZm5fbmFtZSA9IHN0YWNrU3RhcnRGdW5jdGlvbi5uYW1lO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICBpZiAodXRpbC5pc1VuZGVmaW5lZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTtcbiAgfVxuICBpZiAodXRpbC5pc051bWJlcih2YWx1ZSkgJiYgIWlzRmluaXRlKHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIGlmICh1dGlsLmlzRnVuY3Rpb24odmFsdWUpIHx8IHV0aWwuaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cnVuY2F0ZShzLCBuKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHMpKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1lc3NhZ2Uoc2VsZikge1xuICByZXR1cm4gdHJ1bmNhdGUoSlNPTi5zdHJpbmdpZnkoc2VsZi5hY3R1YWwsIHJlcGxhY2VyKSwgMTI4KSArICcgJyArXG4gICAgICAgICBzZWxmLm9wZXJhdG9yICsgJyAnICtcbiAgICAgICAgIHRydW5jYXRlKEpTT04uc3RyaW5naWZ5KHNlbGYuZXhwZWN0ZWQsIHJlcGxhY2VyKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwRXF1YWwnLCBhc3NlcnQuZGVlcEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0J1ZmZlcihhY3R1YWwpICYmIHV0aWwuaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgaWYgKGFjdHVhbC5sZW5ndGggIT0gZXhwZWN0ZWQubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdHVhbFtpXSAhPT0gZXhwZWN0ZWRbaV0pIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyA3LjIuIElmIHRoZSBleHBlY3RlZCB2YWx1ZSBpcyBhIERhdGUgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIERhdGUgb2JqZWN0IHRoYXQgcmVmZXJzIHRvIHRoZSBzYW1lIHRpbWUuXG4gIH0gZWxzZSBpZiAodXRpbC5pc0RhdGUoYWN0dWFsKSAmJiB1dGlsLmlzRGF0ZShleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsLmdldFRpbWUoKSA9PT0gZXhwZWN0ZWQuZ2V0VGltZSgpO1xuXG4gIC8vIDcuMyBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBSZWdFeHAgb2JqZWN0LCB0aGUgYWN0dWFsIHZhbHVlIGlzXG4gIC8vIGVxdWl2YWxlbnQgaWYgaXQgaXMgYWxzbyBhIFJlZ0V4cCBvYmplY3Qgd2l0aCB0aGUgc2FtZSBzb3VyY2UgYW5kXG4gIC8vIHByb3BlcnRpZXMgKGBnbG9iYWxgLCBgbXVsdGlsaW5lYCwgYGxhc3RJbmRleGAsIGBpZ25vcmVDYXNlYCkuXG4gIH0gZWxzZSBpZiAodXRpbC5pc1JlZ0V4cChhY3R1YWwpICYmIHV0aWwuaXNSZWdFeHAoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5zb3VyY2UgPT09IGV4cGVjdGVkLnNvdXJjZSAmJlxuICAgICAgICAgICBhY3R1YWwuZ2xvYmFsID09PSBleHBlY3RlZC5nbG9iYWwgJiZcbiAgICAgICAgICAgYWN0dWFsLm11bHRpbGluZSA9PT0gZXhwZWN0ZWQubXVsdGlsaW5lICYmXG4gICAgICAgICAgIGFjdHVhbC5sYXN0SW5kZXggPT09IGV4cGVjdGVkLmxhc3RJbmRleCAmJlxuICAgICAgICAgICBhY3R1YWwuaWdub3JlQ2FzZSA9PT0gZXhwZWN0ZWQuaWdub3JlQ2FzZTtcblxuICAvLyA3LjQuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNPYmplY3QoYWN0dWFsKSAmJiAhdXRpbC5pc09iamVjdChleHBlY3RlZCkpIHtcbiAgICByZXR1cm4gYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNSBGb3IgYWxsIG90aGVyIE9iamVjdCBwYWlycywgaW5jbHVkaW5nIEFycmF5IG9iamVjdHMsIGVxdWl2YWxlbmNlIGlzXG4gIC8vIGRldGVybWluZWQgYnkgaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChhcyB2ZXJpZmllZFxuICAvLyB3aXRoIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCksIHRoZSBzYW1lIHNldCBvZiBrZXlzXG4gIC8vIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLCBlcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnlcbiAgLy8gY29ycmVzcG9uZGluZyBrZXksIGFuZCBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuIE5vdGU6IHRoaXNcbiAgLy8gYWNjb3VudHMgZm9yIGJvdGggbmFtZWQgYW5kIGluZGV4ZWQgcHJvcGVydGllcyBvbiBBcnJheXMuXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iakVxdWl2KGFjdHVhbCwgZXhwZWN0ZWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKG9iamVjdCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG59XG5cbmZ1bmN0aW9uIG9iakVxdWl2KGEsIGIpIHtcbiAgaWYgKHV0aWwuaXNOdWxsT3JVbmRlZmluZWQoYSkgfHwgdXRpbC5pc051bGxPclVuZGVmaW5lZChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSkge1xuICAgIHJldHVybiBhID09PSBiO1xuICB9XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSksXG4gICAgICBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIpO1xuICB9XG4gIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICBrYiA9IG9iamVjdEtleXMoYiksXG4gICAgICBrZXksIGk7XG4gIC8vIGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoa2V5cyBpbmNvcnBvcmF0ZXNcbiAgLy8gaGFzT3duUHJvcGVydHkpXG4gIGlmIChrYS5sZW5ndGggIT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT0ga2JbaV0pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy9lcXVpdmFsZW50IHZhbHVlcyBmb3IgZXZlcnkgY29ycmVzcG9uZGluZyBrZXksIGFuZFxuICAvL35+fnBvc3NpYmx5IGV4cGVuc2l2ZSBkZWVwIHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIV9kZWVwRXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIDguIFRoZSBub24tZXF1aXZhbGVuY2UgYXNzZXJ0aW9uIHRlc3RzIGZvciBhbnkgZGVlcCBpbmVxdWFsaXR5LlxuLy8gYXNzZXJ0Lm5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5ub3REZWVwRXF1YWwgPSBmdW5jdGlvbiBub3REZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG4vLyA5LiBUaGUgc3RyaWN0IGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzdHJpY3QgZXF1YWxpdHksIGFzIGRldGVybWluZWQgYnkgPT09LlxuLy8gYXNzZXJ0LnN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnN0cmljdEVxdWFsID0gZnVuY3Rpb24gc3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsICE9PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJz09PScsIGFzc2VydC5zdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDEwLiBUaGUgc3RyaWN0IG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHN0cmljdCBpbmVxdWFsaXR5LCBhc1xuLy8gZGV0ZXJtaW5lZCBieSAhPT0uICBhc3NlcnQubm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90U3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBub3RTdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnIT09JywgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkge1xuICBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGV4cGVjdGVkKSA9PSAnW29iamVjdCBSZWdFeHBdJykge1xuICAgIHJldHVybiBleHBlY3RlZC50ZXN0KGFjdHVhbCk7XG4gIH0gZWxzZSBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZC5jYWxsKHt9LCBhY3R1YWwpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh1dGlsLmlzU3RyaW5nKGV4cGVjdGVkKSkge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIGJsb2NrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBhY3R1YWwgPSBlO1xuICB9XG5cbiAgbWVzc2FnZSA9IChleHBlY3RlZCAmJiBleHBlY3RlZC5uYW1lID8gJyAoJyArIGV4cGVjdGVkLm5hbWUgKyAnKS4nIDogJy4nKSArXG4gICAgICAgICAgICAobWVzc2FnZSA/ICcgJyArIG1lc3NhZ2UgOiAnLicpO1xuXG4gIGlmIChzaG91bGRUaHJvdyAmJiAhYWN0dWFsKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnTWlzc2luZyBleHBlY3RlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoIXNob3VsZFRocm93ICYmIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCAnR290IHVud2FudGVkIGV4Y2VwdGlvbicgKyBtZXNzYWdlKTtcbiAgfVxuXG4gIGlmICgoc2hvdWxkVGhyb3cgJiYgYWN0dWFsICYmIGV4cGVjdGVkICYmXG4gICAgICAhZXhwZWN0ZWRFeGNlcHRpb24oYWN0dWFsLCBleHBlY3RlZCkpIHx8ICghc2hvdWxkVGhyb3cgJiYgYWN0dWFsKSkge1xuICAgIHRocm93IGFjdHVhbDtcbiAgfVxufVxuXG4vLyAxMS4gRXhwZWN0ZWQgdG8gdGhyb3cgYW4gZXJyb3I6XG4vLyBhc3NlcnQudGhyb3dzKGJsb2NrLCBFcnJvcl9vcHQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0LnRocm93cyA9IGZ1bmN0aW9uKGJsb2NrLCAvKm9wdGlvbmFsKi9lcnJvciwgLypvcHRpb25hbCovbWVzc2FnZSkge1xuICBfdGhyb3dzLmFwcGx5KHRoaXMsIFt0cnVlXS5jb25jYXQocFNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cy5hcHBseSh0aGlzLCBbZmFsc2VdLmNvbmNhdChwU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB7dGhyb3cgZXJyO319O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuJyk7XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBsZW47IGkrKylcbiAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSsrKVxuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG5cbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICB2YXIgbTtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2Uge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IDA7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZW1pdHRlci5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSAxO1xuICBlbHNlXG4gICAgcmV0ID0gZW1pdHRlci5fZXZlbnRzW3R5cGVdLmxlbmd0aDtcbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xuICByZXR1cm4gYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnXG4gICAgJiYgdHlwZW9mIGFyZy5jb3B5ID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXG4gICAgJiYgdHlwZW9mIGFyZy5yZWFkVUludDggPT09ICdmdW5jdGlvbic7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAoaXNVbmRlZmluZWQoZ2xvYmFsLnByb2Nlc3MpKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKHByb2Nlc3MudHJhY2VEZXByZWNhdGlvbikge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufTtcblxuXG52YXIgZGVidWdzID0ge307XG52YXIgZGVidWdFbnZpcm9uO1xuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xuICBpZiAoaXNVbmRlZmluZWQoZGVidWdFbnZpcm9uKSlcbiAgICBkZWJ1Z0Vudmlyb24gPSBwcm9jZXNzLmVudi5OT0RFX0RFQlVHIHx8ICcnO1xuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcbiAgaWYgKCFkZWJ1Z3Nbc2V0XSkge1xuICAgIGlmIChuZXcgUmVnRXhwKCdcXFxcYicgKyBzZXQgKyAnXFxcXGInLCAnaScpLnRlc3QoZGVidWdFbnZpcm9uKSkge1xuICAgICAgdmFyIHBpZCA9IHByb2Nlc3MucGlkO1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG1zZyA9IGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJyVzICVkOiAlcycsIHNldCwgcGlkLCBtc2cpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVidWdzW3NldF07XG59O1xuXG5cbi8qKlxuICogRWNob3MgdGhlIHZhbHVlIG9mIGEgdmFsdWUuIFRyeXMgdG8gcHJpbnQgdGhlIHZhbHVlIG91dFxuICogaW4gdGhlIGJlc3Qgd2F5IHBvc3NpYmxlIGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBUaGUgb2JqZWN0IHRvIHByaW50IG91dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIE9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHRoYXQgYWx0ZXJzIHRoZSBvdXRwdXQuXG4gKi9cbi8qIGxlZ2FjeTogb2JqLCBzaG93SGlkZGVuLCBkZXB0aCwgY29sb3JzKi9cbmZ1bmN0aW9uIGluc3BlY3Qob2JqLCBvcHRzKSB7XG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xuICB2YXIgY3R4ID0ge1xuICAgIHNlZW46IFtdLFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXG4gIH07XG4gIC8vIGxlZ2FjeS4uLlxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIGN0eC5jb2xvcnMgPSBhcmd1bWVudHNbM107XG4gIGlmIChpc0Jvb2xlYW4ob3B0cykpIHtcbiAgICAvLyBsZWdhY3kuLi5cbiAgICBjdHguc2hvd0hpZGRlbiA9IG9wdHM7XG4gIH0gZWxzZSBpZiAob3B0cykge1xuICAgIC8vIGdvdCBhbiBcIm9wdGlvbnNcIiBvYmplY3RcbiAgICBleHBvcnRzLl9leHRlbmQoY3R4LCBvcHRzKTtcbiAgfVxuICAvLyBzZXQgZGVmYXVsdCBvcHRpb25zXG4gIGlmIChpc1VuZGVmaW5lZChjdHguc2hvd0hpZGRlbikpIGN0eC5zaG93SGlkZGVuID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmNvbG9ycykpIGN0eC5jb2xvcnMgPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jdXN0b21JbnNwZWN0KSkgY3R4LmN1c3RvbUluc3BlY3QgPSB0cnVlO1xuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xuICByZXR1cm4gZm9ybWF0VmFsdWUoY3R4LCBvYmosIGN0eC5kZXB0aCk7XG59XG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xuXG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xuaW5zcGVjdC5jb2xvcnMgPSB7XG4gICdib2xkJyA6IFsxLCAyMl0sXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcbiAgJ3VuZGVybGluZScgOiBbNCwgMjRdLFxuICAnaW52ZXJzZScgOiBbNywgMjddLFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXG4gICdncmV5JyA6IFs5MCwgMzldLFxuICAnYmxhY2snIDogWzMwLCAzOV0sXG4gICdibHVlJyA6IFszNCwgMzldLFxuICAnY3lhbicgOiBbMzYsIDM5XSxcbiAgJ2dyZWVuJyA6IFszMiwgMzldLFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcbiAgJ3JlZCcgOiBbMzEsIDM5XSxcbiAgJ3llbGxvdycgOiBbMzMsIDM5XVxufTtcblxuLy8gRG9uJ3QgdXNlICdibHVlJyBub3QgdmlzaWJsZSBvbiBjbWQuZXhlXG5pbnNwZWN0LnN0eWxlcyA9IHtcbiAgJ3NwZWNpYWwnOiAnY3lhbicsXG4gICdudW1iZXInOiAneWVsbG93JyxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcbiAgJ3VuZGVmaW5lZCc6ICdncmV5JyxcbiAgJ251bGwnOiAnYm9sZCcsXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxuICAnZGF0ZSc6ICdtYWdlbnRhJyxcbiAgLy8gXCJuYW1lXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcbiAgJ3JlZ2V4cCc6ICdyZWQnXG59O1xuXG5cbmZ1bmN0aW9uIHN0eWxpemVXaXRoQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcblxuICBpZiAoc3R5bGUpIHtcbiAgICByZXR1cm4gJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVswXSArICdtJyArIHN0ciArXG4gICAgICAgICAgICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMV0gKyAnbSc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHJldHVybiBzdHI7XG59XG5cblxuZnVuY3Rpb24gYXJyYXlUb0hhc2goYXJyYXkpIHtcbiAgdmFyIGhhc2ggPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHZhbCwgaWR4KSB7XG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0VmFsdWUoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzKSB7XG4gIC8vIFByb3ZpZGUgYSBob29rIGZvciB1c2VyLXNwZWNpZmllZCBpbnNwZWN0IGZ1bmN0aW9ucy5cbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XG4gIGlmIChjdHguY3VzdG9tSW5zcGVjdCAmJlxuICAgICAgdmFsdWUgJiZcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcbiAgICAgIC8vIEZpbHRlciBvdXQgdGhlIHV0aWwgbW9kdWxlLCBpdCdzIGluc3BlY3QgZnVuY3Rpb24gaXMgc3BlY2lhbFxuICAgICAgdmFsdWUuaW5zcGVjdCAhPT0gZXhwb3J0cy5pbnNwZWN0ICYmXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cbiAgICAgICEodmFsdWUuY29uc3RydWN0b3IgJiYgdmFsdWUuY29uc3RydWN0b3IucHJvdG90eXBlID09PSB2YWx1ZSkpIHtcbiAgICB2YXIgcmV0ID0gdmFsdWUuaW5zcGVjdChyZWN1cnNlVGltZXMsIGN0eCk7XG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XG4gICAgICByZXQgPSBmb3JtYXRWYWx1ZShjdHgsIHJldCwgcmVjdXJzZVRpbWVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXG4gIHZhciBwcmltaXRpdmUgPSBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSk7XG4gIGlmIChwcmltaXRpdmUpIHtcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xuICB9XG5cbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgdmFyIHZpc2libGVLZXlzID0gYXJyYXlUb0hhc2goa2V5cyk7XG5cbiAgaWYgKGN0eC5zaG93SGlkZGVuKSB7XG4gICAga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgfVxuXG4gIC8vIElFIGRvZXNuJ3QgbWFrZSBlcnJvciBmaWVsZHMgbm9uLWVudW1lcmFibGVcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcbiAgaWYgKGlzRXJyb3IodmFsdWUpXG4gICAgICAmJiAoa2V5cy5pbmRleE9mKCdtZXNzYWdlJykgPj0gMCB8fCBrZXlzLmluZGV4T2YoJ2Rlc2NyaXB0aW9uJykgPj0gMCkpIHtcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxuICBpZiAoa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tGdW5jdGlvbicgKyBuYW1lICsgJ10nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH1cbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAnZGF0ZScpO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhc2UgPSAnJywgYXJyYXkgPSBmYWxzZSwgYnJhY2VzID0gWyd7JywgJ30nXTtcblxuICAvLyBNYWtlIEFycmF5IHNheSB0aGF0IHRoZXkgYXJlIEFycmF5XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIGFycmF5ID0gdHJ1ZTtcbiAgICBicmFjZXMgPSBbJ1snLCAnXSddO1xuICB9XG5cbiAgLy8gTWFrZSBmdW5jdGlvbnMgc2F5IHRoYXQgdGhleSBhcmUgZnVuY3Rpb25zXG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XG4gICAgYmFzZSA9ICcgW0Z1bmN0aW9uJyArIG4gKyAnXSc7XG4gIH1cblxuICAvLyBNYWtlIFJlZ0V4cHMgc2F5IHRoYXQgdGhleSBhcmUgUmVnRXhwc1xuICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcbiAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgRGF0ZS5wcm90b3R5cGUudG9VVENTdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIH1cblxuICAvLyBNYWtlIGVycm9yIHdpdGggbWVzc2FnZSBmaXJzdCBzYXkgdGhlIGVycm9yXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICBpZiAoa2V5cy5sZW5ndGggPT09IDAgJiYgKCFhcnJheSB8fCB2YWx1ZS5sZW5ndGggPT0gMCkpIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArIGJyYWNlc1sxXTtcbiAgfVxuXG4gIGlmIChyZWN1cnNlVGltZXMgPCAwKSB7XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG5cbiAgY3R4LnNlZW4ucHVzaCh2YWx1ZSk7XG5cbiAgdmFyIG91dHB1dDtcbiAgaWYgKGFycmF5KSB7XG4gICAgb3V0cHV0ID0gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cyk7XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0ID0ga2V5cy5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSk7XG4gICAgfSk7XG4gIH1cblxuICBjdHguc2Vlbi5wb3AoKTtcblxuICByZXR1cm4gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XG4gIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCd1bmRlZmluZWQnLCAndW5kZWZpbmVkJyk7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICB2YXIgc2ltcGxlID0gJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlwifFwiJC9nLCAnJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykgKyAnXFwnJztcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoc2ltcGxlLCAnc3RyaW5nJyk7XG4gIH1cbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ251bWJlcicpO1xuICBpZiAoaXNCb29sZWFuKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcbiAgLy8gRm9yIHNvbWUgcmVhc29uIHR5cGVvZiBudWxsIGlzIFwib2JqZWN0XCIsIHNvIHNwZWNpYWwgY2FzZSBoZXJlLlxuICBpZiAoaXNOdWxsKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ251bGwnLCAnbnVsbCcpO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yKHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0QXJyYXkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5cykge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5KHZhbHVlLCBTdHJpbmcoaSkpKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaCgnJyk7XG4gICAgfVxuICB9XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAga2V5LCB0cnVlKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KSB7XG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XG4gIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHZhbHVlLCBrZXkpIHx8IHsgdmFsdWU6IHZhbHVlW2tleV0gfTtcbiAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlci9TZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGRlc2Muc2V0KSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoIWhhc093blByb3BlcnR5KHZpc2libGVLZXlzLCBrZXkpKSB7XG4gICAgbmFtZSA9ICdbJyArIGtleSArICddJztcbiAgfVxuICBpZiAoIXN0cikge1xuICAgIGlmIChjdHguc2Vlbi5pbmRleE9mKGRlc2MudmFsdWUpIDwgMCkge1xuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgbnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0ci5pbmRleE9mKCdcXG4nKSA+IC0xKSB7XG4gICAgICAgIGlmIChhcnJheSkge1xuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKS5zdWJzdHIoMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyID0gJ1xcbicgKyBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbQ2lyY3VsYXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzVW5kZWZpbmVkKG5hbWUpKSB7XG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcZCskLykpIHtcbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIG5hbWUgPSBKU09OLnN0cmluZ2lmeSgnJyArIGtleSk7XG4gICAgaWYgKG5hbWUubWF0Y2goL15cIihbYS16QS1aX11bYS16QS1aXzAtOV0qKVwiJC8pKSB7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHIoMSwgbmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKC8nL2csIFwiXFxcXCdcIilcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvKF5cInxcIiQpL2csIFwiJ1wiKTtcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnc3RyaW5nJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xufVxuXG5cbmZ1bmN0aW9uIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKSB7XG4gIHZhciBudW1MaW5lc0VzdCA9IDA7XG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xuICAgIG51bUxpbmVzRXN0Kys7XG4gICAgaWYgKGN1ci5pbmRleE9mKCdcXG4nKSA+PSAwKSBudW1MaW5lc0VzdCsrO1xuICAgIHJldHVybiBwcmV2ICsgY3VyLnJlcGxhY2UoL1xcdTAwMWJcXFtcXGRcXGQ/bS9nLCAnJykubGVuZ3RoICsgMTtcbiAgfSwgMCk7XG5cbiAgaWYgKGxlbmd0aCA+IDYwKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXG4gJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBvdXRwdXQuam9pbignLFxcbiAgJykgK1xuICAgICAgICAgICAnICcgK1xuICAgICAgICAgICBicmFjZXNbMV07XG4gIH1cblxuICByZXR1cm4gYnJhY2VzWzBdICsgYmFzZSArICcgJyArIG91dHB1dC5qb2luKCcsICcpICsgJyAnICsgYnJhY2VzWzFdO1xufVxuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5mdW5jdGlvbiBpc0FycmF5KGFyKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHJlKSAmJiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGQpICYmIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiBpc09iamVjdChlKSAmJlxuICAgICAgKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cblxuXG5mdW5jdGlvbiBwYWQobikge1xuICByZXR1cm4gbiA8IDEwID8gJzAnICsgbi50b1N0cmluZygxMCkgOiBuLnRvU3RyaW5nKDEwKTtcbn1cblxuXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXG4gICAgICAgICAgICAgICdPY3QnLCAnTm92JywgJ0RlYyddO1xuXG4vLyAyNiBGZWIgMTY6MTk6MzRcbmZ1bmN0aW9uIHRpbWVzdGFtcCgpIHtcbiAgdmFyIGQgPSBuZXcgRGF0ZSgpO1xuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0TWludXRlcygpKSxcbiAgICAgICAgICAgICAgcGFkKGQuZ2V0U2Vjb25kcygpKV0uam9pbignOicpO1xuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xufVxuXG5cbi8vIGxvZyBpcyBqdXN0IGEgdGhpbiB3cmFwcGVyIHRvIGNvbnNvbGUubG9nIHRoYXQgcHJlcGVuZHMgYSB0aW1lc3RhbXBcbmV4cG9ydHMubG9nID0gZnVuY3Rpb24oKSB7XG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xufTtcblxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlci5cbiAqXG4gKiBUaGUgRnVuY3Rpb24ucHJvdG90eXBlLmluaGVyaXRzIGZyb20gbGFuZy5qcyByZXdyaXR0ZW4gYXMgYSBzdGFuZGFsb25lXG4gKiBmdW5jdGlvbiAobm90IG9uIEZ1bmN0aW9uLnByb3RvdHlwZSkuIE5PVEU6IElmIHRoaXMgZmlsZSBpcyB0byBiZSBsb2FkZWRcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXG4gKiBmdW5jdGlvbnMgYXMgcHJvdG90eXBlIHNldHVwIHVzaW5nIG5vcm1hbCBKYXZhU2NyaXB0IGRvZXMgbm90IHdvcmsgYXNcbiAqIGV4cGVjdGVkIGR1cmluZyBib290c3RyYXBwaW5nIChzZWUgbWlycm9yLmpzIGluIHIxMTQ5MDMpLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gaW5oZXJpdCB0aGVcbiAqICAgICBwcm90b3R5cGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cbiAqL1xuZXhwb3J0cy5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuIiwiLyoqXG4gKiBsb2Rhc2ggMy4yLjAgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiYXNlQXNzaWduID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlYXNzaWduJyksXG4gICAgY3JlYXRlQXNzaWduZXIgPSByZXF1aXJlKCdsb2Rhc2guX2NyZWF0ZWFzc2lnbmVyJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJ2xvZGFzaC5rZXlzJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmFzc2lnbmAgZm9yIGN1c3RvbWl6aW5nIGFzc2lnbmVkIHZhbHVlcyB3aXRob3V0XG4gKiBzdXBwb3J0IGZvciBhcmd1bWVudCBqdWdnbGluZywgbXVsdGlwbGUgc291cmNlcywgYW5kIGB0aGlzYCBiaW5kaW5nIGBjdXN0b21pemVyYFxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBwcm9wcyA9IGtleXMoc291cmNlKSxcbiAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF0sXG4gICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHJlc3VsdCA9IGN1c3RvbWl6ZXIodmFsdWUsIHNvdXJjZVtrZXldLCBrZXksIG9iamVjdCwgc291cmNlKTtcblxuICAgIGlmICgocmVzdWx0ID09PSByZXN1bHQgPyAocmVzdWx0ICE9PSB2YWx1ZSkgOiAodmFsdWUgPT09IHZhbHVlKSkgfHxcbiAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgIG9iamVjdFtrZXldID0gcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICogb2JqZWN0LiBTdWJzZXF1ZW50IHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKiBJZiBgY3VzdG9taXplcmAgaXMgcHJvdmlkZWQgaXQgaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuXG4gKiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOlxuICogKG9iamVjdFZhbHVlLCBzb3VyY2VWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAgYW5kIGlzIGJhc2VkIG9uXG4gKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtb2JqZWN0LmFzc2lnbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBhbGlhcyBleHRlbmRcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjdXN0b21pemVyYC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uYXNzaWduKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiA0MCB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4geyAndXNlcic6ICdmcmVkJywgJ2FnZSc6IDQwIH1cbiAqXG4gKiAvLyB1c2luZyBhIGN1c3RvbWl6ZXIgY2FsbGJhY2tcbiAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduLCBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAqICAgcmV0dXJuIF8uaXNVbmRlZmluZWQodmFsdWUpID8gb3RoZXIgOiB2YWx1ZTtcbiAqIH0pO1xuICpcbiAqIGRlZmF1bHRzKHsgJ3VzZXInOiAnYmFybmV5JyB9LCB7ICdhZ2UnOiAzNiB9LCB7ICd1c2VyJzogJ2ZyZWQnIH0pO1xuICogLy8gPT4geyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICovXG52YXIgYXNzaWduID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgcmV0dXJuIGN1c3RvbWl6ZXJcbiAgICA/IGFzc2lnbldpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpXG4gICAgOiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbiIsIi8qKlxuICogbG9kYXNoIDMuMi4wIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmFzZUNvcHkgPSByZXF1aXJlKCdsb2Rhc2guX2Jhc2Vjb3B5JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJ2xvZGFzaC5rZXlzJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduYCB3aXRob3V0IHN1cHBvcnQgZm9yIGFyZ3VtZW50IGp1Z2dsaW5nLFxuICogbXVsdGlwbGUgc291cmNlcywgYW5kIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gIHJldHVybiBzb3VyY2UgPT0gbnVsbFxuICAgID8gb2JqZWN0XG4gICAgOiBiYXNlQ29weShzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlQ29weShzb3VyY2UsIHByb3BzLCBvYmplY3QpIHtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ29weTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMS4xIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYmluZENhbGxiYWNrID0gcmVxdWlyZSgnbG9kYXNoLl9iaW5kY2FsbGJhY2snKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJ2xvZGFzaC5faXNpdGVyYXRlZWNhbGwnKSxcbiAgICByZXN0UGFyYW0gPSByZXF1aXJlKCdsb2Rhc2gucmVzdHBhcmFtJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgYXNzaWducyBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QocykgdG8gYSBnaXZlblxuICogZGVzdGluYXRpb24gb2JqZWN0LlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY3JlYXRlIGBfLmFzc2lnbmAsIGBfLmRlZmF1bHRzYCwgYW5kIGBfLm1lcmdlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXNzaWduZXIoYXNzaWduZXIpIHtcbiAgcmV0dXJuIHJlc3RQYXJhbShmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gb2JqZWN0ID09IG51bGwgPyAwIDogc291cmNlcy5sZW5ndGgsXG4gICAgICAgIGN1c3RvbWl6ZXIgPSBsZW5ndGggPiAyID8gc291cmNlc1tsZW5ndGggLSAyXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgdGhpc0FyZyA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSBiaW5kQ2FsbGJhY2soY3VzdG9taXplciwgdGhpc0FyZywgNSk7XG4gICAgICBsZW5ndGggLT0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiB0aGlzQXJnID09ICdmdW5jdGlvbicgPyB0aGlzQXJnIDogdW5kZWZpbmVkO1xuICAgICAgbGVuZ3RoIC09IChjdXN0b21pemVyID8gMSA6IDApO1xuICAgIH1cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgY3VzdG9taXplcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFzc2lnbmVyO1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VDYWxsYmFja2Agd2hpY2ggb25seSBzdXBwb3J0cyBgdGhpc2AgYmluZGluZ1xuICogYW5kIHNwZWNpZnlpbmcgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGJpbmQuXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXJnQ291bnRdIFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gYmluZENhbGxiYWNrKGZ1bmMsIHRoaXNBcmcsIGFyZ0NvdW50KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxuICBzd2l0Y2ggKGFyZ0NvdW50KSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgdmFsdWUpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgfTtcbiAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIH07XG4gICAgY2FzZSA1OiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG90aGVyLCBrZXksIG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIHZhbHVlLCBvdGhlciwga2V5LCBvYmplY3QsIHNvdXJjZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxpdHlcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmRDYWxsYmFjaztcbiIsIi8qKlxuICogbG9kYXNoIDMuMC45IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eXFxkKyQvO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFsdWUgPSAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSA/ICt2YWx1ZSA6IC0xO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG4gIHJldHVybiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Kn0gaW5kZXggVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBpbmRleCBvciBrZXkgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgcG90ZW50aWFsIGl0ZXJhdGVlIG9iamVjdCBhcmd1bWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgPyAoaXNBcnJheUxpa2Uob2JqZWN0KSAmJiBpc0luZGV4KGluZGV4LCBvYmplY3QubGVuZ3RoKSlcbiAgICAgIDogKHR5cGUgPT0gJ3N0cmluZycgJiYgaW5kZXggaW4gb2JqZWN0KSkge1xuICAgIHZhciBvdGhlciA9IG9iamVjdFtpbmRleF07XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZSA/ICh2YWx1ZSA9PT0gb3RoZXIpIDogKG90aGVyICE9PSBvdGhlcik7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgYmFzZWQgb24gW2BUb0xlbmd0aGBdKGh0dHBzOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNJdGVyYXRlZUNhbGw7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjYuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogVXNlZCBhcyB0aGUgYFR5cGVFcnJvcmAgbWVzc2FnZSBmb3IgXCJGdW5jdGlvbnNcIiBtZXRob2RzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAqIGNyZWF0ZWQgZnVuY3Rpb24gYW5kIGFyZ3VtZW50cyBmcm9tIGBzdGFydGAgYW5kIGJleW9uZCBwcm92aWRlZCBhcyBhbiBhcnJheS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb24gdGhlIFtyZXN0IHBhcmFtZXRlcl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvRnVuY3Rpb25zL3Jlc3RfcGFyYW1ldGVycykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgc2F5ID0gXy5yZXN0UGFyYW0oZnVuY3Rpb24od2hhdCwgbmFtZXMpIHtcbiAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICogICAgIChfLnNpemUobmFtZXMpID4gMSA/ICcsICYgJyA6ICcnKSArIF8ubGFzdChuYW1lcyk7XG4gKiB9KTtcbiAqXG4gKiBzYXkoJ2hlbGxvJywgJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnKTtcbiAqIC8vID0+ICdoZWxsbyBmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAqL1xuZnVuY3Rpb24gcmVzdFBhcmFtKGZ1bmMsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6ICgrc3RhcnQgfHwgMCksIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgcmVzdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdFtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBzd2l0Y2ggKHN0YXJ0KSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpcywgcmVzdCk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgcmVzdCk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSwgcmVzdCk7XG4gICAgfVxuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIGluZGV4ID0gLTE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gcmVzdDtcbiAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBvdGhlckFyZ3MpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc3RQYXJhbTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMS4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnbG9kYXNoLl9nZXRuYXRpdmUnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJ2xvZGFzaC5pc2FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCdsb2Rhc2guaXNhcnJheScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXlxcZCskLztcblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qIE5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IGdldE5hdGl2ZShPYmplY3QsICdrZXlzJyk7XG5cbi8qKlxuICogVXNlZCBhcyB0aGUgW21heGltdW0gbGVuZ3RoXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy1udW1iZXIubWF4X3NhZmVfaW50ZWdlcilcbiAqIG9mIGFuIGFycmF5LWxpa2UgdmFsdWUuXG4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IHZhbHVlIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gYXZvaWQgYSBbSklUIGJ1Z10oaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE0Mjc5MilcbiAqIHRoYXQgYWZmZWN0cyBTYWZhcmkgb24gYXQgbGVhc3QgaU9TIDguMS04LjMgQVJNNjQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBcImxlbmd0aFwiIHZhbHVlLlxuICovXG52YXIgZ2V0TGVuZ3RoID0gYmFzZVByb3BlcnR5KCdsZW5ndGgnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgoZ2V0TGVuZ3RoKHZhbHVlKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgPyArdmFsdWUgOiAtMTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQSBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiBvZiBgT2JqZWN0LmtleXNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlXG4gKiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gc2hpbUtleXMob2JqZWN0KSB7XG4gIHZhciBwcm9wcyA9IGtleXNJbihvYmplY3QpLFxuICAgICAgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICBsZW5ndGggPSBwcm9wc0xlbmd0aCAmJiBvYmplY3QubGVuZ3RoO1xuXG4gIHZhciBhbGxvd0luZGV4ZXMgPSAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcblxuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgcHJvcHNMZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuICAgIGlmICgoYWxsb3dJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xudmFyIGtleXMgPSAhbmF0aXZlS2V5cyA/IHNoaW1LZXlzIDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciBDdG9yID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3QuY29uc3RydWN0b3I7XG4gIGlmICgodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0KSB8fFxuICAgICAgKHR5cGVvZiBvYmplY3QgIT0gJ2Z1bmN0aW9uJyAmJiBpc0FycmF5TGlrZShvYmplY3QpKSkge1xuICAgIHJldHVybiBzaGltS2V5cyhvYmplY3QpO1xuICB9XG4gIHJldHVybiBpc09iamVjdChvYmplY3QpID8gbmF0aXZlS2V5cyhvYmplY3QpIDogW107XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5c0luKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKi9cbmZ1bmN0aW9uIGtleXNJbihvYmplY3QpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICB9XG4gIHZhciBsZW5ndGggPSBvYmplY3QubGVuZ3RoO1xuICBsZW5ndGggPSAobGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiZcbiAgICAoaXNBcnJheShvYmplY3QpIHx8IGlzQXJndW1lbnRzKG9iamVjdCkpICYmIGxlbmd0aCkgfHwgMDtcblxuICB2YXIgQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgIGluZGV4ID0gLTEsXG4gICAgICBpc1Byb3RvID0gdHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSA9PT0gb2JqZWN0LFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgIHNraXBJbmRleGVzID0gbGVuZ3RoID4gMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSAoaW5kZXggKyAnJyk7XG4gIH1cbiAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgIGlmICghKHNraXBJbmRleGVzICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpKSAmJlxuICAgICAgICAhKGtleSA9PSAnY29uc3RydWN0b3InICYmIChpc1Byb3RvIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjkuMSAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBob3N0IGNvbnN0cnVjdG9ycyAoU2FmYXJpID4gNSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKiogVXNlZCBmb3IgbmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZuVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZSBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9ialRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG52YXIgcmVJc05hdGl2ZSA9IFJlZ0V4cCgnXicgK1xuICBmblRvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UoL1tcXFxcXiQuKis/KClbXFxde318XS9nLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZ1bmN0aW9uIGlmIGl0J3MgbmF0aXZlLCBlbHNlIGB1bmRlZmluZWRgLlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmUob2JqZWN0LCBrZXkpIHtcbiAgdmFyIHZhbHVlID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgcmV0dXJuIGlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBvbGRlciB2ZXJzaW9ucyBvZiBDaHJvbWUgYW5kIFNhZmFyaSB3aGljaCByZXR1cm4gJ2Z1bmN0aW9uJyBmb3IgcmVnZXhlc1xuICAvLyBhbmQgU2FmYXJpIDggZXF1aXZhbGVudHMgd2hpY2ggcmV0dXJuICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcnMuXG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gZnVuY1RhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgW2xhbmd1YWdlIHR5cGVdKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDgpIG9mIGBPYmplY3RgLlxuICogKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdCgxKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8vIEF2b2lkIGEgVjggSklUIGJ1ZyBpbiBDaHJvbWUgMTktMjAuXG4gIC8vIFNlZSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MSBmb3IgbW9yZSBkZXRhaWxzLlxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc05hdGl2ZShfKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgIHJldHVybiByZUlzTmF0aXZlLnRlc3QoZm5Ub1N0cmluZy5jYWxsKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgcmVJc0hvc3RDdG9yLnRlc3QodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5hdGl2ZTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMC40IChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBOYXRpdmUgbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBVc2VkIGFzIHRoZSBbbWF4aW11bSBsZW5ndGhdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW51bWJlci5tYXhfc2FmZV9pbnRlZ2VyKVxuICogb2YgYW4gYXJyYXktbGlrZSB2YWx1ZS5cbiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgdmFsdWUgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBhIFtKSVQgYnVnXShodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNzkyKVxuICogdGhhdCBhZmZlY3RzIFNhZmFyaSBvbiBhdCBsZWFzdCBpT1MgOC4xLTguMyBBUk02NC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIFwibGVuZ3RoXCIgdmFsdWUuXG4gKi9cbnZhciBnZXRMZW5ndGggPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aChnZXRMZW5ndGgodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIGlzIGJhc2VkIG9uIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi82LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpICYmXG4gICAgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuNCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSA+IDUpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqIFVzZWQgZm9yIG5hdGl2ZSBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmblRvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmpUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZm5Ub1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyogTmF0aXZlIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0FycmF5ID0gZ2V0TmF0aXZlKEFycmF5LCAnaXNBcnJheScpO1xuXG4vKipcbiAqIFVzZWQgYXMgdGhlIFttYXhpbXVtIGxlbmd0aF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXIpXG4gKiBvZiBhbiBhcnJheS1saWtlIHZhbHVlLlxuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICByZXR1cm4gaXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBpcyBiYXNlZCBvbiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFycmF5VGFnO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGNvcnJlY3RseSBjbGFzc2lmaWVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gb2xkZXIgdmVyc2lvbnMgb2YgQ2hyb21lIGFuZCBTYWZhcmkgd2hpY2ggcmV0dXJuICdmdW5jdGlvbicgZm9yIHJlZ2V4ZXNcbiAgLy8gYW5kIFNhZmFyaSA4IGVxdWl2YWxlbnRzIHdoaWNoIHJldHVybiAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXkgY29uc3RydWN0b3JzLlxuICByZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIG9ialRvU3RyaW5nLmNhbGwodmFsdWUpID09IGZ1bmNUYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNOYXRpdmUoQXJyYXkucHJvdG90eXBlLnB1c2gpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNOYXRpdmUoXyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICByZXR1cm4gcmVJc05hdGl2ZS50ZXN0KGZuVG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIHJlSXNIb3N0Q3Rvci50ZXN0KHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5O1xuIiwiLyoqXG4gKiBsb2Rhc2ggMy4xLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2Rlcm4gbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE1IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbnZhciBiYXNlQXNzaWduID0gcmVxdWlyZSgnbG9kYXNoLl9iYXNlYXNzaWduJyksXG4gICAgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJ2xvZGFzaC5fYmFzZWNyZWF0ZScpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnbG9kYXNoLl9pc2l0ZXJhdGVlY2FsbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LiBJZiBhXG4gKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIHByb3ZpZGVkIGl0cyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBhc3NpZ25lZFxuICogdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhIGNhbGxiYWNrIGZvciBmdW5jdGlvbnMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gU2hhcGUoKSB7XG4gKiAgIHRoaXMueCA9IDA7XG4gKiAgIHRoaXMueSA9IDA7XG4gKiB9XG4gKlxuICogZnVuY3Rpb24gQ2lyY2xlKCkge1xuICogICBTaGFwZS5jYWxsKHRoaXMpO1xuICogfVxuICpcbiAqIENpcmNsZS5wcm90b3R5cGUgPSBfLmNyZWF0ZShTaGFwZS5wcm90b3R5cGUsIHtcbiAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gKiB9KTtcbiAqXG4gKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAqIGNpcmNsZSBpbnN0YW5jZW9mIENpcmNsZTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBjaXJjbGUgaW5zdGFuY2VvZiBTaGFwZTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpIHtcbiAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHByb3RvdHlwZSwgcHJvcGVydGllcywgZ3VhcmQpKSB7XG4gICAgcHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gcHJvcGVydGllcyA/IGJhc2VBc3NpZ24ocmVzdWx0LCBwcm9wZXJ0aWVzKSA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG4iLCIvKipcbiAqIGxvZGFzaCAzLjAuMyAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZGVybiBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCAyMDEyLTIwMTUgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IDIwMDktMjAxNSBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqL1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlKSkge1xuICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICAgIHZhciByZXN1bHQgPSBuZXcgb2JqZWN0O1xuICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCB8fCB7fTtcbiAgfTtcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlIFtsYW5ndWFnZSB0eXBlXShodHRwczovL2VzNS5naXRodWIuaW8vI3g4KSBvZiBgT2JqZWN0YC5cbiAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoMSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUNyZWF0ZTtcbiIsIi8qKlxuICogbG9kYXNoIDMuMS4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kZXJuIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IDIwMTItMjAxNSBUaGUgRG9qbyBGb3VuZGF0aW9uIDxodHRwOi8vZG9qb2ZvdW5kYXRpb24ub3JnLz5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICovXG52YXIgYXNzaWduID0gcmVxdWlyZSgnbG9kYXNoLmFzc2lnbicpLFxuICAgIHJlc3RQYXJhbSA9IHJlcXVpcmUoJ2xvZGFzaC5yZXN0cGFyYW0nKTtcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbmAgdXNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IG9iamVjdFZhbHVlIFRoZSBkZXN0aW5hdGlvbiBvYmplY3QgcHJvcGVydHkgdmFsdWUuXG4gKiBAcGFyYW0geyp9IHNvdXJjZVZhbHVlIFRoZSBzb3VyY2Ugb2JqZWN0IHByb3BlcnR5IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbiB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhvYmplY3RWYWx1ZSwgc291cmNlVmFsdWUpIHtcbiAgcmV0dXJuIG9iamVjdFZhbHVlID09PSB1bmRlZmluZWQgPyBzb3VyY2VWYWx1ZSA6IG9iamVjdFZhbHVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5kZWZhdWx0c2Agb3IgYF8uZGVmYXVsdHNEZWVwYCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gYXNzaWduZXIgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVmYXVsdHMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRzKGFzc2lnbmVyLCBjdXN0b21pemVyKSB7XG4gIHJldHVybiByZXN0UGFyYW0oZnVuY3Rpb24oYXJncykge1xuICAgIHZhciBvYmplY3QgPSBhcmdzWzBdO1xuICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG4gICAgYXJncy5wdXNoKGN1c3RvbWl6ZXIpO1xuICAgIHJldHVybiBhc3NpZ25lci5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBPbmNlIGFcbiAqIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0cyh7ICd1c2VyJzogJ2Jhcm5leScgfSwgeyAnYWdlJzogMzYgfSwgeyAndXNlcic6ICdmcmVkJyB9KTtcbiAqIC8vID0+IHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2IH1cbiAqL1xudmFyIGRlZmF1bHRzID0gY3JlYXRlRGVmYXVsdHMoYXNzaWduLCBhc3NpZ25EZWZhdWx0cyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoICcuL2xpYi8nICk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblxuICAgIHZhciBub3cgPSByZXF1aXJlKFwicGVyZm9ybWFuY2Utbm93XCIpO1xuXG4gICAgZnVuY3Rpb24gZmluZChhcnIsIHByZWRpY2F0ZSkge1xuICAgICAgICAgICAgaWYgKGFyciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLmZpbmQgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByZWRpY2F0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ByZWRpY2F0ZSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsaXN0ID0gT2JqZWN0KGFycik7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gICAgICAgICAgICB2YXIgdmFsdWU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxpc3RbaV07XG4gICAgICAgICAgICAgICAgaWYgKHByZWRpY2F0ZS5jYWxsKG51bGwsIHZhbHVlLCBpLCBsaXN0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuXG4gICAgdmFyIFNpbXBsZVRleHR1cmVNYW5hZ2VyID0gZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHRoaXMuX3VuaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgKG9wdC51bml0cyB8fCA4KTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl91bml0c1tpXSA9IHtzbG90OiBpLCB1c2U6IDB9O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFNpbXBsZVRleHR1cmVNYW5hZ2VyLk5PVF9GT1VORCA9IC0xO1xuICAgIFNpbXBsZVRleHR1cmVNYW5hZ2VyLkZVTEwgPSAtMjtcblxuICAgIFNpbXBsZVRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZSA9IHtcblxuICAgICAgICBfc2V0OiBmdW5jdGlvbiAoc2xvdCwgbmV3RW50cnkpIHtcbiAgICAgICAgICAgIHZhciBvbGRFbnRyeSA9IHRoaXMuX3VuaXRzW3Nsb3RdO1xuICAgICAgICAgICAgaWYgKG9sZEVudHJ5LmRpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICBvbGRFbnRyeS5kaXNwb3NlKG9sZEVudHJ5LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdFbnRyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRzW3Nsb3RdID0gbmV3RW50cnk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5pdHNbc2xvdF0uc2xvdCA9IHNsb3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VuaXRzW3Nsb3RdID0ge3Nsb3Q6IHNsb3QsIHVzZTogMH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYmluZDogZnVuY3Rpb24gKGlkLCBvcHQpIHtcbiAgICAgICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgICAgIHZhciBmaXhlZCA9ICEhb3B0LmZpeGVkO1xuICAgICAgICAgICAgdmFyIGRpc3Bvc2UgPSB0eXBlb2Ygb3B0LmRpc3Bvc2UgPT0gXCJmdW5jdGlvblwiID8gb3B0LmRpc3Bvc2UgOiBudWxsO1xuXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0ZXh0dXJlIGlzIGFscmVhZHkgYm91bmRcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldChpZCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ICE9PSBTaW1wbGVUZXh0dXJlTWFuYWdlci5OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2FuZGlkYXRlcyA9IHRoaXMuX3VuaXRzLmZpbHRlcihmdW5jdGlvbiAodW5pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdW5pdC5maXhlZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIkNhbmRpZGF0ZXMsXCIsIGNhbmRpZGF0ZXMsIGNhbmRpZGF0ZXMubGVuZ3RoKTtcblxuICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBTaW1wbGVUZXh0dXJlTWFuYWdlci5GVUxMO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBjYW5kaWRhdGVzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3Vycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2ID8gKGN1cnIudXNlIDwgcHJldi51c2UgPyBjdXJyIDogcHJldikgOiBjdXJyO1xuICAgICAgICAgICAgfSwgbnVsbCk7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU2VsZWN0ZWQgZW50cnlcIiwgc2VsZWN0ZWQpO1xuXG4gICAgICAgICAgICB2YXIgc2xvdCA9IHNlbGVjdGVkLnNsb3Q7XG4gICAgICAgICAgICB0aGlzLl9zZXQoc2xvdCwge1xuICAgICAgICAgICAgICAgIGZpeGVkOiBmaXhlZCwgdXNlOiBub3coKSwgaWQ6IGlkLCBkaXNwb3NlOiBkaXNwb3NlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBzbG90O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgZGlzcG9zZTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmdldEVudHJ5KGlkKTtcbiAgICAgICAgICAgIHRoaXMuX3NldChlbnRyeS5zbG90LCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgaWYgdGhlIHRleHR1cmUgb2YgdGhlIGdpdmVuIGlkIGlzIGJvdW5kIHRvIGFuIHVuaXRcbiAgICAgICAgICogQHBhcmFtIGlkXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgaGFzOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuZ2V0RW50cnkoaWQpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudCB0ZXh0dXJlIHVuaXQgZm9yIHRoZSBpZCBvciBTaW1wbGVUZXh0dXJlTWFuYWdlci5OT1RfRk9VTkRcbiAgICAgICAgICogaWYgdGhlIHRleHR1cmUgaXMgY3VycmVudGx5IG5vdCBib3VuZFxuICAgICAgICAgKiBAcGFyYW0gaWRcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZ2V0RW50cnkoaWQpO1xuICAgICAgICAgICAgaWYocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnVzZSA9IG5vdygpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuc2xvdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBTaW1wbGVUZXh0dXJlTWFuYWdlci5OT1RfRk9VTkQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXNlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldEVudHJ5KGlkKTtcbiAgICAgICAgICAgIGlmKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51c2UgPSBub3coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBnZXRFbnRyeTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmluZCh0aGlzLl91bml0cywgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVudHJ5LmlkID09PSBpZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBTaW1wbGVUZXh0dXJlTWFuYWdlcjogU2ltcGxlVGV4dHVyZU1hbmFnZXJcbiAgICB9O1xufSgpO1xuIiwiLy8gR2VuZXJhdGVkIGJ5IENvZmZlZVNjcmlwdCAxLjcuMVxuKGZ1bmN0aW9uKCkge1xuICB2YXIgZ2V0TmFub1NlY29uZHMsIGhydGltZSwgbG9hZFRpbWU7XG5cbiAgaWYgKCh0eXBlb2YgcGVyZm9ybWFuY2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcGVyZm9ybWFuY2UgIT09IG51bGwpICYmIHBlcmZvcm1hbmNlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICgodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2VzcyAhPT0gbnVsbCkgJiYgcHJvY2Vzcy5ocnRpbWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChnZXROYW5vU2Vjb25kcygpIC0gbG9hZFRpbWUpIC8gMWU2O1xuICAgIH07XG4gICAgaHJ0aW1lID0gcHJvY2Vzcy5ocnRpbWU7XG4gICAgZ2V0TmFub1NlY29uZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBocjtcbiAgICAgIGhyID0gaHJ0aW1lKCk7XG4gICAgICByZXR1cm4gaHJbMF0gKiAxZTkgKyBoclsxXTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gZ2V0TmFub1NlY29uZHMoKTtcbiAgfSBlbHNlIGlmIChEYXRlLm5vdykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIGxvYWRUaW1lO1xuICAgIH07XG4gICAgbG9hZFRpbWUgPSBEYXRlLm5vdygpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBsb2FkVGltZTtcbiAgICB9O1xuICAgIGxvYWRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH1cblxufSkuY2FsbCh0aGlzKTtcbiIsInZhciBTZXQgPSByZXF1aXJlKFwiLi4veGZsb3cvdXRpbHMvdXRpbHMuanNcIikuc2V0O1xudmFyIERhdGFOb2RlID0gcmVxdWlyZShcIi4uL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKS5EYXRhTm9kZTtcblxuZnVuY3Rpb24gQXNzZXRFcnJvcihtZXNzYWdlLCBub2RlKXtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG59XG5cbnZhciBBc3NldCA9IGZ1bmN0aW9uKHJlZk5vZGUpe1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5zcmNBc3NldCA9IG51bGw7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMuc3ViQXNzZXRzID0gW107XG4gICAgdGhpcy5waWNrRmlsdGVyID0gbnVsbDtcbiAgICB0aGlzLnBhcmVudHMgPSBbXTtcbiAgICB0aGlzLmxpc3RlbmVyID0gW107XG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5yZWZOb2RlID0gcmVmTm9kZSB8fCBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcblxuICAgIHRoaXMuYXNzZXRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMubG9hZExldmVsID0gMDtcbiAgICB0aGlzLnByb2dyZXNzTGV2ZWwgPSBJbmZpbml0eTtcbn07XG5cbkFzc2V0LnByb3RvdHlwZS5jaGVja1ZhbGlkaXR5ID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmlzU3VidHJlZUxvYWRpbmcoKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNoZWNrUmVjdXJzaXZlKHRoaXMpO1xufTtcbmZ1bmN0aW9uIGNoZWNrUmVjdXJzaXZlKGFzc2V0KXtcbiAgICBpZihhc3NldC5zcmNBc3NldCl7XG4gICAgICAgIGNoZWNrUmVjdXJzaXZlKGFzc2V0LnNyY0Fzc2V0KTtcbiAgICB9XG4gICAgdmFyIGxvY2FsTmFtZXMgPSBbXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXNzZXQuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICB2YXIgY2hpbGQgPSBhc3NldC5jaGlsZHJlbltpXSwgbmFtZSA9IGNoaWxkLm5hbWU7XG4gICAgICAgIGlmKG5hbWUgJiYgbG9jYWxOYW1lcy5pbmRleE9mKG5hbWUpICE9IC0xKXtcbiAgICAgICAgICAgIHRocm93IG5ldyBBc3NldEVycm9yKFwiVHdvIHN1YmRhdGEgZWxlbWVudHMgd2l0aCB0aGUgc2FtZSBuYW1lOiAnXCIgKyBuYW1lICsgXCInXCIsIGNoaWxkLnJlZk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmKG5hbWUpIGxvY2FsTmFtZXMucHVzaChuYW1lKTtcbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFzc2V0LnN1YkFzc2V0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgIGNoZWNrUmVjdXJzaXZlKGFzc2V0LnN1YkFzc2V0c1tpXSk7XG4gICAgfVxufVxuXG5cbkFzc2V0LnByb3RvdHlwZS5zZXRMb2FkaW5nID0gZnVuY3Rpb24obG9hZGluZyl7XG4gICAgaWYobG9hZGluZyAhPSB0aGlzLmxvYWRpbmcpe1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBsb2FkaW5nO1xuICAgICAgICB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcyk7XG4gICAgICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcblxuICAgIH1cbn07XG5cbkFzc2V0LnByb3RvdHlwZS5pc1N1YnRyZWVMb2FkaW5nID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5wcm9ncmVzc0xldmVsID09IDA7XG59O1xuQXNzZXQucHJvdG90eXBlLmdldFByb2dyZXNzTGV2ZWwgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnByb2dyZXNzTGV2ZWw7XG59O1xuXG5Bc3NldC5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgaW52YWxpZGF0ZUFzc2V0KHRoaXMpO1xufTtcblxuQXNzZXQucHJvdG90eXBlLnNldE1hdGVyaWFsID0gZnVuY3Rpb24obWF0ZXJpYWwpe1xuICAgIHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcbiAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XG59O1xuXG5Bc3NldC5wcm90b3R5cGUuc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24odHJhbnNmb3JtKXtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBpZiAodGhpcy5yZWZOb2RlLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm1vZGVsXCIpIHtcbiAgICAgICAgaW52YWxpZGF0ZUFzc2V0KHRoaXMpO1xuICAgIH1cbn07XG5cbkFzc2V0LnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKXtcbiAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIGNoaWxkLmFzc2V0UGFyZW50ID0gdGhpcztcbiAgICB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcyk7XG4gICAgaW52YWxpZGF0ZUFzc2V0KHRoaXMpO1xuXG59O1xuXG5Bc3NldC5wcm90b3R5cGUuc2V0UGlja0ZpbHRlciA9IGZ1bmN0aW9uKHBpY2tGaWx0ZXJTdHJpbmcpe1xuICAgIGlmKHR5cGVvZiBwaWNrRmlsdGVyU3RyaW5nID09IFwic3RyaW5nXCIpe1xuICAgICAgICB0aGlzLnBpY2tGaWx0ZXIgPSBuZXcgQXNzZXRQaWNrRmlsdGVyKCk7XG4gICAgICAgIHRoaXMucGlja0ZpbHRlci5wYXJzZShwaWNrRmlsdGVyU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICB0aGlzLnBpY2tGaWx0ZXIgPSBudWxsO1xuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcbn07XG5cbkFzc2V0LnByb3RvdHlwZS5hcHBlbmRTdWJBc3NldCA9IGZ1bmN0aW9uKHN1YkFzc2V0KXtcbiAgICBzdWJBc3NldC5fYWRkUGFyZW50KHRoaXMpO1xuICAgIHRoaXMuc3ViQXNzZXRzLnB1c2goc3ViQXNzZXQpO1xuICAgIHVwZGF0ZUxvYWRpbmdTdGF0ZSh0aGlzKTtcbiAgICBpbnZhbGlkYXRlQXNzZXQodGhpcyk7XG5cbn07XG5cbkFzc2V0LnByb3RvdHlwZS5zZXRTcmNBc3NldCA9IGZ1bmN0aW9uKGFzc2V0KXtcbiAgICBpZih0aGlzLnNyY0Fzc2V0KVxuICAgICAgICB0aGlzLnNyY0Fzc2V0Ll9yZW1vdmVQYXJlbnQodGhpcyk7XG5cbiAgICB0aGlzLnNyY0Fzc2V0ID0gYXNzZXQ7XG5cbiAgICBpZih0aGlzLnNyY0Fzc2V0KVxuICAgICAgICB0aGlzLnNyY0Fzc2V0Ll9hZGRQYXJlbnQodGhpcyk7XG4gICAgdXBkYXRlTG9hZGluZ1N0YXRlKHRoaXMpO1xuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcblxufTtcblxuQXNzZXQucHJvdG90eXBlLmNsZWFyQ2hpbGRyZW4gPSBmdW5jdGlvbigpe1xuICAgIHZhciBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUoaS0tKSB0aGlzLmNoaWxkcmVuW2ldLmFzc2V0UGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgdXBkYXRlTG9hZGluZ1N0YXRlKHRoaXMpO1xuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcblxufTtcbkFzc2V0LnByb3RvdHlwZS5jbGVhclN1YkFzc2V0cyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGkgPSB0aGlzLnN1YkFzc2V0cy5sZW5ndGg7XG4gICAgd2hpbGUoaS0tKSB7XG4gICAgICAgIHRoaXMuc3ViQXNzZXRzW2ldLl9yZW1vdmVQYXJlbnQodGhpcyk7XG4gICAgfVxuICAgIHRoaXMuc3ViQXNzZXRzLmxlbmd0aCA9IDA7XG4gICAgdXBkYXRlTG9hZGluZ1N0YXRlKHRoaXMpO1xuICAgIGludmFsaWRhdGVBc3NldCh0aGlzKTtcblxufTtcblxuQXNzZXQucHJvdG90eXBlLl9hZGRQYXJlbnQgPSBmdW5jdGlvbihhc3NldCl7XG4gICAgdGhpcy5wYXJlbnRzLnB1c2goYXNzZXQpO1xufTtcbkFzc2V0LnByb3RvdHlwZS5fcmVtb3ZlUGFyZW50ID0gZnVuY3Rpb24oYXNzZXQpe1xuICAgIHZhciBpZHggPSB0aGlzLnBhcmVudHMuaW5kZXhPZihhc3NldCk7XG4gICAgaWYoaWR4ICE9IC0xKVxuICAgICAgICB0aGlzLnBhcmVudHMuc3BsaWNlKGlkeCwgMSk7XG59O1xuXG5Bc3NldC5wcm90b3R5cGUuX2NhbGxMb2FkTGlzdGVuZXJzID0gZnVuY3Rpb24obmV3TGV2ZWwsIG9sZExldmVsKXtcbiAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgbGlzdGVuZXJzW2ldLm9uQXNzZXRMb2FkQ2hhbmdlICYmIGxpc3RlbmVyc1tpXS5vbkFzc2V0TG9hZENoYW5nZSh0aGlzLCBuZXdMZXZlbCwgb2xkTGV2ZWwpO1xuICAgIH1cbn07XG5cblxuQXNzZXQucHJvdG90eXBlLmFkZENoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpe1xuICAgIFNldC5hZGQodGhpcy5saXN0ZW5lciwgbGlzdGVuZXIpO1xufTtcbkFzc2V0LnByb3RvdHlwZS5yZW1vdmVDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKXtcbiAgICBTZXQucmVtb3ZlKHRoaXMubGlzdGVuZXIsIGxpc3RlbmVyKTtcbn07XG5cbkFzc2V0LnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLmFzc2V0UmVzdWx0KXtcbiAgICAgICAgdGhpcy5hc3NldFJlc3VsdCA9IG5ldyBBc3NldFJlc3VsdCgpO1xuICAgICAgICB0aGlzLmFzc2V0UmVzdWx0LmNvbnN0cnVjdCh0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXNzZXRSZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBpbnZhbGlkYXRlQXNzZXQoYXNzZXQpe1xuICAgIGlmKGFzc2V0LmFzc2V0UmVzdWx0KXtcbiAgICAgICAgYXNzZXQuYXNzZXRSZXN1bHQgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgbGlzdGVuZXJzID0gYXNzZXQubGlzdGVuZXI7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7ICsraSl7XG4gICAgICAgIGxpc3RlbmVyc1tpXS5vbkFzc2V0Q2hhbmdlICYmIGxpc3RlbmVyc1tpXS5vbkFzc2V0Q2hhbmdlKHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IGFzc2V0LnBhcmVudHMubGVuZ3RoO1xuICAgIHdoaWxlKGktLSl7XG4gICAgICAgIGludmFsaWRhdGVBc3NldChhc3NldC5wYXJlbnRzW2ldKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gdXBkYXRlTG9hZGluZ1N0YXRlKGFzc2V0KXtcbiAgICB2YXIgcHJvZ3Jlc3NMZXZlbCA9IGFzc2V0LmxvYWRpbmcgPyBhc3NldC5sb2FkTGV2ZWwgOiBJbmZpbml0eTtcbiAgICBpZihwcm9ncmVzc0xldmVsICYmIGFzc2V0LnNyY0Fzc2V0KXtcbiAgICAgICAgcHJvZ3Jlc3NMZXZlbCA9IE1hdGgubWluKHByb2dyZXNzTGV2ZWwsIE1hdGgubWF4KGFzc2V0LnNyY0Fzc2V0LmxvYWRMZXZlbCwgYXNzZXQuc3JjQXNzZXQucHJvZ3Jlc3NMZXZlbCkpO1xuICAgIH1cbiAgICB2YXIgaSA9IGFzc2V0LnN1YkFzc2V0cy5sZW5ndGg7XG4gICAgd2hpbGUocHJvZ3Jlc3NMZXZlbCAmJiBpLS0pe1xuICAgICAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgTWF0aC5tYXgoYXNzZXQuc3ViQXNzZXRzW2ldLmxvYWRMZXZlbCwgYXNzZXQuc3ViQXNzZXRzW2ldLnByb2dyZXNzTGV2ZWwpKTtcbiAgICB9XG4gICAgdmFyIGkgPSBhc3NldC5jaGlsZHJlbi5sZW5ndGg7XG4gICAgd2hpbGUocHJvZ3Jlc3NMZXZlbCAmJiBpLS0pe1xuICAgICAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgYXNzZXQuY2hpbGRyZW5baV0ucHJvZ3Jlc3NMZXZlbCk7XG4gICAgfVxuICAgIHZhciBvbGRMZXZlbCA9IGFzc2V0LnByb2dyZXNzTGV2ZWw7XG4gICAgYXNzZXQucHJvZ3Jlc3NMZXZlbCA9IHByb2dyZXNzTGV2ZWw7XG5cbiAgICBpZihvbGRMZXZlbCAhPSBhc3NldC5wcm9ncmVzc0xldmVsKXtcbiAgICAgICAgYXNzZXQuX2NhbGxMb2FkTGlzdGVuZXJzKGFzc2V0LnByb2dyZXNzTGV2ZWwsIG9sZExldmVsKTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGFzc2V0LnBhcmVudHMubGVuZ3RoOyArK2kpXG4gICAgICAgICAgICB1cGRhdGVMb2FkaW5nU3RhdGUoYXNzZXQucGFyZW50c1tpXSk7XG4gICAgfVxufVxuXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU3ViRGF0YVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBTdWJEYXRhID0gZnVuY3Rpb24oeGZsb3dOb2RlT3V0LCB4Zmxvd05vZGVJbiwgcmVmTm9kZSl7XG4gICAgdGhpcy54Zmxvd05vZGVPdXQgPSB4Zmxvd05vZGVPdXQ7XG4gICAgdGhpcy54Zmxvd05vZGVJbiA9IHhmbG93Tm9kZUluO1xuICAgIHRoaXMucmVmTm9kZSA9IHJlZk5vZGUgfHwgbnVsbDtcbiAgICB0aGlzLm5hbWUgPSBudWxsO1xuICAgIHRoaXMubWF0Y2hGaWx0ZXIgPSBudWxsO1xuICAgIHRoaXMuY2xhc3NOYW1lcyA9IFtdO1xuICAgIHRoaXMucG9zdERhdGFmbG93ID0gbnVsbDtcbiAgICB0aGlzLnBvc3RDb21wdXRlID0gbnVsbDtcbiAgICB0aGlzLnBvc3RGaWx0ZXIgPSBudWxsO1xuICAgIHRoaXMuaW5jbHVkZXMgPSBbXTtcbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5tZXNoVHlwZSA9IG51bGw7XG4gICAgdGhpcy5hc3NldFBhcmVudCA9IG51bGw7XG4gICAgdGhpcy5sb2FkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5sb2FkTGV2ZWwgPSAwO1xuICAgIHRoaXMucHJvZ3Jlc3NMZXZlbCA9IEluZmluaXR5O1xuICAgIHhmbG93Tm9kZUluLmFkZExvYWRMaXN0ZW5lcih0aGlzLm9uWGZsb3dMb2FkRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fdXBkYXRlTG9hZGluZ1N0YXRlKCk7XG59O1xuXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRMb2FkaW5nID0gZnVuY3Rpb24obG9hZGluZyl7XG4gICAgaWYobG9hZGluZyAhPSB0aGlzLmxvYWRpbmcpe1xuICAgICAgICB0aGlzLmxvYWRpbmcgPSBsb2FkaW5nO1xuICAgICAgICB0aGlzLl91cGRhdGVMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcblxuICAgIH1cbn07XG5cblN1YkRhdGEucHJvdG90eXBlLl91cGRhdGVMb2FkaW5nU3RhdGUgPSBmdW5jdGlvbigpe1xuICAgIHZhciBwcm9ncmVzc0xldmVsID0gdGhpcy5sb2FkaW5nID8gdGhpcy5sb2FkTGV2ZWwgOiBJbmZpbml0eTtcbiAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgdGhpcy54Zmxvd05vZGVJbi5nZXRQcm9ncmVzc0xldmVsKCkpO1xuICAgIHZhciBvbGRMZXZlbCA9IHRoaXMucHJvZ3Jlc3NMZXZlbDtcbiAgICB0aGlzLnByb2dyZXNzTGV2ZWwgPSBwcm9ncmVzc0xldmVsO1xuXG4gICAgaWYob2xkTGV2ZWwgIT0gdGhpcy5wcm9ncmVzc0xldmVsKXtcbiAgICAgICAgdGhpcy5hc3NldFBhcmVudCAmJiB1cGRhdGVMb2FkaW5nU3RhdGUodGhpcy5hc3NldFBhcmVudCk7XG4gICAgICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XG4gICAgfVxufTtcblN1YkRhdGEucHJvdG90eXBlLm9uWGZsb3dMb2FkRXZlbnQgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3VwZGF0ZUxvYWRpbmdTdGF0ZSgpO1xufTtcblxuU3ViRGF0YS5wcm90b3R5cGUuaXNTdWJ0cmVlTG9hZGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMubG9hZGluZztcbn07XG5cblN1YkRhdGEucHJvdG90eXBlLmlzTWVzaCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuICEhdGhpcy5tZXNoVHlwZTtcbn07XG5cblN1YkRhdGEucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbihuYW1lKXtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XG59O1xuXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRNYXRjaEZpbHRlciA9IGZ1bmN0aW9uKG1hdGNoU3RyaW5nKXtcbiAgICBpZih0eXBlb2YgbWF0Y2hTdHJpbmcgPT0gXCJzdHJpbmdcIil7XG4gICAgICAgIHRoaXMubWF0Y2hGaWx0ZXIgPSBuZXcgQXNzZXRQaWNrRmlsdGVyKCk7XG4gICAgICAgIHRoaXMubWF0Y2hGaWx0ZXIucGFyc2UobWF0Y2hTdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIHRoaXMubWF0Y2hGaWx0ZXIgPSBudWxsO1xuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XG59O1xuXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRDbGFzc05hbWVzID0gZnVuY3Rpb24oY2xhc3NOYW1lcyl7XG4gICAgdGhpcy5jbGFzc05hbWVzID0gY2xhc3NOYW1lcztcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xufTtcblN1YkRhdGEucHJvdG90eXBlLnNldENsYXNzTmFtZXNTdHJpbmcgPSBmdW5jdGlvbihjbGFzc05hbWVzU3RyaW5nKXtcbiAgICBpZighY2xhc3NOYW1lc1N0cmluZylcbiAgICAgICAgdGhpcy5zZXRDbGFzc05hbWVzKFtdKTtcbiAgICBlbHNle1xuICAgICAgICB2YXIgYXJyYXkgPSBjbGFzc05hbWVzU3RyaW5nLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHZhciBpID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB3aGlsZShpLS0pIGFycmF5W2ldID0gYXJyYXlbaV0udHJpbSgpO1xuICAgICAgICB0aGlzLnNldENsYXNzTmFtZXMoYXJyYXkpO1xuICAgIH1cbn07XG5cblxuU3ViRGF0YS5wcm90b3R5cGUuc2V0UG9zdERhdGFmbG93ID0gZnVuY3Rpb24ocG9zdERhdGFmbG93KXtcbiAgICB0aGlzLnBvc3REYXRhZmxvdyA9IHBvc3REYXRhZmxvdztcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xufTtcblxuU3ViRGF0YS5wcm90b3R5cGUuc2V0UG9zdENvbXB1dGUgPSBmdW5jdGlvbihwb3N0Q29tcHV0ZSl7XG4gICAgdGhpcy5wb3N0Q29tcHV0ZSA9IHBvc3RDb21wdXRlO1xuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XG59O1xuXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRQb3N0RmlsdGVyID0gZnVuY3Rpb24ocG9zdEZpbHRlcil7XG4gICAgdGhpcy5wb3N0RmlsdGVyID0gcG9zdEZpbHRlcjtcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xufTtcblxuU3ViRGF0YS5wcm90b3R5cGUuc2V0SW5jbHVkZXMgPSBmdW5jdGlvbihpbmNsdWRlcyl7XG4gICAgdGhpcy5pbmNsdWRlcyA9IGluY2x1ZGVzO1xuICAgIGludmFsaWRhdGVQYXJlbnQodGhpcyk7XG59O1xuXG5TdWJEYXRhLnByb3RvdHlwZS5zZXRNYXRlcmlhbCA9IGZ1bmN0aW9uKG1hdGVyaWFsKXtcbiAgICB0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcbn07XG5cblN1YkRhdGEucHJvdG90eXBlLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uKHRyYW5zZm9ybSl7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgaW52YWxpZGF0ZVBhcmVudCh0aGlzKTtcbn07XG5cblN1YkRhdGEucHJvdG90eXBlLnNldE1lc2hUeXBlID0gZnVuY3Rpb24obWVzaFR5cGUpe1xuICAgIHRoaXMubWVzaFR5cGUgPSBtZXNoVHlwZTtcbiAgICBpbnZhbGlkYXRlUGFyZW50KHRoaXMpO1xufTtcblxuZnVuY3Rpb24gaW52YWxpZGF0ZVBhcmVudChzdWJEYXRhKXtcbiAgICBpZihzdWJEYXRhLmFzc2V0UGFyZW50KXtcbiAgICAgICAgaW52YWxpZGF0ZUFzc2V0KHN1YkRhdGEuYXNzZXRQYXJlbnQpO1xuICAgIH1cbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBc3NldFJlc3VsdFxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBBc3NldFJlc3VsdCA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5wYXJlbnRSZXN1bHQgPSBudWxsO1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5uYW1lZEVudHJpZXMgPSB7fTtcbiAgICB0aGlzLmFsbEVudHJpZXMgPSBbXTtcbiAgICB0aGlzLm1hdGNoRW50cmllcyA9IFtdO1xuICAgIHRoaXMubmFtZWRTdWJSZXN1bHRzID0ge307XG4gICAgdGhpcy5hbGxTdWJSZXN1bHRzID0gW107XG5cbiAgICB0aGlzLm1hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG51bGw7XG4gICAgdGhpcy5waWNrRmlsdGVyID0gbnVsbDtcbn07XG5cbkFzc2V0UmVzdWx0LnByb3RvdHlwZS5jb25zdHJ1Y3QgPSBmdW5jdGlvbihhc3NldCl7XG4gICAgY29uc3RydWN0QXNzZXRUYWJsZSh0aGlzLCBhc3NldCk7XG59O1xuXG5Bc3NldFJlc3VsdC5wcm90b3R5cGUuZ2V0RGF0YVRyZWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiByZWNfZ2V0RGF0YVRyZWUodGhpcyk7XG59O1xuXG5cbmZ1bmN0aW9uIGNvbnN0cnVjdEFzc2V0VGFibGUodGFibGUsIGFzc2V0KXtcbiAgICB0YWJsZS5uYW1lID0gYXNzZXQubmFtZTtcblxuICAgIHZhciBzcmNBc3NldCA9IGFzc2V0LnNyY0Fzc2V0LCBzcmNSZXN1bHQgPSBzcmNBc3NldCAmJiBzcmNBc3NldC5nZXRSZXN1bHQoKTtcbiAgICBpZihzcmNSZXN1bHQpe1xuICAgICAgICBjb3B5U3JjVGFibGUodGFibGUsIHNyY0Fzc2V0LmdldFJlc3VsdCgpLCBhc3NldC5waWNrRmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICB0YWJsZS5waWNrRmlsdGVyID0gYXNzZXQucGlja0ZpbHRlcjtcblxuICAgIGlmKGFzc2V0Lm1hdGVyaWFsKSB0YWJsZS5tYXRlcmlhbCA9IGFzc2V0Lm1hdGVyaWFsO1xuICAgIGlmKGFzc2V0LnRyYW5zZm9ybSkgdGFibGUudHJhbnNmb3JtID0gY29tYmluZVRyYW5zZm9ybSh0YWJsZS50cmFuc2Zvcm0sIGFzc2V0LnRyYW5zZm9ybSk7XG5cblxuICAgIHZhciBzdWJBc3NldHMgPSBhc3NldC5zdWJBc3NldHM7XG4gICAgdmFyIGkgPSBzdWJBc3NldHMubGVuZ3RoO1xuICAgIHdoaWxlKGktLSl7XG4gICAgICAgIHZhciByZXN1bHQgPSBzdWJBc3NldHNbaV0uZ2V0UmVzdWx0KCk7XG4gICAgICAgIG1lcmdlU3ViQXNzZXRSZXN1bHQodGFibGUsIHJlc3VsdCk7XG4gICAgfVxuICAgIHZhciBtYXRjaENoaWxkcmVuID0gW107XG4gICAgdmFyIGNoaWxkcmVuID0gYXNzZXQuY2hpbGRyZW47XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIHZhciBuYW1lID0gY2hpbGQubmFtZTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICBpZihjaGlsZC5uYW1lICYmIGNoaWxkLm1hdGNoRmlsdGVyKXtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJBc3NldCBlbnRyeSBkZWZpbmVzIGJvdGggbmFtZSBhbmQgbWF0Y2ggYXR0cmlidXRlLiBNYXRjaCBhdHRyaWJ1dGUgd2lsbCBiZSBpZ25vcmVkXCIsIGNoaWxkLnJlZk5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmKG5hbWUpe1xuICAgICAgICAgICAgaWYoIXRhYmxlLm5hbWVkRW50cmllc1tuYW1lXSl7XG4gICAgICAgICAgICAgICAgZW50cnkgPSBuZXcgQXNzZXRUYWJsZUVudHJ5KGNoaWxkKTtcbiAgICAgICAgICAgICAgICBhcHBseU1hdGNoRW50cmllcyhlbnRyeSwgdGFibGUubWF0Y2hFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICB0YWJsZS5uYW1lZEVudHJpZXNbbmFtZV0gPSBlbnRyeTtcbiAgICAgICAgICAgICAgICB0YWJsZS5hbGxFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVudHJ5ID0gdGFibGUubmFtZWRFbnRyaWVzW25hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoY2hpbGQubWF0Y2hGaWx0ZXIpe1xuICAgICAgICAgICAgbWF0Y2hDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBlbnRyeSA9IG5ldyBBc3NldFRhYmxlRW50cnkoY2hpbGQpO1xuICAgICAgICAgICAgYXBwbHlNYXRjaEVudHJpZXMoZW50cnksIHRhYmxlLm1hdGNoRW50cmllcyk7XG4gICAgICAgICAgICB0YWJsZS5hbGxFbnRyaWVzLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5LnB1c2hQb3N0RW50cnkoY2hpbGQpO1xuICAgIH1cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbWF0Y2hDaGlsZHJlbi5sZW5ndGg7ICsraSl7XG4gICAgICAgIHZhciBjaGlsZCA9IG1hdGNoQ2hpbGRyZW5baV07XG4gICAgICAgIHZhciBtYXRjaEVudHJ5ID0ge2ZpbHRlcjogY2hpbGQubWF0Y2hGaWx0ZXIsIHN1YmRhdGE6IGNoaWxkfTtcbiAgICAgICAgdGFibGUubWF0Y2hFbnRyaWVzLnB1c2gobWF0Y2hFbnRyeSk7XG4gICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCB0YWJsZS5hbGxFbnRyaWVzLmxlbmd0aDsgKytqKXtcbiAgICAgICAgICAgIGFwcGx5TWF0Y2hFbnRyeSh0YWJsZS5hbGxFbnRyaWVzW2pdLCBtYXRjaEVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlNYXRjaEVudHJpZXMoZGVzdEVudHJ5LCBtYXRjaEVudHJpZXMpe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXRjaEVudHJpZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICBhcHBseU1hdGNoRW50cnkoZGVzdEVudHJ5LCBtYXRjaEVudHJpZXNbaV0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXBwbHlNYXRjaEVudHJ5KGRlc3RFbnRyeSwgbWF0Y2hFbnRyeSl7XG4gICAgdmFyIGNoaWxkID0gbWF0Y2hFbnRyeS5zdWJkYXRhO1xuICAgIGlmKGNoaWxkLmlzTWVzaCgpID09IGRlc3RFbnRyeS5pc01lc2goKSAmJiBtYXRjaEVudHJ5LmZpbHRlci5jaGVjayhkZXN0RW50cnkpKXtcbiAgICAgICAgZGVzdEVudHJ5LnB1c2hQb3N0RW50cnkoY2hpbGQpO1xuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBjb3B5U3JjVGFibGUodGFibGUsIHNyY1RhYmxlLCBwaWNrRmlsdGVyKXtcblxuICAgIGlmKHNyY1RhYmxlLm1hdGNoRW50cmllcy5sZW5ndGggPiAwKXtcbiAgICAgICAgdmFyIGkgPSB0YWJsZS5hbGxFbnRyaWVzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUoaS0tKXtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRhYmxlLmFsbEVudHJpZXNbaV07XG4gICAgICAgICAgICBpZighZW50cnkubmFtZSB8fCAhc3JjVGFibGUubmFtZWRFbnRyaWVzW2VudHJ5Lm5hbWVdKXtcbiAgICAgICAgICAgICAgICBhcHBseU1hdGNoRW50cmllcyhlbnRyeSwgc3JjVGFibGUubWF0Y2hFbnRyaWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpID0gc3JjVGFibGUuYWxsRW50cmllcy5sZW5ndGg7XG4gICAgd2hpbGUoaS0tKXtcbiAgICAgICAgdmFyIHNyY0VudHJ5ID0gc3JjVGFibGUuYWxsRW50cmllc1tpXTtcbiAgICAgICAgdmFyIGRlc3RFbnRyeSwgbmV3bHlDcmVhdGVkID0gZmFsc2U7XG4gICAgICAgIGlmKHNyY0VudHJ5Lm5hbWUgJiYgdGFibGUubmFtZWRFbnRyaWVzW3NyY0VudHJ5Lm5hbWVdKXtcbiAgICAgICAgICAgIGRlc3RFbnRyeSA9IHRhYmxlLm5hbWVkRW50cmllc1tzcmNFbnRyeS5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgZGVzdEVudHJ5ID0gbmV3IEFzc2V0VGFibGVFbnRyeSgpO1xuICAgICAgICAgICAgbmV3bHlDcmVhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRhYmxlLmFsbEVudHJpZXMucHVzaChkZXN0RW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGRlc3RFbnRyeS5wdXNoVGFibGVFbnRyeShzcmNFbnRyeSk7XG4gICAgICAgIGlmKG5ld2x5Q3JlYXRlZClcbiAgICAgICAgICAgIGFwcGx5TWF0Y2hFbnRyaWVzKGRlc3RFbnRyeSwgdGFibGUubWF0Y2hFbnRyaWVzKTtcblxuICAgICAgICBpZihkZXN0RW50cnkubmFtZSkgdGFibGUubmFtZWRFbnRyaWVzW2Rlc3RFbnRyeS5uYW1lXSA9IGRlc3RFbnRyeTtcbiAgICB9XG5cbiAgICB0YWJsZS5tYXRjaEVudHJpZXMucHVzaC5hcHBseSh0YWJsZS5tYXRjaEVudHJpZXMsIHNyY1RhYmxlLm1hdGNoRW50cmllcyk7XG5cblxuICAgIHZhciBpID0gc3JjVGFibGUuYWxsU3ViUmVzdWx0cy5sZW5ndGg7XG4gICAgd2hpbGUoaS0tKXtcbiAgICAgICAgbWVyZ2VTdWJBc3NldFJlc3VsdCh0YWJsZSwgc3JjVGFibGUuYWxsU3ViUmVzdWx0c1tpXSk7XG4gICAgfVxuXG4gICAgaWYocGlja0ZpbHRlciAmJiBzcmNUYWJsZS5waWNrRmlsdGVyKXtcbiAgICAgICAgdGFibGUucGlja0ZpbHRlciA9IG5ldyBBc3NldFBpY2tGaWx0ZXIoKTtcbiAgICAgICAgdGFibGUucGlja0ZpbHRlci5pbnRlcnNlY3Rpb24ocGlja0ZpbHRlciwgc3JjVGFibGUucGlja0ZpbHRlcik7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIHRhYmxlLnBpY2tGaWx0ZXIgPSBwaWNrRmlsdGVyIHx8IHNyY1RhYmxlLnBpY2tGaWx0ZXI7XG4gICAgfVxuICAgIGlmKHNyY1RhYmxlLm1hdGVyaWFsKSB0YWJsZS5tYXRlcmlhbCA9IHNyY1RhYmxlLm1hdGVyaWFsO1xuICAgIGlmKHNyY1RhYmxlLnRyYW5zZm9ybSkgdGFibGUudHJhbnNmb3JtID0gY29tYmluZVRyYW5zZm9ybSh0YWJsZS50cmFuc2Zvcm0sIHNyY1RhYmxlLnRyYW5zZm9ybSk7XG59XG5cblxuZnVuY3Rpb24gbWVyZ2VTdWJBc3NldFJlc3VsdCh0YWJsZSwgc3JjU3ViVGFibGUpe1xuICAgIHZhciBkZXN0U3ViVGFibGU7XG4gICAgaWYoc3JjU3ViVGFibGUubmFtZSAmJiB0YWJsZS5uYW1lZFN1YlJlc3VsdHNbc3JjU3ViVGFibGUubmFtZV0pe1xuICAgICAgICBkZXN0U3ViVGFibGUgPSB0YWJsZS5uYW1lZFN1YlJlc3VsdHNbc3JjU3ViVGFibGUubmFtZV07XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIGRlc3RTdWJUYWJsZSA9IG5ldyBBc3NldFJlc3VsdCgpO1xuICAgICAgICBkZXN0U3ViVGFibGUucGFyZW50UmVzdWx0ID0gdGFibGU7XG4gICAgICAgIGRlc3RTdWJUYWJsZS5uYW1lID0gc3JjU3ViVGFibGUubmFtZTtcbiAgICAgICAgdGFibGUuYWxsU3ViUmVzdWx0cy5wdXNoKGRlc3RTdWJUYWJsZSk7XG4gICAgICAgIGlmKGRlc3RTdWJUYWJsZS5uYW1lKSB0YWJsZS5uYW1lZFN1YlJlc3VsdHNbZGVzdFN1YlRhYmxlLm5hbWVdID0gZGVzdFN1YlRhYmxlO1xuICAgIH1cbiAgICBjb3B5U3JjVGFibGUoZGVzdFN1YlRhYmxlLCBzcmNTdWJUYWJsZSwgZGVzdFN1YlRhYmxlLnBpY2tGaWx0ZXIpO1xufVxuXG5mdW5jdGlvbiByZWNfZ2V0RGF0YVRyZWUodGFibGUpe1xuICAgIHZhciBub2RlID0ge1xuICAgICAgICBtZXNoZXM6IFtdLFxuICAgICAgICBncm91cHM6IFtdLFxuICAgICAgICB0cmFuc2Zvcm06IHRhYmxlLnRyYW5zZm9ybSxcbiAgICAgICAgbWF0ZXJpYWw6IHRhYmxlLm1hdGVyaWFsLFxuICAgICAgICBwb3N0VHJhbnNmb3JtWGZsb3dOb2RlOiBudWxsXG4gICAgfTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0YWJsZS5hbGxFbnRyaWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGFibGUuYWxsRW50cmllc1tpXTtcbiAgICAgICAgaWYoZW50cnkubWVzaFR5cGUgJiYgKCF0YWJsZS5waWNrRmlsdGVyIHx8IHRhYmxlLnBpY2tGaWx0ZXIuY2hlY2soZW50cnkpKSApe1xuICAgICAgICAgICAgdXBkYXRlQWNjdW11bGF0ZWROb2RlKHRhYmxlLCBlbnRyeSk7XG4gICAgICAgICAgICBub2RlLm1lc2hlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4Zmxvd05vZGU6IGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlLFxuICAgICAgICAgICAgICAgIHR5cGU6IGVudHJ5Lm1lc2hUeXBlLFxuICAgICAgICAgICAgICAgIG1hdGVyaWFsOiBlbnRyeS5tYXRlcmlhbCxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGVudHJ5LnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICByZWZOb2RlOiBlbnRyeS5yZWZOb2RlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgcG9zdFRyYW5zZm9ybUVudHJ5ID0gdGFibGUubmFtZWRFbnRyaWVzW1wiX3Bvc3RUcmFuc2Zvcm1cIl07XG4gICAgaWYocG9zdFRyYW5zZm9ybUVudHJ5KXtcbiAgICAgICAgdXBkYXRlQWNjdW11bGF0ZWROb2RlKHRhYmxlLCBwb3N0VHJhbnNmb3JtRW50cnkpO1xuICAgICAgICBub2RlLnBvc3RUcmFuc2Zvcm1YZmxvd05vZGUgPSBwb3N0VHJhbnNmb3JtRW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGU7XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0YWJsZS5hbGxTdWJSZXN1bHRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIHN1Yk5vZGUgPSByZWNfZ2V0RGF0YVRyZWUodGFibGUuYWxsU3ViUmVzdWx0c1tpXSk7XG4gICAgICAgIG5vZGUuZ3JvdXBzLnB1c2goc3ViTm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVBY2N1bXVsYXRlZE5vZGUodGFibGUsIGVudHJ5KXtcbiAgICBpZighZW50cnkub3V0T2ZTeW5jKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZihlbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZSl7XG4gICAgICAgIGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlLmNsZWFyQ2hpbGRyZW4oKTtcbiAgICAgICAgZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUuc2V0Q29tcHV0ZShcIlwiKTtcbiAgICAgICAgZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUuc2V0RmlsdGVyKFwiXCIpO1xuICAgICAgICBlbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZS5kYXRhZmxvd05vZGUgPSBudWxsO1xuICAgICAgICBlbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZS5zZXRMb2FkaW5nKGZhbHNlKTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgZW50cnkuYWNjdW11bGF0ZWRYZmxvd05vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBkYXRhTm9kZSA9IGVudHJ5LnBvc3RRdWV1ZS5sZW5ndGggPT0gMSA/IGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlIDogbmV3IERhdGFOb2RlKGZhbHNlKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cnkucG9zdFF1ZXVlLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIGluY2x1ZGVzID0gZW50cnkucG9zdFF1ZXVlW2ldLmluY2x1ZGVzO1xuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgaW5jbHVkZXMubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgdmFyIGFkZEVudHJ5ID0gZ2V0SW5jbHVkZUVudHJ5KHRhYmxlLCBpbmNsdWRlc1tqXSk7XG4gICAgICAgICAgICBkYXRhTm9kZS5hcHBlbmRDaGlsZChhZGRFbnRyeS5hY2N1bXVsYXRlZFhmbG93Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYoZW50cnkucG9zdFF1ZXVlW2ldLnhmbG93Tm9kZSlcbiAgICAgICAgICAgIGRhdGFOb2RlLmFwcGVuZENoaWxkKGVudHJ5LnBvc3RRdWV1ZVtpXS54Zmxvd05vZGUpO1xuICAgIH1cbiAgICB2YXIgbm9kZSA9IGRhdGFOb2RlLCBwYXJlbnROb2RlID0gbnVsbDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cnkucG9zdFF1ZXVlLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIHBvc3RFbnRyeSA9IGVudHJ5LnBvc3RRdWV1ZVtpXTtcbiAgICAgICAgaWYoIW5vZGUpIG5vZGUgPSAoaSA9PSBlbnRyeS5wb3N0UXVldWUubGVuZ3RoIC0gMSA/IGVudHJ5LmFjY3VtdWxhdGVkWGZsb3dOb2RlIDogbmV3IERhdGFOb2RlKGZhbHNlKSk7XG4gICAgICAgIG5vZGUuc2V0Q29tcHV0ZShwb3N0RW50cnkuY29tcHV0ZSk7XG4gICAgICAgIG5vZGUuc2V0RmlsdGVyKHBvc3RFbnRyeS5maWx0ZXIpO1xuICAgICAgICBub2RlLmRhdGFmbG93Tm9kZSA9IHBvc3RFbnRyeS5kYXRhZmxvdztcbiAgICAgICAgbm9kZS5zZXRMb2FkaW5nKHBvc3RFbnRyeS5kYXRhZmxvd0xvYWRpbmcpO1xuICAgICAgICBpZihwYXJlbnROb2RlKSBub2RlLmFwcGVuZENoaWxkKHBhcmVudE5vZGUpO1xuICAgICAgICBwYXJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgfVxuICAgIGVudHJ5Lm91dE9mU3luYyA9IGZhbHNlO1xufVxuXG5cbnZhciBjX2FjY3VtX2VudHJpZXMgPSBbXSxcbiAgICBjX2FjY3VtX25hbWVzID0gW107XG5cbmZ1bmN0aW9uIGdldEluY2x1ZGVFbnRyeSh0YWJsZSwgaW5jbHVkZVN0cmluZyl7XG4gICAgdmFyIHNlZ21lbnRzID0gaW5jbHVkZVN0cmluZy5zcGxpdChcIi5cIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aCAtMTsgKytpKXtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBpZihzZWcgPT0gXCJwYXJlbnRcIil7XG4gICAgICAgICAgICBpZighdGFibGUucGFyZW50UmVzdWx0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY2x1ZGVzIGVudHJ5ICdcIiArIGluY2x1ZGVTdHJpbmcgKyBcIicgKHRva2VuIFwiKyBpICtcIikgYWNjZXNzZXMgbm9uIGV4aXN0ZW50IHBhcmVudC5cIik7XG4gICAgICAgICAgICB0YWJsZSA9IHRhYmxlLnBhcmVudFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgaWYoIXRhYmxlLm5hbWVkU3ViUmVzdWx0c1tzZWddKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY2x1ZGVzIGVudHJ5ICdcIiArIGluY2x1ZGVTdHJpbmcgKyBcIicgKHRva2VuIFwiKyBpICtcIikgYWNjZXNzZXMgbm9uIGV4aXN0ZW50IHN1YiByZXN1bHQgJ1wiICsgc2VnICsgXCInXCIpO1xuICAgICAgICAgICAgdGFibGUgPSB0YWJsZS5uYW1lZFN1YlJlc3VsdHNbc2VnXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgZW50cnlLZXkgPSBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcbiAgICB2YXIgZW50cnkgPSB0YWJsZS5uYW1lZEVudHJpZXNbZW50cnlLZXldO1xuICAgIGlmKCFlbnRyeSl7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY2x1ZGVzIGVudHJ5ICdcIiArIGluY2x1ZGVTdHJpbmcgKyBcIicgYWNjZXNzZXMgbm9uIGV4aXN0ZW50IGFzc2V0IGVudHJ5ICdcIiArIGVudHJ5S2V5ICsgXCInXCIgKTtcbiAgICB9XG5cbiAgICBjX2FjY3VtX25hbWVzLnB1c2goaW5jbHVkZVN0cmluZyk7XG4gICAgaWYoY19hY2N1bV9lbnRyaWVzLmluZGV4T2YoZW50cnkpICE9IC0xKXtcbiAgICAgICAgdmFyIHBhdGggPSBjX2FjY3VtX25hbWVzLmpvaW4oXCIgPiBcIik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlY3Vyc2l2ZSBpbmNsdWRlIGRlcGVuZGVuY2llcyBkZXRlY3RlZDogXCIgKyBwYXRoKTtcbiAgICB9XG4gICAgY19hY2N1bV9lbnRyaWVzLnB1c2goZW50cnkpO1xuXG4gICAgdXBkYXRlQWNjdW11bGF0ZWROb2RlKHRhYmxlLCBlbnRyeSk7XG4gICAgY19hY2N1bV9lbnRyaWVzLnBvcCgpO1xuICAgIGNfYWNjdW1fbmFtZXMucG9wKCk7XG4gICAgcmV0dXJuIGVudHJ5O1xufVxuXG5cblxuXG5mdW5jdGlvbiBBc3NldFRhYmxlRW50cnkgKHN1YkRhdGEpe1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5jbGFzc05hbWVzID0gW107XG4gICAgdGhpcy5tZXNoVHlwZSA9IG51bGw7XG5cbiAgICB0aGlzLnBvc3RRdWV1ZSA9IFtdO1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuICAgIHRoaXMudHJhbnNmb3JtID0gbnVsbDtcblxuICAgIHRoaXMuYWNjdW11bGF0ZWRYZmxvd05vZGUgPSBudWxsO1xuICAgIHRoaXMub3V0T2ZTeW5jID0gdHJ1ZTtcbiAgICB0aGlzLnJlZk5vZGUgPSBudWxsO1xuICAgIGlmKHN1YkRhdGEpe1xuICAgICAgICB0aGlzLm5hbWUgPSBzdWJEYXRhLm5hbWU7XG4gICAgICAgIFNldC5hZGQodGhpcy5jbGFzc05hbWVzLCBzdWJEYXRhLmNsYXNzTmFtZXMpO1xuICAgIH1cbn1cblxuQXNzZXRUYWJsZUVudHJ5LnByb3RvdHlwZS5pc01lc2ggPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAhIXRoaXMubWVzaFR5cGU7XG59O1xuXG5Bc3NldFRhYmxlRW50cnkucHJvdG90eXBlLnB1c2hUYWJsZUVudHJ5ID0gZnVuY3Rpb24oc3JjRW50cnkpe1xuICAgIHRoaXMubmFtZSA9IHNyY0VudHJ5Lm5hbWU7XG4gICAgU2V0LmFkZCh0aGlzLmNsYXNzTmFtZXMsIHNyY0VudHJ5LmNsYXNzTmFtZXMpO1xuICAgIGlmKHNyY0VudHJ5Lm1lc2hUeXBlKSB0aGlzLm1lc2hUeXBlID0gc3JjRW50cnkubWVzaFR5cGU7XG5cbiAgICBpZihzcmNFbnRyeS50cmFuc2Zvcm0pIHRoaXMudHJhbnNmb3JtID0gY29tYmluZVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSwgc3JjRW50cnkudHJhbnNmb3JtKTtcbiAgICBpZihzcmNFbnRyeS5tYXRlcmlhbCkgdGhpcy5tYXRlcmlhbCA9IHNyY0VudHJ5Lm1hdGVyaWFsO1xuXG4gICAgdGhpcy5wb3N0UXVldWUucHVzaC5hcHBseSh0aGlzLnBvc3RRdWV1ZSwgc3JjRW50cnkucG9zdFF1ZXVlKTtcbn07XG5cblxuQXNzZXRUYWJsZUVudHJ5LnByb3RvdHlwZS5wdXNoUG9zdEVudHJ5ID0gZnVuY3Rpb24oc3ViRGF0YSl7XG4gICAgdGhpcy5uYW1lID0gc3ViRGF0YS5uYW1lO1xuICAgIHRoaXMucG9zdFF1ZXVlLnB1c2goe1xuICAgICAgICBkYXRhZmxvdzogc3ViRGF0YS5wb3N0RGF0YWZsb3csXG4gICAgICAgIGRhdGFmbG93TG9hZGluZzogc3ViRGF0YS5sb2FkaW5nLFxuICAgICAgICBjb21wdXRlOiBzdWJEYXRhLnBvc3RDb21wdXRlLFxuICAgICAgICBmaWx0ZXI6IHN1YkRhdGEucG9zdEZpbHRlcixcbiAgICAgICAgaW5jbHVkZXM6IHN1YkRhdGEuaW5jbHVkZXMsXG4gICAgICAgIHhmbG93Tm9kZTogc3ViRGF0YS54Zmxvd05vZGVJblxuICAgIH0pO1xuICAgIHRoaXMucmVmTm9kZSA9IHN1YkRhdGEucmVmTm9kZTtcbiAgICB0aGlzLmFjY3VtdWxhdGVkWGZsb3dOb2RlID0gc3ViRGF0YS54Zmxvd05vZGVPdXQ7XG4gICAgU2V0LmFkZCh0aGlzLmNsYXNzTmFtZXMsIHN1YkRhdGEuY2xhc3NOYW1lcyk7XG4gICAgaWYoc3ViRGF0YS5tZXNoVHlwZSkgdGhpcy5tZXNoVHlwZSA9IHN1YkRhdGEubWVzaFR5cGU7XG4gICAgaWYoc3ViRGF0YS5tYXRlcmlhbCkgdGhpcy5tYXRlcmlhbCA9IHN1YkRhdGEubWF0ZXJpYWw7XG4gICAgaWYoc3ViRGF0YS50cmFuc2Zvcm0pIHRoaXMudHJhbnNmb3JtID0gY29tYmluZVRyYW5zZm9ybSh0aGlzLnRyYW5zZm9ybSwgc3ViRGF0YS50cmFuc2Zvcm0pO1xufTtcblxuXG5mdW5jdGlvbiBjb21iaW5lVHJhbnNmb3JtKG9sZFRyYW5zZm9ybSwgbmV3VHJhbnNmb3JtKXtcbiAgICAvLyBUT0RPOiBCZXR0ZXIgbXVsdGlwbHkgdHJhbnNmb3JtYXRpb25zIGhlcmVcbiAgICByZXR1cm4gbmV3VHJhbnNmb3JtO1xufVxuXG5cbmZ1bmN0aW9uIEFzc2V0UGlja0ZpbHRlcigpe1xuICAgIHRoaXMuYWxsID0gZmFsc2U7XG4gICAgdGhpcy5uYW1lcyA9IFtdO1xuICAgIHRoaXMuY2xhc3NOYW1lcyA9IFtdO1xufVxuXG5Bc3NldFBpY2tGaWx0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyaW5nKXtcbiAgICB2YXIgZW50cmllcyA9IHN0cmluZy5zcGxpdChcIixcIik7XG4gICAgdmFyIGkgPSBlbnRyaWVzLmxlbmd0aDtcbiAgICB3aGlsZShpLS0pe1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2ldLnRyaW0oKTtcbiAgICAgICAgaWYoZW50cnkgPT0gXCIqXCIpe1xuICAgICAgICAgICAgdGhpcy5hbGwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYoZW50cnkuaW5kZXhPZihcIi5cIikgPT0gMCl7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGVudHJ5LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIHZhciBqID0gY2xhc3NOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZShqLS0pe1xuICAgICAgICAgICAgICAgIGlmKCFjbGFzc05hbWVzW2pdLnRyaW0oKSlcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lcy5zcGxpY2UoaiwxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lcy5wdXNoKGNsYXNzTmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBTZXQuYWRkKHRoaXMubmFtZXMsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkFzc2V0UGlja0ZpbHRlci5wcm90b3R5cGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oc2V0QSwgc2V0Qil7XG4gICAgU2V0LmludGVyc2VjdGlvbih0aGlzLm5hbWVzLCBzZXRBLm5hbWVzLCBzZXRCLm5hbWVzKTtcbiAgICBTZXQuaW50ZXJzZWN0aW9uKHRoaXMuY2xhc3NOYW1lcywgc2V0QS5jbGFzc05hbWVzLCBzZXRCLmNsYXNzTmFtZXMpO1xufTtcblxuQXNzZXRQaWNrRmlsdGVyLnByb3RvdHlwZS5jaGVjayA9IGZ1bmN0aW9uKGVudHJ5KXtcbiAgICBpZih0aGlzLmFsbClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYoZW50cnkuY2xhc3NOYW1lcy5sZW5ndGggPiAwKXtcbiAgICAgICAgdmFyIGkgPSB0aGlzLmNsYXNzTmFtZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAgICAgaWYoU2V0LmlzU3Vic2V0KHRoaXMuY2xhc3NOYW1lc1tpXSwgZW50cnkuY2xhc3NOYW1lcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIChlbnRyeS5uYW1lICYmIHRoaXMubmFtZXMuaW5kZXhPZihlbnRyeS5uYW1lKSAhPSAtMSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBc3NldDogQXNzZXQsXG4gICAgU3ViRGF0YTogU3ViRGF0YSxcbiAgICBBc3NldFJlc3VsdDogQXNzZXRSZXN1bHRcbn07XG4iLCJ2YXIgcmVnaXN0ZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4vcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLnJlZ2lzdGVyRmFjdG9yeTtcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcbnZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2VsZW1lbnRzLmpzXCIpLmNvbmZpZztcblxuLyoqXG4gKiBBIG5vcm1hbCBhZGFwdGVyIHRoYXQgZG9lc24ndCBuZWVkIHRvIGJlIGNvbm5lY3RlZCB0byBhIERPTSBub2RlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7WE1MM0QuYmFzZS5BZGFwdGVyRmFjdG9yeX0gZmFjdG9yeSAtIHRoZSBmYWN0b3J5IHRoaXMgYWRhcHRlciB3YXMgY3JlYXRlZCBmcm9tXG4gKi9cbnZhciBBZGFwdGVyID0gZnVuY3Rpb24oZmFjdG9yeSkge1xuICAgIHRoaXMuZmFjdG9yeSA9IGZhY3Rvcnk7XG59O1xuXG4vKipcbiAqIENvbm5lY3QgYW4gYWRhcHRlckhhbmRsZSB0byBhIGNlcnRhaW4ga2V5LlxuICogVGhpcyB3aWxsIGVuYWJsZSB0aGUgQ29ubmVjdGVkQWRhcHRlck5vdGlmY2F0aW9ucyBmb3Igbm90aWZ5Q2hhbmdlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSB0aGUga2V5IHRoYXQgd2lsbCBhbHNvIGJlIHByb3ZpZGVkIGluIGNvbm5lY3RBZGFwdGVyQ2hhbmdlZCBjYWxsYmFja1xuICogQHBhcmFtIHtYTUwzRC5iYXNlLkFkYXB0ZXJIYW5kbGV9IGFkYXB0ZXJIYW5kbGUgaGFuZGxlIG9mIGFkYXB0ZXIgdG8gYmUgYWRkZWRcbiAqL1xuQWRhcHRlci5wcm90b3R5cGUuY29ubmVjdEFkYXB0ZXJIYW5kbGUgPSBmdW5jdGlvbihrZXksIGFkYXB0ZXJIYW5kbGUpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXMpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcyA9IHt9O1xuICAgICAgICB0aGlzLl9iaW5kZWRBZGFwdGVySGFuZGxlQ2FsbGJhY2sgPSBhZGFwdGVySGFuZGxlQ2FsbGJhY2suYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc2Nvbm5lY3RBZGFwdGVySGFuZGxlKGtleSk7XG5cbiAgICBpZiAoYWRhcHRlckhhbmRsZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2tleV0gPSBhZGFwdGVySGFuZGxlO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2tleV0uYWRkTGlzdGVuZXIodGhpcy5fYmluZGVkQWRhcHRlckhhbmRsZUNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBkZWxldGUgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1trZXldO1xuXG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBhZGFwdGVyIGhhbmRsZSBmcm9tIHRoZSBnaXZlbiBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gdGhlIGtleSB0aGF0IHdhcyBwcm92aWRlZCB3aGVuIHRoaXMgYWRhcHRlciBoYW5kbGUgd2FzIGNvbm5lY3RlZFxuICovXG5BZGFwdGVyLnByb3RvdHlwZS5kaXNjb25uZWN0QWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICh0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzICYmIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXNba2V5XSkge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2tleV0ucmVtb3ZlTGlzdGVuZXIodGhpcy5fYmluZGVkQWRhcHRlckhhbmRsZUNhbGxiYWNrKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXNba2V5XTtcbiAgICB9XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIGFsbCBhZGFwdGVyIGhhbmRsZXMuXG4gKi9cbkFkYXB0ZXIucHJvdG90eXBlLmNsZWFyQWRhcHRlckhhbmRsZXMgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXMpIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1tpXS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9iaW5kZWRBZGFwdGVySGFuZGxlQ2FsbGJhY2spO1xuICAgIH1cblxuICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckhhbmRsZXMgPSBudWxsO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGNvbm5lY3RlZCBBZGFwdGVySGFuZGxlIG9mIGEgY2VydGFpbiBrZXkuXG4gKiBUaGlzIHdpbGwgb25seSByZXR1cm4gQWRhcHRlckhhbmRsZXMgcHJldmlvdXNseSBhZGRlZCB2aWEgY29ubmVjdEFkYXB0ZXJIYW5kbGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEByZXR1cm4gez9BZGFwdGVySGFuZGxlfSB0aGUgYWRhcHRlciBvZiB0aGF0IGtleSwgb3IgbnVsbCBpZiBub3QgYXZhaWxhYmxlXG4gKi9cbkFkYXB0ZXIucHJvdG90eXBlLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcyAmJiB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGVzW2tleV07XG59O1xuXG4vKipcbiAqIEdldCB0aGUgY29ubmVjdGVkIGFkYXB0ZXIgb2YgYSBjZXJ0YWluIGtleS5cbiAqIFRoaXMgd2lsbCBvbmx5IHJldHVybiBhZGFwdGVycyBvZiBBZGFwdGVySGFuZGxlcyBwcmV2aW91c2x5IGFkZGVkIHZpYSBjb25uZWN0QWRhcHRlclxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7P1hNTDNELmJhc2UuQWRhcHRlcn0gdGhlIGFkYXB0ZXIgb2YgdGhhdCBrZXksIG9yIG51bGwgaWYgbm90IGF2YWlsYWJsZVxuICovXG5BZGFwdGVyLnByb3RvdHlwZS5nZXRDb25uZWN0ZWRBZGFwdGVyID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGhhbmRsZSA9IHRoaXMuZ2V0Q29ubmVjdGVkQWRhcHRlckhhbmRsZShrZXkpO1xuICAgIHJldHVybiBoYW5kbGUgJiYgaGFuZGxlLmdldEFkYXB0ZXIoKTtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQsIHdoZW4gdGhlIGFkYXBhdGVyIGlzIGRldGFjaGVkIGZyb20gdGhlIG5vZGUuXG4gKiBBdCB0aGlzIHBvaW50LCB0aGUgYWRhcGF0ZXIgc2hvdWxkIGRpc2Nvbm5lY3QgZnJvbSBhbnkgb3RoZXIgYWRhcHRlciBhbmQgcHJlcGFyZSB0byBiZSBwcm9wZXJseSBnYXJiYWdlIGNvbGxlY3RlZFxuICovXG5BZGFwdGVyLnByb3RvdHlwZS5vbkRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcbn07XG5cblxuLyoqXG4gKiBJbnRlcm5hbCBmdW5jdGlvbiB0aGF0IGNvbnZlcnRzIGFuIEFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24gdG8gYSBDb25uZWN0ZWRBZGFwdGVyTm90aWZpY2F0aW9uXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtFdmVudHMuQWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbn0gZXZ0XG4gKi9cbmZ1bmN0aW9uIGFkYXB0ZXJIYW5kbGVDYWxsYmFjayhldnQpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlcykge1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlc1trZXldID09IGV2dC5hZGFwdGVySGFuZGxlKSB7XG4gICAgICAgICAgICB2YXIgc3ViRXZlbnQgPSBuZXcgRXZlbnRzLkNvbm5lY3RlZEFkYXB0ZXJOb3RpZmljYXRpb24oZXZ0LCBrZXkpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VkKHN1YkV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIEFuIEFkYXB0ZXIgY29ubmVjdGVkIHRvIGEgRE9NTm9kZSAocG9zc2libHkgb2YgYW4gZXh0ZXJuYWwgZG9jdW1lbnQpXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QWRhcHRlckZhY3Rvcnl9IGZhY3RvcnkgdGhlIEFkYXB0ZXJGYWN0b3J5IHRoaXMgYWRhcHRlciB3YXMgY3JlYXRlZCBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZSAtIERPTSBub2RlIG9mIHRoaXMgQWRhcHRlclxuICovXG52YXIgTm9kZUFkYXB0ZXIgPSBmdW5jdGlvbihmYWN0b3J5LCBub2RlKSB7XG4gICAgQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnkpO1xuICAgIHRoaXMubm9kZSA9IG5vZGU7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoTm9kZUFkYXB0ZXIsIEFkYXB0ZXIpO1xuXG4vKipcbiAqIGNhbGxlZCBieSB0aGUgZmFjdG9yeSBhZnRlciBhZGRpbmcgdGhlIGFkYXB0ZXIgdG8gdGhlIG5vZGVcbiAqL1xuTm9kZUFkYXB0ZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbigpIHtcbn07XG5cbi8qKlxuICogTm90aWZpY3Rpb24gZHVlIHRvIGEgY2hhbmdlIGluIERPTSwgcmVsYXRlZCBhZGFwdGVycyBhbmQgc28gb24uXG4gKiBAcGFyYW0ge0V2ZW50cy5Ob3RpZmljYXRpb259IGVcbiAqL1xuTm9kZUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbihlKSB7XG5cbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8WE1MM0QuVVJJfSB1cmkgVXJpIHRvIHJlZmVycmVkIGFkYXB0ZXJIYW5kbGVcbiAqIEBwYXJhbSB7T2JqZWN0PX0gYXNwZWN0VHlwZSBPcHRpb25hbDogdGhlIHR5cGUgb2YgYWRhcHRlciAodXNlIHNhbWUgYWRhcHRlciB0eXBlIGJ5IGRlZmF1bHQpXG4gKiBAcGFyYW0ge251bWJlcj19IGNhbnZhc0lkIE9wdGlvbmFsOiB0aGUgY2FudmFzIGlkIG9mIHRoZSBhZGFwdGVyICh1c2UgY2FudmFzIGlkIG9mIHRoaXMgYWRhcHRlciBieSBkZWZhdWx0KVxuICogQHJldHVybnMgYW4gQWRhcHRlckhhbmRsZSB0byB0aGUgcmVmZXJyZWQgQWRhcHRlciBvZiB0aGUgc2FtZSBhc3BlY3QgYW5kIGNhbnZhc0lkXG4gKi9cbk5vZGVBZGFwdGVyLnByb3RvdHlwZS5nZXRBZGFwdGVySGFuZGxlID0gZnVuY3Rpb24odXJpLCBhc3BlY3RUeXBlLCBjYW52YXNJZCkge1xuICAgIGNhbnZhc0lkID0gY2FudmFzSWQgPT09IHVuZGVmaW5lZCA/IHRoaXMuZmFjdG9yeS5jYW52YXNJZCA6IGNhbnZhc0lkO1xuICAgIHJldHVybiBSZXNvdXJjZS5nZXRBZGFwdGVySGFuZGxlKHRoaXMubm9kZS5vd25lckRvY3VtZW50Ll9kb2N1bWVudFVSTCB8fCB0aGlzLm5vZGUub3duZXJEb2N1bWVudC5VUkwsXG4gICAgICAgIHVyaSwgYXNwZWN0VHlwZSB8fCB0aGlzLmZhY3RvcnkuYXNwZWN0LCBjYW52YXNJZCwgdGhpcy5ub2RlLm5vZGVOYW1lKTtcbn07XG4vKipcbiAqIG5vdGlmaWVzIGFsbCBhZGFwdGVyIHRoYXQgcmVmZXIgdG8gdGhpcyBhZGFwdGVyIHRocm91Z2ggQWRhcHRlckhhbmRsZXMuXG4gKiBAcGFyYW0ge251bWJlcj99IHR5cGUgVGhlIHR5cGUgb2YgY2hhbmdlXG4gKi9cbk5vZGVBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlPcHBvc2l0ZUFkYXB0ZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHR5cGUgPSB0eXBlIHx8IEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEO1xuICAgIHJldHVybiBSZXNvdXJjZS5ub3RpZnlOb2RlQWRhcHRlckNoYW5nZSh0aGlzLm5vZGUsXG4gICAgICAgIHRoaXMuZmFjdG9yeS5hc3BlY3QsIHRoaXMuZmFjdG9yeS5jYW52YXNJZCwgdHlwZSk7XG59O1xuXG4vKipcbiAqIERlcHRoLWZpcnN0IHRyYXZlcnNhbCBvdmVyIGVsZW1lbnQgaGllcmFyY2h5XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE5vZGVBZGFwdGVyKX0gY2FsbGJhY2tcbiAqL1xuTm9kZUFkYXB0ZXIucHJvdG90eXBlLnRyYXZlcnNlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0aGlzKTtcbiAgICB2YXIgY2hpbGQgPSB0aGlzLm5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHZhciBhZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIoY2hpbGQpO1xuICAgICAgICBhZGFwdGVyICYmIGFkYXB0ZXIudHJhdmVyc2UoY2FsbGJhY2spO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcbiAgICB9XG59O1xuXG5cbi8qKlxuICogQGludGVyZmFjZVxuICovXG52YXIgSUZhY3RvcnkgPSBmdW5jdGlvbigpIHtcbn07XG5cbi8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuSUZhY3RvcnkucHJvdG90eXBlLmFzcGVjdDtcblxuXG4vKipcbiAqIEFuIGFkYXB0ZXIgZmFjdG9yeSBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYWRhcHRlciBmcm9tIGEgY2VydGFpbiBkYXRhIHNvdXJjZS5cbiAqIE5vdGUgdGhhdCBhbnkgQWRhcHRlckZhY3RvcnkgaXMgcmVnaXN0ZXJlZCB3aXRoIFJlc291cmNlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtJRmFjdG9yeX1cbiAqIEBwYXJhbSB7T2JqZWN0fSBhc3BlY3QgVGhlIGFzcGVjdCB0aGlzIGZhY3Rvcnkgc2VydmVzIChlLmcuIFhNTDNELmRhdGEgb3IgWE1MM0Qud2ViZ2wpXG4gKiBAcGFyYW0ge3N0cmluZ3xBcnJheS48c3RyaW5nPn0gbWltZXR5cGVzIFRoZSBtaW1ldHlwZSB0aGlzIGZhY3RvcnkgaXMgY29tcGF0aWJsZSB0b1xuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc0lkIFRoZSBpZCBvZiB0aGUgY29ycmVzcG9uZGluZyBjYW52YXMgaGFuZGxlci4gMCwgaWYgbm90IGRlcGVuZGVudCBvbiBhbnkgR0xDYW52YXNIYW5kbGVyXG4gKi9cbnZhciBBZGFwdGVyRmFjdG9yeSA9IGZ1bmN0aW9uKGFzcGVjdCwgbWltZXR5cGVzLCBjYW52YXNJZCkge1xuICAgIHRoaXMuYXNwZWN0ID0gYXNwZWN0O1xuICAgIHRoaXMuY2FudmFzSWQgPSBjYW52YXNJZCB8fCAwO1xuICAgIHRoaXMubWltZXR5cGVzID0gdHlwZW9mIG1pbWV0eXBlcyA9PSBcInN0cmluZ1wiID8gWyBtaW1ldHlwZXNdIDogbWltZXR5cGVzO1xuXG4gICAgcmVnaXN0ZXJGYWN0b3J5KHRoaXMpO1xufTtcblxuIC8qKiBJbXBsZW1lbnRlZCBieSBzdWJjbGFzc1xuICogQ3JlYXRlIGFkYXB0ZXIgZnJvbSBhbiBvYmplY3QgKG5vZGUgaW4gY2FzZSBvZiBhbiB4bWwsIGFuZCBvYmplY3QgaW4gY2FzZSBvZiBqc29uKVxuICogQHBhcmFtIHtvYmplY3R9IG9ialxuICogQHJldHVybnMgez9BZGFwdGVyfSBjcmVhdGVkIGFkYXB0ZXIgb3IgbnVsbCBpZiBubyBhZGFwdGVyIGNhbiBiZSBjcmVhdGVkXG4gKi9cbkFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVBZGFwdGVyID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRhcHRlciBmYWN0b3J5IHN1cHBvcnRzIHNwZWNpZmllZCBtaW1ldHlwZS4gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgc3ViY2xhc3MuXG4gKiBAcGFyYW0ge1N0cmluZ30gbWltZXR5cGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIGFkYXB0ZXIgZmFjdG9yeSBzdXBwb3J0cyBzcGVjaWZpZWQgbWltZXR5cGVcbiAqL1xuQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLnN1cHBvcnRzTWltZXR5cGUgPSBmdW5jdGlvbihtaW1ldHlwZSkge1xuICAgIHJldHVybiB0aGlzLm1pbWV0eXBlcy5pbmRleE9mKG1pbWV0eXBlKSAhPSAtMTtcbn07XG5cbi8qKlxuICogQSBOb2RlQWRhcGVyRmFjdG9yeSBpcyBhIEFkYXB0ZXJGYWN0b3J5LCB0aGF0IHdvcmtzIHNwZWNpZmljYWxseSBmb3IgRE9NIG5vZGVzIC8gZWxlbWVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBhc3BlY3QgVGhlIGFzcGVjdCB0aGlzIGZhY3Rvcnkgc2VydmVzIChlLmcuIFhNTDNELmRhdGEgb3IgWE1MM0Qud2ViZ2wpXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWQgVGhlIGlkIG9mIHRoZSBjb3JyZXNwb25kaW5nIGNhbnZhcyBoYW5kbGVyLiAwLCBpZiBub3QgZGVwZW5kZW50IG9uIGFueSBHTENhbnZhc0hhbmRsZXJcbiAqL1xudmFyIE5vZGVBZGFwdGVyRmFjdG9yeSA9IGZ1bmN0aW9uKGFzcGVjdCwgY2FudmFzSWQpIHtcbiAgICBBZGFwdGVyRmFjdG9yeS5jYWxsKHRoaXMsIGFzcGVjdCwgW1widGV4dC94bWxcIiwgXCJhcHBsaWNhdGlvbi94bWxcIl0sIGNhbnZhc0lkKTtcbn07XG5YTUwzRC5jcmVhdGVDbGFzcyhOb2RlQWRhcHRlckZhY3RvcnksIEFkYXB0ZXJGYWN0b3J5KTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGZpcnN0IGNoZWNrcywgaWYgYW4gYWRhcHRlciBoYXMgYmVlbiBhbHJlYWR5IGNyZWF0ZWQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIG5vZGVcbiAqIElmIHllcywgdGhpcyBhZGFwdGVyIGlzIHJldHVybmVkLCBvdGhlcndpc2UsIGEgbmV3IGFkYXB0ZXIgaXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICogQHJldHVybnMge0FkYXB0ZXJ9IFRoZSBhZGFwdGVyIG9mIHRoZSBub2RlXG4gKi9cbk5vZGVBZGFwdGVyRmFjdG9yeS5wcm90b3R5cGUuZ2V0QWRhcHRlciA9IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZihub2RlICYmIG5vZGUuX2NvbmZpZ3VyZWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgY29uZmlnLmVsZW1lbnQobm9kZSk7XG4gICAgaWYgKCFub2RlIHx8IG5vZGUuX2NvbmZpZ3VyZWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICB2YXIgZWxlbUhhbmRsZXIgPSBub2RlLl9jb25maWd1cmVkO1xuICAgIHZhciBrZXkgPSB0aGlzLmFzcGVjdCArIFwiX1wiICsgdGhpcy5jYW52YXNJZDtcbiAgICB2YXIgYWRhcHRlciA9IGVsZW1IYW5kbGVyLmFkYXB0ZXJzW2tleV07XG4gICAgaWYgKGFkYXB0ZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG5cbiAgICAvLyBObyBhZGFwdGVyIGZvdW5kLCB0cnkgdG8gY3JlYXRlIG9uZVxuICAgIGFkYXB0ZXIgPSB0aGlzLmNyZWF0ZUFkYXB0ZXIobm9kZSk7XG4gICAgaWYgKGFkYXB0ZXIpIHtcbiAgICAgICAgZWxlbUhhbmRsZXIuYWRhcHRlcnNba2V5XSA9IGFkYXB0ZXI7XG4gICAgICAgIGFkYXB0ZXIuaW5pdCgpO1xuICAgIH1cbiAgICByZXR1cm4gYWRhcHRlcjtcbn07XG5cblhNTDNELnJlc291cmNlLkFkYXB0ZXJGYWN0b3J5ID0gQWRhcHRlckZhY3Rvcnk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuTm9kZUFkYXB0ZXIgOiBOb2RlQWRhcHRlcixcbkFkYXB0ZXJGYWN0b3J5IDogQWRhcHRlckZhY3RvcnksXG5Ob2RlQWRhcHRlckZhY3RvcnkgOiBOb2RlQWRhcHRlckZhY3Rvcnlcbn07XG4iLCJ2YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG5cblwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBbiBhZGFwdGVyIGhhbmRsZSBpcyBhIGNvbm5lY3Rpb24gcGllY2UgZm9yIGFuIGFkYXB0ZXIgdGhhdCBpcyByZWZlcnJlZCB0aHJvdWdoIGEgdXJpIChlLmcuIGlkIHJlZmVyZW5jZSlcbiAqIEFkYXB0ZXJIYW5kbGVzIGFyZSBhbHdheXMgZmV0Y2hlZCBmcm9tIHRoZSBSZXNvdXJjZSBvYmplY3RcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKHVybCkge1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuYWRhcHRlciA9IG51bGw7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLnN0YXR1cyA9IDA7IC8vIFNUQVRVUy5MT0FESU5HXG59O1xuXG4vKipcbiAqIEVudW1hZXJhdGlvbiBvZiBzdGF0ZXMgZm9yIHRoZSBhZGFwdGVyIGhhbmRsZVxuICogQGVudW0ge251bWJlcn1cbiAqL1xuQWRhcHRlckhhbmRsZS5TVEFUVVMgPSB7XG4gICAgTE9BRElORzogMCxcbiAgICBOT1RfRk9VTkQ6IDEsXG4gICAgUkVBRFk6IDJcbn07XG5cbi8qKlxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWZmIGFuIGFkYXB0ZXIgaXMgYXZhaWxhYmxlXG4gKi9cbkFkYXB0ZXJIYW5kbGUucHJvdG90eXBlLmhhc0FkYXB0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyICE9IG51bGw7XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHs/WE1MM0QuYmFzZS5BZGFwdGVyfSB0aGUgYWRhcHRlciBjb25uZWN0ZWQgdG8gdGhlIGhhbmRsZS4gQ2FuIGJlIG51bGxcbiAqL1xuQWRhcHRlckhhbmRsZS5wcm90b3R5cGUuZ2V0QWRhcHRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXI7XG59O1xuXG4vKipcbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGJ5IFJlc291cmNlXG4gKiBAcGFyYW0ge1hNTDNELmJhc2UuQWRhcHRlcn0gYWRhcHRlciBUaGUgYWRhcHRlciBjb25uZWN0ZWQgdG8gdGhlIEFkYXB0ZXJIYW5kbGVyXG4gKiBAcGFyYW0ge0FkYXB0ZXJIYW5kbGUuU1RBVFVTfSBzdGF0dXNcbiAqL1xuQWRhcHRlckhhbmRsZS5wcm90b3R5cGUuc2V0QWRhcHRlciA9IGZ1bmN0aW9uKGFkYXB0ZXIsIHN0YXR1cykge1xuICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQpO1xufTtcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCB0byBub3RpZnkgYWxsIGxpc3RlbmVycyBvZiB0aGlzIEFkYXB0ZXJIYW5kbGUgYWJvdXQgc29tZSBjaGFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZSBBIHR5cGUgbnVtYmVyIHdpdGggdGhlIHR5cGUgb2YgY2hhbmdlICh1c3VhbGx5IEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEKVxuICovXG5BZGFwdGVySGFuZGxlLnByb3RvdHlwZS5ub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50cy5BZGFwdGVySGFuZGxlTm90aWZpY2F0aW9uKHRoaXMsIHR5cGUpO1xuICAgIHZhciBpID0gdGhpcy5saXN0ZW5lcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbaV0oZXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgdG8gdGhlIEFkYXB0ZXJIYW5kbGUgdGhhdCBpcyBub3RpZmllZCBhYm91dCBjaGFuZ2VzLlxuICogTGlzdGVuZXJzIGNhbm5vdCBiZSBpbnNlcnRlZCB0d2ljZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gRnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gc29tZXRoaW5nIGNvbmNlcmluZyB0aGUgYWRhcHRlciBjaGFuZ2VzXG4gKi9cbkFkYXB0ZXJIYW5kbGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGlkeCA9PSAtMSlcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIGxpc3RlbmVyIGZyb20gdGhlIEFkYXB0ZXJIYW5kbGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gKi9cbkFkYXB0ZXJIYW5kbGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB2YXIgaWR4ID0gdGhpcy5saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gICAgaWYgKGlkeCAhPSAtMSlcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFkYXB0ZXJIYW5kbGU7IiwidmFyIEFkYXB0ZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4vYWRhcHRlci5qc1wiKS5BZGFwdGVyRmFjdG9yeTtcbnZhciByZWdpc3RlckZvcm1hdCA9IHJlcXVpcmUoXCIuL3Jlc291cmNlbWFuYWdlci5qc1wiKS5yZWdpc3RlckZvcm1hdDtcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2VsZW1lbnRzLmpzXCIpLmNvbmZpZztcblxuLyoqXG4gKiBBIGZvcm1hdCBoYW5kbGVyIGlzIHByb3ZpZGUgZnVuY3Rpb25hbGl0eSBmb3IgZGV0ZWN0aW5nIGZvcm1hdCBvZiByZXNvdXJjZXNcbiAqIGFuZCBwcm92aWRpbmcgZm9ybWF0LXNwZWNpZmljIHNlcnZpY2VzLlxuICogRm9ybWF0SGFuZGxlcnMgYXJlIHJlZ2lzdGVyZWQgd2l0aCBYTUwzRC5iYXNlLnJlZ2lzdGVyRm9ybWF0KCkgZnVuY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZvcm1hdEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZhY3RvcnlDbGFzc2VzID0ge307IC8vIGEgbWFwIGZyb20gYW4gYXNwZWN0IG5hbWUgdG8gYSBmYWN0b3J5IGNsYXNzXG4gICAgdGhpcy5mYWN0b3J5Q2FjaGUgPSB7fTsgLy8gbWFwcyB1bmlxdWUga2V5cyAoYXNwZWN0ICsgXCJfXCIgKyBjYW52YXNJZCkgdG8gdGhlIGZhY3RvcnkgaW5zdGFuY2Vcbn07XG5cbkZvcm1hdEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyRmFjdG9yeUNsYXNzID0gZnVuY3Rpb24gKGZhY3RvcnlDbGFzcykge1xuICAgIGlmICghZmFjdG9yeUNsYXNzLnByb3RvdHlwZS5hc3BlY3QgKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmYWN0b3J5Q2xhc3MgbXVzdCBiZSBhIHN1YmNsYXNzIG9mIFhNTDNELmJhc2UuQWRhcHRlckZhY3RvcnlcIik7XG4gICAgdGhpcy5mYWN0b3J5Q2xhc3Nlc1tmYWN0b3J5Q2xhc3MucHJvdG90eXBlLmFzcGVjdF0gPSBmYWN0b3J5Q2xhc3M7XG59O1xuXG5Gb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGYWN0b3J5Q2xhc3NCeUFzcGVjdCA9IGZ1bmN0aW9uIChhc3BlY3QpIHtcbiAgICByZXR1cm4gdGhpcy5mYWN0b3J5Q2xhc3Nlc1thc3BlY3RdO1xufTtcblxuRm9ybWF0SGFuZGxlci5wcm90b3R5cGUuZ2V0RmFjdG9yeSA9IGZ1bmN0aW9uIChhc3BlY3QsIGNhbnZhc0lkKSB7XG4gICAgY2FudmFzSWQgPSBjYW52YXNJZCB8fCAwO1xuICAgIHZhciBrZXkgPSBhc3BlY3QgKyBcIl9cIiArIGNhbnZhc0lkO1xuICAgIHZhciBmYWN0b3J5ID0gdGhpcy5mYWN0b3J5Q2FjaGVba2V5XTtcbiAgICBpZiAoIWZhY3RvcnkpIHtcbiAgICAgICAgdmFyIGZhY3RvcnlDbGFzcyA9IHRoaXMuZ2V0RmFjdG9yeUNsYXNzQnlBc3BlY3QoYXNwZWN0KTtcbiAgICAgICAgaWYgKCFmYWN0b3J5Q2xhc3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZmFjdG9yeSA9IG5ldyBmYWN0b3J5Q2xhc3MoY2FudmFzSWQpO1xuICAgICAgICB0aGlzLmZhY3RvcnlDYWNoZVtrZXldID0gZmFjdG9yeTtcbiAgICB9XG4gICAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZExvY2FsU3ltYm9sc1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgcmVzcG9uc2UgZGF0YSBmb3JtYXQgaXMgc3VwcG9ydGVkLlxuICogcmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgYW5kIG1pbWV0eXBlIHZhbHVlcyBhcmUgcmV0dXJuZWQgYnkgWE1MSHR0cFJlcXVlc3QuXG4gKiBEYXRhIHR5cGUgb2YgdGhlIHJlc3BvbnNlIGlzIG9uZSBvZiBBcnJheUJ1ZmZlciwgQmxvYiwgRG9jdW1lbnQsIFN0cmluZywgT2JqZWN0LlxuICogcmVzcG9uc2VUeXBlIGlzIG9uZSBvZiBcIlwiLCBcImFycmF5YnVmZmVyXCIsIFwiYmxvYlwiLCBcImRvY3VtZW50XCIsIFwianNvblwiLCBcInRleHRcIlxuICpcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWltZXR5cGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbkZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmlzRm9ybWF0U3VwcG9ydGVkID0gZnVuY3Rpb24gKHJlc3BvbnNlLCByZXNwb25zZVR5cGUsIG1pbWV0eXBlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyByZXNwb25zZSBkYXRhIHRvIGZvcm1hdCBkYXRhLlxuICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHZhbHVlIG9mIHJlc3BvbnNlLlxuICpcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2VUeXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWltZXR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmdldEZvcm1hdERhdGEgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodHJ1ZSwgcmVzcG9uc2UpO1xufTtcblxuLyoqXG4gKiBFeHRyYWN0cyBkYXRhIGZvciBhIGZyYWdtZW50IGZyb20gZG9jdW1lbnQgZGF0YSBhbmQgZnJhZ21lbnQgcmVmZXJlbmNlLlxuICpcbiAqIEBvdmVycmlkZVxuICogQHBhcmFtIHtPYmplY3R9IGRvY3VtZW50RGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IGZyYWdtZW50IEZyYWdtZW50IHdpdGhvdXQgcG91bmQga2V5IHdoaWNoIGRlZmluZXMgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50XG4gKiBAcmV0dXJuIHsqfVxuICovXG5Gb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGcmFnbWVudERhdGEgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhLCBmcmFnbWVudCkge1xuICAgIGlmICghZnJhZ21lbnQpXG4gICAgICAgIHJldHVybiBkb2N1bWVudERhdGE7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFhNTEZvcm1hdEhhbmRsZXIgc3VwcG9ydHMgYWxsIFhNTCBhbmQgSFRNTC1iYXNlZCBkb2N1bWVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIEZvcm1hdEhhbmRsZXJcbiAqL1xudmFyIFhNTEZvcm1hdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgRm9ybWF0SGFuZGxlci5jYWxsKHRoaXMpO1xufTtcblhNTDNELmNyZWF0ZUNsYXNzKFhNTEZvcm1hdEhhbmRsZXIsIEZvcm1hdEhhbmRsZXIpO1xuXG5YTUxGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5pc0Zvcm1hdFN1cHBvcnRlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSkge1xuICAgIHJldHVybiByZXNwb25zZSAmJiByZXNwb25zZS5ub2RlVHlwZSA9PT0gOSAmJiAobWltZXR5cGUubWF0Y2goL3htbC8pKTtcbn07XG5cblhNTEZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmdldEZvcm1hdERhdGEgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUsIGNhbGxiYWNrKSB7XG4gICAgY2FsbGJhY2sodHJ1ZSwgcmVzcG9uc2UpO1xufTtcblxuWE1MRm9ybWF0SGFuZGxlci5wcm90b3R5cGUuZ2V0RnJhZ21lbnREYXRhID0gZnVuY3Rpb24gKGRvY3VtZW50RGF0YSwgZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnREYXRhLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqW2lkPSdcIiArIGZyYWdtZW50ICsgXCInXVwiKVswXTtcbn07XG5cblxuLyoqXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGb3JtYXRIYW5kbGVyXG4gKi9cbnZhciBYTUwzREZvcm1hdEhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgWE1MRm9ybWF0SGFuZGxlci5jYWxsKHRoaXMpO1xufTtcblhNTDNELmNyZWF0ZUNsYXNzKFhNTDNERm9ybWF0SGFuZGxlciwgWE1MRm9ybWF0SGFuZGxlcik7XG5cblhNTDNERm9ybWF0SGFuZGxlci5wcm90b3R5cGUuaXNGb3JtYXRTdXBwb3J0ZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUpIHtcbiAgICB2YXIgeG1sM2RzID0gW107XG4gICAgaWYgKHJlc3BvbnNlIGluc3RhbmNlb2YgWE1MRG9jdW1lbnQpIHtcbiAgICAgICAgeG1sM2RzID0gcmVzcG9uc2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ4bWwzZFwiKTtcbiAgICAgICAgaWYgKCF4bWwzZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBBbHNvIGNoZWNrIGNhc2VzIHdoZXJlIHRoZSBYTUwzRCBlbGVtZW50IG1heSBoYXZlIGJlZW4gZml0dGVkIHdpdGggYSBOUyBwcmVmaXggKGVnLiBuczE6eG1sM2QpXG4gICAgICAgICAgICB4bWwzZHMgPSByZXNwb25zZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TKFhNTDNELnhtbDNkTlMsIFwieG1sM2RcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHhtbDNkcy5sZW5ndGggIT09IDA7XG59O1xuXG5YTUwzREZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmdldEZvcm1hdERhdGEgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gQ29uZmlndXJlIGFsbCB4bWwzZCBlbGVtZW50czpcbiAgICB2YXIgeG1sM2RFbGVtZW50cyA9IHJlc3BvbnNlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJ4bWwzZFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhtbDNkRWxlbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uZmlnLmVsZW1lbnQoeG1sM2RFbGVtZW50c1tpXSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKHRydWUsIHJlc3BvbnNlKTtcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBGb3JtYXRIYW5kbGVyXG4gKi9cbnZhciBKU09ORm9ybWF0SGFuZGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgICBGb3JtYXRIYW5kbGVyLmNhbGwodGhpcyk7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoSlNPTkZvcm1hdEhhbmRsZXIsIEZvcm1hdEhhbmRsZXIpO1xuXG5KU09ORm9ybWF0SGFuZGxlci5wcm90b3R5cGUuaXNGb3JtYXRTdXBwb3J0ZWQgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJlc3BvbnNlVHlwZSwgbWltZXR5cGUpIHtcbiAgICByZXR1cm4gbWltZXR5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiO1xufTtcblxudmFyIHhtbDNkRm9ybWF0SGFuZGxlciA9IG5ldyBYTUwzREZvcm1hdEhhbmRsZXIoKTtcbnJlZ2lzdGVyRm9ybWF0KHhtbDNkRm9ybWF0SGFuZGxlcik7XG5YTUwzRC54bWwzZEZvcm1hdEhhbmRsZXIgPSB4bWwzZEZvcm1hdEhhbmRsZXI7XG5YTUwzRC5yZXNvdXJjZS5Gb3JtYXRIYW5kbGVyID0gRm9ybWF0SGFuZGxlcjtcblhNTDNELnJlc291cmNlLkpTT05Gb3JtYXRIYW5kbGVyID0gSlNPTkZvcm1hdEhhbmRsZXI7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEpTT05Gb3JtYXRIYW5kbGVyOiBKU09ORm9ybWF0SGFuZGxlcixcbiAgICBYTUxGb3JtYXRIYW5kbGVyOiBYTUxGb3JtYXRIYW5kbGVyLFxuICAgIFhNTDNERm9ybWF0SGFuZGxlcjogWE1MM0RGb3JtYXRIYW5kbGVyLFxuICAgIEZvcm1hdEhhbmRsZXI6IEZvcm1hdEhhbmRsZXIsXG4gICAgeG1sM2RGb3JtYXRIYW5kbGVyOiB4bWwzZEZvcm1hdEhhbmRsZXJcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIEFkYXB0ZXJIYW5kbGUgPSByZXF1aXJlKFwiLi9hZGFwdGVyaGFuZGxlLmpzXCIpO1xudmFyIFVSSVJlc29sdmVyID0gcmVxdWlyZShcIi4uL3V0aWxzL3VyaS5qc1wiKS5VUklSZXNvbHZlcjtcbnZhciBVUkkgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXJpLmpzXCIpLlVSSTtcbnZhciBPcHRpb25zID0gcmVxdWlyZShcIi4uL3V0aWxzL29wdGlvbnMuanNcIik7XG5cbnZhciBPUFRJT05fUkVTT1VSQ0VfQ09SUyA9IFwicmVzb3VyY2UtY3Jvc3NvcmlnaW4tYXR0cmlidXRlXCI7XG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9SRVNPVVJDRV9DT1JTLCBcImFub255bW91c1wiKTtcblxudmFyIGNfY2FjaGVkRG9jdW1lbnRzID0ge307XG52YXIgY19mYWN0b3JpZXMgPSB7fTtcbnZhciBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzID0ge307XG52YXIgY19jYW52YXNJZENvdW50ZXJzID0ge307XG52YXIgY19mb3JtYXRIYW5kbGVycyA9IFtdO1xuXG52YXIgY19iaW5hcnlDb250ZW50VHlwZXMgPSBbXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiwgXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCJdO1xudmFyIGNfYmluYXJ5RXh0ZW5zaW9ucyA9IFtcIi5iaW5cIiwgXCIuYnNvblwiXTtcblxuLyoqXG4gKiBSZWdpc3RlciBhIGZhY3Rvcnkgd2l0aCB0aGUgcmVzb3VyY2UgbWFuYWdlclxuICogQHBhcmFtIHtBZGFwdGVyRmFjdG9yeX0gZmFjdG9yeSAtIHRoZSBmYWN0b3J5IHRvIGJlIHJlZ2lzdGVyZWRcbiAqL1xudmFyIHJlZ2lzdGVyRmFjdG9yeSA9IGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICB2YXIgY2FudmFzSWQgPSBmYWN0b3J5LmNhbnZhc0lkO1xuICAgIGlmICghY19mYWN0b3JpZXNbY2FudmFzSWRdKVxuICAgICAgICBjX2ZhY3Rvcmllc1tjYW52YXNJZF0gPSBbXTtcbiAgICBjX2ZhY3Rvcmllc1tjYW52YXNJZF0ucHVzaChmYWN0b3J5KTtcbn07XG5cbnZhciByZWdpc3RlckZvcm1hdCA9IGZ1bmN0aW9uKGZvcm1hdEhhbmRsZXIpIHtcbiAgICBpZiAoZm9ybWF0SGFuZGxlcilcbiAgICAgICAgY19mb3JtYXRIYW5kbGVycy5wdXNoKGZvcm1hdEhhbmRsZXIpO1xufTtcblxudmFyIGZpbmRGb3JtYXQgPSBmdW5jdGlvbihyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY19mb3JtYXRIYW5kbGVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZm9ybWF0SGFuZGxlciA9IGNfZm9ybWF0SGFuZGxlcnNbaV07XG4gICAgICAgIGlmIChjX2Zvcm1hdEhhbmRsZXJzW2ldLmlzRm9ybWF0U3VwcG9ydGVkKHJlc3BvbnNlLCByZXNwb25zZVR5cGUsIG1pbWV0eXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdEhhbmRsZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUmVzb3VyY2UgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q291bnRlck9iamVjdChjYW52YXNJZCkge1xuICAgIHJldHVybiBjX2NhbnZhc0lkQ291bnRlcnNbY2FudmFzSWRdO1xufVxuXG5mdW5jdGlvbiBnZXRPckNyZWF0ZUNvdW50ZXJPYmplY3QoY2FudmFzSWQpIHtcbiAgICB2YXIgY291bnRlck9iamVjdCA9IGNfY2FudmFzSWRDb3VudGVyc1tjYW52YXNJZF07XG4gICAgaWYgKCFjb3VudGVyT2JqZWN0KSB7XG4gICAgICAgIGNvdW50ZXJPYmplY3QgPSB7Y291bnRlcjogMCwgbGlzdGVuZXJzOiBbXX07XG4gICAgICAgIGNfY2FudmFzSWRDb3VudGVyc1tjYW52YXNJZF0gPSBjb3VudGVyT2JqZWN0O1xuICAgIH1cbiAgICByZXR1cm4gY291bnRlck9iamVjdDtcbn1cblxuZnVuY3Rpb24gbm90aWZ5TG9hZENvbXBsZXRlTGlzdGVuZXJzKGNvdW50ZXJPYmplY3QpIHtcbiAgICB2YXIgbGlzdGVuZXJzID0gY291bnRlck9iamVjdC5saXN0ZW5lcnM7XG4gICAgLy9jb3VudGVyT2JqZWN0Lmxpc3RlbmVycyA9IG5ldyBBcnJheSgpO1xuICAgIHZhciBpID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGxpc3RlbmVyc1tpXSh0aGlzKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGxvYWRDb21wbGV0ZShjYW52YXNJZCkge1xuICAgIC8vIG5vdGlmeSBhbGwgbG9hZCBjb21wbGV0ZSBsaXN0ZW5lcnNcbiAgICB2YXIgY291bnRlck9iamVjdCA9IGdldENvdW50ZXJPYmplY3QoY2FudmFzSWQpO1xuICAgIGlmIChjb3VudGVyT2JqZWN0KSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmFzc2VydChjb3VudGVyT2JqZWN0LmNvdW50ZXIgPiAwLCBcImNvdW50ZXIgbXVzdCBiZSA+IDBcIik7XG4gICAgICAgIGNvdW50ZXJPYmplY3QuY291bnRlci0tO1xuICAgICAgICBpZiAoY291bnRlck9iamVjdC5jb3VudGVyID09IDApIHtcbiAgICAgICAgICAgIG5vdGlmeUxvYWRDb21wbGV0ZUxpc3RlbmVycyhjb3VudGVyT2JqZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuUmVzb3VyY2UuaXNMb2FkQ29tcGxldGUgPSBmdW5jdGlvbihjYW52YXNJZCkge1xuICAgIHZhciBjb3VudGVyT2JqZWN0ID0gZ2V0Q291bnRlck9iamVjdChjYW52YXNJZCk7XG4gICAgcmV0dXJuICFjb3VudGVyT2JqZWN0IHx8IGNvdW50ZXJPYmplY3QuY291bnRlciA9PSAwO1xufTtcblxuLypcbiAqIFJlZ2lzdGVyIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFsbCByZXNvdXJjZXMgZm9yIHNwZWNpZmllZCBjYW52YXNJZCBhcmUgbG9hZGVkLlxuICogTGlzdGVuZXIgaXMgZmlyZWQgb25seSBvbmNlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNJZFxuICogQHBhcmFtIHtFdmVudExpc3RlbmVyfSBsaXN0ZW5lclxuICovXG5SZXNvdXJjZS5hZGRMb2FkQ29tcGxldGVMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbnZhc0lkLCBsaXN0ZW5lcikge1xuICAgIHZhciBjb3VudGVyT2JqZWN0ID0gZ2V0T3JDcmVhdGVDb3VudGVyT2JqZWN0KGNhbnZhc0lkKTtcblxuICAgIC8qXG4gICAgaWYgKGNvdW50ZXJPYmplY3QgPT09IHVuZGVmaW5lZCB8fCBjb3VudGVyT2JqZWN0LmNvdW50ZXIgPT0gMCkge1xuICAgICAgICBsaXN0ZW5lcihjYW52YXNJZCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKi9cblxuICAgIHZhciBpZHggPSBjb3VudGVyT2JqZWN0Lmxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICBpZiAoaWR4ID09IC0xKSB7XG4gICAgICAgIGNvdW50ZXJPYmplY3QubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbn07XG5cbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuLyoqXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc0lkXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lclxuICovXG5SZXNvdXJjZS5yZW1vdmVMb2FkQ29tcGxldGVMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbnZhc0lkLCBsaXN0ZW5lcikge1xuICAgIHZhciBjb3VudGVyT2JqZWN0ID0gZ2V0Q291bnRlck9iamVjdChjYW52YXNJZCk7XG4gICAgaWYgKGNvdW50ZXJPYmplY3QpIHtcbiAgICAgICAgdmFyIGlkeCA9IGNvdW50ZXJPYmplY3QubGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgICAgICBpZiAoaWR4ICE9IC0xKVxuICAgICAgICAgICAgY291bnRlck9iamVjdC5saXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBzdHJpbmdFbmRzV2l0aFN1ZmZpeChzdHIsIHN1ZmZpeCkge1xuICAgIHJldHVybiBzdHIuaW5kZXhPZihzdWZmaXgsIHN0ci5sZW5ndGggLSBzdWZmaXgubGVuZ3RoKSAhPT0gLTE7XG59XG5cbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuUmVzb3VyY2UuYWRkQmluYXJ5Q29udGVudFR5cGUgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgaWYgKGNfYmluYXJ5Q29udGVudFR5cGVzLmluZGV4T2YodHlwZSkgPT0gLTEpXG4gICAgICAgIGNfYmluYXJ5Q29udGVudFR5cGVzLnB1c2godHlwZSk7XG59O1xuXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcblJlc291cmNlLnJlbW92ZUJpbmFyeUNvbnRlbnRUeXBlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBpZHggPSBjX2JpbmFyeUNvbnRlbnRUeXBlcy5pbmRleE9mKHR5cGUpO1xuICAgIGlmIChpZHggIT0gLTEpXG4gICAgICAgIGNfYmluYXJ5Q29udGVudFR5cGVzLnNwbGljZShpZHgsIDEpO1xufTtcblxuZnVuY3Rpb24gaXNCaW5hcnlDb250ZW50VHlwZShjb250ZW50VHlwZSkge1xuICAgIGZvciAodmFyIGkgaW4gY19iaW5hcnlDb250ZW50VHlwZXMpIHtcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09IGNfYmluYXJ5Q29udGVudFR5cGVzW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblJlc291cmNlLmFkZEJpbmFyeUV4dGVuc2lvbiA9IGZ1bmN0aW9uKGV4dGVuc2lvbikge1xuICAgIGlmIChjX2JpbmFyeUV4dGVuc2lvbnMuaW5kZXhPZihleHRlbnNpb24pID09IC0xKVxuICAgICAgICBjX2JpbmFyeUV4dGVuc2lvbnMucHVzaChleHRlbnNpb24pO1xufTtcblxuLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG5SZXNvdXJjZS5yZW1vdmVCaW5hcnlFeHRlbnNpb24gPSBmdW5jdGlvbihleHRlbnNpb24pIHtcbiAgICB2YXIgaWR4ID0gY19iaW5hcnlFeHRlbnNpb25zLmluZGV4T2YoZXh0ZW5zaW9uKTtcbiAgICBpZiAoaWR4ICE9IC0xKVxuICAgICAgICBjX2JpbmFyeUV4dGVuc2lvbnMuc3BsaWNlKGlkeCwgMSk7XG59O1xuXG5mdW5jdGlvbiBpc0JpbmFyeUV4dGVuc2lvbih1cmwpIHtcbiAgICBmb3IgKHZhciBpIGluIGNfYmluYXJ5RXh0ZW5zaW9ucykge1xuICAgICAgICBpZiAoc3RyaW5nRW5kc1dpdGhTdWZmaXgodXJsLCBjX2JpbmFyeUV4dGVuc2lvbnNbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBMb2FkIGEgZG9jdW1lbnQgdmlhIFhNTEh0dHBSZXF1ZXN0XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgb2YgdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gYWNjZXB0VHlwZSBUaGUgY29udGVudCB0eXBlIHRoYXQgc2hvdWxkIGJlIHJlcXVlc3RlZCBmb3IgdGhpcyBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBsb2FkRG9jdW1lbnQodXJsLCBhY2NlcHRUeXBlKSB7XG4gICAgdmFyIHhtbEh0dHAgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIHhtbEh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHhtbEh0dHAgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoeG1sSHR0cCkge1xuICAgICAgICB4bWxIdHRwLl91cmwgPSB1cmw7XG4gICAgICAgIHhtbEh0dHAuX2NvbnRlbnRDaGVja2VkID0gZmFsc2U7XG4gICAgICAgIHhtbEh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgaWYgKGlzQmluYXJ5RXh0ZW5zaW9uKHVybCkpXG4gICAgICAgICAgICB4bWxIdHRwLnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcblxuICAgICAgICB4bWxIdHRwLnNldFJlcXVlc3RIZWFkZXIoXCJBY2NlcHRcIiwgYWNjZXB0VHlwZSk7XG5cbiAgICAgICAgeG1sSHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh4bWxIdHRwLl9hYm9ydGVkKSAvLyBUaGlzIGNoZWNrIGlzIHBvc3NpYmx5IG5vdCBuZWVkZWRcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBjaGVjayBjb21wYXRpYmlsaXR5IGJldHdlZW4gY29udGVudCBhbmQgcmVxdWVzdCBtb2RlXG4gICAgICAgICAgICBpZiAoIXhtbEh0dHAuX2NvbnRlbnRDaGVja2VkICYmXG4gICAgICAgICAgICAgICAgLy8gMiAtIEhFQURFUlNfUkVDRUlWRUQsIDMgLSBMT0FESU5HLCA0IC0gRE9ORVxuICAgICAgICAgICAgICAgICgoeG1sSHR0cC5yZWFkeVN0YXRlID09IDIgfHwgeG1sSHR0cC5yZWFkeVN0YXRlID09IDMgfHwgeG1sSHR0cC5yZWFkeVN0YXRlID09IDQpICYmXG4gICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuc3RhdHVzID09IDIwMCkpIHtcbiAgICAgICAgICAgICAgICB4bWxIdHRwLl9jb250ZW50Q2hlY2tlZCA9IHRydWU7IC8vIHdlIGNoZWNrIG9ubHkgb25jZVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gY2hhbmdlIHJlcXVlc3QgbW9kZVxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHhtbEh0dHAuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIik7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5hcnlDb250ZW50ID0gaXNCaW5hcnlDb250ZW50VHlwZShjb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBiaW5hcnlSZXF1ZXN0ID0gKHhtbEh0dHAucmVzcG9uc2VUeXBlID09IFwiYXJyYXlidWZmZXJcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gY29udGVudCBpcyBub3QgdGhlIHNhbWUgYXMgcmVxdWVzdCwgd2UgbmVlZCB0byByZXBlYXQgcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICBpZiAoYmluYXJ5Q29udGVudCAhPSBiaW5hcnlSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLl9hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYiA9IHhtbEh0dHAub25yZWFkeXN0YXRlY2hhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IHhtbEh0dHAuX3VybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuYWJvcnQoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogV2UgZG8gbm90IHJlY3ljbGUgWE1MSHR0cFJlcXVlc3QgIVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgVGhpcyBkb2VzIHdvcmsgb25seSB3aGVuIHJlc3BvbnNlVHlwZSBpcyBjaGFuZ2VkIHRvIFwiYXJyYXlidWZmZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIGhvd2V2ZXIgdGhlIHNpemUgb2YgdGhlIHhtbEh0dHAucmVzcG9uc2UgYnVmZmVyIGlzIHRoZW4gd3JvbmcgIVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgSXQgZG9lcyBub3Qgd29yayBhdCBhbGwgKGF0IGxlYXN0IGluIENocm9tZSkgd2hlbiB3ZSB1c2Ugb3ZlcnJpZGVNaW1lVHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgd2l0aCBcInRleHQvcGxhaW47IGNoYXJzZXQ9eC11c2VyLWRlZmluZWRcIiBhcmd1bWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIFRoZSBsYXR0ZXIgbW9kZSByZXF1aXJlIGNyZWF0aW9uIG9mIHRoZSBmcmVzaCBYTUxIdHRwUmVxdWVzdC5cblxuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5fdXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5fY29udGVudENoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGNiO1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5zZW5kKG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVxdWVzdCBtb2RlIGFuZCBjb250ZW50IHR5cGUgYXJlIGNvbXBhdGlibGUgaGVyZSAoYm90aCBiaW5hcnkgb3IgYm90aCB0ZXh0KVxuICAgICAgICAgICAgaWYgKHhtbEh0dHAucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHhtbEh0dHAuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIkxvYWRlZDogXCIgKyB4bWxIdHRwLl91cmwpO1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC54bWxIdHRwQ2FsbGJhY2sgJiYgWE1MM0QueG1sSHR0cENhbGxiYWNrKHhtbEh0dHApO1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzUmVzcG9uc2UoeG1sSHR0cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGV4dGVybmFsIGRvY3VtZW50ICdcIiArIHhtbEh0dHAuX3VybCArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIic6IFwiICsgeG1sSHR0cC5zdGF0dXMgKyBcIiAtIFwiICsgeG1sSHR0cC5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZURvY3VtZW50SGFuZGxlcyh4bWxIdHRwLl91cmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeG1sSHR0cC5zZW5kKG51bGwpO1xuICAgIH1cbn1cbi8qKlxuICogUHJvY2VzcyByZXNwb25zZSBvZiBhamF4IHJlcXVlc3QgZnJvbSBsb2FkRG9jdW1lbnQoKVxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WE1MSHR0cFJlcXVlc3R9IGh0dHBSZXF1ZXN0XG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NSZXNwb25zZShodHRwUmVxdWVzdCkge1xuICAgIHZhciBtaW1ldHlwZSA9IGh0dHBSZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpO1xuICAgIGlmICghbWltZXR5cGUpIHtcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgbG9hZCBleHRlcm5hbCBkb2N1bWVudCBiZWNhdXNlIHRoZSBzZXJ2ZXIgZGlkIG5vdCBwcm92aWRlIGEgY29udGVudC10eXBlIGhlYWRlcjogXCIraHR0cFJlcXVlc3QuX3VybCk7XG4gICAgICAgIGludmFsaWRhdGVEb2N1bWVudEhhbmRsZXMoaHR0cFJlcXVlc3QuX3VybCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0RG9jdW1lbnREYXRhKGh0dHBSZXF1ZXN0LCBodHRwUmVxdWVzdC5fdXJsLCBtaW1ldHlwZSk7XG59XG4vKipcbiAqIEluaXRpYWxpemUgZGF0YSBvZiBhIHJlY2VpdmVkIGRvY3VtZW50XG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdH0gaHR0cFJlcXVlc3QgVGhlIFhNTEh0dHBSZXF1ZXN0IG9mIHRoZSBsb2FkZWQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIG9mIHRoZSBsb2FkZWQgZG9jdW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtaW1ldHlwZSBUaGUgbWltZXR5cGUgb2YgdGhlIGxvYWRlZCBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBzZXREb2N1bWVudERhdGEoaHR0cFJlcXVlc3QsIHVybCwgbWltZXR5cGUpIHtcbiAgICB2YXIgZG9jQ2FjaGUgPSBjX2NhY2hlZERvY3VtZW50c1t1cmxdO1xuICAgIGRvY0NhY2hlLm1pbWV0eXBlID0gbWltZXR5cGU7XG5cbiAgICB2YXIgY2xlYW5lZE1pbWV0eXBlID0gbWltZXR5cGU7XG5cbiAgICBpZiAobWltZXR5cGUuaW5kZXhPZignOycpID4gMClcbiAgICAgICAgY2xlYW5lZE1pbWV0eXBlID0gbWltZXR5cGUuc3Vic3RyKDAsIG1pbWV0eXBlLmluZGV4T2YoJzsnKSk7XG5cbiAgICB2YXIgcmVzcG9uc2UgPSBudWxsO1xuICAgIGlmIChodHRwUmVxdWVzdC5yZXNwb25zZVR5cGUgPT0gXCJhcnJheWJ1ZmZlclwiKSB7XG4gICAgICAgIHJlc3BvbnNlID0gaHR0cFJlcXVlc3QucmVzcG9uc2U7XG4gICAgfSBlbHNlIGlmIChjbGVhbmVkTWltZXR5cGUubWF0Y2goL2pzb24vKSkge1xuICAgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UoaHR0cFJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICB9IGVsc2UgaWYgKGNsZWFuZWRNaW1ldHlwZS5tYXRjaCgveG1sLykpIHtcbiAgICAgICAgcmVzcG9uc2UgPSBodHRwUmVxdWVzdC5yZXNwb25zZVhNTDtcbiAgICAgICAgLy9Xb3JrYXJvdW5kIGZvciBJRSBcImJ1Z1wiIHdoZXJlIGV4dGVybmFsIGRvY3VtZW50cyBhbHdheXMgcmVwb3J0IHRoZWlyIGRvY3VtZW50LlVSTCBhcyBiZWluZyBpZGVudGljYWwgdG8gd2luZG93LmxvY2F0aW9uLmhyZWZcbiAgICAgICAgcmVzcG9uc2UuX2RvY3VtZW50VVJMID0gdXJsO1xuICAgICAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkludmFsaWQgZXh0ZXJuYWwgWE1MIGRvY3VtZW50ICdcIiArIGh0dHBSZXF1ZXN0Ll91cmwgK1xuICAgICAgICAgICAgICAgIFwiJzogWE1MIFN5bnRheCBlcnJvclwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2xlYW5lZE1pbWV0eXBlID09IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgfHwgbWltZXR5cGUubWF0Y2goL3RleHRcXC9wbGFpbi8pKSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiUG9zc2libHkgd3JvbmcgbG9hZGluZyBvZiByZXNvdXJjZSBcIiArIHVybCArIFwiLiBNaW1ldHlwZSBpcyBcIiArIG1pbWV0eXBlICsgXCIgYnV0IHJlc3BvbnNlIGlzIG5vdCBhbiBBcnJheUJ1ZmZlclwiKTtcbiAgICAgICAgcmVzcG9uc2UgPSBodHRwUmVxdWVzdC5yZXNwb25zZTtcbiAgICB9IGVsc2UgaWYgKGNsZWFuZWRNaW1ldHlwZSA9PSBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIiB8fCBtaW1ldHlwZSA9PSBcInRleHQvamF2YXNjcmlwdFwiKSB7XG4gICAgICAgIHJlc3BvbnNlID0gaHR0cFJlcXVlc3QucmVzcG9uc2U7XG4gICAgfWVsc2Uge1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlVuaWRlbnRpZmllZCByZXNwb25zZSB0eXBlIChyZXNwb25zZSA9ICdcIiArIGh0dHBSZXF1ZXN0LnJlc3BvbnNlICsgXCInLCByZXNwb25zZVR5cGUgPSAnXCIgKyBodHRwUmVxdWVzdC5yZXNwb25zZVR5cGUgKyBcIicpXCIpO1xuICAgICAgICByZXNwb25zZSA9IGh0dHBSZXF1ZXN0LnJlc3BvbnNlO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXRIYW5kbGVyID0gZmluZEZvcm1hdChyZXNwb25zZSwgaHR0cFJlcXVlc3QucmVzcG9uc2VUeXBlLCBjbGVhbmVkTWltZXR5cGUpO1xuICAgIGlmICghZm9ybWF0SGFuZGxlcikge1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIk5vIGZvcm1hdCBoYW5kbGVyIGZvciByZXNvdXJjZSAocmVzcG9uc2UgPSAnXCIgKyByZXNwb25zZSArIFwiJywgcmVzcG9uc2VUeXBlID0gJ1wiICsgaHR0cFJlcXVlc3QucmVzcG9uc2VUeXBlICsgXCInKVwiKTtcbiAgICAgICAgaW52YWxpZGF0ZURvY3VtZW50SGFuZGxlcyh1cmwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRvY0NhY2hlLmZvcm1hdCA9IGZvcm1hdEhhbmRsZXI7XG4gICAgZm9ybWF0SGFuZGxlci5nZXRGb3JtYXREYXRhKHJlc3BvbnNlLCBodHRwUmVxdWVzdC5yZXNwb25zZVR5cGUsIGNsZWFuZWRNaW1ldHlwZSwgZnVuY3Rpb24oc3VjY2VzcywgcmVzdWx0KXtcbiAgICAgICAgaWYoc3VjY2Vzcyl7XG4gICAgICAgICAgICBkb2NDYWNoZS5yZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHVwZGF0ZURvY3VtZW50SGFuZGxlcyh1cmwpXG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGludmFsaWRhdGVEb2N1bWVudEhhbmRsZXModXJsKTtcbiAgICAgICAgfVxuICAgIH0gKTtcblxufVxuXG4vKipcbiAqIFVwZGF0ZSBhbGwgZXhpc3RpbmcgaGFuZGxlcyBvZiBhIHJlY2VpdmVkIGRvY3VtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZURvY3VtZW50SGFuZGxlcyh1cmwpIHtcbiAgICB2YXIgZG9jQ2FjaGUgPSBjX2NhY2hlZERvY3VtZW50c1t1cmxdO1xuICAgIHZhciBmcmFnbWVudHMgPSBkb2NDYWNoZS5mcmFnbWVudHM7XG4gICAgZG9jQ2FjaGUuZnJhZ21lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFnbWVudHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdXBkYXRlRXh0ZXJuYWxIYW5kbGVzKHVybCwgZnJhZ21lbnRzW2ldKTtcbiAgICB9XG59XG5cbi8qKlxuICogSW52YWxpZGF0ZSBhbGwgaGFuZGxlcyBvZiBhIGRvY3VtZW50LCB0aGF0IGNvdWxkIG5vdCBiZSBsb2FkZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgdGhlIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIGludmFsaWRhdGVEb2N1bWVudEhhbmRsZXModXJsKSB7XG4gICAgdmFyIGRvY0NhY2hlID0gY19jYWNoZWREb2N1bWVudHNbdXJsXTtcbiAgICB2YXIgZnJhZ21lbnRzID0gZG9jQ2FjaGUuZnJhZ21lbnRzO1xuICAgIGRvY0NhY2hlLmZyYWdtZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZnJhZ21lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBmdWxsVXJsID0gdXJsICsgKGZyYWdtZW50c1tpXSA/IFwiI1wiICsgZnJhZ21lbnRzW2ldIDogXCJcIik7XG4gICAgICAgIGludmFsaWRhdGVIYW5kbGVzKGZ1bGxVcmwpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgYWxsIGhhbmRsZXMgb2YgYSBwYXJ0IGZyb20gYW4gZXh0ZXJuYWwgZG9jdW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgZG9jdW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcmFnbWVudCBGcmFnbWVudCB3aXRob3V0IHBvdW5kIGtleSB3aGljaCBkZWZpbmVzIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudFxuICovXG5mdW5jdGlvbiB1cGRhdGVFeHRlcm5hbEhhbmRsZXModXJsLCBmcmFnbWVudCkge1xuXG4gICAgdmFyIHJlc3BvbnNlID0gY19jYWNoZWREb2N1bWVudHNbdXJsXS5yZXNwb25zZTtcbiAgICB2YXIgbWltZXR5cGUgPSBjX2NhY2hlZERvY3VtZW50c1t1cmxdLm1pbWV0eXBlO1xuICAgIHZhciBmb3JtYXQgPSBjX2NhY2hlZERvY3VtZW50c1t1cmxdLmZvcm1hdDtcblxuICAgIHZhciBmdWxsVXJsID0gdXJsICsgKGZyYWdtZW50ID8gXCIjXCIgKyBmcmFnbWVudCA6IFwiXCIpO1xuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgLy8gSW4gdGhlIGNhc2UgdGhlIGxvYWRlZCBkb2N1bWVudCBpcyBub3Qgc3VwcG9ydGVkIHdlIHN0aWxsIG5lZWQgdG8gZGVjcmVtZW50IGNvdW50ZXIgb2JqZWN0XG4gICAgICAgIGludmFsaWRhdGVIYW5kbGVzKGZ1bGxVcmwpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gZ2V0IHBhcnQgb2YgdGhlIHJlc291cmNlIHJlcHJlc2VudGVkIGJ5IHRoZSBmcmFnbWVudFxuICAgIHZhciBkYXRhID0gZm9ybWF0LmdldEZyYWdtZW50RGF0YShyZXNwb25zZSwgZnJhZ21lbnQpO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgdXBkYXRlTWlzc2luZ0hhbmRsZXMoZnVsbFVybCwgZm9ybWF0LCBkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGludmFsaWRhdGVIYW5kbGVzKGZ1bGxVcmwpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIFVwZGF0ZSBhbGwgQWRhcHRlckhhbmRsZXMgd2l0aG91dCBhZGFwdGVycyBvZiBhIGNlcnRhaW4gdXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBjb21wbGV0ZSB1cmwgKyBmcmFnbWVudFxuICogQHBhcmFtIHtGb3JtYXRIYW5kbGVyfSBmb3JtYXRIYW5kbGVyIEZvcm1hdCBoYW5kbGVyXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBEYXRhIG9mIHRoZSBkb2N1bWVudCBjb3JyZXNwb25kaW5nIHRvIHRoZSB1cmwuIFBvc3NpYmx5IGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGxvY2FsQ2hhbmdlIElmIHRydWUsIHRoZW4gdGhpcyBpcyBhYm91dCBhIGxvY2FsIGlkIGNoYW5nZS4gZG8gbm90IGNhbGwgbG9hZENvbXBsZXRlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZU1pc3NpbmdIYW5kbGVzKHVybCwgZm9ybWF0SGFuZGxlciwgZGF0YSwgbG9jYWxDaGFuZ2UpIHtcbiAgICBmb3IgKHZhciBhZGFwdGVyVHlwZSBpbiBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF0pIHtcbiAgICAgICAgZm9yICh2YXIgY2FudmFzSWQgaW4gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdW2FkYXB0ZXJUeXBlXSkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJsXVthZGFwdGVyVHlwZV1bY2FudmFzSWRdO1xuICAgICAgICAgICAgaWYgKCFoYW5kbGUuaGFzQWRhcHRlcigpKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlSGFuZGxlKGhhbmRsZSwgYWRhcHRlclR5cGUsICtjYW52YXNJZCwgZm9ybWF0SGFuZGxlciwgZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYoIWxvY2FsQ2hhbmdlKSBsb2FkQ29tcGxldGUoY2FudmFzSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEludmFsaWRhdGUgYWxsIEFkYXB0ZXJIYW5kbGVzIHdpdGhvdXQgYWRhcHRlcnMgb2YgYSBjZXJ0YWluIHVybFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgY29tcGxldGUgdXJsICsgZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gaW52YWxpZGF0ZUhhbmRsZXModXJsKSB7XG4gICAgZm9yICh2YXIgYWRhcHRlclR5cGUgaW4gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdKSB7XG4gICAgICAgIGZvciAodmFyIGNhbnZhc0lkIGluIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJsXVthZGFwdGVyVHlwZV0pIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF1bYWRhcHRlclR5cGVdW2NhbnZhc0lkXTtcbiAgICAgICAgICAgIGhhbmRsZS5zZXRBZGFwdGVyKG51bGwsIEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCk7XG4gICAgICAgICAgICBsb2FkQ29tcGxldGUoY2FudmFzSWQpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSBhIHNwZWNpZmljIEFkYXB0ZXJIYW5kbGUgd2l0aCB0aGUgcHJvdmlkZWQgZGF0YS5cbiAqIEludGVybmFsbHkgYW4gYWRhcHRlciB3aWxsIGJlIGNyZWF0ZWQgd2l0aCAnZGF0YScgYW5kIGFkZGVkIHRvICdoYW5kbGUnXG4gKiBBbGwgb3RoZXIgYXJndW1lbnQgYXJlIHJlcXVpcmVkIHRvIGZpbmQgdGhlIGNvcnJlY3QgZmFjdG9yeVxuICogQHBhcmFtIHtBZGFwdGVySGFuZGxlfSBoYW5kbGUgVGhlIEFkYXB0ZXJIYW5kbGUgdG8gYmUgdXBkYXRlZFxuICogQHBhcmFtIHtPYmplY3R9IGFkYXB0ZXJUeXBlIFRoZSB0eXBlIC8gYXNwZWN0IG9mIHRoZSBhZGFwdGVyIChlLmcuIFhNTDNELmRhdGEgb3IgWE1MM0Qud2ViZ2wpXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWQgSWQgb2YgY29ycmVzcG9uZGluZyBjYW52YXMgaGFuZGxlci4gMCBpZiBub3QgZGVwZW5kZW50IG9mIGNhbnZhcyBoYW5kbGVyXG4gKiBAcGFyYW0ge0Zvcm1hdEhhbmRsZXJ9IGZvcm1hdCBGb3JtYXQgaGFuZGxlciBvZiB0aGUgY29ycmVzcG9uZGluZyBkb2N1bWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgRGF0YSBmb3IgdGhpcyBoYW5kbGUuIFBvc3NpYmx5IGEgRE9NIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdXBkYXRlSGFuZGxlKGhhbmRsZSwgYWRhcHRlclR5cGUsIGNhbnZhc0lkLCBmb3JtYXQsIGRhdGEpIHtcblxuICAgIHZhciBmYWN0b3J5ID0gZm9ybWF0LmdldEZhY3RvcnkoYWRhcHRlclR5cGUsIGNhbnZhc0lkKTtcblxuICAgIGlmKCFmYWN0b3J5KSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiRm9ybWF0IGRvZXMgbm90IHN1cHBvcnQgYWRhcHRlclR5cGUgXCIgKyBhZGFwdGVyVHlwZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgYWRhcHRlciA9IGZhY3RvcnkuZ2V0QWRhcHRlciA/IGZhY3RvcnkuZ2V0QWRhcHRlcihkYXRhKSA6IGZhY3RvcnkuY3JlYXRlQWRhcHRlcihkYXRhKTtcbiAgICBpZiAoYWRhcHRlcikge1xuICAgICAgICBoYW5kbGUuc2V0QWRhcHRlcihhZGFwdGVyLCBBZGFwdGVySGFuZGxlLlNUQVRVUy5SRUFEWSk7XG4gICAgfVxuXG5cbn1cblxuLyoqXG4gKiBSZW1vdmUgdGhlIGFkYXB0ZXIgb2YgYWxsIEFkYXB0ZXJIYW5kbGVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIFVSTC5cbiAqIFRoaXMgaXMgY2FsbGVkIGUuZy4gd2hlbiBhIG5vZGUgaXMgcmVtb3ZlIGZyb20gdGhlIGRvY3VtZW50LCBvciBhbiBpZCBjaGFuZ2VzXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgb2YgYWxsIEFkYXB0ZXJIYW5kbGVzIHRvIGJlIGNsZWFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNsZWFySGFuZGxlcyh1cmwpIHtcbiAgICBmb3IgKHZhciBhZGFwdGVyVHlwZSBpbiBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VybF0pIHtcbiAgICAgICAgZm9yICh2YXIgY2FudmFzSWQgaW4gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmxdW2FkYXB0ZXJUeXBlXSkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJsXVthZGFwdGVyVHlwZV1bY2FudmFzSWRdO1xuICAgICAgICAgICAgaWYgKGhhbmRsZS5oYXNBZGFwdGVyKCkpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGUuc2V0QWRhcHRlcihudWxsLCBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kcyByZXR1cm5zIGFuIGFic29sdXRlIFVSSSBjb21wYXRpYmxlIHdpdGggdGhlIHJlc291cmNlIG1hbmFnZXIuXG4gKiBUaGlzIG1lYW5zOiBBbnkgcmVmZXJlbmNlIGZyb20gYW4gZXh0ZXJuYWwgZG9jdW1lbnQgd2lsbCBiZSBhYnNvbHV0ZSBhbmQgYW55IGlkIHJlZmVyZW5jZSBmcm9tIHRoZSBjdXJyZW50XG4gKiBkb2N1bWVudCB3aWxsIHJlbWFpbiBhbiBpZCByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZVVSSSAtIHRoZSBiYXNlIFVSSSB0aGF0IHRoZSB1cmkgaXMgcmVsYXRpdmUgdG9cbiAqIEBwYXJhbSB7VVJJfSB1cmkgLSBUaGUgVVJJIHVzZWQgdG8gZmluZCB0aGUgcmVmZXJyZWQgQWRhcHRlckhhbmRsZS4gQ2FuIGJlIHJlbGF0aXZlXG4gKiBAcmV0dXJucyB7VVJJfSBUaGUgKHNvbWV0aW1lcykgYWJzb2x1dGUgVVJJXG4gKi9cblJlc291cmNlLmdldEFic29sdXRlVVJJID0gZnVuY3Rpb24oYmFzZVVSSSwgdXJpKXtcbiAgICBpZiAoIXVyaSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAodHlwZW9mIHVyaSA9PSBcInN0cmluZ1wiKSB1cmkgPSBuZXcgVVJJKHVyaSk7XG4gICAgaWYgKGJhc2VVUkkgIT0gZG9jdW1lbnQuVVJMIHx8ICF1cmkuaXNMb2NhbCgpKSB7XG4gICAgICAgIHVyaSA9IHVyaS5nZXRBYnNvbHV0ZVVSSShiYXNlVVJJKTtcbiAgICB9XG4gICAgcmV0dXJuIHVyaTtcbn07XG5cbi8qKlxuICogR2V0IGFueSBhZGFwdGVyLCBpbnRlcm5hbCBvciBleHRlcm5hbC5cbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCB0cmlnZ2VyIHRoZSBsb2FkaW5nIG9mIGRvY3VtZW50cywgaWYgcmVxdWlyZWQuXG4gKiBBbiBBZGFwdGVySGFuZGxlIHdpbGwgYmUgYWx3YXlzIGJlIHJldHVybmVkLCBleHBlY3Qgd2hlbiBhbiBpbnZhbGlkIChlbXB0eSkgdXJpIGlzIHBhc3NlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZVVSSSAtIHRoZSBiYXNlIFVSSSBmcm9tIHdoaWNoIHRvIGxvb2sgdXAgdGhlIHJlZmVyZW5jZVxuICogQHBhcmFtIHtVUkl9IHVyaSAtIFRoZSBVUkkgdXNlZCB0byBmaW5kIHRoZSByZWZlcnJlZCBBZGFwdGVySGFuZGxlLiBDYW4gYmUgcmVsYXRpdmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBub2RlTmFtZSBUaGUgdGFnIG5hbWUgb2YgdGhlIGVsZW1lbnQgcmVmZXJlbmNpbmcgdGhpcyBhZGFwdGVyIGhhbmRsZVxuICogQHBhcmFtIHtPYmplY3R9IGFkYXB0ZXJUeXBlIFRoZSB0eXBlIG9mIGFkYXB0ZXIgcmVxdWlyZWQgKGUuZy4gWE1MM0QuZGF0YSBvciBYTUwzRC53ZWJnbClcbiAqIEBwYXJhbSB7bnVtYmVyPX0gY2FudmFzSWQgSWQgb2YgR0xDYW52YXNIYW5kbGVyIGhhbmRsZXIgdGhpcyBhZGFwdGVyIGRlcGVuZHMgb24sIDAgaWYgbm90IGRlcGVuZGluZyBvbiBhbnkgR0xDYW52YXNIYW5kbGVyXG4gKiBAcmV0dXJucyB7P0FkYXB0ZXJIYW5kbGV9IFRoZSByZXF1ZXN0ZWQgQWRhcHRlckhhbmRsZXIuIE5vdGU6IG1pZ2h0IGJlIG51bGxcbiAqL1xuUmVzb3VyY2UuZ2V0QWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKGJhc2VVUkksIHVyaSwgYWRhcHRlclR5cGUsIGNhbnZhc0lkLCBub2RlTmFtZSkge1xuICAgIGNhbnZhc0lkID0gY2FudmFzSWQgfHwgMDtcbiAgICB1cmkgPSBSZXNvdXJjZS5nZXRBYnNvbHV0ZVVSSShiYXNlVVJJLCB1cmkpO1xuXG4gICAgaWYgKCF1cmkpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgaWYgKCFjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VyaV0pXG4gICAgICAgIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXSA9IHt9O1xuXG4gICAgaWYgKCFjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VyaV1bYWRhcHRlclR5cGVdKSB7XG4gICAgICAgIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXVthZGFwdGVyVHlwZV0gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgaGFuZGxlID0gY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FkYXB0ZXJUeXBlXVtjYW52YXNJZF07XG4gICAgaWYgKGhhbmRsZSlcbiAgICAgICAgcmV0dXJuIGhhbmRsZTtcblxuICAgIGhhbmRsZSA9IG5ldyBBZGFwdGVySGFuZGxlKHVyaSk7XG4gICAgY19jYWNoZWRBZGFwdGVySGFuZGxlc1t1cmldW2FkYXB0ZXJUeXBlXVtjYW52YXNJZF0gPSBoYW5kbGU7XG5cbiAgICBpZiAodXJpLmlzTG9jYWwoKSkge1xuICAgICAgICB2YXIgbm9kZSA9IFVSSVJlc29sdmVyLnJlc29sdmVMb2NhbCh1cmkpO1xuICAgICAgICBpZiAobm9kZSlcbiAgICAgICAgICAgIHVwZGF0ZUhhbmRsZShoYW5kbGUsIGFkYXB0ZXJUeXBlLCBjYW52YXNJZCwgWE1MM0QueG1sM2RGb3JtYXRIYW5kbGVyLCBub2RlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgaGFuZGxlLnNldEFkYXB0ZXIobnVsbCwgQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBjb3VudGVyT2JqZWN0ID0gZ2V0T3JDcmVhdGVDb3VudGVyT2JqZWN0KGNhbnZhc0lkKTtcbiAgICAgICAgY291bnRlck9iamVjdC5jb3VudGVyKys7XG5cbiAgICAgICAgdmFyIGRvY1VSSSA9IHVyaS50b1N0cmluZ1dpdGhvdXRGcmFnbWVudCgpO1xuICAgICAgICB2YXIgZG9jRGF0YSA9IGNfY2FjaGVkRG9jdW1lbnRzW2RvY1VSSV07XG4gICAgICAgIGlmIChkb2NEYXRhICYmIGRvY0RhdGEucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHVwZGF0ZUV4dGVybmFsSGFuZGxlcyhkb2NVUkksIHVyaS5mcmFnbWVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWRvY0RhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWNjZXB0VHlwZSA9IGdldEFjY2VwdFR5cGVGb3JOb2RlKG5vZGVOYW1lLCBkb2NVUkkpO1xuICAgICAgICAgICAgICAgIGxvYWREb2N1bWVudChkb2NVUkksIGFjY2VwdFR5cGUpO1xuICAgICAgICAgICAgICAgIGNfY2FjaGVkRG9jdW1lbnRzW2RvY1VSSV0gPSBkb2NEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudHM6IFtdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvY0RhdGEuZnJhZ21lbnRzLnB1c2godXJpLmZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlO1xufTtcblxuZnVuY3Rpb24gZ2V0QWNjZXB0VHlwZUZvck5vZGUobm9kZU5hbWUsIHVyaSkge1xuICAgIG5vZGVOYW1lID0gbm9kZU5hbWUgfHwgXCJcIjtcbiAgICBzd2l0Y2gobm9kZU5hbWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlIFwibW9kZWxcIjpcbiAgICAgICAgICAgIHJldHVybiBcIm1vZGVsL3ZuZC54bWwzZC5tb2RlbCt4bWxcIjtcbiAgICAgICAgY2FzZSBcIm1lc2hcIjpcbiAgICAgICAgY2FzZSBcImRhdGFcIjpcbiAgICAgICAgICAgIGlmICh1cmkucGF0aCAmJiB1cmkucGF0aC5tYXRjaCgvXFwuanNvbi8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibW9kZWwvdm5kLnhtbDNkLm1lc2granNvblwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtb2RlbC92bmQueG1sM2QubWVzaCt4bWxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBcIm1vZGVsL3ZuZC54bWwzZC5tZXNoK3htbFwiO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXQgYW55IGFkYXB0ZXIsIGludGVybmFsIG9yIGV4dGVybmFsLlxuICpcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gYWRhcHRlclR5cGVcbiAqIEBwYXJhbSBjYW52YXNJZFxuICogQHJldHVybiB7WE1MM0QuYmFzZS5BZGFwdGVyP31cbiAqL1xuUmVzb3VyY2UuZ2V0QWRhcHRlciA9IGZ1bmN0aW9uKG5vZGUsIGFkYXB0ZXJUeXBlLCBjYW52YXNJZCkge1xuICAgIHZhciBmYWN0b3J5ID0gWE1MM0QueG1sM2RGb3JtYXRIYW5kbGVyLmdldEZhY3RvcnkoYWRhcHRlclR5cGUsIGNhbnZhc0lkKTtcbiAgICBpZiAoZmFjdG9yeSkge1xuICAgICAgICByZXR1cm4gZmFjdG9yeS5nZXRBZGFwdGVyKG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBhbiBpZCBvZiBhbiBlbGVtZW50IGNoYW5nZXMgb3IgaWYgdGhhdCBlbGVtZW50IGlzIG5vdyByZWFjaGFibGVcbiAqIG9yIG5vdCByZWFjaGFibGUgYW55bW9yZS4gSXQgd2lsbCB1cGRhdGUgYWxsIEFkYXB0ZXJIYW5kbGVzIGNvbm5lY3RlZCB0byB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IG9mIHdoaWNoIGlkIGhhcyBjaGFuZ2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJldmlvdXNJZCBQcmV2aW91cyBpZCBvZiBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3SWQgTmV3IGlkIG9mIGVsZW1lbnRcbiAqL1xuUmVzb3VyY2Uubm90aWZ5Tm9kZUlkQ2hhbmdlID0gZnVuY3Rpb24obm9kZSwgcHJldmlvdXNJZCwgbmV3SWQpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZTtcbiAgICB3aGlsZSAocGFyZW50LnBhcmVudE5vZGUpIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgIGlmIChwYXJlbnQgIT0gd2luZG93LmRvY3VtZW50KVxuICAgICAgICByZXR1cm47XG5cbiAgICAvLyBjbGVhciBjYWNoZWQgYWRhcHRlcnMgb2YgcHJldmlvdXMgaWRcIlxuICAgIGlmIChwcmV2aW91c0lkKSB7XG4gICAgICAgIGNsZWFySGFuZGxlcyhcIiNcIiArIHByZXZpb3VzSWQpO1xuICAgIH1cbiAgICBpZiAobmV3SWQpIHtcbiAgICAgICAgdXBkYXRlTWlzc2luZ0hhbmRsZXMoXCIjXCIgKyBuZXdJZCwgWE1MM0QueG1sM2RGb3JtYXRIYW5kbGVyLCBub2RlLCB0cnVlKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIG5vdGlmeSBhbiBBZGFwdGVySGFuZGxlciBhYm91dCBhIGNoYW5nZSAoY2FuIGJlIHRyaWdnZXJlZCB0aHJvdWdoIGFkYXB0ZXJzKVxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gb25seSB3b3JrcyB3aXRoIG5vZGVzIGluc2lkZSB3aW5kb3cuZG9jdW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IG9mIEFkYXB0ZXJIYW5kbGVyLiBNdXN0IGJlIGZyb20gd2luZG93LmRvY3VtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gYWRhcHRlclR5cGUgVHlwZS9Bc3BlY3Qgb2YgQWRhcHRlckhhbmRsZXIgKGUuZy4gWE1MM0QuZGF0YSBvciBYTUwzRC53ZWJnbClcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNJZCBHTENhbnZhc0hhbmRsZXIgaWQgb2YgQWRhcHRlckhhbmRsZXIsIDAgaWYgbm90IGRlcGVuZGluZyBvbiBHTENhbnZhc0hhbmRsZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFR5cGUgb2YgTm90aWZpY2F0aW9uLiBVc3VhbGx5IEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEXG4gKi9cblJlc291cmNlLm5vdGlmeU5vZGVBZGFwdGVyQ2hhbmdlID0gZnVuY3Rpb24oZWxlbWVudCwgYWRhcHRlclR5cGUsIGNhbnZhc0lkLCB0eXBlKSB7XG4gICAgY2FudmFzSWQgPSBjYW52YXNJZCB8fCAwO1xuICAgIHZhciB1cmkgPSBcIiNcIiArIGVsZW1lbnQuaWQ7XG4gICAgaWYgKGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXSAmJiBjX2NhY2hlZEFkYXB0ZXJIYW5kbGVzW3VyaV1bYWRhcHRlclR5cGVdICYmXG4gICAgICAgIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXVthZGFwdGVyVHlwZV1bY2FudmFzSWRdKSB7XG4gICAgICAgIGNfY2FjaGVkQWRhcHRlckhhbmRsZXNbdXJpXVthZGFwdGVyVHlwZV1bY2FudmFzSWRdLm5vdGlmeUxpc3RlbmVycyh0eXBlKTtcbiAgICB9XG59O1xuXG5cbi8qKlxuICogTG9hZCBkYXRhIHZpYSBYTUxIdHRwUmVxdWVzdFxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIG9mIHRoZSBkb2N1bWVudFxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpfSBsb2FkTGlzdGVuZXIgR2V0cyB0aGUgcmVzcG9uc2Ugb2YgdGhlIFhIUlxuICogQHBhcmFtIHtmdW5jdGlvbihYTUxIdHRwUmVxdWVzdCl9IGVycm9yTGlzdGVuZXIgR2V0IHRoZSBYSFIgb2JqZWN0IGZvciBmdXJ0aGVyIGFuYWx5c2lzXG4gKi9cblJlc291cmNlLmxvYWREYXRhID0gZnVuY3Rpb24odXJsLCBsb2FkTGlzdGVuZXIsIGVycm9yTGlzdGVuZXIpIHtcbiAgICB2YXIgeG1sSHR0cCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgeG1sSHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgeG1sSHR0cCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh4bWxIdHRwKSB7XG4gICAgICAgIHhtbEh0dHAuX3VybCA9IHVybDtcbiAgICAgICAgeG1sSHR0cC5fY29udGVudENoZWNrZWQgPSBmYWxzZTtcbiAgICAgICAgeG1sSHR0cC5vcGVuKCdHRVQnLCB1cmwsIHRydWUpO1xuICAgICAgICBpZiAoaXNCaW5hcnlFeHRlbnNpb24odXJsKSlcbiAgICAgICAgICAgIHhtbEh0dHAucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuXG4gICAgICAgIHhtbEh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoeG1sSHR0cC5fYWJvcnRlZCkgLy8gVGhpcyBjaGVjayBpcyBwb3NzaWJseSBub3QgbmVlZGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gY2hlY2sgY29tcGF0aWJpbGl0eSBiZXR3ZWVuIGNvbnRlbnQgYW5kIHJlcXVlc3QgbW9kZVxuICAgICAgICAgICAgaWYgKCF4bWxIdHRwLl9jb250ZW50Q2hlY2tlZCAmJlxuICAgICAgICAgICAgICAgIC8vIDIgLSBIRUFERVJTX1JFQ0VJVkVELCAzIC0gTE9BRElORywgNCAtIERPTkVcbiAgICAgICAgICAgICAgICAoKHhtbEh0dHAucmVhZHlTdGF0ZSA9PSAyIHx8IHhtbEh0dHAucmVhZHlTdGF0ZSA9PSAzIHx8IHhtbEh0dHAucmVhZHlTdGF0ZSA9PSA0KSAmJlxuICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLnN0YXR1cyA9PSAyMDApKSB7XG4gICAgICAgICAgICAgICAgeG1sSHR0cC5fY29udGVudENoZWNrZWQgPSB0cnVlOyAvLyB3ZSBjaGVjayBvbmx5IG9uY2VcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGNoYW5nZSByZXF1ZXN0IG1vZGVcbiAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGUgPSB4bWxIdHRwLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluYXJ5Q29udGVudCA9IGlzQmluYXJ5Q29udGVudFR5cGUoY29udGVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmluYXJ5UmVxdWVzdCA9ICh4bWxIdHRwLnJlc3BvbnNlVHlwZSA9PSBcImFycmF5YnVmZmVyXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGNvbnRlbnQgaXMgbm90IHRoZSBzYW1lIGFzIHJlcXVlc3QsIHdlIG5lZWQgdG8gcmVwZWF0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJpbmFyeUNvbnRlbnQgIT0gYmluYXJ5UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5fYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2IgPSB4bWxIdHRwLm9ucmVhZHlzdGF0ZWNoYW5nZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSB4bWxIdHRwLl91cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICB4bWxIdHRwLmFib3J0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGRvIG5vdCByZWN5Y2xlIFhNTEh0dHBSZXF1ZXN0ICFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIFRoaXMgZG9lcyB3b3JrIG9ubHkgd2hlbiByZXNwb25zZVR5cGUgaXMgY2hhbmdlZCB0byBcImFycmF5YnVmZmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBob3dldmVyIHRoZSBzaXplIG9mIHRoZSB4bWxIdHRwLnJlc3BvbnNlIGJ1ZmZlciBpcyB0aGVuIHdyb25nICFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIEl0IGRvZXMgbm90IHdvcmsgYXQgYWxsIChhdCBsZWFzdCBpbiBDaHJvbWUpIHdoZW4gd2UgdXNlIG92ZXJyaWRlTWltZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgIHdpdGggXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCIgYXJndW1lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgICBUaGUgbGF0dGVyIG1vZGUgcmVxdWlyZSBjcmVhdGlvbiBvZiB0aGUgZnJlc2ggWE1MSHR0cFJlcXVlc3QuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuX3VybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuX2NvbnRlbnRDaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAub3BlbignR0VUJywgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlDb250ZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgeG1sSHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBjYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhtbEh0dHAuc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcXVlc3QgbW9kZSBhbmQgY29udGVudCB0eXBlIGFyZSBjb21wYXRpYmxlIGhlcmUgKGJvdGggYmluYXJ5IG9yIGJvdGggdGV4dClcbiAgICAgICAgICAgIGlmICh4bWxIdHRwLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgIGlmICh4bWxIdHRwLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJMb2FkZWQ6IFwiICsgeG1sSHR0cC5fdXJsKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgbWltZXR5cGUgPSB4bWxIdHRwLmdldFJlc3BvbnNlSGVhZGVyKFwiY29udGVudC10eXBlXCIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh4bWxIdHRwLnJlc3BvbnNlVHlwZSA9PSBcImFycmF5YnVmZmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geG1sSHR0cC5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtaW1ldHlwZSA9PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHhtbEh0dHAucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtaW1ldHlwZSA9PSBcImFwcGxpY2F0aW9uL3htbFwiIHx8IG1pbWV0eXBlID09IFwidGV4dC94bWxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSB4bWxIdHRwLnJlc3BvbnNlWE1MO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1pbWV0eXBlID09IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgfHwgbWltZXR5cGUgPT0gXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiUG9zc2libHkgd3JvbmcgbG9hZGluZyBvZiByZXNvdXJjZSBcIiArIHVybCArIFwiLiBNaW1ldHlwZSBpcyBcIiArIG1pbWV0eXBlICsgXCIgYnV0IHJlc3BvbnNlIGlzIG5vdCBhbiBBcnJheUJ1ZmZlclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0geG1sSHR0cC5yZXNwb25zZVRleHQ7IC8vIEZJWE1FIGlzIHRoaXMgY29ycmVjdCA/XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvYWRMaXN0ZW5lcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRMaXN0ZW5lcihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBsb2FkIGV4dGVybmFsIGRvY3VtZW50ICdcIiArIHhtbEh0dHAuX3VybCArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIic6IFwiICsgeG1sSHR0cC5zdGF0dXMgKyBcIiAtIFwiICsgeG1sSHR0cC5zdGF0dXNUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yTGlzdGVuZXIpXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvckxpc3RlbmVyKHhtbEh0dHApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeG1sSHR0cC5zZW5kKG51bGwpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gbG9hZCBhbiBJbWFnZS5cbiAqXG4gKiBAcGFyYW0ge1VSSX0gdXJpIEltYWdlIFVSSVxuICogQHBhcmFtIHtmdW5jdGlvbihFdmVudCwgSFRNTEltYWdlRWxlbWVudCl9IGxvYWRMaXN0ZW5lciBGdW5jdGlvbiBjYWxsZWQgd2hlbiBpbWFnZSB3YXMgc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGV2ZW50IGFzIHRoZSBmaXJzdCBhbmQgaW1hZ2UgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50LCBIVE1MSW1hZ2VFbGVtZW50KX0gZXJyb3JMaXN0ZW5lciBGdW5jdGlvbiBjYWxsZWQgd2hlbiBpbWFnZSBjb3VsZCBub3QgYmUgbG9hZGVkLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGV2ZW50IGFzIHRoZSBmaXJzdCBhbmQgaW1hZ2UgYXMgdGhlIHNlY29uZCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fVxuICovXG5SZXNvdXJjZS5nZXRJbWFnZSA9IGZ1bmN0aW9uKHVyaSwgbG9hZExpc3RlbmVyLCBlcnJvckxpc3RlbmVyKSB7XG4gICAgLy8gd2UgdXNlIGNhbnZhc0lkIDAgdG8gcmVwcmVzZW50IGltYWdlcyBsb2FkZWQgaW4gYSBkb2N1bWVudFxuICAgIGdldE9yQ3JlYXRlQ291bnRlck9iamVjdCgwKS5jb3VudGVyKys7XG5cbiAgICB2YXIgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGxvYWRMaXN0ZW5lcihlLCBpbWFnZSk7XG4gICAgICAgIGxvYWRDb21wbGV0ZSgwKTtcbiAgICB9O1xuICAgIGltYWdlLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGVycm9yTGlzdGVuZXIoZSwgaW1hZ2UpO1xuICAgICAgICBsb2FkQ29tcGxldGUoMCk7XG4gICAgfTtcbiAgICBpZighdXJpLmhhc1NhbWVPcmlnaW4oZG9jdW1lbnQubG9jYXRpb24uaHJlZikpIHtcbiAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSBPcHRpb25zLmdldFZhbHVlKE9QVElPTl9SRVNPVVJDRV9DT1JTKTtcbiAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIllvdSBhcmUgdXNpbmcgYW4gY3Jvc3Mtb3JpZ2luIGltYWdlIGFzIHRleHR1cmUuIFRoaXMgbWlnaHQgY2F1c2UgdHJvdWJsZXMgY2F1c2UgdGhlIGNhbnZhcyBpcyAndGFpbnRlZCcuXCIpXG4gICAgfVxuXG4gICAgaW1hZ2Uuc3JjID0gdXJpLnRvU3RyaW5nKCk7IC8vIGhlcmUgbG9hZGluZyBzdGFydHNcbiAgICByZXR1cm4gaW1hZ2U7XG59O1xuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgdG8gbG9hZCBhIFZpZGVvLlxuICpcbiAqIEBwYXJhbSB7VVJJfSB1cmkgVmlkZW8gVVJJXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9wbGF5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvb3BcbiAqIEBwYXJhbSB7T2JqZWN0fSBsaXN0ZW5lcnMgIERpY3Rpb25hcnkgb2YgYWxsIGxpc3RlbmVycyB0byByZWdpc3RlciB3aXRoIHZpZGVvIGVsZW1lbnQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMaXN0ZW5lcnMgd2lsbCBiZSBjYWxsZWQgd2l0aCBldmVudCBhcyB0aGUgZmlyc3QgYW5kIHZpZGVvIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyLlxuICogQHJldHVybiB7SFRNTFZpZGVvRWxlbWVudH1cbiAqL1xuUmVzb3VyY2UuZ2V0VmlkZW8gPSBmdW5jdGlvbih1cmksIGF1dG9wbGF5LCBsb29wLCBsaXN0ZW5lcnMpIHtcbiAgICAvLyB3ZSB1c2UgY2FudmFzSWQgMCB0byByZXByZXNlbnQgdmlkZW9zIGxvYWRlZCBpbiBhIGRvY3VtZW50XG4gICAgZ2V0T3JDcmVhdGVDb3VudGVyT2JqZWN0KDApLmNvdW50ZXIrKztcblxuICAgIC8vIEZJWE1FOiBJbiBIVE1MLCB3ZSBjcmVhdGUgYSBjb25maWd1cmVkIHZpZGVvLCBwbGF5L3BhdXNlIHdvbid0IHdvcmtcbiAgICB2YXIgdmlkZW8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidmlkZW9cIik7XG5cbiAgICB2YXIgbG9hZENvbXBsZXRlQ2FsbGJhY2sgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICBsb2FkQ29tcGxldGUoMCk7XG4gICAgICAgIHZpZGVvLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjYW5wbGF5XCIsIGxvYWRDb21wbGV0ZUNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgdmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGxvYWRDb21wbGV0ZUNhbGxiYWNrLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgaWYgKCF1cmkuaGFzU2FtZU9yaWdpbihkb2N1bWVudC5sb2NhdGlvbi5ocmVmKSkge1xuICAgICAgICB2aWRlby5jcm9zc09yaWdpbiA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX1JFU09VUkNFX0NPUlMpO1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiWW91IGFyZSB1c2luZyBhbiBjcm9zcy1vcmlnaW4gdmlkZW8gYXMgdGV4dHVyZS4gVGhpcyBtaWdodCBjYXVzZSB0cm91YmxlcyBjYXVzZSB0aGUgY2FudmFzIGlzICd0YWludGVkJy5cIiwgdXJpKVxuICAgIH1cblxuICAgIHZpZGVvLmF1dG9wbGF5ID0gYXV0b3BsYXk7XG4gICAgdmlkZW8ubG9vcCA9IGxvb3A7XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKGV2ZW50LCB2aWRlbyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGxpc3RlbmVycykge1xuICAgICAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY3JlYXRlQ2FsbGJhY2sobGlzdGVuZXJzW2V2ZW50TmFtZV0pLCB0cnVlKTtcbiAgICB9XG5cbiAgICB2aWRlby5hZGRFdmVudExpc3RlbmVyKFwiY2FucGxheVwiLCBsb2FkQ29tcGxldGVDYWxsYmFjaywgdHJ1ZSk7XG4gICAgdmlkZW8uYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGxvYWRDb21wbGV0ZUNhbGxiYWNrLCB0cnVlKTtcblxuICAgIHZpZGVvLnNyYyA9IHVyaS50b1N0cmluZygpOyAvLyBoZXJlIGxvYWRpbmcgc3RhcnRzXG4gICAgcmV0dXJuIHZpZGVvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVnaXN0ZXJGYWN0b3J5OiByZWdpc3RlckZhY3RvcnksXG4gICAgcmVnaXN0ZXJGb3JtYXQ6IHJlZ2lzdGVyRm9ybWF0LFxuICAgIGZpbmRGb3JtYXQ6IGZpbmRGb3JtYXQsXG4gICAgUmVzb3VyY2U6IFJlc291cmNlXG59O1xuIiwiLypqc2xpbnQgd2hpdGU6IGZhbHNlLCBvbmV2YXI6IGZhbHNlLCB1bmRlZjogdHJ1ZSwgbm9tZW46IHRydWUsIGVxZXFlcTogdHJ1ZSwgcGx1c3BsdXM6IHRydWUsIGJpdHdpc2U6IHRydWUsIHJlZ2V4cDogdHJ1ZSwgbmV3Y2FwOiB0cnVlLCBpbW1lZDogdHJ1ZSwgc3ViOiB0cnVlLCBub21lbjogZmFsc2UgKi9cblxuLyoqXG4qIFRoaXMgZmlsZSBjb250YWlucyBjb2RlIHRoYXQgbWF5IGJlIHVuZGVyIHRoZSBmb2xsb3dpbmcgbGljZW5zZTpcbipcbiogU0dJIEZSRUUgU09GVFdBUkUgTElDRU5TRSBCIChWZXJzaW9uIDIuMCwgU2VwdC4gMTgsIDIwMDgpXG4qIENvcHlyaWdodCAoQykgMTk5MS0yMDAwIFNpbGljb24gR3JhcGhpY3MsIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbipcbiogU2VlIGh0dHA6Ly9vc3Muc2dpLmNvbS9wcm9qZWN0cy9GcmVlQi8gZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4qXG4qIEFsbCBjb2RlIGluIHRoaXMgZmlsZSB3aGljaCBpcyBOT1QgdW5kZXIgdGhlIFNHSSBGUkVFIFNPRlRXQVJFIExJQ0VOU0UgQlxuKiBpcyBmcmVlIGFuZCB1bmVuY3VtYmVyZWQgc29mdHdhcmUgcmVsZWFzZWQgaW50byB0aGUgcHVibGljIGRvbWFpbi5cbipcbiogQW55b25lIGlzIGZyZWUgdG8gY29weSwgbW9kaWZ5LCBwdWJsaXNoLCB1c2UsIGNvbXBpbGUsIHNlbGwsIG9yXG4qIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSwgZWl0aGVyIGluIHNvdXJjZSBjb2RlIGZvcm0gb3IgYXMgYSBjb21waWxlZFxuKiBiaW5hcnksIGZvciBhbnkgcHVycG9zZSwgY29tbWVyY2lhbCBvciBub24tY29tbWVyY2lhbCwgYW5kIGJ5IGFueVxuKiBtZWFucy5cbipcbiogSW4ganVyaXNkaWN0aW9ucyB0aGF0IHJlY29nbml6ZSBjb3B5cmlnaHQgbGF3cywgdGhlIGF1dGhvciBvciBhdXRob3JzXG4qIG9mIHRoaXMgc29mdHdhcmUgZGVkaWNhdGUgYW55IGFuZCBhbGwgY29weXJpZ2h0IGludGVyZXN0IGluIHRoZVxuKiBzb2Z0d2FyZSB0byB0aGUgcHVibGljIGRvbWFpbi4gV2UgbWFrZSB0aGlzIGRlZGljYXRpb24gZm9yIHRoZSBiZW5lZml0XG4qIG9mIHRoZSBwdWJsaWMgYXQgbGFyZ2UgYW5kIHRvIHRoZSBkZXRyaW1lbnQgb2Ygb3VyIGhlaXJzIGFuZFxuKiBzdWNjZXNzb3JzLiBXZSBpbnRlbmQgdGhpcyBkZWRpY2F0aW9uIHRvIGJlIGFuIG92ZXJ0IGFjdCBvZlxuKiByZWxpbnF1aXNobWVudCBpbiBwZXJwZXR1aXR5IG9mIGFsbCBwcmVzZW50IGFuZCBmdXR1cmUgcmlnaHRzIHRvIHRoaXNcbiogc29mdHdhcmUgdW5kZXIgY29weXJpZ2h0IGxhdy5cbipcbiogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiogRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4qIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiogSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1JcbiogT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsXG4qIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuKiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4qL1xuXG52YXIgR0xVID0ge307XG4vKipcbiogVW5wcm9qZWN0IGEgc2NyZWVuIHBvaW50LlxuKlxuKiBAcGFyYW0ge251bWJlcn0gd2luWCB0aGUgd2luZG93IHBvaW50IGZvciB0aGUgeCB2YWx1ZS5cbiogQHBhcmFtIHtudW1iZXJ9IHdpblkgdGhlIHdpbmRvdyBwb2ludCBmb3IgdGhlIHkgdmFsdWUuXG4qIEBwYXJhbSB7bnVtYmVyfSB3aW5aIHRoZSB3aW5kb3cgcG9pbnQgZm9yIHRoZSB6IHZhbHVlLlxuKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtb2RlbCB0aGUgbW9kZWwtdmlldyBtYXRyaXguXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHByb2ogdGhlIHByb2plY3Rpb24gbWF0cml4LlxuKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2aWV3IHRoZSB2aWV3cG9ydCBjb29yZGluYXRlIGFycmF5LlxuKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvYmpQb3MgdGhlIG1vZGVsIHBvaW50IHJlc3VsdC5cbiogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdW5wcm9qZWN0IG9wZXJhdGlvbiB3YXMgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlLlxuKi9cbkdMVS51blByb2plY3QgPSBmdW5jdGlvbih3aW5YLCB3aW5ZLCB3aW5aLCBtb2RlbCwgcHJvaiwgdmlldywgb2JqUG9zKSB7XG5cbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgIHZhciBpbnAgPSBbXG4gICAgICAgIHdpblgsXG4gICAgICAgIHdpblksXG4gICAgICAgIHdpblosXG4gICAgICAgIDEuMFxuICAgIF07XG5cbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgIHZhciBmaW5hbE1hdHJpeCA9IFtdO1xuXG4gICAgR0xVLm11bHRNYXRyaWNlcyhtb2RlbCwgcHJvaiwgZmluYWxNYXRyaXgpO1xuICAgIGlmICghR0xVLmludmVydE1hdHJpeChmaW5hbE1hdHJpeCwgZmluYWxNYXRyaXgpKSB7XG4gICAgICAgIHJldHVybiAoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qIE1hcCB4IGFuZCB5IGZyb20gd2luZG93IGNvb3JkaW5hdGVzICovXG4gICAgaW5wWzBdID0gKGlucFswXSAtIHZpZXdbMF0pIC8gdmlld1syXTtcbiAgICBpbnBbMV0gPSAoaW5wWzFdIC0gdmlld1sxXSkgLyB2aWV3WzNdO1xuXG4gICAgLyogTWFwIHRvIHJhbmdlIC0xIHRvIDEgKi9cbiAgICBpbnBbMF0gPSBpbnBbMF0gKiAyIC0gMTtcbiAgICBpbnBbMV0gPSBpbnBbMV0gKiAyIC0gMTtcbiAgICBpbnBbMl0gPSBpbnBbMl0gKiAyIC0gMTtcblxuICAgIC8qKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59ICovXG4gICAgdmFyIG91dCA9IFtdO1xuXG4gICAgR0xVLm11bHRNYXRyaXhWZWMoZmluYWxNYXRyaXgsIGlucCwgb3V0KTtcblxuICAgIGlmIChvdXRbM10gPT09IDAuMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgb3V0WzBdIC89IG91dFszXTtcbiAgICBvdXRbMV0gLz0gb3V0WzNdO1xuICAgIG91dFsyXSAvPSBvdXRbM107XG5cbiAgICBvYmpQb3NbMF0gPSBvdXRbMF07XG4gICAgb2JqUG9zWzFdID0gb3V0WzFdO1xuICAgIG9ialBvc1syXSA9IG91dFsyXTtcblxuICAgIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4qIE11bHRpcGx5IHRoZSBtYXRyaXggYnkgdGhlIHNwZWNpZmllZCB2ZWN0b3IuXG4qXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1hdHJpeCB0aGUgbWF0cml4LlxuKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBpbnAgdGhlIHZlY3Rvci5cbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IHRoZSBvdXRwdXQuXG4qL1xuR0xVLm11bHRNYXRyaXhWZWMgPSBmdW5jdGlvbihtYXRyaXgsIGlucCwgb3V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpID0gaSArIDEpIHtcbiAgICAgICAgb3V0W2ldID1cbiAgICAgICAgICAgIGlucFswXSAqIG1hdHJpeFswICogNCArIGldICtcbiAgICAgICAgICAgIGlucFsxXSAqIG1hdHJpeFsxICogNCArIGldICtcbiAgICAgICAgICAgIGlucFsyXSAqIG1hdHJpeFsyICogNCArIGldICtcbiAgICAgICAgICAgIGlucFszXSAqIG1hdHJpeFszICogNCArIGldO1xuICAgIH1cbn07XG5cbi8qKlxuKiBNdWx0aXBseSB0aGUgc3BlY2lmaWVkIG1hdHJpY2VzLlxuKlxuKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhIHRoZSBmaXJzdCBtYXRyaXguXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGIgdGhlIHNlY29uZCBtYXRyaXguXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHIgdGhlIHJlc3VsdC5cbiovXG5HTFUubXVsdE1hdHJpY2VzID0gZnVuY3Rpb24oYSwgYiwgcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSA9IGkgKyAxKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgNDsgaiA9IGogKyAxKSB7XG4gICAgICAgICAgICByW2kgKiA0ICsgal0gPVxuICAgICAgICAgICAgICAgIGFbaSAqIDQgKyAwXSAqIGJbMCAqIDQgKyBqXSArXG4gICAgICAgICAgICAgICAgYVtpICogNCArIDFdICogYlsxICogNCArIGpdICtcbiAgICAgICAgICAgICAgICBhW2kgKiA0ICsgMl0gKiBiWzIgKiA0ICsgal0gK1xuICAgICAgICAgICAgICAgIGFbaSAqIDQgKyAzXSAqIGJbMyAqIDQgKyBqXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuKiBJbnZlcnQgYSBtYXRyaXguXG4qXG4qIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG0gdGhlIG1hdHJpeC5cbiogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW52T3V0IHRoZSBpbnZlcnRlZCBvdXRwdXQuXG4qIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgc3VjY2Vzc2Z1bCwgZmFsc2Ugb3RoZXJ3aXNlLlxuKi9cbkdMVS5pbnZlcnRNYXRyaXggPSBmdW5jdGlvbihtLCBpbnZPdXQpIHtcbiAgICAvKiogQHR5cGUge0FycmF5LjxudW1iZXI+fSAqL1xuICAgIHZhciBpbnYgPSBbXTtcblxuICAgIGludlswXSA9IG1bNV0gKiBtWzEwXSAqIG1bMTVdIC0gbVs1XSAqIG1bMTFdICogbVsxNF0gLSBtWzldICogbVs2XSAqIG1bMTVdICtcbiAgICAgICAgbVs5XSAqIG1bN10gKiBtWzE0XSArIG1bMTNdICogbVs2XSAqIG1bMTFdIC0gbVsxM10gKiBtWzddICogbVsxMF07XG4gICAgaW52WzRdID0gLW1bNF0gKiBtWzEwXSAqIG1bMTVdICsgbVs0XSAqIG1bMTFdICogbVsxNF0gKyBtWzhdICogbVs2XSAqIG1bMTVdIC1cbiAgICAgICAgbVs4XSAqIG1bN10gKiBtWzE0XSAtIG1bMTJdICogbVs2XSAqIG1bMTFdICsgbVsxMl0gKiBtWzddICogbVsxMF07XG4gICAgaW52WzhdID0gbVs0XSAqIG1bOV0gKiBtWzE1XSAtIG1bNF0gKiBtWzExXSAqIG1bMTNdIC0gbVs4XSAqIG1bNV0gKiBtWzE1XSArXG4gICAgICAgIG1bOF0gKiBtWzddICogbVsxM10gKyBtWzEyXSAqIG1bNV0gKiBtWzExXSAtIG1bMTJdICogbVs3XSAqIG1bOV07XG4gICAgaW52WzEyXSA9IC1tWzRdICogbVs5XSAqIG1bMTRdICsgbVs0XSAqIG1bMTBdICogbVsxM10gKyBtWzhdICogbVs1XSAqIG1bMTRdIC1cbiAgICAgICAgbVs4XSAqIG1bNl0gKiBtWzEzXSAtIG1bMTJdICogbVs1XSAqIG1bMTBdICsgbVsxMl0gKiBtWzZdICogbVs5XTtcbiAgICBpbnZbMV0gPSAtbVsxXSAqIG1bMTBdICogbVsxNV0gKyBtWzFdICogbVsxMV0gKiBtWzE0XSArIG1bOV0gKiBtWzJdICogbVsxNV0gLVxuICAgICAgICBtWzldICogbVszXSAqIG1bMTRdIC0gbVsxM10gKiBtWzJdICogbVsxMV0gKyBtWzEzXSAqIG1bM10gKiBtWzEwXTtcbiAgICBpbnZbNV0gPSBtWzBdICogbVsxMF0gKiBtWzE1XSAtIG1bMF0gKiBtWzExXSAqIG1bMTRdIC0gbVs4XSAqIG1bMl0gKiBtWzE1XSArXG4gICAgICAgIG1bOF0gKiBtWzNdICogbVsxNF0gKyBtWzEyXSAqIG1bMl0gKiBtWzExXSAtIG1bMTJdICogbVszXSAqIG1bMTBdO1xuICAgIGludls5XSA9IC1tWzBdICogbVs5XSAqIG1bMTVdICsgbVswXSAqIG1bMTFdICogbVsxM10gKyBtWzhdICogbVsxXSAqIG1bMTVdIC1cbiAgICAgICAgbVs4XSAqIG1bM10gKiBtWzEzXSAtIG1bMTJdICogbVsxXSAqIG1bMTFdICsgbVsxMl0gKiBtWzNdICogbVs5XTtcbiAgICBpbnZbMTNdID0gbVswXSAqIG1bOV0gKiBtWzE0XSAtIG1bMF0gKiBtWzEwXSAqIG1bMTNdIC0gbVs4XSAqIG1bMV0gKiBtWzE0XSArXG4gICAgICAgIG1bOF0gKiBtWzJdICogbVsxM10gKyBtWzEyXSAqIG1bMV0gKiBtWzEwXSAtIG1bMTJdICogbVsyXSAqIG1bOV07XG4gICAgaW52WzJdID0gbVsxXSAqIG1bNl0gKiBtWzE1XSAtIG1bMV0gKiBtWzddICogbVsxNF0gLSBtWzVdICogbVsyXSAqIG1bMTVdICtcbiAgICAgICAgbVs1XSAqIG1bM10gKiBtWzE0XSArIG1bMTNdICogbVsyXSAqIG1bN10gLSBtWzEzXSAqIG1bM10gKiBtWzZdO1xuICAgIGludls2XSA9IC1tWzBdICogbVs2XSAqIG1bMTVdICsgbVswXSAqIG1bN10gKiBtWzE0XSArIG1bNF0gKiBtWzJdICogbVsxNV0gLVxuICAgICAgICBtWzRdICogbVszXSAqIG1bMTRdIC0gbVsxMl0gKiBtWzJdICogbVs3XSArIG1bMTJdICogbVszXSAqIG1bNl07XG4gICAgaW52WzEwXSA9IG1bMF0gKiBtWzVdICogbVsxNV0gLSBtWzBdICogbVs3XSAqIG1bMTNdIC0gbVs0XSAqIG1bMV0gKiBtWzE1XSArXG4gICAgICAgIG1bNF0gKiBtWzNdICogbVsxM10gKyBtWzEyXSAqIG1bMV0gKiBtWzddIC0gbVsxMl0gKiBtWzNdICogbVs1XTtcbiAgICBpbnZbMTRdID0gLW1bMF0gKiBtWzVdICogbVsxNF0gKyBtWzBdICogbVs2XSAqIG1bMTNdICsgbVs0XSAqIG1bMV0gKiBtWzE0XSAtXG4gICAgICAgIG1bNF0gKiBtWzJdICogbVsxM10gLSBtWzEyXSAqIG1bMV0gKiBtWzZdICsgbVsxMl0gKiBtWzJdICogbVs1XTtcbiAgICBpbnZbM10gPSAtbVsxXSAqIG1bNl0gKiBtWzExXSArIG1bMV0gKiBtWzddICogbVsxMF0gKyBtWzVdICogbVsyXSAqIG1bMTFdIC1cbiAgICAgICAgbVs1XSAqIG1bM10gKiBtWzEwXSAtIG1bOV0gKiBtWzJdICogbVs3XSArIG1bOV0gKiBtWzNdICogbVs2XTtcbiAgICBpbnZbN10gPSBtWzBdICogbVs2XSAqIG1bMTFdIC0gbVswXSAqIG1bN10gKiBtWzEwXSAtIG1bNF0gKiBtWzJdICogbVsxMV0gK1xuICAgICAgICBtWzRdICogbVszXSAqIG1bMTBdICsgbVs4XSAqIG1bMl0gKiBtWzddIC0gbVs4XSAqIG1bM10gKiBtWzZdO1xuICAgIGludlsxMV0gPSAtbVswXSAqIG1bNV0gKiBtWzExXSArIG1bMF0gKiBtWzddICogbVs5XSArIG1bNF0gKiBtWzFdICogbVsxMV0gLVxuICAgICAgICBtWzRdICogbVszXSAqIG1bOV0gLSBtWzhdICogbVsxXSAqIG1bN10gKyBtWzhdICogbVszXSAqIG1bNV07XG4gICAgaW52WzE1XSA9IG1bMF0gKiBtWzVdICogbVsxMF0gLSBtWzBdICogbVs2XSAqIG1bOV0gLSBtWzRdICogbVsxXSAqIG1bMTBdICtcbiAgICAgICAgbVs0XSAqIG1bMl0gKiBtWzldICsgbVs4XSAqIG1bMV0gKiBtWzZdIC0gbVs4XSAqIG1bMl0gKiBtWzVdO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdmFyIGRldCA9IG1bMF0gKiBpbnZbMF0gKyBtWzFdICogaW52WzRdICsgbVsyXSAqIGludls4XSArIG1bM10gKiBpbnZbMTJdO1xuXG4gICAgaWYgKGRldCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZGV0ID0gMS4wIC8gZGV0O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSA9IGkgKyAxKSB7XG4gICAgICAgIGludk91dFtpXSA9IGludltpXSAqIGRldDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR0xVOyIsIi8vIERvbWFpbiBQdWJsaWMgYnkgRXJpYyBXZW5kZWxpbiBodHRwOi8vZXJpd2VuLmNvbS8gKDIwMDgpXG4vLyAgICAgICAgICAgICAgICAgIEx1a2UgU21pdGggaHR0cDovL2x1Y2Fzc21pdGgubmFtZS8gKDIwMDgpXG4vLyAgICAgICAgICAgICAgICAgIExvaWMgRGFjaGFyeSA8bG9pY0BkYWNoYXJ5Lm9yZz4gKDIwMDgpXG4vLyAgICAgICAgICAgICAgICAgIEpvaGFuIEV1cGhyb3NpbmUgPHByb3BweUBhbWluY2hlLmNvbT4gKDIwMDgpXG4vLyAgICAgICAgICAgICAgICAgIE95dmluZCBTZWFuIEtpbnNleSBodHRwOi8va2luc2V5Lm5vL2Jsb2cgKDIwMTApXG4vLyAgICAgICAgICAgICAgICAgIFZpY3RvciBIb215YWtvdiA8dmljdG9yLWhvbXlha292QHVzZXJzLnNvdXJjZWZvcmdlLm5ldD4gKDIwMTApXG5cblxuLyoqXG4gKiBNYWluIGZ1bmN0aW9uIGdpdmluZyBhIGZ1bmN0aW9uIHN0YWNrIHRyYWNlIHdpdGggYSBmb3JjZWQgb3IgcGFzc2VkIGluXG4gKiBFcnJvclxuICpcbiAqIEBjZmcge0Vycm9yfSBlIFRoZSBlcnJvciB0byBjcmVhdGUgYSBzdGFja3RyYWNlIGZyb20gKG9wdGlvbmFsKVxuICogQGNmZyB7Qm9vbGVhbn0gZ3Vlc3MgSWYgd2Ugc2hvdWxkIHRyeSB0byByZXNvbHZlIHRoZSBuYW1lcyBvZiBhbm9ueW1vdXNcbiAqIGZ1bmN0aW9uc1xuICogQHJldHVybiB7QXJyYXl9IG9mIFN0cmluZ3Mgd2l0aCBmdW5jdGlvbnMsIGxpbmVzLCBmaWxlcywgYW5kIGFyZ3VtZW50c1xuICogd2hlcmUgcG9zc2libGVcbiAqL1xudmFyIHByaW50U3RhY2tUcmFjZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge1xuICAgICAgICBndWVzcyA6IHRydWVcbiAgICB9O1xuICAgIHZhciBleCA9IG9wdGlvbnMuZSB8fCBudWxsLCBndWVzcyA9ICEhb3B0aW9ucy5ndWVzcztcbiAgICB2YXIgcCA9IG5ldyBwcmludFN0YWNrVHJhY2UuaW1wbGVtZW50YXRpb24oKSwgcmVzdWx0ID0gcC5ydW4oZXgpO1xuICAgIHJldHVybiAoZ3Vlc3MpID8gcC5ndWVzc0Fub255bW91c0Z1bmN0aW9ucyhyZXN1bHQpIDogcmVzdWx0O1xufTtcblxucHJpbnRTdGFja1RyYWNlLmltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24oKSB7fTtcblxucHJpbnRTdGFja1RyYWNlLmltcGxlbWVudGF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Vycm9yfSBleCBUaGUgZXJyb3IgdG8gY3JlYXRlIGEgc3RhY2t0cmFjZSBmcm9tIChvcHRpb25hbClcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSBGb3JjZWQgbW9kZSAob3B0aW9uYWwsIG1vc3RseSBmb3IgdW5pdCB0ZXN0cylcbiAgICAgKi9cbiAgICBydW4gOiBmdW5jdGlvbihleCwgbW9kZSkge1xuICAgICAgICBleCA9IGV4IHx8IHRoaXMuY3JlYXRlRXhjZXB0aW9uKCk7XG4gICAgICAgIC8vIGV4YW1pbmUgZXhjZXB0aW9uIHByb3BlcnRpZXMgdy9vIGRlYnVnZ2VyXG4gICAgICAgIC8vIGZvciAodmFyIHByb3AgaW4gZXgpIHthbGVydChcIkV4WydcIiArIHByb3AgKyBcIiddPVwiICsgZXhbcHJvcF0pO31cbiAgICAgICAgbW9kZSA9IG1vZGUgfHwgdGhpcy5tb2RlKGV4KTtcbiAgICAgICAgaWYgKG1vZGUgPT09ICdvdGhlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm90aGVyKGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbbW9kZV0oZXgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZUV4Y2VwdGlvbiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy51bmRlZigpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNb2RlIGNvdWxkIGRpZmZlciBmb3IgZGlmZmVyZW50IGV4Y2VwdGlvbiwgZS5nLiBleGNlcHRpb25zIGluIENocm9tZVxuICAgICAqIG1heSBvciBtYXkgbm90IGhhdmUgYXJndW1lbnRzIG9yIHN0YWNrLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBtb2RlIG9mIG9wZXJhdGlvbiBmb3IgdGhlIGV4Y2VwdGlvblxuICAgICAqL1xuICAgIG1vZGUgOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlWydhcmd1bWVudHMnXSAmJiBlLnN0YWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Nocm9tZSc7XG4gICAgICAgIH0gZWxzZSBpZiAoZS5zdGFjayAmJiBlLnNvdXJjZVVSTCkge1xuICAgICAgICAgICAgcmV0dXJuICdzYWZhcmknO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBlLm1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5vcGVyYSkge1xuICAgICAgICAgICAgLy8gZS5tZXNzYWdlLmluZGV4T2YoXCJCYWNrdHJhY2U6XCIpID4gLTEgLT4gb3BlcmFcbiAgICAgICAgICAgIC8vICFlLnN0YWNrdHJhY2UgLT4gb3BlcmFcbiAgICAgICAgICAgIGlmICghZS5zdGFja3RyYWNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvcGVyYTknOyAvLyB1c2UgZS5tZXNzYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAnb3BlcmEjc291cmNlbG9jJyBpbiBlIC0+IG9wZXJhOSwgb3BlcmExMGFcbiAgICAgICAgICAgIGlmIChlLm1lc3NhZ2UuaW5kZXhPZignXFxuJykgPiAtMSAmJiBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCA+IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJykubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdvcGVyYTknOyAvLyB1c2UgZS5tZXNzYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlLnN0YWNrdHJhY2UgJiYgIWUuc3RhY2sgLT4gb3BlcmExMGFcbiAgICAgICAgICAgIGlmICghZS5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnb3BlcmExMGEnOyAvLyB1c2UgZS5zdGFja3RyYWNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlLnN0YWNrdHJhY2UgJiYgZS5zdGFjayAtPiBvcGVyYTEwYlxuICAgICAgICAgICAgaWYgKGUuc3RhY2t0cmFjZS5pbmRleE9mKFwiY2FsbGVkIGZyb20gbGluZVwiKSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ29wZXJhMTBiJzsgLy8gdXNlIGUuc3RhY2t0cmFjZSwgZm9ybWF0IGRpZmZlcnMgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ29wZXJhMTBhJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZS5zdGFja3RyYWNlICYmIGUuc3RhY2sgLT4gb3BlcmExMVxuICAgICAgICAgICAgcmV0dXJuICdvcGVyYTExJzsgLy8gdXNlIGUuc3RhY2t0cmFjZSwgZm9ybWF0IGRpZmZlcnMgZnJvbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAnb3BlcmExMGEnLCAnb3BlcmExMGInXG4gICAgICAgIH0gZWxzZSBpZiAoZS5zdGFjaykge1xuICAgICAgICAgICAgcmV0dXJuICdmaXJlZm94JztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBjb250ZXh0LCBmdW5jdGlvbiBuYW1lLCBhbmQgY2FsbGJhY2sgZnVuY3Rpb24sIG92ZXJ3cml0ZSBpdFxuICAgICAqIHNvIHRoYXQgaXQgY2FsbHMgcHJpbnRTdGFja1RyYWNlKCkgZmlyc3Qgd2l0aCBhIGNhbGxiYWNrIGFuZCB0aGVuXG4gICAgICogcnVucyB0aGUgcmVzdCBvZiB0aGUgYm9keS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IG9mIGV4ZWN1dGlvbiAoZS5nLiB3aW5kb3cpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZ1bmN0aW9uTmFtZSB0byBpbnN0cnVtZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuY3Rpb24gdG8gY2FsbCB3aXRoIGEgc3RhY2sgdHJhY2Ugb24gaW52b2NhdGlvblxuICAgICAqL1xuICAgIGluc3RydW1lbnRGdW5jdGlvbiA6IGZ1bmN0aW9uKGNvbnRleHQsIGZ1bmN0aW9uTmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgd2luZG93O1xuICAgICAgICB2YXIgb3JpZ2luYWwgPSBjb250ZXh0W2Z1bmN0aW9uTmFtZV07XG4gICAgICAgIGNvbnRleHRbZnVuY3Rpb25OYW1lXSA9IGZ1bmN0aW9uIGluc3RydW1lbnRlZCgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpcywgcHJpbnRTdGFja1RyYWNlKCkuc2xpY2UoNCkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHRbZnVuY3Rpb25OYW1lXS5faW5zdHJ1bWVudGVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnRleHRbZnVuY3Rpb25OYW1lXS5faW5zdHJ1bWVudGVkID0gb3JpZ2luYWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgY29udGV4dCBhbmQgZnVuY3Rpb24gbmFtZSBvZiBhIGZ1bmN0aW9uIHRoYXQgaGFzIGJlZW5cbiAgICAgKiBpbnN0cnVtZW50ZWQsIHJldmVydCB0aGUgZnVuY3Rpb24gdG8gaXQncyBvcmlnaW5hbCAobm9uLWluc3RydW1lbnRlZClcbiAgICAgKiBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0IG9mIGV4ZWN1dGlvbiAoZS5nLiB3aW5kb3cpXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGZ1bmN0aW9uTmFtZSB0byBkZS1pbnN0cnVtZW50XG4gICAgICovXG4gICAgZGVpbnN0cnVtZW50RnVuY3Rpb24gOiBmdW5jdGlvbihjb250ZXh0LCBmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKGNvbnRleHRbZnVuY3Rpb25OYW1lXS5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24gJiYgY29udGV4dFtmdW5jdGlvbk5hbWVdLl9pbnN0cnVtZW50ZWRcbiAgICAgICAgICAgICAgICAmJiBjb250ZXh0W2Z1bmN0aW9uTmFtZV0uX2luc3RydW1lbnRlZC5jb25zdHJ1Y3RvciA9PT0gRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnRleHRbZnVuY3Rpb25OYW1lXSA9IGNvbnRleHRbZnVuY3Rpb25OYW1lXS5faW5zdHJ1bWVudGVkO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgcmV0dXJuIGEgZm9ybWF0dGVkIEFycmF5IGJhc2VkIG9uIENocm9tZSdzXG4gICAgICogc3RhY2sgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGUgLSBFcnJvciBvYmplY3QgdG8gaW5zcGVjdFxuICAgICAqIEByZXR1cm4gQXJyYXk8U3RyaW5nPiBvZiBmdW5jdGlvbiBjYWxscywgZmlsZXMgYW5kIGxpbmUgbnVtYmVyc1xuICAgICAqL1xuICAgIGNocm9tZSA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHN0YWNrID0gKGUuc3RhY2sgKyAnXFxuJykucmVwbGFjZSgvXlxcU1teXFwoXSs/W1xcbiRdL2dtLCAnJykucmVwbGFjZSgvXlxccysoYXQgZXZhbCApP2F0XFxzKy9nbSwgJycpLnJlcGxhY2UoL14oW15cXChdKz8pKFtcXG4kXSkvZ20sXG4gICAgICAgICAgICAgICAgJ3thbm9ueW1vdXN9KClAJDEkMicpLnJlcGxhY2UoL15PYmplY3QuPGFub255bW91cz5cXHMqXFwoKFteXFwpXSspXFwpL2dtLCAne2Fub255bW91c30oKUAkMScpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gRXJyb3Igb2JqZWN0LCByZXR1cm4gYSBmb3JtYXR0ZWQgQXJyYXkgYmFzZWQgb24gU2FmYXJpJ3NcbiAgICAgKiBzdGFjayBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZSAtIEVycm9yIG9iamVjdCB0byBpbnNwZWN0XG4gICAgICogQHJldHVybiBBcnJheTxTdHJpbmc+IG9mIGZ1bmN0aW9uIGNhbGxzLCBmaWxlcyBhbmQgbGluZSBudW1iZXJzXG4gICAgICovXG4gICAgc2FmYXJpIDogZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZS5zdGFjay5yZXBsYWNlKC9cXFtuYXRpdmUgY29kZVxcXVxcbi9tLCAnJykucmVwbGFjZSgvXkAvZ20sICd7YW5vbnltb3VzfSgpQCcpLnNwbGl0KCdcXG4nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gRXJyb3Igb2JqZWN0LCByZXR1cm4gYSBmb3JtYXR0ZWQgQXJyYXkgYmFzZWQgb24gRmlyZWZveCdzXG4gICAgICogc3RhY2sgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGUgLSBFcnJvciBvYmplY3QgdG8gaW5zcGVjdFxuICAgICAqIEByZXR1cm4gQXJyYXk8U3RyaW5nPiBvZiBmdW5jdGlvbiBjYWxscywgZmlsZXMgYW5kIGxpbmUgbnVtYmVyc1xuICAgICAqL1xuICAgIGZpcmVmb3ggOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLnN0YWNrLnJlcGxhY2UoLyg/OlxcbkA6MCk/XFxzKyQvbSwgJycpLnJlcGxhY2UoL15bXFwoQF0vZ20sICd7YW5vbnltb3VzfSgpQCcpLnNwbGl0KCdcXG4nKTtcbiAgICB9LFxuXG4gICAgb3BlcmExMSA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBsaW5lUkUgPSAvXi4qbGluZSAoXFxkKyksIGNvbHVtbiAoXFxkKykoPzogaW4gKC4rKSk/IGluIChcXFMrKTokLztcbiAgICAgICAgdmFyIGxpbmVzID0gZS5zdGFja3RyYWNlLnNwbGl0KCdcXG4nKSwgcmVzdWx0ID0gW107XG5cbiAgICAgICAgZm9yICggdmFyIGkgPSAwLCBsZW4gPSBsaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gbWF0Y2hbNF0gKyAnOicgKyBtYXRjaFsxXSArICc6JyArIG1hdGNoWzJdO1xuICAgICAgICAgICAgICAgIHZhciBmbk5hbWUgPSBtYXRjaFszXSB8fCBcImdsb2JhbCBjb2RlXCI7XG4gICAgICAgICAgICAgICAgZm5OYW1lID0gZm5OYW1lLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb246IChcXFMrKT4vLCBcIiQxXCIpLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24+LywgQU5PTik7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZm5OYW1lICsgJ0AnICsgbG9jYXRpb24gKyAnIC0tICcgKyBsaW5lc1tpICsgMV0ucmVwbGFjZSgvXlxccysvLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgb3BlcmExMGIgOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIFwiPGFub255bW91cyBmdW5jdGlvbjogcnVuPihbYXJndW1lbnRzIG5vdFxuICAgICAgICAvLyBhdmFpbGFibGVdKUBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3N0YWNrdHJhY2UuanM6MjdcXG5cIiArXG4gICAgICAgIC8vIFwicHJpbnRTdGFja1RyYWNlKFthcmd1bWVudHMgbm90XG4gICAgICAgIC8vIGF2YWlsYWJsZV0pQGZpbGU6Ly9sb2NhbGhvc3QvRzovanMvc3RhY2t0cmFjZS5qczoxOFxcblwiICtcbiAgICAgICAgLy8gXCJAZmlsZTovL2xvY2FsaG9zdC9HOi9qcy90ZXN0L2Z1bmN0aW9uYWwvdGVzdGNhc2UxLmh0bWw6MTVcIlxuICAgICAgICB2YXIgbGluZVJFID0gL14oLiopQCguKyk6KFxcZCspJC87XG4gICAgICAgIHZhciBsaW5lcyA9IGUuc3RhY2t0cmFjZS5zcGxpdCgnXFxuJyksIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZvciAoIHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIHZhciBmbk5hbWUgPSBtYXRjaFsxXSA/IChtYXRjaFsxXSArICcoKScpIDogXCJnbG9iYWwgY29kZVwiO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZuTmFtZSArICdAJyArIG1hdGNoWzJdICsgJzonICsgbWF0Y2hbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gRXJyb3Igb2JqZWN0LCByZXR1cm4gYSBmb3JtYXR0ZWQgQXJyYXkgYmFzZWQgb24gT3BlcmEgMTAnc1xuICAgICAqIHN0YWNrdHJhY2Ugc3RyaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIGUgLSBFcnJvciBvYmplY3QgdG8gaW5zcGVjdFxuICAgICAqIEByZXR1cm4gQXJyYXk8U3RyaW5nPiBvZiBmdW5jdGlvbiBjYWxscywgZmlsZXMgYW5kIGxpbmUgbnVtYmVyc1xuICAgICAqL1xuICAgIG9wZXJhMTBhIDogZnVuY3Rpb24oZSkge1xuICAgICAgICAvLyBcIiBMaW5lIDI3IG9mIGxpbmtlZCBzY3JpcHRcbiAgICAgICAgLy8gZmlsZTovL2xvY2FsaG9zdC9HOi9qcy9zdGFja3RyYWNlLmpzXFxuXCJcbiAgICAgICAgLy8gXCIgTGluZSAxMSBvZiBpbmxpbmUjMSBzY3JpcHQgaW5cbiAgICAgICAgLy8gZmlsZTovL2xvY2FsaG9zdC9HOi9qcy90ZXN0L2Z1bmN0aW9uYWwvdGVzdGNhc2UxLmh0bWw6IEluXG4gICAgICAgIC8vIGZ1bmN0aW9uIGZvb1xcblwiXG4gICAgICAgIHZhciBBTk9OID0gJ3thbm9ueW1vdXN9JywgbGluZVJFID0gL0xpbmUgKFxcZCspLipzY3JpcHQgKD86aW4gKT8oXFxTKykoPzo6IEluIGZ1bmN0aW9uIChcXFMrKSk/JC9pO1xuICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLCByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgZm5OYW1lID0gbWF0Y2hbM10gfHwgQU5PTjtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChmbk5hbWUgKyAnKClAJyArIG1hdGNoWzJdICsgJzonICsgbWF0Y2hbMV0gKyAnIC0tICcgKyBsaW5lc1tpICsgMV0ucmVwbGFjZSgvXlxccysvLCAnJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgLy8gT3BlcmEgNy54LTkuMnggb25seSFcbiAgICBvcGVyYTkgOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vIFwiIExpbmUgNDMgb2YgbGlua2VkIHNjcmlwdFxuICAgICAgICAvLyBmaWxlOi8vbG9jYWxob3N0L0c6L2pzL3N0YWNrdHJhY2UuanNcXG5cIlxuICAgICAgICAvLyBcIiBMaW5lIDcgb2YgaW5saW5lIzEgc2NyaXB0IGluXG4gICAgICAgIC8vIGZpbGU6Ly9sb2NhbGhvc3QvRzovanMvdGVzdC9mdW5jdGlvbmFsL3Rlc3RjYXNlMS5odG1sXFxuXCJcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKS9pO1xuICAgICAgICB2YXIgbGluZXMgPSBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpLCByZXN1bHQgPSBbXTtcblxuICAgICAgICBmb3IgKCB2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChBTk9OICsgJygpQCcgKyBtYXRjaFsyXSArICc6JyArIG1hdGNoWzFdICsgJyAtLSAnICsgbGluZXNbaSArIDFdLnJlcGxhY2UoL15cXHMrLywgJycpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8vIFNhZmFyaSA1LSwgSUUgOS0sIGFuZCBvdGhlcnNcbiAgICBvdGhlciA6IGZ1bmN0aW9uKGN1cnIpIHtcbiAgICAgICAgdmFyIEFOT04gPSAne2Fub255bW91c30nLCBmblJFID0gL2Z1bmN0aW9uXFxzKihbXFx3XFwtJF0rKT9cXHMqXFwoL2ksIHN0YWNrID0gW10sIGZuLCBhcmdzLCBtYXhTdGFja1NpemUgPSAxMDtcbiAgICAgICAgd2hpbGUgKGN1cnIgJiYgY3VyclsnYXJndW1lbnRzJ10gJiYgc3RhY2subGVuZ3RoIDwgbWF4U3RhY2tTaXplKSB7XG4gICAgICAgICAgICBmbiA9IGZuUkUudGVzdChjdXJyLnRvU3RyaW5nKCkpID8gUmVnRXhwLiQxIHx8IEFOT04gOiBBTk9OO1xuICAgICAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGN1cnJbJ2FyZ3VtZW50cyddIHx8IFtdKTtcbiAgICAgICAgICAgIHN0YWNrW3N0YWNrLmxlbmd0aF0gPSBmbiArICcoJyArIHRoaXMuc3RyaW5naWZ5QXJndW1lbnRzKGFyZ3MpICsgJyknO1xuICAgICAgICAgICAgY3VyciA9IGN1cnIuY2FsbGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYXJndW1lbnRzIGFycmF5IGFzIGEgU3RyaW5nLCBzdWJzaXR1dGluZyB0eXBlIG5hbWVzIGZvclxuICAgICAqIG5vbi1zdHJpbmcgdHlwZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FyZ3VtZW50c30gYXJnc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBvZiBTdHJpbmdzIHdpdGggc3RyaW5naWZpZWQgYXJndW1lbnRzXG4gICAgICovXG4gICAgc3RyaW5naWZ5QXJndW1lbnRzIDogZnVuY3Rpb24oYXJncykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAndW5kZWZpbmVkJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gJ251bGwnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmcuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9ICdbJyArIHRoaXMuc3RyaW5naWZ5QXJndW1lbnRzKGFyZykgKyAnXSc7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnWycgKyB0aGlzLnN0cmluZ2lmeUFyZ3VtZW50cyhzbGljZS5jYWxsKGFyZywgMCwgMSkpICsgJy4uLicgKyB0aGlzLnN0cmluZ2lmeUFyZ3VtZW50cyhzbGljZS5jYWxsKGFyZywgLTEpKSArICddJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gJyNvYmplY3QnO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaV0gPSAnI2Z1bmN0aW9uJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpXSA9ICdcIicgKyBhcmcgKyAnXCInO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gYXJnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJywnKTtcbiAgICB9LFxuXG4gICAgc291cmNlQ2FjaGUgOiB7fSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdGhlIHRleHQgZnJvbSBhIGdpdmVuIFVSTFxuICAgICAqL1xuICAgIGFqYXggOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgdmFyIHJlcSA9IHRoaXMuY3JlYXRlWE1MSFRUUE9iamVjdCgpO1xuICAgICAgICBpZiAocmVxKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlcS5vcGVuKCdHRVQnLCB1cmwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAvLyByZXEub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbicpO1xuICAgICAgICAgICAgICAgIC8vIHJlcS5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L2phdmFzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICByZXEuc2VuZChudWxsKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gcmVxLnN0YXR1cyA9PSAyMDAgPyByZXEucmVzcG9uc2VUZXh0IDogJyc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcS5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnkgWEhSIG1ldGhvZHMgaW4gb3JkZXIgYW5kIHN0b3JlIFhIUiBmYWN0b3J5LlxuICAgICAqXG4gICAgICogQHJldHVybiA8RnVuY3Rpb24+IFhIUiBmdW5jdGlvbiBvciBlcXVpdmFsZW50XG4gICAgICovXG4gICAgY3JlYXRlWE1MSFRUUE9iamVjdCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeG1saHR0cCwgWE1MSHR0cEZhY3RvcmllcyA9IFsgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpO1xuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwzLlhNTEhUVFAnKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgICAgIH0gXTtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgWE1MSHR0cEZhY3Rvcmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB4bWxodHRwID0gWE1MSHR0cEZhY3Rvcmllc1tpXSgpO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBtZW1vaXphdGlvbiB0byBjYWNoZSB0aGUgZmFjdG9yeVxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlWE1MSFRUUE9iamVjdCA9IFhNTEh0dHBGYWN0b3JpZXNbaV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhtbGh0dHA7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBVUkwsIGNoZWNrIGlmIGl0IGlzIGluIHRoZSBzYW1lIGRvbWFpbiAoc28gd2UgY2FuIGdldCB0aGVcbiAgICAgKiBzb3VyY2UgdmlhIEFqYXgpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCA8U3RyaW5nPiBzb3VyY2UgdXJsXG4gICAgICogQHJldHVybiBGYWxzZSBpZiB3ZSBuZWVkIGEgY3Jvc3MtZG9tYWluIHJlcXVlc3RcbiAgICAgKi9cbiAgICBpc1NhbWVEb21haW4gOiBmdW5jdGlvbih1cmwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBsb2NhdGlvbiAhPT0gXCJ1bmRlZmluZWRcIiAmJiB1cmwuaW5kZXhPZihsb2NhdGlvbi5ob3N0bmFtZSkgIT09IC0xOyAvLyBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGUuZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBydW5uaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb21cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm9kZWpzLlxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgc291cmNlIGNvZGUgZnJvbSBnaXZlbiBVUkwgaWYgaW4gdGhlIHNhbWUgZG9tYWluLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVybCA8U3RyaW5nPiBKUyBzb3VyY2UgVVJMXG4gICAgICogQHJldHVybiA8QXJyYXk+IEFycmF5IG9mIHNvdXJjZSBjb2RlIGxpbmVzXG4gICAgICovXG4gICAgZ2V0U291cmNlIDogZnVuY3Rpb24odXJsKSB7XG4gICAgICAgIC8vIFRPRE8gcmV1c2Ugc291cmNlIGZyb20gc2NyaXB0IHRhZ3M/XG4gICAgICAgIGlmICghKHVybCBpbiB0aGlzLnNvdXJjZUNhY2hlKSkge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VDYWNoZVt1cmxdID0gdGhpcy5hamF4KHVybCkuc3BsaXQoJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUNhY2hlW3VybF07XG4gICAgfSxcblxuICAgIGd1ZXNzQW5vbnltb3VzRnVuY3Rpb25zIDogZnVuY3Rpb24oc3RhY2spIHtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciByZVN0YWNrID0gL1xce2Fub255bW91c1xcfVxcKC4qXFwpQCguKikvLCByZVJlZiA9IC9eKC4qPykoPzo6KFxcZCspKSg/OjooXFxkKykpPyg/OiAtLSAuKyk/JC8sIGZyYW1lID0gc3RhY2tbaV0sIHJlZiA9IHJlU3RhY2suZXhlYyhmcmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IHJlUmVmLmV4ZWMocmVmWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAobSkgeyAvLyBJZiBmYWxzZXksIHdlIGRpZCBub3QgZ2V0IGFueSBmaWxlL2xpbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlsZSA9IG1bMV0sIGxpbmVubyA9IG1bMl0sIGNoYXJubyA9IG1bM10gfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUgJiYgdGhpcy5pc1NhbWVEb21haW4oZmlsZSkgJiYgbGluZW5vKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gdGhpcy5ndWVzc0Fub255bW91c0Z1bmN0aW9uKGZpbGUsIGxpbmVubywgY2hhcm5vKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrW2ldID0gZnJhbWUucmVwbGFjZSgne2Fub255bW91c30nLCBmdW5jdGlvbk5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICB9LFxuXG4gICAgZ3Vlc3NBbm9ueW1vdXNGdW5jdGlvbiA6IGZ1bmN0aW9uKHVybCwgbGluZU5vLCBjaGFyTm8pIHtcbiAgICAgICAgdmFyIHJldDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldCA9IHRoaXMuZmluZEZ1bmN0aW9uTmFtZSh0aGlzLmdldFNvdXJjZSh1cmwpLCBsaW5lTm8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXQgPSAnZ2V0U291cmNlIGZhaWxlZCB3aXRoIHVybDogJyArIHVybCArICcsIGV4Y2VwdGlvbjogJyArIGUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sXG5cbiAgICBmaW5kRnVuY3Rpb25OYW1lIDogZnVuY3Rpb24oc291cmNlLCBsaW5lTm8pIHtcbiAgICAgICAgLy8gRklYTUUgZmluZEZ1bmN0aW9uTmFtZSBmYWlscyBmb3IgY29tcHJlc3NlZCBzb3VyY2VcbiAgICAgICAgLy8gKG1vcmUgdGhhbiBvbmUgZnVuY3Rpb24gb24gdGhlIHNhbWUgbGluZSlcbiAgICAgICAgLy8gVE9ETyB1c2UgY2FwdHVyZWQgYXJnc1xuICAgICAgICAvLyBmdW5jdGlvbiB7bmFtZX0oe2FyZ3N9KSBtWzFdPW5hbWUgbVsyXT1hcmdzXG4gICAgICAgIHZhciByZUZ1bmN0aW9uRGVjbGFyYXRpb24gPSAvZnVuY3Rpb25cXHMrKFteKF0qPylcXHMqXFwoKFteKV0qKVxcKS87XG4gICAgICAgIC8vIHtuYW1lfSA9IGZ1bmN0aW9uICh7YXJnc30pIFRPRE8gYXJncyBjYXB0dXJlXG4gICAgICAgIC8vIC9bJ1wiXT8oWzAtOUEtWmEtel9dKylbJ1wiXT9cXHMqWzo9XVxccypmdW5jdGlvbig/OlteKF0qKS9cbiAgICAgICAgdmFyIHJlRnVuY3Rpb25FeHByZXNzaW9uID0gL1snXCJdPyhbMC05QS1aYS16X10rKVsnXCJdP1xccypbOj1dXFxzKmZ1bmN0aW9uXFxiLztcbiAgICAgICAgLy8ge25hbWV9ID0gZXZhbCgpXG4gICAgICAgIHZhciByZUZ1bmN0aW9uRXZhbHVhdGlvbiA9IC9bJ1wiXT8oWzAtOUEtWmEtel9dKylbJ1wiXT9cXHMqWzo9XVxccyooPzpldmFsfG5ldyBGdW5jdGlvbilcXGIvO1xuICAgICAgICAvLyBXYWxrIGJhY2t3YXJkcyBpbiB0aGUgc291cmNlIGxpbmVzIHVudGlsIHdlIGZpbmRcbiAgICAgICAgLy8gdGhlIGxpbmUgd2hpY2ggbWF0Y2hlcyBvbmUgb2YgdGhlIHBhdHRlcm5zIGFib3ZlXG4gICAgICAgIHZhciBjb2RlID0gXCJcIiwgbGluZSwgbWF4TGluZXMgPSBNYXRoLm1pbihsaW5lTm8sIDIwKSwgbSwgY29tbWVudFBvcztcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbWF4TGluZXM7ICsraSkge1xuICAgICAgICAgICAgLy8gbGluZU5vIGlzIDEtYmFzZWQsIHNvdXJjZVtdIGlzIDAtYmFzZWRcbiAgICAgICAgICAgIGxpbmUgPSBzb3VyY2VbbGluZU5vIC0gaSAtIDFdO1xuICAgICAgICAgICAgY29tbWVudFBvcyA9IGxpbmUuaW5kZXhPZignLy8nKTtcbiAgICAgICAgICAgIGlmIChjb21tZW50UG9zID49IDApIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHIoMCwgY29tbWVudFBvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPIGNoZWNrIG90aGVyIHR5cGVzIG9mIGNvbW1lbnRzPyBDb21tZW50ZWQgY29kZSBtYXkgbGVhZCB0byBmYWxzZSBwb3NpdGl2ZVxuICAgICAgICAgICAgaWYgKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gbGluZSArIGNvZGU7XG4gICAgICAgICAgICAgICAgbSA9IHJlRnVuY3Rpb25FeHByZXNzaW9uLmV4ZWMoY29kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG0gJiYgbVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHJlRnVuY3Rpb25EZWNsYXJhdGlvbi5leGVjKGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgLy9yZXR1cm4gbVsxXSArIFwiKFwiICsgKG1bMl0gfHwgXCJcIikgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG0gPSByZUZ1bmN0aW9uRXZhbHVhdGlvbi5leGVjKGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChtICYmIG1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1bMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnKD8pJztcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByaW50U3RhY2tUcmFjZTsiLCJcbnZhciBTdGF0ZU1hY2hpbmUgPSB7XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgVkVSU0lPTjogXCIyLjIuMFwiLFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIFJlc3VsdDoge1xuICAgICAgU1VDQ0VFREVEOiAgICAxLCAvLyB0aGUgZXZlbnQgdHJhbnNpdGlvbmVkIHN1Y2Nlc3NmdWxseSBmcm9tIG9uZSBzdGF0ZSB0byBhbm90aGVyXG4gICAgICBOT1RSQU5TSVRJT046IDIsIC8vIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGwgYnV0IG5vIHN0YXRlIHRyYW5zaXRpb24gd2FzIG5lY2Vzc2FyeVxuICAgICAgQ0FOQ0VMTEVEOiAgICAzLCAvLyB0aGUgZXZlbnQgd2FzIGNhbmNlbGxlZCBieSB0aGUgY2FsbGVyIGluIGEgYmVmb3JlRXZlbnQgY2FsbGJhY2tcbiAgICAgIEFTWU5DOiAgICAgICAgNCAvLyB0aGUgZXZlbnQgaXMgYXN5bmNocm9ub3VzIGFuZCB0aGUgY2FsbGVyIGlzIGluIGNvbnRyb2wgb2Ygd2hlbiB0aGUgdHJhbnNpdGlvbiBvY2N1cnNcbiAgICB9LFxuXG4gICAgRXJyb3I6IHtcbiAgICAgIElOVkFMSURfVFJBTlNJVElPTjogMTAwLCAvLyBjYWxsZXIgdHJpZWQgdG8gZmlyZSBhbiBldmVudCB0aGF0IHdhcyBpbm5hcHJvcHJpYXRlIGluIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICBQRU5ESU5HX1RSQU5TSVRJT046IDIwMCwgLy8gY2FsbGVyIHRyaWVkIHRvIGZpcmUgYW4gZXZlbnQgd2hpbGUgYW4gYXN5bmMgdHJhbnNpdGlvbiB3YXMgc3RpbGwgcGVuZGluZ1xuICAgICAgSU5WQUxJRF9DQUxMQkFDSzogICAzMDAgLy8gY2FsbGVyIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIHRocmV3IGFuIGV4Y2VwdGlvblxuICAgIH0sXG5cbiAgICBXSUxEQ0FSRDogJyonLFxuICAgIEFTWU5DOiAnYXN5bmMnLFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIGNyZWF0ZTogZnVuY3Rpb24oY2ZnLCB0YXJnZXQpIHtcblxuICAgICAgdmFyIGluaXRpYWwgICA9ICh0eXBlb2YgY2ZnLmluaXRpYWwgPT0gJ3N0cmluZycpID8geyBzdGF0ZTogY2ZnLmluaXRpYWwgfSA6IGNmZy5pbml0aWFsOyAvLyBhbGxvdyBmb3IgYSBzaW1wbGUgc3RyaW5nLCBvciBhbiBvYmplY3Qgd2l0aCB7IHN0YXRlOiAnZm9vJywgZXZlbnQ6ICdzZXR1cCcsIGRlZmVyOiB0cnVlfGZhbHNlIH1cbiAgICAgIHZhciBmc20gICAgICAgPSB0YXJnZXQgfHwgY2ZnLnRhcmdldCAgfHwge307XG4gICAgICB2YXIgZXZlbnRzICAgID0gY2ZnLmV2ZW50cyB8fCBbXTtcbiAgICAgIHZhciBjYWxsYmFja3MgPSBjZmcuY2FsbGJhY2tzIHx8IHt9O1xuICAgICAgdmFyIG1hcCAgICAgICA9IHt9O1xuXG4gICAgICB2YXIgYWRkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZnJvbSA9IChlLmZyb20gaW5zdGFuY2VvZiBBcnJheSkgPyBlLmZyb20gOiAoZS5mcm9tID8gW2UuZnJvbV0gOiBbU3RhdGVNYWNoaW5lLldJTERDQVJEXSk7IC8vIGFsbG93ICd3aWxkY2FyZCcgdHJhbnNpdGlvbiBpZiAnZnJvbScgaXMgbm90IHNwZWNpZmllZFxuICAgICAgICBtYXBbZS5uYW1lXSA9IG1hcFtlLm5hbWVdIHx8IHt9O1xuICAgICAgICBmb3IgKHZhciBuID0gMCA7IG4gPCBmcm9tLmxlbmd0aCA7IG4rKylcbiAgICAgICAgICBtYXBbZS5uYW1lXVtmcm9tW25dXSA9IGUudG8gfHwgZnJvbVtuXTsgLy8gYWxsb3cgbm8tb3AgdHJhbnNpdGlvbiBpZiAndG8nIGlzIG5vdCBzcGVjaWZpZWRcbiAgICAgIH07XG5cbiAgICAgIGlmIChpbml0aWFsKSB7XG4gICAgICAgIGluaXRpYWwuZXZlbnQgPSBpbml0aWFsLmV2ZW50IHx8ICdzdGFydHVwJztcbiAgICAgICAgYWRkKHsgbmFtZTogaW5pdGlhbC5ldmVudCwgZnJvbTogJ25vbmUnLCB0bzogaW5pdGlhbC5zdGF0ZSB9KTtcbiAgICAgIH1cblxuICAgICAgZm9yKHZhciBuID0gMCA7IG4gPCBldmVudHMubGVuZ3RoIDsgbisrKVxuICAgICAgICBhZGQoZXZlbnRzW25dKTtcblxuICAgICAgZm9yKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgIGZzbVtuYW1lXSA9IFN0YXRlTWFjaGluZS5idWlsZEV2ZW50KG5hbWUsIG1hcFtuYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGZvcih2YXIgbmFtZSBpbiBjYWxsYmFja3MpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSlcbiAgICAgICAgICBmc21bbmFtZV0gPSBjYWxsYmFja3NbbmFtZV1cbiAgICAgIH1cblxuICAgICAgZnNtLmN1cnJlbnQgPSAnbm9uZSc7XG4gICAgICBmc20uaXMgICAgICA9IGZ1bmN0aW9uKHN0YXRlKSB7IHJldHVybiB0aGlzLmN1cnJlbnQgPT0gc3RhdGU7IH07XG4gICAgICBmc20uY2FuICAgICA9IGZ1bmN0aW9uKGV2ZW50KSB7IHJldHVybiAhdGhpcy50cmFuc2l0aW9uICYmIChtYXBbZXZlbnRdLmhhc093blByb3BlcnR5KHRoaXMuY3VycmVudCkgfHwgbWFwW2V2ZW50XS5oYXNPd25Qcm9wZXJ0eShTdGF0ZU1hY2hpbmUuV0lMRENBUkQpKTsgfVxuICAgICAgZnNtLmNhbm5vdCAgPSBmdW5jdGlvbihldmVudCkgeyByZXR1cm4gIXRoaXMuY2FuKGV2ZW50KTsgfTtcbiAgICAgIGZzbS5lcnJvciAgID0gY2ZnLmVycm9yIHx8IGZ1bmN0aW9uKG5hbWUsIGZyb20sIHRvLCBhcmdzLCBlcnJvciwgbXNnLCBlKSB7IHRocm93IGUgfHwgbXNnOyB9OyAvLyBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gc29tZXRoaW5nIHVuZXhwZWN0ZWQgaGFwcGVucyBpcyB0byB0aHJvdyBhbiBleGNlcHRpb24sIGJ1dCBjYWxsZXIgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgaWYgZGVzaXJlZCAoc2VlIGdpdGh1YiBpc3N1ZSAjMyBhbmQgIzE3KVxuXG4gICAgICBpZiAoaW5pdGlhbCAmJiAhaW5pdGlhbC5kZWZlcilcbiAgICAgICAgZnNtW2luaXRpYWwuZXZlbnRdKCk7XG5cbiAgICAgIHJldHVybiBmc207XG5cbiAgICB9LFxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIGRvQ2FsbGJhY2s6IGZ1bmN0aW9uKGZzbSwgZnVuYywgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpIHtcbiAgICAgIGlmIChmdW5jKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoZnNtLCBbbmFtZSwgZnJvbSwgdG9dLmNvbmNhdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2goZSkge1xuICAgICAgICAgIHJldHVybiBmc20uZXJyb3IobmFtZSwgZnJvbSwgdG8sIGFyZ3MsIFN0YXRlTWFjaGluZS5FcnJvci5JTlZBTElEX0NBTExCQUNLLCBcImFuIGV4Y2VwdGlvbiBvY2N1cnJlZCBpbiBhIGNhbGxlci1wcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvblwiLCBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBiZWZvcmVFdmVudDogZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29uYmVmb3JlJyArIG5hbWVdLCAgICAgICAgICAgICAgICAgICAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcbiAgICBhZnRlckV2ZW50OiAgZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29uYWZ0ZXInICArIG5hbWVdIHx8IGZzbVsnb24nICsgbmFtZV0sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcbiAgICBsZWF2ZVN0YXRlOiAgZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29ubGVhdmUnICArIGZyb21dLCAgICAgICAgICAgICAgICAgICAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcbiAgICBlbnRlclN0YXRlOiAgZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29uZW50ZXInICArIHRvXSAgIHx8IGZzbVsnb24nICsgdG9dLCAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcbiAgICBjaGFuZ2VTdGF0ZTogZnVuY3Rpb24oZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncykgeyByZXR1cm4gU3RhdGVNYWNoaW5lLmRvQ2FsbGJhY2soZnNtLCBmc21bJ29uY2hhbmdlc3RhdGUnXSwgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsIGZyb20sIHRvLCBhcmdzKTsgfSxcblxuXG4gICAgYnVpbGRFdmVudDogZnVuY3Rpb24obmFtZSwgbWFwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIGZyb20gID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB2YXIgdG8gICAgPSBtYXBbZnJvbV0gfHwgbWFwW1N0YXRlTWFjaGluZS5XSUxEQ0FSRF0gfHwgZnJvbTtcbiAgICAgICAgdmFyIGFyZ3MgID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTsgLy8gdHVybiBhcmd1bWVudHMgaW50byBwdXJlIGFycmF5XG5cbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbilcbiAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihuYW1lLCBmcm9tLCB0bywgYXJncywgU3RhdGVNYWNoaW5lLkVycm9yLlBFTkRJTkdfVFJBTlNJVElPTiwgXCJldmVudCBcIiArIG5hbWUgKyBcIiBpbmFwcHJvcHJpYXRlIGJlY2F1c2UgcHJldmlvdXMgdHJhbnNpdGlvbiBkaWQgbm90IGNvbXBsZXRlXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLmNhbm5vdChuYW1lKSlcbiAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcihuYW1lLCBmcm9tLCB0bywgYXJncywgU3RhdGVNYWNoaW5lLkVycm9yLklOVkFMSURfVFJBTlNJVElPTiwgXCJldmVudCBcIiArIG5hbWUgKyBcIiBpbmFwcHJvcHJpYXRlIGluIGN1cnJlbnQgc3RhdGUgXCIgKyB0aGlzLmN1cnJlbnQpO1xuXG4gICAgICAgIGlmIChmYWxzZSA9PT0gU3RhdGVNYWNoaW5lLmJlZm9yZUV2ZW50KHRoaXMsIG5hbWUsIGZyb20sIHRvLCBhcmdzKSlcbiAgICAgICAgICByZXR1cm4gU3RhdGVNYWNoaW5lLlJlc3VsdC5DQU5DRUxMRUQ7XG5cbiAgICAgICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgICAgU3RhdGVNYWNoaW5lLmFmdGVyRXZlbnQodGhpcywgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpO1xuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0Lk5PVFJBTlNJVElPTjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHByZXBhcmUgYSB0cmFuc2l0aW9uIG1ldGhvZCBmb3IgdXNlIEVJVEhFUiBsb3dlciBkb3duLCBvciBieSBjYWxsZXIgaWYgdGhleSB3YW50IGFuIGFzeW5jIHRyYW5zaXRpb24gKGluZGljYXRlZCBieSBhbiBBU1lOQyByZXR1cm4gdmFsdWUgZnJvbSBsZWF2ZVN0YXRlKVxuICAgICAgICB2YXIgZnNtID0gdGhpcztcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgZnNtLnRyYW5zaXRpb24gPSBudWxsOyAvLyB0aGlzIG1ldGhvZCBzaG91bGQgb25seSBldmVyIGJlIGNhbGxlZCBvbmNlXG4gICAgICAgICAgZnNtLmN1cnJlbnQgPSB0bztcbiAgICAgICAgICBTdGF0ZU1hY2hpbmUuZW50ZXJTdGF0ZSggZnNtLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XG4gICAgICAgICAgU3RhdGVNYWNoaW5lLmNoYW5nZVN0YXRlKGZzbSwgbmFtZSwgZnJvbSwgdG8sIGFyZ3MpO1xuICAgICAgICAgIFN0YXRlTWFjaGluZS5hZnRlckV2ZW50KCBmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uLmNhbmNlbCA9IGZ1bmN0aW9uKCkgeyAvLyBwcm92aWRlIGEgd2F5IGZvciBjYWxsZXIgdG8gY2FuY2VsIGFzeW5jIHRyYW5zaXRpb24gaWYgZGVzaXJlZCAoaXNzdWUgIzIyKVxuICAgICAgICAgIGZzbS50cmFuc2l0aW9uID0gbnVsbDtcbiAgICAgICAgICBTdGF0ZU1hY2hpbmUuYWZ0ZXJFdmVudChmc20sIG5hbWUsIGZyb20sIHRvLCBhcmdzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgbGVhdmUgPSBTdGF0ZU1hY2hpbmUubGVhdmVTdGF0ZSh0aGlzLCBuYW1lLCBmcm9tLCB0bywgYXJncyk7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gbGVhdmUpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zaXRpb24gPSBudWxsO1xuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0LkNBTkNFTExFRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcImFzeW5jXCIgPT09IGxlYXZlKSB7XG4gICAgICAgICAgcmV0dXJuIFN0YXRlTWFjaGluZS5SZXN1bHQuQVNZTkM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvbilcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvbigpOyAvLyBpbiBjYXNlIHVzZXIgbWFudWFsbHkgY2FsbGVkIHRyYW5zaXRpb24oKSBidXQgZm9yZ290IHRvIHJldHVybiBBU1lOQ1xuICAgICAgICAgIHJldHVybiBTdGF0ZU1hY2hpbmUuUmVzdWx0LlNVQ0NFRURFRDtcbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgIH1cblxufTsgLy8gU3RhdGVNYWNoaW5lXG5cbi8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGRlZmluZSkge1xuZGVmaW5lKGZ1bmN0aW9uKHJlcXVpcmUpIHsgcmV0dXJuIFN0YXRlTWFjaGluZTsgfSk7XG59XG5lbHNlIHsqL1xud2luZG93LlN0YXRlTWFjaGluZSA9IFN0YXRlTWFjaGluZTtcbi8qfSovXG5cbm1vZHVsZS5leHBvcnRzID0gU3RhdGVNYWNoaW5lO1xuXG4iLCJ2YXIgRE9NVHJhbnNmb3JtRmV0Y2hlciA9IHJlcXVpcmUoXCIuLi90cmFuc2Zvcm0tZmV0Y2hlci5qc1wiKTtcbnZhciBEYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL2RhdGEuanNcIik7XG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xudmFyIGdldENvbXB1dGVEYXRhZmxvd1VybCA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuZ2V0Q29tcHV0ZURhdGFmbG93VXJsO1xudmFyIEFzc2V0ID0gcmVxdWlyZShcIi4uLy4uL2Fzc2V0L2Fzc2V0LmpzXCIpLkFzc2V0O1xudmFyIFN1YkRhdGEgPSByZXF1aXJlKFwiLi4vLi4vYXNzZXQvYXNzZXQuanNcIikuU3ViRGF0YTtcbnZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcbnZhciBkaXNwYXRjaEN1c3RvbUV2ZW50ID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL21pc2MuanNcIikuZGlzcGF0Y2hDdXN0b21FdmVudDtcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcblxudmFyIE5vZGVBZGFwdGVyID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlcjtcbnZhciBjcmVhdGVDbGFzcyA9IFhNTDNELmNyZWF0ZUNsYXNzO1xudmFyIEFkYXB0ZXJIYW5kbGUgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyaGFuZGxlLmpzXCIpO1xuXG5cbnZhciBBc3NldEFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG5cbiAgICAvKipcbiAgICAgKiAgQHR5cGUgQXNzZXRcbiAgICAgKiovXG4gICAgdGhpcy5hc3NldCA9IG5ldyBBc3NldCh0aGlzLm5vZGUpO1xuICAgIGlmIChub2RlLmxvY2FsTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcIm1vZGVsXCIpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyID0gbmV3IERPTVRyYW5zZm9ybUZldGNoZXIodGhpcywgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2Zvcm1cIik7XG4gICAgfVxufTtcblxuY3JlYXRlQ2xhc3MoQXNzZXRBZGFwdGVyLCBOb2RlQWRhcHRlcik7XG5cbkFzc2V0QWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFzc2V0LmFkZENoYW5nZUxpc3RlbmVyKHRoaXMpO1xuICAgIHRoaXMuYXNzZXQuc2V0TmFtZSh0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwibmFtZVwiKSk7XG4gICAgdXBkYXRlQWRhcHRlckhhbmRsZSh0aGlzLCBcInNyY1wiLCB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwic3JjXCIpKTtcbiAgICB1cGRhdGVQaWNrRmlsdGVyKHRoaXMpO1xuICAgIHVwZGF0ZUNoaWxkcmVuKHRoaXMpO1xuICAgIHNldE1hdGVyaWFsVXJsKHRoaXMsIHRoaXMuYXNzZXQpO1xuICAgIHRoaXMudHJhbnNmb3JtRmV0Y2hlciAmJiB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XG59O1xuXG5Bc3NldEFkYXB0ZXIucHJvdG90eXBlLm9uQXNzZXRMb2FkQ2hhbmdlID0gZnVuY3Rpb24gKGFzc2V0LCBuZXdMZXZlbCwgb2xkTGV2ZWwpIHtcbiAgICBpZiAobmV3TGV2ZWwgPT0gSW5maW5pdHkpIHtcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudCh0aGlzLm5vZGUsICdsb2FkJywgZmFsc2UsIHRydWUsIG51bGwpO1xuICAgIH0gZWxzZSBpZiAobmV3TGV2ZWwgPiBvbGRMZXZlbCkge1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50KHRoaXMubm9kZSwgJ3Byb2dyZXNzJywgZmFsc2UsIHRydWUsIG51bGwpO1xuICAgIH1cbn07XG5cbkFzc2V0QWRhcHRlci5wcm90b3R5cGUuZ2V0QXNzZXRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NldC5nZXRQcm9ncmVzc0xldmVsKCkgPT0gSW5maW5pdHk7XG59O1xuQXNzZXRBZGFwdGVyLnByb3RvdHlwZS5nZXRBc3NldFByb2dyZXNzTGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzZXQuZ2V0UHJvZ3Jlc3NMZXZlbCgpO1xufTtcblxuQXNzZXRBZGFwdGVyLnByb3RvdHlwZS5nZXRBc3NldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NldDtcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuKGFkYXB0ZXIpIHtcbiAgICBhZGFwdGVyLmFzc2V0LmNsZWFyQ2hpbGRyZW4oKTtcbiAgICBhZGFwdGVyLmFzc2V0LmNsZWFyU3ViQXNzZXRzKCk7XG4gICAgZm9yICh2YXIgY2hpbGQgPSBhZGFwdGVyLm5vZGUuZmlyc3RFbGVtZW50Q2hpbGQ7IGNoaWxkICE9PSBudWxsOyBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZykge1xuICAgICAgICB2YXIgc3ViYWRhcHRlciA9IGFkYXB0ZXIuZmFjdG9yeS5nZXRBZGFwdGVyKGNoaWxkKTtcbiAgICAgICAgaWYgKHN1YmFkYXB0ZXIgJiYgc3ViYWRhcHRlci5nZXRBc3NldCkge1xuICAgICAgICAgICAgYWRhcHRlci5hc3NldC5hcHBlbmRTdWJBc3NldChzdWJhZGFwdGVyLmdldEFzc2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdWJhZGFwdGVyICYmIHN1YmFkYXB0ZXIuYXNzZXRFbnRyeSkge1xuICAgICAgICAgICAgYWRhcHRlci5hc3NldC5hcHBlbmRDaGlsZChzdWJhZGFwdGVyLmFzc2V0RW50cnkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVBZGFwdGVySGFuZGxlKGFkYXB0ZXIsIGtleSwgdXJsKSB7XG4gICAgdmFyIGFkYXB0ZXJIYW5kbGUgPSBhZGFwdGVyLmdldEFkYXB0ZXJIYW5kbGUodXJsKSwgc3RhdHVzID0gKGFkYXB0ZXJIYW5kbGUgJiYgYWRhcHRlckhhbmRsZS5zdGF0dXMpO1xuXG4gICAgaWYgKHN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGZpbmQgZWxlbWVudCBvZiB1cmwgJ1wiICsgYWRhcHRlckhhbmRsZS51cmwgKyBcIicgZm9yIFwiICsga2V5LCBhZGFwdGVyLm5vZGUpO1xuICAgIH1cbiAgICBhZGFwdGVyLmNvbm5lY3RBZGFwdGVySGFuZGxlKGtleSwgYWRhcHRlckhhbmRsZSk7XG4gICAgYWRhcHRlci5jb25uZWN0ZWRBZGFwdGVyQ2hhbmdlZChrZXksIGFkYXB0ZXJIYW5kbGUgPyBhZGFwdGVySGFuZGxlLmdldEFkYXB0ZXIoKSA6IG51bGwsIHN0YXR1cyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUFzc2V0TG9hZFN0YXRlKGRhdGFBZGFwdGVyKSB7XG4gICAgdmFyIGxvYWRpbmcgPSBmYWxzZSwgaGFuZGxlO1xuXG4gICAgaGFuZGxlID0gZGF0YUFkYXB0ZXIuZ2V0Q29ubmVjdGVkQWRhcHRlckhhbmRsZShcInNyY1wiKTtcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5zdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkcpIHtcbiAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgfVxuICAgIGRhdGFBZGFwdGVyLmFzc2V0LnNldExvYWRpbmcobG9hZGluZyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBpY2tGaWx0ZXIoYWRhcHRlcikge1xuICAgIGlmICghYWRhcHRlci5ub2RlLmhhc0F0dHJpYnV0ZShcInBpY2tcIikpXG4gICAgICAgIGFkYXB0ZXIuYXNzZXQuc2V0UGlja0ZpbHRlcihudWxsKTsgZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFkYXB0ZXIubm9kZS5nZXRBdHRyaWJ1dGUoXCJwaWNrXCIpO1xuICAgICAgICBhZGFwdGVyLmFzc2V0LnNldFBpY2tGaWx0ZXIodmFsdWUpO1xuICAgIH1cbn1cblxuQXNzZXRBZGFwdGVyLnByb3RvdHlwZS5jb25uZWN0ZWRBZGFwdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uIChhdHRyaWJ1dGVOYW1lLCBhZGFwdGVyKSB7XG4gICAgaWYgKGF0dHJpYnV0ZU5hbWUgPT0gXCJzcmNcIilcbiAgICAgICAgdGhpcy5hc3NldC5zZXRTcmNBc3NldChhZGFwdGVyICYmIGFkYXB0ZXIuZ2V0QXNzZXQoKSB8fCBudWxsKTtcbiAgICB1cGRhdGVBc3NldExvYWRTdGF0ZSh0aGlzKTtcbn07XG5cbkFzc2V0QWRhcHRlci5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UgPSBmdW5jdGlvbiAoYXR0ck5hbWUsIG1hdHJpeCkge1xuICAgIHRoaXMuYXNzZXQuc2V0VHJhbnNmb3JtKG1hdHJpeCk7XG59O1xuXG5Bc3NldEFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJuYW1lXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NldC5zZXROYW1lKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXRlcmlhbFwiOlxuICAgICAgICAgICAgICAgIHNldE1hdGVyaWFsVXJsKHRoaXMsIHRoaXMuYXNzZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0eWxlXCI6XG4gICAgICAgICAgICBjYXNlIFwidHJhbnNmb3JtXCI6XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyICYmIHRoaXMudHJhbnNmb3JtRmV0Y2hlci51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzcmNcIjpcbiAgICAgICAgICAgICAgICB1cGRhdGVBZGFwdGVySGFuZGxlKHRoaXMsIFwic3JjXCIsIG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwaWNrXCI6XG4gICAgICAgICAgICAgICAgdXBkYXRlUGlja0ZpbHRlcih0aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxufTtcblxuXG5Bc3NldEFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09IEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckNoYW5nZWQoZXZ0LmtleSwgZXZ0LmFkYXB0ZXIpO1xuICAgICAgICBpZiAoZXZ0LmhhbmRsZVN0YXR1cyA9PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGZpbmQgPGFzc2V0PiBlbGVtZW50IG9mIHVybCAnXCIgKyBldnQudXJsICsgXCInIGZvciBcIiArIGV2dC5rZXkpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PSBFdmVudHMuTk9ERV9JTlNFUlRFRCkge1xuICAgICAgICB1cGRhdGVDaGlsZHJlbih0aGlzKTtcblxuICAgIH0gZWxzZSBpZiAoZXZ0LnR5cGUgPT0gRXZlbnRzLk5PREVfUkVNT1ZFRCkge1xuICAgICAgICB1cGRhdGVDaGlsZHJlbih0aGlzKTtcblxuICAgIH0gIGVsc2UgaWYgKGV2dC50eXBlID09IEV2ZW50cy5USElTX1JFTU9WRUQpIHtcbiAgICAgICAgdGhpcy5jbGVhckFkYXB0ZXJIYW5kbGVzKCk7XG4gICAgfVxufTtcblxudmFyIEFzc2V0RGF0YUFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xuICAgIHRoaXMuYXNzZXREYXRhID0gdHJ1ZTtcbiAgICBEYXRhQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xuXG4gICAgLy8gTm9kZSBoYW5kbGVzIGZvciBzcmMgYW5kIHByb3RvXG4gICAgdGhpcy5hc3NldEVudHJ5ID0gbnVsbDtcbiAgICB0aGlzLm91dHB1dFhmbG93Tm9kZSA9IG51bGw7XG59O1xuY3JlYXRlQ2xhc3MoQXNzZXREYXRhQWRhcHRlciwgRGF0YUFkYXB0ZXIpO1xuXG5Bc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIERhdGFBZGFwdGVyLnByb3RvdHlwZS5pbml0LmNhbGwodGhpcyk7XG4gICAgdGhpcy5vdXRwdXRYZmxvd05vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xuICAgIHRoaXMuYXNzZXRFbnRyeSA9IG5ldyBTdWJEYXRhKHRoaXMub3V0cHV0WGZsb3dOb2RlLCB0aGlzLmdldFhmbG93Tm9kZSgpLCB0aGlzLm5vZGUpO1xuICAgIHRoaXMuYXNzZXRFbnRyeS5zZXROYW1lKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKTtcbiAgICB1cGRhdGVDbGFzc05hbWVzKHRoaXMpO1xuICAgIHVwZGF0ZVBvc3RDb21wdXRlKHRoaXMpO1xuICAgIHRoaXMuYXNzZXRFbnRyeS5zZXRQb3N0RmlsdGVyKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJmaWx0ZXJcIikpO1xuICAgIHVwZGF0ZUluY2x1ZGVzKHRoaXMuYXNzZXRFbnRyeSwgdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcImluY2x1ZGVzXCIpKTtcbn07XG5cbkFzc2V0RGF0YUFkYXB0ZXIucHJvdG90eXBlLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUsIGFkYXB0ZXIpIHtcbiAgICBpZiAoYXR0cmlidXRlTmFtZSA9PSBcInBvc3REYXRhZmxvd1wiKSB7XG4gICAgICAgIHRoaXMuYXNzZXRFbnRyeS5zZXRQb3N0RGF0YWZsb3coYWRhcHRlciAmJiBhZGFwdGVyLmdldFhmbG93Tm9kZSgpIHx8IG51bGwpO1xuICAgICAgICB1cGRhdGVTdWJEYXRhTG9hZFN0YXRlKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIERhdGFBZGFwdGVyLnByb3RvdHlwZS5jb25uZWN0ZWRBZGFwdGVyQ2hhbmdlZC5jYWxsKHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGFkYXB0ZXIpO1xuICAgIH1cbn07XG5cbkFzc2V0RGF0YUFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBEYXRhQWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcIm5hbWVcIjpcbiAgICAgICAgICAgIHRoaXMuYXNzZXRFbnRyeS5zZXROYW1lKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY29tcHV0ZVwiOlxuICAgICAgICAgICAgdXBkYXRlUG9zdENvbXB1dGUodGhpcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNsYXNzXCI6XG4gICAgICAgICAgICB1cGRhdGVDbGFzc05hbWVzKHRoaXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgICAgIHRoaXMuYXNzZXRFbnRyeS5zZXRQb3N0RmlsdGVyKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaW5jbHVkZXNcIjpcbiAgICAgICAgICAgIHVwZGF0ZUluY2x1ZGVzKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbn07XG5cbkFzc2V0RGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQuY2FsbCh0aGlzLCBldnQpO1xuXG59O1xuXG5Bc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIChhdHRyTmFtZSwgbWF0cml4KSB7XG4gICAgdGhpcy5hc3NldEVudHJ5LnNldFRyYW5zZm9ybShtYXRyaXgpO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlSW5jbHVkZXMoYXNzZXRFbnRyeSwgaW5jbHVkZVN0cmluZykge1xuICAgIGlmICghaW5jbHVkZVN0cmluZylcbiAgICAgICAgYXNzZXRFbnRyeS5zZXRJbmNsdWRlcyhbXSk7IGVsc2VcbiAgICAgICAgYXNzZXRFbnRyeS5zZXRJbmNsdWRlcyhpbmNsdWRlU3RyaW5nLnRyaW0oKS5zcGxpdCgvXFxzKixcXHMqLykpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc05hbWVzKGFkYXB0ZXIpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IGFkYXB0ZXIubm9kZS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICBhZGFwdGVyLmFzc2V0RW50cnkuc2V0Q2xhc3NOYW1lc1N0cmluZyhjbGFzc05hbWVzKVxufVxuXG5mdW5jdGlvbiB1cGRhdGVQb3N0Q29tcHV0ZShhZGFwdGVyKSB7XG4gICAgdmFyIGNvbXB1dGVTdHJpbmcgPSBhZGFwdGVyLm5vZGUuZ2V0QXR0cmlidXRlKFwiY29tcHV0ZVwiKTtcbiAgICB2YXIgZGF0YWZsb3dVcmwgPSBnZXRDb21wdXRlRGF0YWZsb3dVcmwoY29tcHV0ZVN0cmluZyk7XG4gICAgaWYgKGRhdGFmbG93VXJsKSB7XG4gICAgICAgIHVwZGF0ZUFkYXB0ZXJIYW5kbGUoYWRhcHRlciwgXCJwb3N0RGF0YWZsb3dcIiwgZGF0YWZsb3dVcmwpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFkYXB0ZXIuZGlzY29ubmVjdEFkYXB0ZXJIYW5kbGUoXCJwb3N0RGF0YWZsb3dcIik7XG4gICAgICAgIHVwZGF0ZVN1YkRhdGFMb2FkU3RhdGUoYWRhcHRlcik7XG4gICAgfVxuICAgIGFkYXB0ZXIuYXNzZXRFbnRyeS5zZXRQb3N0Q29tcHV0ZShjb21wdXRlU3RyaW5nKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3ViRGF0YUxvYWRTdGF0ZShkYXRhQWRhcHRlcikge1xuICAgIHZhciBsb2FkaW5nID0gZmFsc2UsIGhhbmRsZTtcblxuICAgIGhhbmRsZSA9IGRhdGFBZGFwdGVyLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUoXCJwb3N0RGF0YWZsb3dcIik7XG4gICAgaWYgKGhhbmRsZSAmJiBoYW5kbGUuc3RhdHVzID09PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5MT0FESU5HKSB7XG4gICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBkYXRhQWRhcHRlci5hc3NldEVudHJ5LnNldExvYWRpbmcobG9hZGluZyk7XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIGFkYXB0ZXJcbiAqIEBwYXJhbSB7QXNzZXR9IGRlc3RcbiAqL1xuZnVuY3Rpb24gc2V0TWF0ZXJpYWxVcmwoYWRhcHRlciwgZGVzdCkge1xuICAgIHZhciBub2RlID0gYWRhcHRlci5ub2RlO1xuICAgIHZhciBtYXRlcmlhbFVSTCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwibWF0ZXJpYWxcIik7XG4gICAgaWYgKG1hdGVyaWFsVVJMKSB7XG4gICAgICAgIHZhciBtYXRlcmlhbEFic29sdXRlVVJMID0gUmVzb3VyY2UuZ2V0QWJzb2x1dGVVUkkobm9kZS5vd25lckRvY3VtZW50Ll9kb2N1bWVudFVSTCB8fCBub2RlLm93bmVyRG9jdW1lbnQuVVJMLCBtYXRlcmlhbFVSTCk7XG4gICAgICAgIGRlc3Quc2V0TWF0ZXJpYWwobWF0ZXJpYWxBYnNvbHV0ZVVSTC50b1N0cmluZygpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkZXN0LnNldE1hdGVyaWFsKG51bGwpO1xuICAgIH1cbn1cblxudmFyIEFzc2V0TWVzaEFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xuICAgIEFzc2V0RGF0YUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcbiAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIgPSBuZXcgRE9NVHJhbnNmb3JtRmV0Y2hlcih0aGlzLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zZm9ybVwiKTtcbn07XG5jcmVhdGVDbGFzcyhBc3NldE1lc2hBZGFwdGVyLCBBc3NldERhdGFBZGFwdGVyLCB7XG5cbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIEFzc2V0RGF0YUFkYXB0ZXIucHJvdG90eXBlLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgICAgc2V0TWF0ZXJpYWxVcmwodGhpcywgdGhpcy5hc3NldEVudHJ5KTtcbiAgICAgICAgdGhpcy5hc3NldEVudHJ5LnNldE1lc2hUeXBlKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpIHx8IFwidHJpYW5nbGVzXCIpO1xuICAgICAgICB0aGlzLmFzc2V0RW50cnkuc2V0TWF0Y2hGaWx0ZXIodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcIm1hdGNoXCIpKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgQXNzZXREYXRhQWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwibWF0ZXJpYWxcIjpcbiAgICAgICAgICAgICAgICBzZXRNYXRlcmlhbFVybCh0aGlzLCB0aGlzLmFzc2V0RW50cnkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm1hdGNoXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NldEVudHJ5LnNldE1hdGNoRmlsdGVyKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgICAgY2FzZSBcInRyYW5zZm9ybVwiOlxuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRmV0Y2hlci51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0eXBlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NldEVudHJ5LnNldE1lc2hUeXBlKG5ld1ZhbHVlIHx8IFwidHJpYW5nbGVzXCIpXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbm90aWZ5Q2hhbmdlZDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBBc3NldERhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkLmNhbGwodGhpcywgZXZ0KTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQXNzZXRBZGFwdGVyOiBBc3NldEFkYXB0ZXIsIEFzc2V0TWVzaEFkYXB0ZXI6IEFzc2V0TWVzaEFkYXB0ZXIsIEFzc2V0RGF0YUFkYXB0ZXI6IEFzc2V0RGF0YUFkYXB0ZXJcbn07XG4iLCJ2YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XG52YXIgc2V0U2hhZGVyQ29uc3RhbnQgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvcHJvY2Vzc2luZy92cy1jb25uZWN0LmpzXCIpLnNldFNoYWRlckNvbnN0YW50O1xudmFyIHJlZ2lzdGVyRXJyb3JDYWxsYmFjayA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9iYXNlLmpzXCIpLnJlZ2lzdGVyRXJyb3JDYWxsYmFjaztcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xudmFyIFVSSSA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy91cmkuanNcIikuVVJJO1xuXG52YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xudmFyIGNyZWF0ZUNsYXNzID0gWE1MM0QuY3JlYXRlQ2xhc3M7XG5cbi8qKlxuICogQGV4dGVuZHMgTm9kZUFkYXB0ZXJcbiAqIEBhYnN0cmFjdFxuICpcbiAqIEBwYXJhbSBmYWN0b3J5XG4gKiBAcGFyYW0gbm9kZVxuICovXG52YXIgQmFzZURhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcbiAgICBOb2RlQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xuICAgIHRoaXMueGZsb3dEYXRhTm9kZSA9IG51bGw7XG59O1xuY3JlYXRlQ2xhc3MoQmFzZURhdGFBZGFwdGVyLCBOb2RlQWRhcHRlcik7XG5cblxuQmFzZURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRYZmxvd05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueGZsb3dEYXRhTm9kZTtcbn07XG5cbkJhc2VEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZVJlcXVlc3QgPSBmdW5jdGlvbiAoZmlsdGVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBuZXcgQ29tcHV0ZVJlcXVlc3QodGhpcy54Zmxvd0RhdGFOb2RlLCBmaWx0ZXIsIGNhbGxiYWNrKTtcbn07XG5cbkJhc2VEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZVJlc3VsdCA9IGZ1bmN0aW9uIChmaWx0ZXIpIHtcbiAgICByZXR1cm4gdGhpcy54Zmxvd0RhdGFOb2RlLl9nZXRSZXN1bHQoWEMuUkVTVUxUX1RZUEUuQ09NUFVURSwgZmlsdGVyKTtcbn07XG5cbkJhc2VEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0T3V0cHV0TmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueGZsb3dEYXRhTm9kZS5nZXRPdXRwdXROYW1lcygpO1xufTtcblxuQmFzZURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRPdXRwdXRDaGFubmVsSW5mbyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMueGZsb3dEYXRhTm9kZS5nZXRPdXRwdXRDaGFubmVsSW5mbyhuYW1lKTtcbn07XG5cbnNldFNoYWRlckNvbnN0YW50KFhDLlNIQURFUl9DT05TVEFOVF9LRVkuT0JKRUNUX0lELCBcIm9iamVjdElEXCIpO1xuc2V0U2hhZGVyQ29uc3RhbnQoWEMuU0hBREVSX0NPTlNUQU5UX0tFWS5TQ1JFRU5fVFJBTlNGT1JNLCBcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIik7XG5zZXRTaGFkZXJDb25zdGFudChYQy5TSEFERVJfQ09OU1RBTlRfS0VZLlNDUkVFTl9UUkFOU0ZPUk1fTk9STUFMLCBcIm1vZGVsVmlld1Byb2plY3Rpb25Ob3JtYWxNYXRyaXhcIik7XG5zZXRTaGFkZXJDb25zdGFudChYQy5TSEFERVJfQ09OU1RBTlRfS0VZLlZJRVdfVFJBTlNGT1JNLCBcIm1vZGVsVmlld01hdHJpeFwiKTtcbnNldFNoYWRlckNvbnN0YW50KFhDLlNIQURFUl9DT05TVEFOVF9LRVkuVklFV19UUkFOU0ZPUk1fTk9STUFMLCBcIm1vZGVsVmlld01hdHJpeE5cIik7XG5zZXRTaGFkZXJDb25zdGFudChYQy5TSEFERVJfQ09OU1RBTlRfS0VZLldPUkxEX1RSQU5TRk9STSwgXCJtb2RlbE1hdHJpeFwiKTtcbnJlZ2lzdGVyRXJyb3JDYWxsYmFjayhmdW5jdGlvbihtZXNzYWdlLCB4Zmxvd05vZGUpe1xuICAgIG1lc3NhZ2UgPSBcIlhmbG93OiBcIiArIG1lc3NhZ2U7XG4gICAgdmFyIHVzZXJEYXRhID0geGZsb3dOb2RlID8geGZsb3dOb2RlLnVzZXJEYXRhIDogbnVsbDtcbiAgICBpZiAodXNlckRhdGEgJiYgdXNlckRhdGEub3duZXJEb2N1bWVudCkge1xuICAgICAgICBpZiAodXNlckRhdGEub3duZXJEb2N1bWVudCA9PT0gZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKG1lc3NhZ2UsIHVzZXJEYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1c2VyRGF0YS5pZCkge1xuICAgICAgICAgICAgdmFyIHVyaSA9IG5ldyBVUkkoXCIjXCIgKyB1c2VyRGF0YS5pZCk7XG4gICAgICAgICAgICB1cmkgPSB1cmkuZ2V0QWJzb2x1dGVVUkkodXNlckRhdGEub3duZXJEb2N1bWVudC5fZG9jdW1lbnRVUkwgfHwgdXNlckRhdGEub3duZXJEb2N1bWVudC5VUkwpO1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IobWVzc2FnZSwgXCJFeHRlcm5hbCBOb2RlOiBcIiArIHVyaSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihtZXNzYWdlLCBcIkV4dGVybmFsIERvY3VtZW50OiBcIiArIHVzZXJEYXRhLm93bmVyRG9jdW1lbnQuVVJMKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdXNlckRhdGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihtZXNzYWdlLCB1c2VyRGF0YSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihtZXNzYWdlKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlRGF0YUFkYXB0ZXI7XG4iLCJ2YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG52YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xuXG4vKipcbiAqIERhdGFBZGFwdGVyIGhhbmRsaW5nIGEgPGNvbXB1dGU+IGVsZW1lbnRcbiAqIEBwYXJhbSB7QWRhcHRlckZhY3Rvcnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb21wdXRlRGF0YUFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoQ29tcHV0ZURhdGFBZGFwdGVyLCBOb2RlQWRhcHRlcik7XG5cbkNvbXB1dGVEYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29tcHV0ZUNvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS52YWx1ZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGV2dCBub3RpZmljYXRpb24gb2YgdHlwZSBYTUwzRC5Ob3RpZmljYXRpb25cbiAqL1xuQ29tcHV0ZURhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcbiAgICAgICAgY2FzZSBFdmVudHMuVkFMVUVfTU9ESUZJRUQ6XG4gICAgICAgIGNhc2UgRXZlbnRzLk5PREVfSU5TRVJURUQ6XG4gICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLm5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50QWRhcHRlciA9IHRoaXMuZmFjdG9yeS5nZXRBZGFwdGVyKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgcGFyZW50QWRhcHRlciAmJiBwYXJlbnRBZGFwdGVyLnVwZGF0ZVhmbG93Tm9kZSgpO1xuICAgICAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcHV0ZURhdGFBZGFwdGVyO1xuIiwidmFyIEJhc2VEYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG52YXIgZGlzcGF0Y2hDdXN0b21FdmVudCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy9taXNjLmpzXCIpLmRpc3BhdGNoQ3VzdG9tRXZlbnQ7XG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XG5cbi8qKlxuICogVGhlIERhdGFBZGFwdGVyIGltcGxlbWVudHMgdGhlXG4gKiBEYXRhQ29sbGVjdG9yIGNvbmNlcHQgYW5kIHNlcnZlcyBhcyBiYXNpcyBvZiBhbGwgRGF0YUFkYXB0ZXIgY2xhc3Nlcy4gSW5cbiAqIGdlbmVyYWwsIGEgRGF0YUFkYXB0ZXIgaXMgYXNzb2NpYXRlZCB3aXRoIGFuIGVsZW1lbnQgbm9kZSB3aGljaCB1c2VzXG4gKiBnZW5lcmljIGRhdGEgYW5kIHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgdmlhXG4gKiBYTUwzRERhdGFBZGFwdGVyRmFjdG9yeSB0byBlbnN1cmUgcHJvcGVyIGZ1bmN0aW9uYWxpdHkuXG4gKlxuICogQGV4dGVuZHMgQWRhcHRlclxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIGZhY3RvcnlcbiAqIEBwYXJhbSBub2RlXG4gKi9cbnZhciBEYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XG4gICAgQmFzZURhdGFBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG4gICAgLy8gTm9kZSBoYW5kbGVzIGZvciBzcmMgYW5kIHByb3RvXG4gICAgdGhpcy54Zmxvd0RhdGFOb2RlID0gbnVsbDtcbiAgICB0aGlzLmV4dGVybmFsU2NyaXB0cyA9IHt9O1xufTtcblhNTDNELmNyZWF0ZUNsYXNzKERhdGFBZGFwdGVyLCBCYXNlRGF0YUFkYXB0ZXIpO1xuXG5EYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnhmbG93RGF0YU5vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xuICAgIHRoaXMueGZsb3dEYXRhTm9kZS5hZGRMb2FkTGlzdGVuZXIodGhpcy5vblhmbG93TG9hZEV2ZW50LmJpbmQodGhpcykpO1xuICAgIHRoaXMueGZsb3dEYXRhTm9kZS51c2VyRGF0YSA9IHRoaXMubm9kZTtcblxuICAgIC8vIFNldHRpbmcgcGxhdGZvcm0gYW5kIG5vZGUgdHlwZSBpbmZvcm1hdGlvbiBmb3IgYSBkYXRhIHNlcXVlbmNlXG4gICAgdGhpcy54Zmxvd0RhdGFOb2RlLnNldFBsYXRmb3JtKHRoaXMubm9kZS5nZXRBdHRyaWJ1dGUoXCJwbGF0Zm9ybVwiKSk7XG5cbiAgICB0aGlzLnVwZGF0ZUFkYXB0ZXJIYW5kbGUoXCJzcmNcIiwgdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcInNyY1wiKSk7XG4gICAgaWYoIXRoaXMuYXNzZXREYXRhKXtcbiAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLnNldEZpbHRlcih0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwiZmlsdGVyXCIpKTtcbiAgICAgICAgdXBkYXRlQ29tcHV0ZSh0aGlzKTtcbiAgICB9XG4gICAgcmVjdXJzaXZlRGF0YUFkYXB0ZXJDb25zdHJ1Y3Rpb24odGhpcyk7XG59O1xuXG5EYXRhQWRhcHRlci5wcm90b3R5cGUudXBkYXRlQWRhcHRlckhhbmRsZSA9IGZ1bmN0aW9uKGtleSwgdXJsKSB7XG4gICAgdmFyIG9sZEFkYXB0ZXJIYW5kbGUgPSB0aGlzLmdldENvbm5lY3RlZEFkYXB0ZXJIYW5kbGUoa2V5KTtcblxuICAgIHZhciBhZGFwdGVySGFuZGxlID0gdGhpcy5nZXRBZGFwdGVySGFuZGxlKHVybCksXG4gICAgICAgIHN0YXR1cyA9IChhZGFwdGVySGFuZGxlICYmIGFkYXB0ZXJIYW5kbGUuc3RhdHVzKTtcblxuICAgIGlmKG9sZEFkYXB0ZXJIYW5kbGUgPT0gYWRhcHRlckhhbmRsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmIChzdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCkge1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgb2YgdXJsICdcIiArIGFkYXB0ZXJIYW5kbGUudXJsICsgXCInIGZvciBcIiArIGtleSwgdGhpcy5ub2RlKTtcbiAgICB9XG4gICAgdGhpcy5jb25uZWN0QWRhcHRlckhhbmRsZShrZXksIGFkYXB0ZXJIYW5kbGUpO1xuICAgIHRoaXMuY29ubmVjdGVkQWRhcHRlckNoYW5nZWQoa2V5LCBhZGFwdGVySGFuZGxlID8gYWRhcHRlckhhbmRsZS5nZXRBZGFwdGVyKCkgOiBudWxsLCBzdGF0dXMpO1xufTtcblxuRGF0YUFkYXB0ZXIucHJvdG90eXBlLm9uWGZsb3dMb2FkRXZlbnQgPSBmdW5jdGlvbihub2RlLCBuZXdMZXZlbCwgb2xkTGV2ZWwpe1xuICAgIGlmKG5ld0xldmVsID09IEluZmluaXR5KXtcbiAgICAgICAgZGlzcGF0Y2hDdXN0b21FdmVudCh0aGlzLm5vZGUsICdsb2FkJywgZmFsc2UsIHRydWUsIG51bGwpO1xuICAgIH1cbiAgICBlbHNlIGlmKG5ld0xldmVsID4gb2xkTGV2ZWwpe1xuICAgICAgICBkaXNwYXRjaEN1c3RvbUV2ZW50KHRoaXMubm9kZSwgJ3Byb2dyZXNzJywgZmFsc2UsIHRydWUsIG51bGwpO1xuICAgIH1cbn07XG5EYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0YUNvbXBsZXRlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy54Zmxvd0RhdGFOb2RlLmdldFByb2dyZXNzTGV2ZWwoKSA9PSBJbmZpbml0eTtcbn07XG5EYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0RGF0YVByb2dyZXNzTGV2ZWwgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLnhmbG93RGF0YU5vZGUuZ2V0UHJvZ3Jlc3NMZXZlbCgpO1xufTtcblxuICAgIC8qKiBSZWN1cnNpdmVseSBwYXNzaW5nIHBsYXRmb3JtIGluZm9ybWF0aW9uIHRvIGNoaWxkcmVuIG9mIGEgZGF0YSBub2RlXG4gICAgICogIFJlcXVpcmVzIHRoYXQgdGhlIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50cyBvZiBkYXRhIG5vZGVzIGFyZSBkZWZpbmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0RhdGFOb2RlfSBwYXJlbnROb2RlXG4gICAgICovXG5mdW5jdGlvbiByZWN1cnNpdmVEYXRhTm9kZUF0dHJJbml0KHBhcmVudE5vZGUpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnROb2RlLl9jaGlsZHJlbiwgTkNoaWxkcmVuLCBpO1xuXG4gICAgaWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgTkNoaWxkcmVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgIGZvciAoaSA9IE5DaGlsZHJlbjsgaS0tOykge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldIGluc3RhbmNlb2YgRGF0YU5vZGUpIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRQbGF0Zm9ybShwYXJlbnROb2RlLl9wbGF0Zm9ybSk7XG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlRGF0YU5vZGVBdHRySW5pdChjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZURhdGFBZGFwdGVyQ29uc3RydWN0aW9uKGFkYXB0ZXIpIHtcbiAgICBmb3IgKHZhciBjaGlsZCA9IGFkYXB0ZXIubm9kZS5maXJzdEVsZW1lbnRDaGlsZDsgY2hpbGQgIT09IG51bGw7IGNoaWxkID0gY2hpbGQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgICAgIHZhciBzdWJhZGFwdGVyID0gYWRhcHRlci5mYWN0b3J5LmdldEFkYXB0ZXIoY2hpbGQpO1xuICAgICAgICBpZiAoc3ViYWRhcHRlcikge1xuICAgICAgICAgICAgaWYgKHN1YmFkYXB0ZXIuZ2V0WGZsb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgYWRhcHRlci54Zmxvd0RhdGFOb2RlLmFwcGVuZENoaWxkKHN1YmFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdWJhZGFwdGVyLmdldFNjcmlwdFR5cGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NyaXB0SWQgPSBzdWJhZGFwdGVyLm5vZGUubmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIXNjcmlwdElkKSB7XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiUGFyc2luZyBlcnJvcjogRXh0ZXJuYWxseSByZWZlcmVuY2VkIG9wZXJhdG9ycyBtdXN0IGhhdmUgYSAnbmFtZScgYXR0cmlidXRlIG1hdGNoaW5nIHRoZSBuYW1lIHRoZXkgd2VyZSByZWdpc3RlcmVkIHdpdGguIFwiLCBzdWJhZGFwdGVyLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRJZCA9IFwidW5rbm93bl9vcGVyYXRvclwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhZGFwdGVyLmV4dGVybmFsU2NyaXB0c1tzY3JpcHRJZF0gPSBzdWJhZGFwdGVyO1xuICAgICAgICAgICAgICAgIGlmIChzdWJhZGFwdGVyLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRhcHRlci5jb25uZWN0QWRhcHRlckhhbmRsZShzY3JpcHRJZCwgc3ViYWRhcHRlci5jb25uZWN0ZWRBZGFwdGVySGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWRhcHRlci54Zmxvd0RhdGFOb2RlLnNldExvYWRpbmcodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXNzZXMgX3BsYXRmb3JtIHZhbHVlcyB0byBjaGlsZHJlbiBub2RlcyBzdGFydGluZyBmcm9tIHRoZSBub2RlXG4gICAgICAgICAgICAvLyB3aGVyZSB0aGVzZSBhdHRyaWJ1dGVzIGFyZSBmaXJzdCBkZWZpbmVkXG4gICAgICAgICAgICBpZiAoYWRhcHRlci54Zmxvd0RhdGFOb2RlLl9wbGF0Zm9ybSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZURhdGFOb2RlQXR0ckluaXQoYWRhcHRlci54Zmxvd0RhdGFOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgbm90aWZ5Q2hhbmdlZCgpIG1ldGhvZCBpcyBjYWxsZWQgYnkgdGhlIFhNTDNEIGRhdGEgc3RydWN0dXJlIHRvXG4gKiBub3RpZnkgdGhlIERhdGFBZGFwdGVyIGFib3V0IGRhdGEgY2hhbmdlcyAoRE9NIG11c3RhdGlvbiBldmVudHMpIGluIGl0c1xuICogYXNzb2NpYXRpbmcgbm9kZS4gV2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQsIGFsbCBvYnNlcnZlcnMgb2YgdGhlXG4gKiBEYXRhQWRhcHRlciBhcmUgbm90aWZpZWQgYWJvdXQgZGF0YSBjaGFuZ2VzIHZpYSB0aGVpciBub3RpZnlEYXRhQ2hhbmdlZCgpXG4gKiBtZXRob2QuXG4gKlxuICogQHBhcmFtIGV2dCBub3RpZmljYXRpb24gb2YgdHlwZSBYTUwzRC5Ob3RpZmljYXRpb25cbiAqL1xuRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09PSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRCkge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkKGV2dC5rZXksIGV2dC5hZGFwdGVyLCBldnQuaGFuZGxlU3RhdHVzKTtcbiAgICAgICAgaWYgKGV2dC5oYW5kbGVTdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgZmluZCA8ZGF0YT4gZWxlbWVudCBvZiB1cmwgJ1wiICsgZXZ0LnVybCArIFwiJyBmb3IgXCIgKyBldnQua2V5LCB0aGlzLm5vZGUpO1xuICAgICAgICB9XG5cbiAgICB9IGVsc2UgaWYgKGV2dC50eXBlID09PSBFdmVudHMuTk9ERV9JTlNFUlRFRCkge1xuICAgICAgICB2YXIgaW5zZXJ0ZWROb2RlID0gZXZ0LmFmZmVjdGVkTm9kZTtcbiAgICAgICAgdmFyIGFkYXB0ZXIgPSB0aGlzLmZhY3RvcnkuZ2V0QWRhcHRlcihpbnNlcnRlZE5vZGUpO1xuICAgICAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbnNlcnRlZFhmbG93Tm9kZSA9IGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCk7XG4gICAgICAgIHZhciBzaWJsaW5nID0gaW5zZXJ0ZWROb2RlLCBmb2xsb3dVcEFkYXB0ZXIgPSBudWxsO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICB9IHdoaWxlIChzaWJsaW5nICYmICEoZm9sbG93VXBBZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIoc2libGluZykpKTtcblxuICAgICAgICBpZiAoZm9sbG93VXBBZGFwdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnhmbG93RGF0YU5vZGUuaW5zZXJ0QmVmb3JlKGluc2VydGVkWGZsb3dOb2RlLCBmb2xsb3dVcEFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLmFwcGVuZENoaWxkKGluc2VydGVkWGZsb3dOb2RlKTtcbiAgICAgICAgfVxuXG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PT0gRXZlbnRzLk5PREVfUkVNT1ZFRCkge1xuICAgICAgICB2YXIgYWRhcHRlciA9IHRoaXMuZmFjdG9yeS5nZXRBZGFwdGVyKGV2dC5hZmZlY3RlZE5vZGUpO1xuICAgICAgICBpZiAoIWFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW1vdmVkWGZsb3dOb2RlID0gYWRhcHRlci5nZXRYZmxvd05vZGUoKTtcbiAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLnJlbW92ZUNoaWxkKHJlbW92ZWRYZmxvd05vZGUpO1xuXG4gICAgfSBlbHNlIGlmIChldnQudHlwZSA9PT0gRXZlbnRzLlRISVNfUkVNT1ZFRCkge1xuICAgICAgICB0aGlzLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcbiAgICB9XG59O1xuXG5EYXRhQWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgIGlmIChuYW1lID09PSBcImZpbHRlclwiICYmICF0aGlzLmFzc2V0RGF0YSkge1xuICAgICAgICB0aGlzLnhmbG93RGF0YU5vZGUuc2V0RmlsdGVyKG5ld1ZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09IFwiY29tcHV0ZVwiICYmICF0aGlzLmFzc2V0RGF0YSkge1xuICAgICAgICB1cGRhdGVDb21wdXRlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJzcmNcIikge1xuICAgICAgICB0aGlzLnVwZGF0ZUFkYXB0ZXJIYW5kbGUobmFtZSwgbmV3VmFsdWUpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gXCJwbGF0Zm9ybVwiKSB7XG4gICAgICAgIHVwZGF0ZVBsYXRmb3JtKHRoaXMpO1xuICAgIH1cbn07XG5cbkRhdGFBZGFwdGVyLnByb3RvdHlwZS5jb25uZWN0ZWRBZGFwdGVyQ2hhbmdlZCA9IGZ1bmN0aW9uIChrZXksIGFkYXB0ZXIgLyosIHN0YXR1cyAqLykge1xuICAgIGlmIChrZXkgPT09IFwic3JjXCIpIHtcbiAgICAgICAgdGhpcy54Zmxvd0RhdGFOb2RlLnNvdXJjZU5vZGUgPSBhZGFwdGVyID8gYWRhcHRlci5nZXRYZmxvd05vZGUoKSA6IG51bGw7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwiZGF0YWZsb3dcIikge1xuICAgICAgICB0aGlzLnhmbG93RGF0YU5vZGUuZGF0YWZsb3dOb2RlID0gYWRhcHRlciA/IGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkgOiBudWxsO1xuICAgIH0gZWxzZSBpZiAodGhpcy5leHRlcm5hbFNjcmlwdHNba2V5XSkge1xuICAgICAgICB3aW5kb3cuZXZhbChhZGFwdGVyLnNjcmlwdCk7XG4gICAgICAgIHRoaXMueGZsb3dEYXRhTm9kZS5ub3RpZnkoWEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcbiAgICB9XG4gICAgLy8gQ3ljbGUgdGhlIGxvYWQgc3RhdGUgdG8gZm9yY2UgYSBsb2FkIGV2ZW50IGV2ZW4gaWYgdGhlIG5ldyBzb3VyY2VOb2RlIGlzIGNhY2hlZFxuICAgIHRoaXMueGZsb3dEYXRhTm9kZS5zZXRMb2FkaW5nKHRydWUpO1xuICAgIHVwZGF0ZUxvYWRTdGF0ZSh0aGlzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRhQWRhcHRlclxuICovXG5EYXRhQWRhcHRlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiRGF0YUFkYXB0ZXJcIjtcbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbXB1dGUoZGF0YUFkYXB0ZXIpIHtcbiAgICB2YXIgeGZsb3dOb2RlID0gZGF0YUFkYXB0ZXIueGZsb3dEYXRhTm9kZTtcbiAgICB4Zmxvd05vZGUuc2V0Q29tcHV0ZShkYXRhQWRhcHRlci5ub2RlLmdldEF0dHJpYnV0ZShcImNvbXB1dGVcIikpO1xuICAgIGlmICh4Zmxvd05vZGUuY29tcHV0ZURhdGFmbG93VXJsKSB7XG4gICAgICAgIGRhdGFBZGFwdGVyLnVwZGF0ZUFkYXB0ZXJIYW5kbGUoXCJkYXRhZmxvd1wiLCB4Zmxvd05vZGUuY29tcHV0ZURhdGFmbG93VXJsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRhdGFBZGFwdGVyLmRpc2Nvbm5lY3RBZGFwdGVySGFuZGxlKFwiZGF0YWZsb3dcIik7XG4gICAgICAgIHVwZGF0ZUxvYWRTdGF0ZShkYXRhQWRhcHRlcik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVQbGF0Zm9ybShkYXRhQWRhcHRlcikge1xuICAgIHZhciB4Zmxvd05vZGUgPSBkYXRhQWRhcHRlci54Zmxvd0RhdGFOb2RlO1xuXG4gICAgeGZsb3dOb2RlLnNldFBsYXRmb3JtKGRhdGFBZGFwdGVyLm5vZGUuZ2V0QXR0cmlidXRlKFwicGxhdGZvcm1cIikpO1xuICAgIHJlY3Vyc2l2ZURhdGFOb2RlQXR0ckluaXQoeGZsb3dOb2RlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTG9hZFN0YXRlKGRhdGFBZHBhdGVyKSB7XG4gICAgdmFyIGxvYWRpbmcgPSBmYWxzZSwgaGFuZGxlO1xuXG4gICAgaGFuZGxlID0gZGF0YUFkcGF0ZXIuZ2V0Q29ubmVjdGVkQWRhcHRlckhhbmRsZShcInNyY1wiKTtcbiAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5zdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkcpIHtcbiAgICAgICAgbG9hZGluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgaGFuZGxlID0gZGF0YUFkcGF0ZXIuZ2V0Q29ubmVjdGVkQWRhcHRlckhhbmRsZShcImRhdGFmbG93XCIpO1xuICAgIGlmIChoYW5kbGUgJiYgaGFuZGxlLnN0YXR1cyA9PT0gQWRhcHRlckhhbmRsZS5TVEFUVVMuTE9BRElORykge1xuICAgICAgICBsb2FkaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBuYW1lIGluIGRhdGFBZHBhdGVyLmV4dGVybmFsU2NyaXB0cykge1xuICAgICAgICBoYW5kbGUgPSBkYXRhQWRwYXRlci5nZXRDb25uZWN0ZWRBZGFwdGVySGFuZGxlKG5hbWUpO1xuICAgICAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5zdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkcpIHtcbiAgICAgICAgICAgIGxvYWRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGF0YUFkcGF0ZXIueGZsb3dEYXRhTm9kZS5zZXRMb2FkaW5nKGxvYWRpbmcpO1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YUFkYXB0ZXI7XG5cblxuIiwidmFyIEJhc2VEYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLkRhdGFOb2RlO1xudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XG5cbi8qKlxuICogRGF0YUFkYXB0ZXIgaGFuZGxpbmcgYSA8ZGF0YWZsb3c+IGVsZW1lbnRcbiAqIEBwYXJhbSBmYWN0b3J5XG4gKiBAcGFyYW0gbm9kZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhZmxvd0RhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcbiAgICBCYXNlRGF0YUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcbiAgICB0aGlzLnhmbG93RGF0YU5vZGUgPSBudWxsO1xuICAgIHRoaXMuZXh0ZXJuYWxTY3JpcHRzID0ge307XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoRGF0YWZsb3dEYXRhQWRhcHRlciwgQmFzZURhdGFBZGFwdGVyKTtcblxuRGF0YWZsb3dEYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnhmbG93RGF0YU5vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xuICAgIHRoaXMuZGF0YWZsb3dSZWZzID0gW107XG4gICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcywgdGhpcy5ub2RlKTtcbn07XG5cbkRhdGFmbG93RGF0YUFkYXB0ZXIucHJvdG90eXBlLnVwZGF0ZUFkYXB0ZXJIYW5kbGUgPSBmdW5jdGlvbihrZXksIHVybCkge1xuICAgIHZhciBvbGRBZGFwdGVySGFuZGxlID0gdGhpcy5nZXRDb25uZWN0ZWRBZGFwdGVySGFuZGxlKGtleSk7XG5cbiAgICB2YXIgYWRhcHRlckhhbmRsZSA9IHRoaXMuZ2V0QWRhcHRlckhhbmRsZSh1cmwpLFxuICAgICAgICBzdGF0dXMgPSAoYWRhcHRlckhhbmRsZSAmJiBhZGFwdGVySGFuZGxlLnN0YXR1cyk7XG5cbiAgICBpZihvbGRBZGFwdGVySGFuZGxlID09IGFkYXB0ZXJIYW5kbGUpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoc3RhdHVzID09PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IG9mIHVybCAnXCIgKyBhZGFwdGVySGFuZGxlLnVybCArIFwiJyBmb3IgXCIgKyBrZXksIHRoaXMubm9kZSk7XG4gICAgfVxuICAgIHRoaXMuY29ubmVjdEFkYXB0ZXJIYW5kbGUoa2V5LCBhZGFwdGVySGFuZGxlKTtcbiAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkKGtleSwgYWRhcHRlckhhbmRsZSA/IGFkYXB0ZXJIYW5kbGUuZ2V0QWRhcHRlcigpIDogbnVsbCwgc3RhdHVzKTtcbn07XG5cblxuLyoqXG4gKiBAcGFyYW0gZXZ0IG5vdGlmaWNhdGlvbiBvZiB0eXBlIFhNTDNELk5vdGlmaWNhdGlvblxuICovXG5EYXRhZmxvd0RhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIGlmIChldnQudHlwZSA9PT0gRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQpIHtcbiAgICAgICAgLy9UT0RPOiBIYW5kbGUgQURBUFRFUl9IQU5ETEVfQ0hBTkdFRFxuICAgICAgICBpZiAodGhpcy5leHRlcm5hbFNjcmlwdHNbZXZ0LmtleV0pIHtcbiAgICAgICAgICAgIHdpbmRvdy5ldmFsKGV2dC5hZGFwdGVyLnNjcmlwdCk7XG4gICAgICAgICAgICBzZXRMb2FkaW5nU3RhdGVGb3JNYXRjaGluZ1hmbG93Tm9kZXModGhpcy54Zmxvd0RhdGFOb2RlLCBldnQua2V5LCBmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLnhmbG93RGF0YU5vZGUubm90aWZ5KFhDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQ6XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkKGV2dC5rZXksIGV2dC5hZGFwdGVyLCBldnQuaGFuZGxlU3RhdHVzKTtcbiAgICAgICAgICAgIGlmIChldnQuaGFuZGxlU3RhdHVzID09PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNvdWxkIG5vdCBmaW5kIGRhdGFmbG93IG9mIHVybCAnXCIgKyBldnQudXJsLCB0aGlzLm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9JTlNFUlRFRDpcbiAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9SRU1PVkVEOlxuICAgICAgICAgICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEV2ZW50cy5WQUxVRV9NT0RJRklFRDpcbiAgICAgICAgICAgIHZhciBhdHRyID0gZXZ0Lm11dGF0aW9uLmF0dHJpYnV0ZU5hbWU7XG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gXCJvdXRcIikge1xuICAgICAgICAgICAgICAgIHVwZGF0ZURhdGFmbG93T3V0KHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhdHRyID09PSBcInBsYXRmb3JtXCIpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVEYXRhZmxvd1hmbG93Tm9kZSh0aGlzLCB0aGlzLm5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuLyoqXG4gKiBUcmF2ZXJzZSBhbGwgc3Vibm9kZXMgb2YgYSBkYXRhZmxvdyBhbmQgc2V0IHRoZSBsb2FkaW5nIHN0YXRlIG9mXG4gKiBhbGwgbm9kZXMgd2l0aCBhIGNvbXB1dGUgb3BlcmF0b3IgdGhhdCByZWxpZXMgb24gdGhlIG1hdGNoaW5nIGV4dGVybmFsIHNjcmlwdCBuYW1lLlxuICogQSBjb21wdXRlIG5vZGUgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGlmIGl0cyBsb2FkaW5nIHN0YXRlIGlzICdmYWxzZScgYW5kIG5vbmUgb2YgaXRzIGNoaWxkcmVuIGFyZSAnbG9hZGluZycsIHNvXG4gKiB0aGlzIGVuc3VyZXMgd2UgZG9uJ3QgZG8gdGhlIGNvbXB1dGUgb3BlcmF0aW9ucyB1bnRpbCB0aGUgZXh0ZXJuYWwgb3BlcmF0b3JzIGhhdmUgYmVlbiBsb2FkZWQuXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBub2RlIHRoZSBjdXJyZW50IG5vZGUgdG8gY2hlY2sgZm9yIGluc3RhbmNlcyBvZiB0aGUgZ2l2ZW4gb3BlcmF0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBleHRlcm5hbCBvcGVyYXRvciB0byBjaGVjayBmb3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9hZGluZyB3aGV0aGVyIHRoZSBvcGVyYXRvciBoYXMgZmluaXNoZWQgbG9hZGluZyBvciBub3RcbiAqL1xuZnVuY3Rpb24gc2V0TG9hZGluZ1N0YXRlRm9yTWF0Y2hpbmdYZmxvd05vZGVzKG5vZGUsIG5hbWUsIGxvYWRpbmcpIHtcbiAgICBpZiAobm9kZS5fY29tcHV0ZU9wZXJhdG9yID09PSBuYW1lKSB7XG4gICAgICAgIG5vZGUuc2V0TG9hZGluZyhsb2FkaW5nKTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX2NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBpID0gbm9kZS5fY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICBzZXRMb2FkaW5nU3RhdGVGb3JNYXRjaGluZ1hmbG93Tm9kZXMobm9kZS5fY2hpbGRyZW5baV0sIG5hbWUsIGxvYWRpbmcpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5EYXRhZmxvd0RhdGFBZGFwdGVyLnByb3RvdHlwZS51cGRhdGVYZmxvd05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXBkYXRlRGF0YWZsb3dYZmxvd05vZGUodGhpcywgdGhpcy5ub2RlKTtcbn07XG5cbkRhdGFmbG93RGF0YUFkYXB0ZXIucHJvdG90eXBlLmNvbm5lY3RlZEFkYXB0ZXJDaGFuZ2VkID0gZnVuY3Rpb24gKGtleSwgYWRhcHRlciwgc3RhdHVzKSB7XG4gICAgdmFyIHhmbG93Tm9kZSA9IHRoaXMuZGF0YWZsb3dSZWZzW2tleV07XG4gICAgaWYgKHhmbG93Tm9kZSkge1xuICAgICAgICB4Zmxvd05vZGUuZGF0YWZsb3dOb2RlID0gYWRhcHRlciA/IGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCkgOiBudWxsO1xuICAgICAgICB4Zmxvd05vZGUuc2V0TG9hZGluZyhzdGF0dXMgPT09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLkxPQURJTkcpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHVwZGF0ZURhdGFmbG93T3V0KGFkYXB0ZXIpIHtcbiAgICB2YXIgb3V0ID0gYWRhcHRlci5ub2RlLmdldEF0dHJpYnV0ZShcIm91dFwiKTtcbiAgICBpZiAob3V0KSB7XG4gICAgICAgIGFkYXB0ZXIueGZsb3dEYXRhTm9kZS5zZXRGaWx0ZXIoXCJrZWVwKFwiICsgb3V0ICsgXCIpXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFkYXB0ZXIueGZsb3dEYXRhTm9kZS5zZXRGaWx0ZXIoXCJcIik7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVEYXRhZmxvd1hmbG93Tm9kZShhZGFwdGVyLCBub2RlKSB7XG4gICAgLy8gR2V0dGluZyBwbGF0Zm9ybSBhbmQgbm9kZSB0eXBlIGluZm9ybWF0aW9uIGZvciBhIERhdGFmbG93IG5vZGVcbiAgICB2YXIgcGxhdGZvcm0gPSBub2RlLmdldEF0dHJpYnV0ZShcInBsYXRmb3JtXCIpO1xuXG4gICAgYWRhcHRlci54Zmxvd0RhdGFOb2RlLmNsZWFyQ2hpbGRyZW4oKTtcbiAgICBhZGFwdGVyLnhmbG93RGF0YU5vZGUuc2V0Q29tcHV0ZShcIlwiKTtcbiAgICBhZGFwdGVyLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcbiAgICBhZGFwdGVyLmRhdGFmbG93UmVmcyA9IFtdO1xuICAgIGFkYXB0ZXIuZXh0ZXJuYWxTY3JpcHRzID0ge307XG4gICAgdXBkYXRlRGF0YWZsb3dPdXQoYWRhcHRlcik7XG5cbiAgICB2YXIgY2hpbGQgPSBub2RlLmxhc3RFbGVtZW50Q2hpbGQsIGZpcnN0Tm9kZSA9IHRydWUsIHByZXZOb2RlID0gbnVsbCwgY3VycmVudE5vZGUgPSBhZGFwdGVyLnhmbG93RGF0YU5vZGUsIHN1YkFkYXB0ZXIsIHhmbG93Tm9kZTtcblxuICAgIGRvIHtcbiAgICAgICAgc3ViQWRhcHRlciA9IGFkYXB0ZXIuZmFjdG9yeS5nZXRBZGFwdGVyKGNoaWxkKTtcbiAgICAgICAgaWYgKCFzdWJBZGFwdGVyKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdWJBZGFwdGVyLmdldFhmbG93Tm9kZSkge1xuICAgICAgICAgICAgeGZsb3dOb2RlID0gc3ViQWRhcHRlci5nZXRYZmxvd05vZGUoKTtcblxuICAgICAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUuaW5zZXJ0QmVmb3JlKHhmbG93Tm9kZSwgcHJldk5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5hcHBlbmRDaGlsZCh4Zmxvd05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldk5vZGUgPSB4Zmxvd05vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoc3ViQWRhcHRlci5nZXRDb21wdXRlQ29kZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlbWVudHMgPSBzdWJBZGFwdGVyLmdldENvbXB1dGVDb2RlKCkuc3BsaXQoXCI7XCIpO1xuICAgICAgICAgICAgdmFyIGogPSBzdGF0ZW1lbnRzLmxlbmd0aDtcblxuICAgICAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgICAgIHZhciBjb21wdXRlID0gc3RhdGVtZW50c1tqXS50cmltKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wdXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChmaXJzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeGZsb3dOb2RlID0gbmV3IERhdGFOb2RlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5pbnNlcnRCZWZvcmUoeGZsb3dOb2RlLCBwcmV2Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5hcHBlbmRDaGlsZCh4Zmxvd05vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0geGZsb3dOb2RlO1xuICAgICAgICAgICAgICAgICAgICBwcmV2Tm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLnVzZXJEYXRhID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRQbGF0Zm9ybShwbGF0Zm9ybSk7XG5cbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5zZXRDb21wdXRlKHN0YXRlbWVudHNbal0udHJpbSgpKTtcblxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5jb21wdXRlRGF0YWZsb3dVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkeCA9IGFkYXB0ZXIuZGF0YWZsb3dSZWZzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgYWRhcHRlci5kYXRhZmxvd1JlZnMucHVzaChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkYXB0ZXIudXBkYXRlQWRhcHRlckhhbmRsZShpZHgsIGN1cnJlbnROb2RlLmNvbXB1dGVEYXRhZmxvd1VybCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHN1YkFkYXB0ZXIuZ2V0U2NyaXB0VHlwZSkge1xuICAgICAgICAgICAgdmFyIHNjcmlwdElkID0gc3ViQWRhcHRlci5ub2RlLm5hbWU7XG4gICAgICAgICAgICBpZiAoIXNjcmlwdElkKSB7XG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJQYXJzaW5nIGVycm9yOiBFeHRlcm5hbGx5IHJlZmVyZW5jZWQgb3BlcmF0b3JzIG11c3QgaGF2ZSBhICduYW1lJyBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIG5hbWUgdGhleSB3ZXJlIHJlZ2lzdGVyZWQgd2l0aC4gXCIsIHN1YkFkYXB0ZXIubm9kZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0SWQgPSBcInVua25vd25fb3BlcmF0b3JcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkYXB0ZXIuZXh0ZXJuYWxTY3JpcHRzW3NjcmlwdElkXSA9IHN1YkFkYXB0ZXI7XG4gICAgICAgICAgICBpZiAoc3ViQWRhcHRlci5jb25uZWN0ZWRBZGFwdGVySGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgYWRhcHRlci5jb25uZWN0QWRhcHRlckhhbmRsZShzY3JpcHRJZCwgc3ViQWRhcHRlci5jb25uZWN0ZWRBZGFwdGVySGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gYWRhcHRlci5leHRlcm5hbFNjcmlwdHMpIHtcbiAgICAgICAgLy8gRW5zdXJlIFhGbG93IGRvZXNuJ3QgZXhlY3V0ZSBhbnkgY29tcHV0ZSBub2RlcyB0aGF0IGRlcGVuZCBvbiBleHRlcm5hbCBzY3JpcHRzIHVudGlsIHRoZXkncmUgbG9hZGVkXG4gICAgICAgIHNldExvYWRpbmdTdGF0ZUZvck1hdGNoaW5nWGZsb3dOb2RlcyhhZGFwdGVyLnhmbG93RGF0YU5vZGUsIG5hbWUsIHRydWUpO1xuICAgIH1cbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFmbG93RGF0YUFkYXB0ZXI7XG4iLCJ2YXIgTm9kZUFkYXB0ZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlckZhY3Rvcnk7XG52YXIgQXNzZXQgPSByZXF1aXJlKFwiLi9hc3NldC5qc1wiKTtcbnZhciBNaXNjID0gcmVxdWlyZShcIi4vbWlzYy5qc1wiKTtcbnZhciBTY3JpcHREYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL3NjcmlwdC5qc1wiKTtcbnZhciBUZXh0dXJlRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi90ZXh0dXJlLmpzXCIpO1xudmFyIFRyYW5zZm9ybURhdGFBZGFwdGVyID0gcmVxdWlyZShcIi4vdHJhbnNmb3JtLmpzXCIpO1xudmFyIFZhbHVlRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi92YWx1ZXMuanNcIik7XG52YXIgRGF0YUFkYXB0ZXIgPSByZXF1aXJlKFwiLi9kYXRhLmpzXCIpO1xudmFyIENvbXB1dGVEYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL2NvbXB1dGUuanNcIik7XG52YXIgRGF0YWZsb3dEYXRhQWRhcHRlciA9IHJlcXVpcmUoXCIuL2RhdGFmbG93LmpzXCIpO1xuLy8gUmVnaXN0ZXIgSlNPTiBIYW5kbGVyXG5yZXF1aXJlKFwiLi9qc29uL2ZhY3RvcnkuanNcIik7XG4vLyBSZWdpc3RlciBKYXZhU2NyaXB0IEhhbmRsZXIgKHJlcXVpcmVkIGZvciBleHRlcm5hbCBzaGFkZS5qcyBKYXZhc2NyaXB0IHJlc291cmNlcylcbnJlcXVpcmUoXCIuL2phdmFzY3JpcHQvZmFjdG9yeS5qc1wiKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBvZiBYTUwzRERhdGFBZGFwdGVyRmFjdG9yeVxuICogWE1MM0REYXRhQWRhcHRlckZhY3RvcnkgY3JlYXRlcyBEYXRhQWRhcHRlciBpbnN0YW5jZXMgZm9yIGVsZW1lbnRzIHVzaW5nIGdlbmVyaWMgZGF0YSAoPG1lc2g+LCA8ZGF0YT4sIDxmbG9hdD4sLi4uKS5cbiAqIEFkZGl0aW9uYWxseSwgaXQgbWFuYWdlcyBhbGwgRGF0YUFkYXB0ZXIgaW5zdGFuY2VzIHNvIHRoYXQgZm9yIGVhY2ggbm9kZSB0aGVyZSBpcyBhbHdheXMganVzdCBvbmUgRGF0YUFkYXB0ZXIuIFdoZW5cbiAqIGl0IGNyZWF0ZXMgYSBEYXRhQWRhcHRlciwgaXQgY2FsbHMgaXRzIGluaXQgbWV0aG9kLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQWRhcHRlckZhY3RvcnlcbiAqL1xuXG52YXIgWE1MM0REYXRhQWRhcHRlckZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgTm9kZUFkYXB0ZXJGYWN0b3J5LmNhbGwodGhpcywgXCJkYXRhXCIpO1xufTtcblhNTDNELmNyZWF0ZUNsYXNzKFhNTDNERGF0YUFkYXB0ZXJGYWN0b3J5LCBOb2RlQWRhcHRlckZhY3RvcnkpO1xuWE1MM0REYXRhQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLmFzcGVjdCA9IFwiZGF0YVwiO1xuXG52YXIgcmVnID0ge1xuICAgICdtZXNoJzogTWlzYy5TaW5rRGF0YUFkYXB0ZXIsXG4gICAgJ21hdGVyaWFsJzogTWlzYy5TaW5rRGF0YUFkYXB0ZXIsXG4gICAgJ3NoYWRlcic6IE1pc2MuU2lua0RhdGFBZGFwdGVyLCAvLyBUT0RPKGtzb25zKTogUmVtb3ZlIGluIDUuMVxuICAgICdsaWdodCc6IE1pc2MuU2lua0RhdGFBZGFwdGVyLFxuICAgICdmbG9hdCc6IFZhbHVlRGF0YUFkYXB0ZXIsXG4gICAgJ2Zsb2F0Mic6IFZhbHVlRGF0YUFkYXB0ZXIsXG4gICAgJ2Zsb2F0Myc6IFZhbHVlRGF0YUFkYXB0ZXIsXG4gICAgJ2Zsb2F0NCc6IFZhbHVlRGF0YUFkYXB0ZXIsXG4gICAgJ2Zsb2F0NHg0JzogVmFsdWVEYXRhQWRhcHRlcixcbiAgICAnaW50JzogVmFsdWVEYXRhQWRhcHRlcixcbiAgICAnaW50NCc6IFZhbHVlRGF0YUFkYXB0ZXIsXG4gICAgJ2Jvb2wnOiBWYWx1ZURhdGFBZGFwdGVyLFxuICAgICdieXRlJzogVmFsdWVEYXRhQWRhcHRlcixcbiAgICAndWJ5dGUnOiBWYWx1ZURhdGFBZGFwdGVyLFxuICAgICdpbWcnOiBNaXNjLkltZ0RhdGFBZGFwdGVyLFxuICAgICd0ZXh0dXJlJzogVGV4dHVyZURhdGFBZGFwdGVyLFxuICAgICdkYXRhJzogRGF0YUFkYXB0ZXIsXG4gICAgJ3Byb3RvJzogRGF0YUFkYXB0ZXIsXG4gICAgJ2RhdGFmbG93JzogRGF0YWZsb3dEYXRhQWRhcHRlcixcbiAgICAnY29tcHV0ZSc6IENvbXB1dGVEYXRhQWRhcHRlcixcbiAgICAndmlkZW8nOiBNaXNjLlZpZGVvRGF0YUFkYXB0ZXIsXG4gICAgJ3NjcmlwdCc6IFNjcmlwdERhdGFBZGFwdGVyLFxuICAgICd0cmFuc2Zvcm0nOiBUcmFuc2Zvcm1EYXRhQWRhcHRlcixcbiAgICAnYXNzZXQnOiBBc3NldC5Bc3NldEFkYXB0ZXIsXG4gICAgJ2Fzc2V0ZGF0YSc6IEFzc2V0LkFzc2V0RGF0YUFkYXB0ZXIsXG4gICAgJ2Fzc2V0bWVzaCc6IEFzc2V0LkFzc2V0TWVzaEFkYXB0ZXIsXG4gICAgJ21vZGVsJzogQXNzZXQuQXNzZXRBZGFwdGVyXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBEYXRhQWRhcHRlciBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtIG5vZGVcbiAqICAgICAgICAgICAgZWxlbWVudCBub2RlIHdoaWNoIHVzZXMgZ2VuZXJpYyBkYXRhLiBUaGUgc3VwcG9ydGVkIGVsZW1lbnRzXG4gKiAgICAgICAgICAgIGFyZSBsaXN0ZWQgaW4gdGhlIGNsYXNzIGRlc2NyaXB0aW9uIGFib3ZlLlxuICogQHJldHVybnMgRGF0YUFkYXB0ZXIgaW5zdGFuY2VcbiAqL1xuWE1MM0REYXRhQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUFkYXB0ZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vWE1MM0QuZGVidWcubG9nRGVidWcoXCJDcmVhdGluZyBhZGFwdGVyOiBcIiArIG5vZGUubG9jYWxOYW1lKTtcbiAgICB2YXIgYWRhcHRlckNvbnRydWN0b3IgPSByZWdbbm9kZS5sb2NhbE5hbWVdO1xuICAgIGlmIChhZGFwdGVyQ29udHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgYWRhcHRlckNvbnRydWN0b3IodGhpcywgbm9kZSk7XG4gICAgfVxuICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJOb3Qgc3VwcG9ydGVkIGFzIGRhdGEgZWxlbWVudDogXCIgKyBub2RlLmxvY2FsTmFtZSk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9ICBYTUwzRERhdGFBZGFwdGVyRmFjdG9yeTtcbiIsInZhciByZWdpc3RlckZvcm1hdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5yZWdpc3RlckZvcm1hdDtcbnZhciBGb3JtYXRIYW5kbGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvZm9ybWF0aGFuZGxlci5qc1wiKS5Gb3JtYXRIYW5kbGVyO1xudmFyIEFkYXB0ZXJGYWN0b3J5ID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5BZGFwdGVyRmFjdG9yeTtcblxudmFyIEphdmFTY3JpcHRGb3JtYXRIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgIEZvcm1hdEhhbmRsZXIuY2FsbCh0aGlzKTtcbn07XG5YTUwzRC5jcmVhdGVDbGFzcyhKYXZhU2NyaXB0Rm9ybWF0SGFuZGxlciwgRm9ybWF0SGFuZGxlcik7XG5cbkphdmFTY3JpcHRGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5pc0Zvcm1hdFN1cHBvcnRlZCA9IGZ1bmN0aW9uIChyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSkge1xuICAgIHJldHVybiBtaW1ldHlwZSA9PT0gXCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCIgfHwgbWltZXR5cGUgPT09IFwidGV4dC9qYXZhc2NyaXB0XCI7XG59O1xuXG5cbkphdmFTY3JpcHRGb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5nZXRGb3JtYXREYXRhID0gZnVuY3Rpb24gKHJlc3BvbnNlLCByZXNwb25zZVR5cGUsIG1pbWV0eXBlLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrKHRydWUsIHJlc3BvbnNlKTtcbn07XG5cbnZhciBqYXZhU2NyaXB0Rm9ybWF0SGFuZGxlciA9IG5ldyBKYXZhU2NyaXB0Rm9ybWF0SGFuZGxlcigpO1xucmVnaXN0ZXJGb3JtYXQoamF2YVNjcmlwdEZvcm1hdEhhbmRsZXIpO1xuXG5cbnZhciBTY3JpcHREYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChzY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcbn07XG5cblNjcmlwdERhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRTY3JpcHRUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIjtcbn07XG5cblNjcmlwdERhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRTY3JpcHQ9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JpcHQ7XG59O1xuXG5cbnZhciBTY3JpcHRGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIEFkYXB0ZXJGYWN0b3J5LmNhbGwodGhpcywgXCJkYXRhXCIpO1xufTtcblhNTDNELmNyZWF0ZUNsYXNzKFNjcmlwdEZhY3RvcnksIEFkYXB0ZXJGYWN0b3J5KTtcblxuXG5TY3JpcHRGYWN0b3J5LnByb3RvdHlwZS5hc3BlY3QgPSBcImRhdGFcIjtcblxuU2NyaXB0RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlQWRhcHRlciA9IGZ1bmN0aW9uICh4Zmxvd05vZGUpIHtcbiAgICByZXR1cm4gbmV3IFNjcmlwdERhdGFBZGFwdGVyKHhmbG93Tm9kZSk7XG59O1xuXG5qYXZhU2NyaXB0Rm9ybWF0SGFuZGxlci5yZWdpc3RlckZhY3RvcnlDbGFzcyhTY3JpcHRGYWN0b3J5KTtcbiIsInZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xudmFyIElucHV0Tm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuSW5wdXROb2RlO1xudmFyIERhdGFOb2RlID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKS5EYXRhTm9kZTtcbnZhciBCdWZmZXJFbnRyeSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qc1wiKS5CdWZmZXJFbnRyeTtcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcbnZhciByZWdpc3RlckZvcm1hdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5yZWdpc3RlckZvcm1hdDtcbnZhciBKU09ORm9ybWF0SGFuZGxlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2Zvcm1hdGhhbmRsZXIuanNcIikuSlNPTkZvcm1hdEhhbmRsZXI7XG52YXIgQWRhcHRlckZhY3RvcnkgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLkFkYXB0ZXJGYWN0b3J5O1xuXG52YXIgWE1MM0RKU09ORm9ybWF0SGFuZGxlciA9IGZ1bmN0aW9uKCkge1xuICAgIEpTT05Gb3JtYXRIYW5kbGVyLmNhbGwodGhpcyk7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoWE1MM0RKU09ORm9ybWF0SGFuZGxlciwgSlNPTkZvcm1hdEhhbmRsZXIpO1xuXG5YTUwzREpTT05Gb3JtYXRIYW5kbGVyLnByb3RvdHlwZS5pc0Zvcm1hdFN1cHBvcnRlZCA9IGZ1bmN0aW9uKHJlc3BvbnNlLCByZXNwb25zZVR5cGUsIG1pbWV0eXBlKSB7XG4gICAgcmV0dXJuIG1pbWV0eXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIiAmJiByZXNwb25zZS5mb3JtYXQgPT0gXCJ4bWwzZC1qc29uXCIgJiYgcmVzcG9uc2UudmVyc2lvbiA9PSBcIjAuNC4wXCI7XG59O1xuXG5cblhNTDNESlNPTkZvcm1hdEhhbmRsZXIucHJvdG90eXBlLmdldEZvcm1hdERhdGEgPSBmdW5jdGlvbihyZXNwb25zZSwgcmVzcG9uc2VUeXBlLCBtaW1ldHlwZSwgY2FsbGJhY2spIHtcbiAgICB0cnl7XG4gICAgICAgIHZhciB4Zmxvd05vZGUgPSBjcmVhdGVYZmxvd05vZGUocmVzcG9uc2UpO1xuICAgICAgICBjYWxsYmFjayh0cnVlLCB4Zmxvd05vZGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXhjZXB0aW9uKGUsIFwiRmFpbGVkIHRvIHByb2Nlc3MgWE1MM0QganNvbiBmaWxlXCIpO1xuICAgICAgICBjYWxsYmFjayhmYWxzZSk7XG4gICAgfVxuXG59O1xuXG52YXIgeG1sM2RKU29uRm9ybWF0SGFuZGxlciA9IG5ldyBYTUwzREpTT05Gb3JtYXRIYW5kbGVyKCk7XG5yZWdpc3RlckZvcm1hdCh4bWwzZEpTb25Gb3JtYXRIYW5kbGVyKTtcblxuXG52YXIgZW1wdHkgPSBmdW5jdGlvbigpIHt9O1xuXG52YXIgVFlQRURfQVJSQVlfTUFQID0ge1xuICAgIFwiaW50XCIgOiBJbnQzMkFycmF5LFxuICAgIFwiaW50NFwiIDogSW50MzJBcnJheSxcbiAgICBcImZsb2F0XCIgOiBGbG9hdDMyQXJyYXksXG4gICAgXCJmbG9hdDJcIiA6IEZsb2F0MzJBcnJheSxcbiAgICBcImZsb2F0M1wiIDogRmxvYXQzMkFycmF5LFxuICAgIFwiZmxvYXQ0XCIgOiBGbG9hdDMyQXJyYXksXG4gICAgXCJmbG9hdDR4NFwiIDogRmxvYXQzMkFycmF5LFxuICAgIFwiYm9vbFwiIDogVWludDhBcnJheSxcbiAgICBcImJ5dGVcIiA6IEludDhBcnJheSxcbiAgICBcInVieXRlXCIgOiBVaW50OEFycmF5XG59O1xuXG52YXIgaXNMaXR0bGVFbmRpYW4gPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoNCk7XG4gICAgdmFyIGR2ID0gbmV3IERhdGFWaWV3KGJ1Zik7XG4gICAgdmFyIHZpZXcgPSBuZXcgSW50MzJBcnJheShidWYpO1xuICAgIHZpZXdbMF0gPSAweDAxMDIwMzA0O1xuICAgIHZhciBsaXR0bGVFbmRpYW4gPSAoZHYuZ2V0SW50MzIoMCwgdHJ1ZSkgPT09IDB4MDEwMjAzMDQpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBsaXR0bGVFbmRpYW47IH1cbn0pKCk7XG5cbmZ1bmN0aW9uIHJlYWxUeXBlT2Yob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopLnNsaWNlKDgsIC0xKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlWGZsb3dWYWx1ZShkYXRhTm9kZSwgZGF0YVR5cGUsIG5hbWUsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgdiA9IG5ldyAoVFlQRURfQVJSQVlfTUFQW2RhdGFUeXBlXSkodmFsdWUpO1xuICAgIHZhciB0eXBlID0gWEMuREFUQV9UWVBFLmZyb21TdHJpbmcoZGF0YVR5cGUpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyRW50cnkodHlwZSwgdik7XG5cbiAgICB2YXIgaW5wdXROb2RlID0gbmV3IElucHV0Tm9kZSgpO1xuICAgIGlucHV0Tm9kZS5kYXRhID0gYnVmZmVyO1xuICAgIGlucHV0Tm9kZS5uYW1lID0gbmFtZTtcbiAgICBpbnB1dE5vZGUua2V5ID0ga2V5O1xuICAgIGRhdGFOb2RlLmFwcGVuZENoaWxkKGlucHV0Tm9kZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVhmbG93VmFsdWVGcm9tQnVmZmVyKGRhdGFOb2RlLCBkYXRhVHlwZSwgbmFtZSwga2V5LCBhcnJheUJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBBcnJheVR5cGUgPSBUWVBFRF9BUlJBWV9NQVBbZGF0YVR5cGVdO1xuICAgIHZhciB2ID0gbmV3IChBcnJheVR5cGUpKGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoL0FycmF5VHlwZS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgdmFyIHR5cGUgPSBYQy5EQVRBX1RZUEUuZnJvbVN0cmluZyhkYXRhVHlwZSk7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXJFbnRyeSh0eXBlLCB2KTtcblxuICAgIHZhciBpbnB1dE5vZGUgPSBuZXcgSW5wdXROb2RlKCk7XG4gICAgaW5wdXROb2RlLmRhdGEgPSBidWZmZXI7XG4gICAgaW5wdXROb2RlLm5hbWUgPSBuYW1lO1xuICAgIGlucHV0Tm9kZS5rZXkgPSBrZXk7XG4gICAgZGF0YU5vZGUuYXBwZW5kQ2hpbGQoaW5wdXROb2RlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlWGZsb3dJbnB1dHMoZGF0YU5vZGUsIG5hbWUsIGpzb25EYXRhKXtcbiAgICB2YXIgdiA9IG51bGw7XG5cbiAgICBpZiAoIVRZUEVEX0FSUkFZX01BUFtqc29uRGF0YS50eXBlXSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGpzb25EYXRhLnNlcS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZW50cnkgPSBqc29uRGF0YS5zZXFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5LnZhbHVlO1xuICAgICAgICB2YXIga2V5ID0gZW50cnkua2V5O1xuXG4gICAgICAgIGlmIChyZWFsVHlwZU9mKHZhbHVlKSA9PT0gJ09iamVjdCcgJiYgdmFsdWUudXJsKSB7XG4gICAgICAgICAgICBpZiAoIWlzTGl0dGxlRW5kaWFuKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBhZGQgYmlnLWVuZGlhbiAtPiBsaXR0bGUtZW5kaWFuIGNvbnZlcnNpb25cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCaWctZW5kaWFuIGJpbmFyeSBkYXRhIGFyZSBub3Qgc3VwcG9ydGVkIHlldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFJlc291cmNlLmxvYWREYXRhKHZhbHVlLnVybCwgZnVuY3Rpb24gKGFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlWGZsb3dWYWx1ZUZyb21CdWZmZXIoZGF0YU5vZGUsIGpzb25EYXRhLnR5cGUsIG5hbWUsIGtleSwgYXJyYXlCdWZmZXIsIHZhbHVlLmJ5dGVPZmZzZXQsIHZhbHVlLmJ5dGVMZW5ndGgpO1xuICAgICAgICAgICAgfSwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjcmVhdGVYZmxvd1ZhbHVlKGRhdGFOb2RlLCBqc29uRGF0YS50eXBlLCBuYW1lLCBrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlWGZsb3dOb2RlKGpzb25EYXRhKXtcbiAgICBpZiAoanNvbkRhdGEuZm9ybWF0ICE9IFwieG1sM2QtanNvblwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEpTT04gZm9ybWF0OiBcIiArIGpzb25EYXRhLmZvcm1hdCk7XG4gICAgaWYgKGpzb25EYXRhLnZlcnNpb24gIT0gXCIwLjQuMFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEpTT04gdmVyc2lvbjogXCIgKyBqc29uRGF0YS52ZXJzaW9uKTtcblxuICAgIHZhciBub2RlID0gbmV3IERhdGFOb2RlKGZhbHNlKTtcbiAgICBub2RlLnVzZXJEYXRhID0gXCJFeHRlcm5hbCBKc29uXCI7IC8vIFRPRE86IFRyeSB0byBhZGQgZG9jdW1lbnQgVVJMIGhlcmUgKGhvdyB0byBnZXQgaXQ/KVxuXG4gICAgdmFyIGVudHJpZXMgPSBqc29uRGF0YS5kYXRhO1xuICAgIGZvcih2YXIgbmFtZSBpbiBlbnRyaWVzKSB7XG4gICAgICAgIGNyZWF0ZVhmbG93SW5wdXRzKG5vZGUsIG5hbWUsIGVudHJpZXNbbmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBAaW1wbGVtZW50cyBJRGF0YUFkYXB0ZXJcbiAqL1xudmFyIEpTT05EYXRhQWRhcHRlciA9IGZ1bmN0aW9uKHhmbG93Tm9kZSkge1xuICAgIHRoaXMueGZsb3dEYXRhTm9kZSA9IHhmbG93Tm9kZTtcbn07XG5cbkpTT05EYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0WGZsb3dOb2RlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy54Zmxvd0RhdGFOb2RlO1xufTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtYTUwzRC5iYXNlLklGYWN0b3J5fVxuICovXG52YXIgSlNPTkZhY3RvcnkgPSBmdW5jdGlvbigpXG57XG4gICAgQWRhcHRlckZhY3RvcnkuY2FsbCh0aGlzLCBcImRhdGFcIik7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoSlNPTkZhY3RvcnksIEFkYXB0ZXJGYWN0b3J5KTtcblxuXG5KU09ORmFjdG9yeS5wcm90b3R5cGUuYXNwZWN0ID0gXCJkYXRhXCI7XG5cbkpTT05GYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVBZGFwdGVyID0gZnVuY3Rpb24oeGZsb3dOb2RlKSB7XG4gICAgcmV0dXJuIG5ldyBKU09ORGF0YUFkYXB0ZXIoeGZsb3dOb2RlKTtcbn07XG5cbnhtbDNkSlNvbkZvcm1hdEhhbmRsZXIucmVnaXN0ZXJGYWN0b3J5Q2xhc3MoSlNPTkZhY3RvcnkpO1xuIiwidmFyIERhdGFBZGFwdGVyID0gcmVxdWlyZShcIi4vZGF0YS5qc1wiKTtcbnZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcbnZhciBVUkkgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvdXJpLmpzXCIpLlVSSTtcbnZhciBVdGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzL21pc2MuanNcIik7XG5cbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcbnZhciBOb2RlQWRhcHRlciA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXI7XG52YXIgY3JlYXRlQ2xhc3MgPSBYTUwzRC5jcmVhdGVDbGFzcztcblxuLyoqXG4gKiBTaW5rRGF0YUFkYXB0ZXIgcmVwcmVzZW50cyB0aGUgc2luayBpbiB0aGUgZGF0YSBoaWVyYXJjaHkgKG5vIHBhcmVudHMpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RGF0YUFkYXB0ZXJ9XG4gKiBAcGFyYW0gZmFjdG9yeVxuICogQHBhcmFtIG5vZGVcbiAqL1xudmFyIFNpbmtEYXRhQWRhcHRlciA9IGZ1bmN0aW9uKGZhY3RvcnksIG5vZGUpIHtcbiAgICBEYXRhQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xufTtcbmNyZWF0ZUNsYXNzKFNpbmtEYXRhQWRhcHRlciwgRGF0YUFkYXB0ZXIsIHtcblxuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgRGF0YUFkYXB0ZXIgaXMgYSBTaW5rQWRhcHRlciAoaGFzIG5vIHBhcmVudFxuICAgICAqIERhdGFBZGFwdGVyKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHRydWUgaWYgdGhpcyBEYXRhQWRhcHRlciBpcyBhIFNpbmtBZGFwdGVyLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICovXG4gICAgaXNTaW5rQWRhcHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBEYXRhQWRhcHRlclxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBcIlhNTDNELmRhdGEuU2lua0RhdGFBZGFwdGVyXCI7XG4gICAgfVxufSk7XG5cblxuICAgIHZhciBJbWdEYXRhQWRhcHRlciA9IGZ1bmN0aW9uKGZhY3RvcnksIG5vZGUpIHtcbiAgICAgICAgTm9kZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcbiAgICAgICAgdGhpcy50ZXh0dXJlRW50cnkgPSBudWxsO1xuICAgICAgICB0aGlzLmltYWdlID0gbnVsbDtcbiAgICAgICAgaWYgKG5vZGUuc3JjKVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVJbWFnZUZyb21VUkwobm9kZS5zcmMpO1xuICAgIH07XG4gICAgY3JlYXRlQ2xhc3MoSW1nRGF0YUFkYXB0ZXIsIE5vZGVBZGFwdGVyLCB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgaW1hZ2Ugb2JqZWN0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUltYWdlRnJvbVVSTDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHVyaSA9IG5ldyBVUkkodXJsKS5nZXRBYnNvbHV0ZVVSSSh0aGlzLm5vZGUub3duZXJEb2N1bWVudC5fZG9jdW1lbnRVUkwgfHwgdGhpcy5ub2RlLm93bmVyRG9jdW1lbnQuVVJMKTtcbiAgICAgICAgICAgIHZhciBvbmxvYWQgPSBmdW5jdGlvbiAoZSwgaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC50ZXh0dXJlRW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC50ZXh0dXJlRW50cnkuc2V0SW1hZ2UoaW1hZ2UsIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uIChlLCBpbWFnZSkge1xuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGxvYWQgaW1hZ2UgVVJJPVwiICsgaW1hZ2Uuc3JjKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmltYWdlID0gUmVzb3VyY2UuZ2V0SW1hZ2UodXJpLCBvbmxvYWQsIG9uZXJyb3IpO1xuICAgICAgICAgICAgaWYgKHRoYXQudGV4dHVyZUVudHJ5KSB7XG4gICAgICAgICAgICAgICAgdGhhdC50ZXh0dXJlRW50cnkuc2V0SW1hZ2UodGhpcy5pbWFnZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7WGZsb3cuVGV4dHVyZUVudHJ5fSBlbnRyeVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0VGV4dHVyZUVudHJ5OiBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgICBpZiAodGhpcy5pbWFnZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZUVudHJ5LnNldEltYWdlKHRoaXMuaW1hZ2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJzcmNcIikge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlSW1hZ2VGcm9tVVJMKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChjYiwgb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbWFnZTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRPdXRwdXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgICAgICByZXN1bHRbJ2ltYWdlJ10gPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNvbHZlU2NyaXB0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIFZpZGVvRGF0YUFkYXB0ZXIgPSBmdW5jdGlvbihmYWN0b3J5LCBub2RlKSB7XG4gICAgICAgIERhdGFBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG4gICAgICAgIHRoaXMudGV4dHVyZUVudHJ5ID0gbnVsbDtcbiAgICAgICAgdGhpcy52aWRlbyA9IG51bGw7XG4gICAgICAgIHRoaXMuX3RpY2tpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYm91bmRUaWNrID0gdGhpcy5fdGljay5iaW5kKHRoaXMpO1xuICAgICAgICBpZiAobm9kZS5zcmMpXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVZpZGVvRnJvbVVSTChub2RlLnNyYyk7XG4gICAgfTtcbiAgICBjcmVhdGVDbGFzcyhWaWRlb0RhdGFBZGFwdGVyLCBOb2RlQWRhcHRlcik7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IHZpZGVvIG9iamVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgICAqL1xuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNyZWF0ZVZpZGVvRnJvbVVSTCA9IGZ1bmN0aW9uKHVybCkge1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgIHZhciB1cmkgPSBuZXcgVVJJKHVybCkuZ2V0QWJzb2x1dGVVUkkodGhpcy5ub2RlLm93bmVyRG9jdW1lbnQuX2RvY3VtZW50VVJMIHx8IHRoaXMubm9kZS5vd25lckRvY3VtZW50LlVSTCk7XG4gICAgICAgIHRoaXMudmlkZW8gPSBSZXNvdXJjZS5nZXRWaWRlbyh1cmksIHRoaXMubm9kZS5hdXRvcGxheSwgdGhpcy5ub2RlLmxvb3AsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2FucGxheSA6IGZ1bmN0aW9uKGV2ZW50LCB2aWRlbykge1xuICAgICAgICAgICAgICAgICAgICBVdGlsLmRpc3BhdGNoQ3VzdG9tRXZlbnQodGhhdC5ub2RlLCAnY2FucGxheScsIHRydWUsIHRydWUsIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9zdGFydFZpZGVvUmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW5kZWQgOiBmdW5jdGlvbihldmVudCwgdmlkZW8pIHtcbiAgICAgICAgICAgICAgICAgICAgVXRpbC5kaXNwYXRjaEN1c3RvbUV2ZW50KHRoYXQubm9kZSwgJ2VuZGVkJywgdHJ1ZSwgdHJ1ZSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsb2FkIDogZnVuY3Rpb24oZXZlbnQsIHZpZGVvKSB7XG4gICAgICAgICAgICAgICAgICAgIFV0aWwuZGlzcGF0Y2hFdmVudCh0aGF0Lm5vZGUsICdsb2FkJyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvciA6IGZ1bmN0aW9uKGV2ZW50LCB2aWRlbykge1xuICAgICAgICAgICAgICAgICAgICBVdGlsLmRpc3BhdGNoQ3VzdG9tRXZlbnQodGhhdC5ub2RlLCAnZXJyb3InLCB0cnVlLCB0cnVlLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgbG9hZCB2aWRlbyBVUkk9XCIrdmlkZW8uc3JjKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICAgIGlmICh0aGlzLnRleHR1cmVFbnRyeSlcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUVudHJ5LnNldEltYWdlKHRoaXMudmlkZW8sIHRydWUpO1xuICAgIH07XG5cbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvKVxuICAgICAgICAgICAgdGhpcy52aWRlby5wbGF5KCk7XG4gICAgfTtcblxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvKVxuICAgICAgICAgICAgdGhpcy52aWRlby5wYXVzZSgpO1xuICAgIH07XG5cbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5fc3RhcnRWaWRlb1JlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90aWNraW5nKVxuICAgICAgICAgICAgdGhpcy5fdGljaygpO1xuICAgIH07XG5cbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5fdGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl90aWNraW5nID0gdHJ1ZTtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZFRpY2spO1xuICAgICAgICAvLyBGSVhNRSBEbyB0aGlzIG9ubHkgd2hlbiBjdXJyZW50VGltZSBpcyBjaGFuZ2VkICh3aGF0IGFib3V0IHdlYmNhbSA/KVxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlRW50cnkpIHtcbiAgICAgICAgICAgIHRoaXMudGV4dHVyZUVudHJ5LnNldEltYWdlKHRoaXMudmlkZW8pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WGZsb3cuVGV4dHVyZUVudHJ5fSBlbnRyeVxuICAgICAqL1xuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLnNldFRleHR1cmVFbnRyeSA9IGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgIHRoaXMudGV4dHVyZUVudHJ5ID0gZW50cnk7XG4gICAgICAgIGlmICh0aGlzLnZpZGVvKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVFbnRyeS5zZXRJbWFnZSh0aGlzLnZpZGVvLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBWaWRlb0RhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgfTtcblxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJzcmNcIikge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVWaWRlb0Zyb21VUkwobmV3VmFsdWUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFZpZGVvRGF0YUFkYXB0ZXIucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24oY2IsIG9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy52aWRlbztcbiAgICB9O1xuXG4gICAgVmlkZW9EYXRhQWRhcHRlci5wcm90b3R5cGUuZ2V0T3V0cHV0cyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIHJlc3VsdFsndmlkZW8nXSA9IHRoaXM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcblxuICAgIC8vIEV4cG9ydFxuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgICBJbWdEYXRhQWRhcHRlcjogSW1nRGF0YUFkYXB0ZXIsXG4gICAgICAgIFZpZGVvRGF0YUFkYXB0ZXI6IFZpZGVvRGF0YUFkYXB0ZXIsXG4gICAgICAgIFNpbmtEYXRhQWRhcHRlcjogU2lua0RhdGFBZGFwdGVyXG4gICAgfTtcblxuIiwidmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xudmFyIGNyZWF0ZUNsYXNzID0gWE1MM0QuY3JlYXRlQ2xhc3M7XG52YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xuXG52YXIgU2NyaXB0RGF0YUFkYXB0ZXIgPSBmdW5jdGlvbihmYWN0b3J5LCBub2RlKSB7XG4gICAgTm9kZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcbiAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGUgPSBudWxsO1xuICAgIGlmIChub2RlLnNyYykge1xuICAgICAgICB0aGlzLmNvbm5lY3RlZEFkYXB0ZXJIYW5kbGUgPSB0aGlzLmdldEFkYXB0ZXJIYW5kbGUobm9kZS5zcmMpO1xuICAgICAgICB0aGlzLmNvbm5lY3RBZGFwdGVySGFuZGxlKG5vZGUubmFtZSwgdGhpcy5jb25uZWN0ZWRBZGFwdGVySGFuZGxlKTtcbiAgICB9XG59O1xuXG5jcmVhdGVDbGFzcyhTY3JpcHREYXRhQWRhcHRlciwgTm9kZUFkYXB0ZXIsIHtcblxuICAgIGdldFNjcmlwdFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS50eXBlO1xuICAgIH0sXG5cbiAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5zcmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2NyaXB0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm9kZS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlPcHBvc2l0ZUFkYXB0ZXJzKCk7XG4gICAgfSxcblxuICAgIG5vdGlmeUNoYW5nZWQ6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9JTlNFUlRFRDpcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLlZBTFVFX01PRElGSUVEOlxuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5T3Bwb3NpdGVBZGFwdGVycygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEOlxuICAgICAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxTY3JpcHQgPSBldnQuYWRhcHRlci5zY3JpcHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlPcHBvc2l0ZUFkYXB0ZXJzKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY3JpcHREYXRhQWRhcHRlcjtcbiIsInZhciBUZXh0dXJlRW50cnkgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikuVGV4dHVyZUVudHJ5O1xudmFyIElucHV0Tm9kZSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuSW5wdXROb2RlO1xudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG52YXIgTm9kZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9hZGFwdGVyLmpzXCIpLk5vZGVBZGFwdGVyO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCdsb2Rhc2guZGVmYXVsdHMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdsb2Rhc2guYXNzaWduJyk7XG5cblxudmFyIFRleHR1cmVEYXRhQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XG4gICAgTm9kZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKFRleHR1cmVEYXRhQWRhcHRlciwgTm9kZUFkYXB0ZXIsIHtcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZSA9IHRoaXMuY3JlYXRlWGZsb3dOb2RlKCk7XG4gICAgICAgIHRoaXMueGZsb3dJbnB1dE5vZGUuZGF0YSA9IHRoaXMuY3JlYXRlVGV4dHVyZUVudHJ5KCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVRleHR1cmVFbnRyeTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZTtcbiAgICAgICAgdmFyIGVudHJ5ID0gbmV3IFRleHR1cmVFbnRyeShudWxsKTtcbiAgICAgICAgaW5pdFRleHR1cmVTYW1wbGluZ1BhcmFtZXRlcnMoZW50cnkuZ2V0U2FtcGxlckNvbmZpZygpLCBub2RlLmdldEF0dHJpYnV0ZShcIndyYXBcIiksIG5vZGUuZ2V0QXR0cmlidXRlKFwiZmlsdGVyXCIpLCBub2RlLmdldEF0dHJpYnV0ZShcImFuaXNvdHJvcHlcIikpO1xuXG4gICAgICAgIHZhciBpbWFnZUFkYXB0ZXIgPSB0aGlzLmZhY3RvcnkuZ2V0QWRhcHRlcih0aGlzLm5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICBpZiAoaW1hZ2VBZGFwdGVyKSB7XG4gICAgICAgICAgICBpbWFnZUFkYXB0ZXIuc2V0VGV4dHVyZUVudHJ5KGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnk7XG4gICAgfSxcblxuICAgIHNob3VsZEdlbmVyYXRlTWlwTWFwczogc2hvdWxkR2VuZXJhdGVNaXBNYXBzLFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SW5wdXROb2RlfVxuICAgICAqL1xuICAgIGNyZWF0ZVhmbG93Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgeG5vZGUgPSBuZXcgSW5wdXROb2RlKCk7XG4gICAgICAgIHhub2RlLm5hbWUgPSB0aGlzLm5vZGUubmFtZTtcbiAgICAgICAgeG5vZGUucGFyYW1OYW1lID0gdGhpcy5ub2RlLnBhcmFtID8gdGhpcy5ub2RlLm5hbWUgOiBudWxsO1xuICAgICAgICB4bm9kZS5rZXkgPSB0aGlzLm5vZGUua2V5O1xuICAgICAgICByZXR1cm4geG5vZGU7XG4gICAgfSxcblxuICAgIHNldFNjcmlwdFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiVGV4dHVyZSBjdXJyZW50bHkgZG9lcyBub3Qgc3VwcG9ydCBzZXRTY3JpcHRWYWx1ZSgpXCIpO1xuICAgIH0sXG5cbiAgICBnZXRPdXRwdXRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgcmVzdWx0W3RoaXMubm9kZS5uYW1lXSA9IHRoaXM7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwibmFtZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMueGZsb3dJbnB1dE5vZGUubmFtZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBhcmFtXCI6XG4gICAgICAgICAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5wYXJhbU5hbWUgPSBuZXdWYWx1ZSA/IHRoaXMubm9kZS5uYW1lIDogbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJrZXlcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnhmbG93SW5wdXROb2RlLmtleSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIndyYXBcIjpcbiAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzYW1wbGVzXCI6XG4gICAgICAgICAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5kYXRhID0gdGhpcy5jcmVhdGVUZXh0dXJlRW50cnkoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7IC8qIE5vdGhpbmcgdG8gZG8gKi9cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXRYZmxvd05vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMueGZsb3dJbnB1dE5vZGU7XG4gICAgfVxuXG59KTtcblxudmFyIHdyYXBUb0dMID0ge1xuICAgIFwiY2xhbXBcIjogIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DTEFNUF9UT19FREdFLFxuICAgIFwicmVwZWF0XCI6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5SRVBFQVRcbn07XG5cbnZhciBmaWx0ZXJUb0dMID0ge1xuICAgIFwibmVhcmVzdFwiOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVCxcbiAgICBcImxpbmVhclwiOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORUFSLFxuICAgIFwibmVhcmVzdC1taXBtYXAtbmVhcmVzdFwiOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCxcbiAgICBcImxpbmVhci1taXBtYXAtbmVhcmVzdFwiOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORUFSX01JUE1BUF9ORUFSRVNULFxuICAgIFwibmVhcmVzdC1taXBtYXAtbGluZWFyXCI6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUX01JUE1BUF9MSU5FQVIsXG4gICAgXCJsaW5lYXItbWlwbWFwLWxpbmVhclwiOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORUFSX01JUE1BUF9MSU5FQVJcbn07XG5cbmZ1bmN0aW9uIHNob3VsZEdlbmVyYXRlTWlwTWFwcyhtaW5GaWx0ZXIsIG1hZ0ZpbHRlcikge1xuICAgIHJldHVybiAobWluRmlsdGVyICE9IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUICYmIG1pbkZpbHRlciAhPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORUFSKSB8fCAobWFnRmlsdGVyICE9IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5ORUFSRVNUICYmIG1hZ0ZpbHRlciAhPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORUFSKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUZXh0dXJlU2FtcGxpbmdQYXJhbWV0ZXJzKHdyYXAsIGZpbHRlciwgYW5pc290cm9weSkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgYXJncztcblxuICAgIGlmKHdyYXApIHtcbiAgICAgICAgYXJncyA9IHdyYXAuc3BsaXQoLyhcXHMrKS8pO1xuICAgICAgICByZXN1bHQud3JhcFMgPSB3cmFwVG9HTFthcmdzWzBdXTtcbiAgICAgICAgcmVzdWx0LndyYXBUID0gd3JhcFRvR0xbYXJnc1thcmdzLmxlbmd0aCAtIDFdXTtcbiAgICB9XG5cbiAgICBpZihmaWx0ZXIpIHtcbiAgICAgICAgYXJncyA9IGZpbHRlci5zcGxpdCgvKFxccyspLyk7XG4gICAgICAgIHJlc3VsdC5taW5GaWx0ZXIgPSBmaWx0ZXJUb0dMW2FyZ3NbMF1dO1xuICAgICAgICByZXN1bHQubWFnRmlsdGVyID0gZmlsdGVyVG9HTFthcmdzW2FyZ3MubGVuZ3RoIC0gMV1dO1xuICAgIH1cblxuICAgIGlmKGFuaXNvdHJvcHkpIHtcbiAgICAgICAgdmFyIG51bWJlciA9IHBhcnNlRmxvYXQoYW5pc290cm9weSk7XG4gICAgICAgIGlmIChudW1iZXIgPT0gTnVtYmVyLk5hTikge1xuICAgICAgICAgICAgbnVtYmVyID0gYW5pc290cm9weSA9PSBcIm1heFwiID8gSW5maW5pdHkgOiB1bmRlZmluZWRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG51bWJlciA9IE1hdGgubWluKDEuMCwgbnVtYmVyKVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5hbmlzb3Ryb3B5ID0gbnVtYmVyO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGluaXRUZXh0dXJlU2FtcGxpbmdQYXJhbWV0ZXJzKGNvbmZpZywgd3JhcCwgZmlsdGVyLCBzYW1wbGVzKSB7XG4gICAgdmFyIHBhcmFtcyA9IHBhcnNlVGV4dHVyZVNhbXBsaW5nUGFyYW1ldGVycyh3cmFwLCBmaWx0ZXIsIHNhbXBsZXMpO1xuICAgIGRlZmF1bHRzKHBhcmFtcywge1xuICAgICAgICB3cmFwUzogV2ViR0xSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0UsXG4gICAgICAgIHdyYXBUOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgbWluRmlsdGVyOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORUFSX01JUE1BUF9MSU5FQVIsXG4gICAgICAgIG1hZ0ZpbHRlcjogV2ViR0xSZW5kZXJpbmdDb250ZXh0LkxJTkVBUixcbiAgICAgICAgdGV4dHVyZVR5cGU6IFhDLlRFWF9UWVBFLlRFWFRVUkVfMkQsXG4gICAgICAgIGFuaXNvdHJvcHk6IDFcbiAgICB9KTtcbiAgICBhc3NpZ24oY29uZmlnLCBwYXJhbXMpO1xuICAgIGNvbmZpZy5nZW5lcmF0ZU1pcE1hcCA9IHNob3VsZEdlbmVyYXRlTWlwTWFwcyhjb25maWcubWluRmlsdGVyLCBjb25maWcubWFnRmlsdGVyKTtcbn1cblxuLy8gRXhwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IFRleHR1cmVEYXRhQWRhcHRlcjtcbiIsInZhciBFdmVudHMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL25vdGlmaWNhdGlvbi5qc1wiKTtcbnZhciBOb2RlQWRhcHRlciA9IHJlcXVpcmUoXCIuLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXI7XG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcbnZhciB2ZWMzID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWMzO1xuXG52YXIgVHJhbnNmb3JtRGF0YUFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG4gICAgdGhpcy5pc1ZhbGlkID0gdHJ1ZTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKFRyYW5zZm9ybURhdGFBZGFwdGVyLCBOb2RlQWRhcHRlcik7XG5cbnZhciBJREVOVF9NQVQgPSBtYXQ0LmNyZWF0ZSgpO1xuXG5UcmFuc2Zvcm1EYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBDcmVhdGUgYWxsIG1hdHJpY2VzLCBubyB2YWxpZCB2YWx1ZXMgeWV0XG4gICAgdGhpcy5tYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgIHRoaXMudHJhbnNmb3JtID0ge1xuICAgICAgICB0cmFuc2xhdGU6IG1hdDQuY3JlYXRlKCksXG4gICAgICAgIHNjYWxlOiBtYXQ0LmNyZWF0ZSgpLFxuICAgICAgICBzY2FsZU9yaWVudGF0aW9uOiBtYXQ0LmNyZWF0ZSgpLFxuICAgICAgICBzY2FsZU9yaWVudGF0aW9uSW52OiBtYXQ0LmNyZWF0ZSgpLFxuICAgICAgICBjZW50ZXI6IG1hdDQuY3JlYXRlKCksXG4gICAgICAgIGNlbnRlckludmVyc2U6IG1hdDQuY3JlYXRlKCksXG4gICAgICAgIHJvdGF0aW9uOiBtYXQ0LmNyZWF0ZSgpXG4gICAgfTtcbiAgICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLmNoZWNrRm9ySW1wcm9wZXJOZXN0aW5nKCk7XG59O1xuXG5UcmFuc2Zvcm1EYXRhQWRhcHRlci5wcm90b3R5cGUudXBkYXRlTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuID0gdGhpcy5ub2RlO1xuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICB2YXIgY2VudGVyVmVjID0gbi5jZW50ZXIuZGF0YTtcbiAgICB2YXIgc28gPSBuLnNjYWxlT3JpZW50YXRpb24uZGF0YTtcbiAgICB2YXIgcm8gPSBuLnJvdGF0aW9uLmRhdGE7XG5cbiAgICBtYXQ0LmZyb21Sb3RhdGlvbih0cmFuc2Zvcm0uc2NhbGVPcmllbnRhdGlvbiwgc29bM10sIHNvKTtcbiAgICBtYXQ0LmZyb21Sb3RhdGlvbih0cmFuc2Zvcm0ucm90YXRpb24sIHJvWzNdLCBybyk7XG5cbiAgICBtYXQ0LnRyYW5zbGF0ZSh0cmFuc2Zvcm0udHJhbnNsYXRlLCBJREVOVF9NQVQsIG4udHJhbnNsYXRpb24uZGF0YSk7XG4gICAgbWF0NC50cmFuc2xhdGUodHJhbnNmb3JtLmNlbnRlciwgSURFTlRfTUFULCBjZW50ZXJWZWMpO1xuICAgIG1hdDQudHJhbnNsYXRlKHRyYW5zZm9ybS5jZW50ZXJJbnZlcnNlLCBJREVOVF9NQVQsIHZlYzMubmVnYXRlKGNlbnRlclZlYywgY2VudGVyVmVjKSk7XG4gICAgbWF0NC5zY2FsZSh0cmFuc2Zvcm0uc2NhbGUsIElERU5UX01BVCwgbi5zY2FsZS5kYXRhKTtcbiAgICBtYXQ0LmludmVydCh0cmFuc2Zvcm0uc2NhbGVPcmllbnRhdGlvbkludiwgdHJhbnNmb3JtLnNjYWxlT3JpZW50YXRpb24pO1xuXG4gICAgbXVsdGlwbHlDb21wb25lbnRzKHRyYW5zZm9ybSwgdGhpcy5tYXRyaXgpO1xuICAgIHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIG11bHRpcGx5Q29tcG9uZW50cyh0cmFuc2Zvcm0sIG1hdHJpeCkge1xuICAgIC8vIE0gPSBUICogQ1xuICAgIG1hdDQubXVsdGlwbHkobWF0cml4LCB0cmFuc2Zvcm0udHJhbnNsYXRlLCB0cmFuc2Zvcm0uY2VudGVyKTtcbiAgICAvLyBNID0gVCAqIEMgKiBSXG4gICAgbWF0NC5tdWx0aXBseShtYXRyaXgsIG1hdHJpeCwgdHJhbnNmb3JtLnJvdGF0aW9uKTtcbiAgICAvLyBNID0gVCAqIEMgKiBSICogU09cbiAgICBtYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0cmFuc2Zvcm0uc2NhbGVPcmllbnRhdGlvbik7XG4gICAgLy8gTSA9IFQgKiBDICogUiAqIFNPICogU1xuICAgIG1hdDQubXVsdGlwbHkobWF0cml4LCBtYXRyaXgsIHRyYW5zZm9ybS5zY2FsZSk7XG4gICAgLy8gTSA9IFQgKiBDICogUiAqIFNPICogUyAqIC1TT1xuICAgIG1hdDQubXVsdGlwbHkobWF0cml4LCBtYXRyaXgsIHRyYW5zZm9ybS5zY2FsZU9yaWVudGF0aW9uSW52KTtcbiAgICAvLyBNID0gVCAqIEMgKiBSICogU08gKiBTICogLVNPICogLUNcbiAgICBtYXQ0Lm11bHRpcGx5KG1hdHJpeCwgbWF0cml4LCB0cmFuc2Zvcm0uY2VudGVySW52ZXJzZSk7XG59XG5cblRyYW5zZm9ybURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5uZWVkc1VwZGF0ZSAmJiB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIHJldHVybiB0aGlzLm1hdHJpeDtcbn07XG5cblRyYW5zZm9ybURhdGFBZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICB0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgIHRoaXMubm90aWZ5T3Bwb3NpdGVBZGFwdGVycyhFdmVudHMuQURBUFRFUl9WQUxVRV9DSEFOR0VEKTtcbn07XG5cblRyYW5zZm9ybURhdGFBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoZS50eXBlID09IEV2ZW50cy5OT0RFX1JFTU9WRUQpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMubm90aWZ5T3Bwb3NpdGVBZGFwdGVycyhFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRCk7XG4gICAgfVxufTtcblRyYW5zZm9ybURhdGFBZGFwdGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNWYWxpZCA9IGZhbHNlO1xufTtcblxuVHJhbnNmb3JtRGF0YUFkYXB0ZXIucHJvdG90eXBlLmNoZWNrRm9ySW1wcm9wZXJOZXN0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZS5jaGlsZE5vZGVzW2ldLmxvY2FsTmFtZSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJQYXJzaW5nIGVycm9yOiBUcmFuc2Zvcm0gZWxlbWVudHMgY2Fubm90IGJlIG5lc3RlZCFcIiwgdGhpcy5ub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8vIEV4cG9ydCB0byBYTUwzRC5kYXRhIG5hbWVzcGFjZVxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1EYXRhQWRhcHRlcjtcblxuXG5cbiIsInZhciBCdWZmZXJFbnRyeSA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qc1wiKS5CdWZmZXJFbnRyeTtcbnZhciBJbnB1dE5vZGUgPSByZXF1aXJlKFwiLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLklucHV0Tm9kZTtcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xudmFyIE5vZGVBZGFwdGVyID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlcjtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBvZiBYTUwzRC5kYXRhLlZhbHVlRGF0YUFkYXB0ZXJcbiAqXG4gKiBAZXh0ZW5kcyBYTUwzRC5kYXRhLkRhdGFBZGFwdGVyXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0gZmFjdG9yeVxuICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gKi9cbnZhciBWYWx1ZURhdGFBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcbiAgICBOb2RlQWRhcHRlci5jYWxsKHRoaXMsIGZhY3RvcnksIG5vZGUpO1xuICAgIHRoaXMueGZsb3dJbnB1dE5vZGUgPSBudWxsO1xufTtcblhNTDNELmNyZWF0ZUNsYXNzKFZhbHVlRGF0YUFkYXB0ZXIsIE5vZGVBZGFwdGVyKTtcblxuVmFsdWVEYXRhQWRhcHRlci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgY29uZmlnID0gdGhpcy5ub2RlLl9jb25maWd1cmVkLCB2YWx1ZTtcbiAgICBpZih0aGlzLm5vZGUudGV4dENvbnRlbnQgPT0gXCJbdmFsdWUgc2V0IGJ5IHNjcmlwdF1cIil7XG4gICAgICAgIHZhbHVlID0gY29uZmlnLnNjcmlwdFZhbHVlO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBkZWxldGUgY29uZmlnLnNjcmlwdFZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHRoaXMubm9kZS52YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IFhDLkRBVEFfVFlQRS5mcm9tU3RyaW5nKHRoaXMubm9kZS5sb2NhbE5hbWUpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyRW50cnkodHlwZSwgdmFsdWUpO1xuXG4gICAgdGhpcy54Zmxvd0lucHV0Tm9kZSA9IG5ldyBJbnB1dE5vZGUobnVsbCk7XG4gICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5uYW1lID0gdGhpcy5ub2RlLm5hbWU7XG4gICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5kYXRhID0gYnVmZmVyO1xuICAgIHRoaXMueGZsb3dJbnB1dE5vZGUua2V5ID0gdGhpcy5ub2RlLmtleTtcbiAgICB0aGlzLnhmbG93SW5wdXROb2RlLnBhcmFtTmFtZSA9IHRoaXMubm9kZS5wYXJhbSA/IHRoaXMubm9kZS5uYW1lIDogbnVsbDtcbiAgICB0aGlzLmNoZWNrRm9ySW1wcm9wZXJOZXN0aW5nKCk7XG59O1xuXG5WYWx1ZURhdGFBZGFwdGVyLnByb3RvdHlwZS5nZXRYZmxvd05vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMueGZsb3dJbnB1dE5vZGU7XG59O1xuXG4vKipcbiAqXG4gKi9cblZhbHVlRGF0YUFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09IEV2ZW50cy5WQUxVRV9NT0RJRklFRCkge1xuICAgICAgICB2YXIgYXR0ciA9IGV2dC5tdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICBpZiAoIWF0dHIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm5vZGUuX2NvbmZpZ3VyZWQuc2NyaXB0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnhmbG93SW5wdXROb2RlLmRhdGEuc2V0VmFsdWUodGhpcy5ub2RlLnZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblZhbHVlRGF0YUFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICBpZiAobmFtZSA9PSBcIm5hbWVcIikge1xuICAgICAgICB0aGlzLnhmbG93SW5wdXROb2RlLm5hbWUgPSBuZXdWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJrZXlcIikge1xuICAgICAgICB0aGlzLnhmbG93SW5wdXROb2RlLmtleSA9IG5ld1ZhbHVlO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcInBhcmFtXCIpIHtcbiAgICAgICAgdGhpcy54Zmxvd0lucHV0Tm9kZS5wYXJhbU5hbWUgPSBuZXdWYWx1ZSA/IHRoaXMubm9kZS5uYW1lIDogbnVsbDtcbiAgICB9XG59O1xuXG5cblZhbHVlRGF0YUFkYXB0ZXIucHJvdG90eXBlLnNldFNjcmlwdFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gVE9ETzogQWRkIFR5cGUgY2hlY2tcbiAgICB0aGlzLnhmbG93SW5wdXROb2RlLmRhdGEuc2V0VmFsdWUodmFsdWUpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIERhdGFBZGFwdGVyXG4gKi9cblZhbHVlRGF0YUFkYXB0ZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIlhNTDNELmRhdGEuVmFsdWVEYXRhQWRhcHRlclwiO1xufTtcblxuVmFsdWVEYXRhQWRhcHRlci5wcm90b3R5cGUuY2hlY2tGb3JJbXByb3Blck5lc3RpbmcgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpPTA7IGkgPCB0aGlzLm5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoWEMuREFUQV9UWVBFLmZyb21TdHJpbmcodGhpcy5ub2RlLmNoaWxkTm9kZXNbaV0ubG9jYWxOYW1lKSkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJQYXJzaW5nIGVycm9yOiBWYWx1ZSBlbGVtZW50cyBjYW5ub3QgYmUgbmVzdGVkIVwiLCB0aGlzLm5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLy8gRXhwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IFZhbHVlRGF0YUFkYXB0ZXI7XG4iLCJ2YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG52YXIgQ1NTID0gcmVxdWlyZShcIi4uL3V0aWxzL2Nzcy5qc1wiKTtcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xuXG52YXIgRE9NVHJhbnNmb3JtRmV0Y2hlciA9IGZ1bmN0aW9uIChvd25lciwgYXR0ck5hbWUsIGRhdGFOYW1lLCBvbmx5RGF0YVRyYW5zZm9ybSkge1xuICAgIHRoaXMub3duZXIgPSBvd25lcjtcbiAgICB0aGlzLm5vZGUgPSBvd25lci5ub2RlO1xuICAgIHRoaXMuYXR0ck5hbWUgPSBhdHRyTmFtZTtcbiAgICB0aGlzLmRhdGFOYW1lID0gZGF0YU5hbWU7XG4gICAgdGhpcy5hZGFwdGVySGFuZGxlID0gbnVsbDtcbiAgICB0aGlzLnhmbG93UmVxdWVzdCA9IG51bGw7XG4gICAgdGhpcy5vbmx5RGF0YVRyYW5zZm9ybSA9IG9ubHlEYXRhVHJhbnNmb3JtIHx8IGZhbHNlO1xuICAgIHRoaXMuX2JpbmRlZENhbGxiYWNrID0gdGhpcy5fb25DaGFuZ2UuYmluZCh0aGlzKTtcbn07XG5ET01UcmFuc2Zvcm1GZXRjaGVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnhmbG93UmVxdWVzdCAmJiB0aGlzLnhmbG93UmVxdWVzdC5jbGVhcigpO1xuICAgIHRoaXMueGZsb3dSZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLmFkYXB0ZXJIYW5kbGUgJiYgdGhpcy5hZGFwdGVySGFuZGxlLnJlbW92ZUxpc3RlbmVyKHRoaXMuX2JpbmRlZENhbGxiYWNrKVxufTtcblxuRE9NVHJhbnNmb3JtRmV0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdIYW5kbGUgPSB0aGlzLm93bmVyLmdldEFkYXB0ZXJIYW5kbGUodGhpcy5ub2RlLmdldEF0dHJpYnV0ZSh0aGlzLmF0dHJOYW1lKSwgXCJkYXRhXCIsIDApO1xuICAgIGlmIChuZXdIYW5kbGUgIT0gdGhpcy5hZGFwdGVySGFuZGxlKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5hZGFwdGVySGFuZGxlID0gbmV3SGFuZGxlO1xuICAgICAgICBpZiAobmV3SGFuZGxlKVxuICAgICAgICAgICAgbmV3SGFuZGxlLmFkZExpc3RlbmVyKHRoaXMuX2JpbmRlZENhbGxiYWNrKVxuICAgIH1cbiAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xufTtcblxuRE9NVHJhbnNmb3JtRmV0Y2hlci5wcm90b3R5cGUudXBkYXRlTWF0cml4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMub3duZXIub25UcmFuc2Zvcm1DaGFuZ2UodGhpcy5hdHRyTmFtZSwgdGhpcy5nZXRNYXRyaXgoKSk7XG59O1xuXG5ET01UcmFuc2Zvcm1GZXRjaGVyLnByb3RvdHlwZS5nZXRNYXRyaXggPSAoIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgSURFTlRJVFkgPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9ubHlEYXRhVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2YXIgY3NzTWF0cml4ID0gQ1NTLmdldENTU01hdHJpeCh0aGlzLm5vZGUpO1xuICAgICAgICAgICAgaWYgKGNzc01hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDU1MuY29udmVydENzc1RvTWF0NChjc3NNYXRyaXgpLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkYXB0ZXI7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0ZXJIYW5kbGUgJiYgKGFkYXB0ZXIgPSB0aGlzLmFkYXB0ZXJIYW5kbGUuZ2V0QWRhcHRlcigpKSkge1xuICAgICAgICAgICAgaWYgKGFkYXB0ZXIuZ2V0WGZsb3dOb2RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnhmbG93UmVxdWVzdClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy54Zmxvd1JlcXVlc3QgPSBuZXcgQ29tcHV0ZVJlcXVlc3QoYWRhcHRlci5nZXRYZmxvd05vZGUoKSwgW3RoaXMuZGF0YU5hbWVdLCB0aGlzLl9iaW5kZWRDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFSZXN1bHQgPSB0aGlzLnhmbG93UmVxdWVzdC5nZXRSZXN1bHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtRGF0YSA9IChkYXRhUmVzdWx0LmdldE91dHB1dERhdGEodGhpcy5kYXRhTmFtZSkgJiYgZGF0YVJlc3VsdC5nZXRPdXRwdXREYXRhKHRoaXMuZGF0YU5hbWUpLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1EYXRhKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGFwdGVyLmdldE1hdHJpeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyLmdldE1hdHJpeCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm9ubHlEYXRhVHJhbnNmb3JtID8gbnVsbCA6IElERU5USVRZO1xuICAgIH07XG59KCkpO1xuXG5ET01UcmFuc2Zvcm1GZXRjaGVyLnByb3RvdHlwZS5fb25DaGFuZ2UgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09IEV2ZW50cy5BREFQVEVSX1ZBTFVFX0NIQU5HRUQpIHtcbiAgICAgICAgdGhpcy5vd25lci5vblRyYW5zZm9ybUNoYW5nZSh0aGlzLmF0dHJOYW1lLCBldnQuYWRhcHRlckhhbmRsZS5nZXRBZGFwdGVyKCkuZ2V0TWF0cml4KCkpO1xuICAgIH0gZWxzZSB7IC8vIElmIHRoZSBhZGFwdGVyIGNoYW5nZWQsIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgdGhlIG1hdHJpeFxuICAgICAgICB0aGlzLnVwZGF0ZU1hdHJpeCgpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NVHJhbnNmb3JtRmV0Y2hlcjtcbiIsInZhciBhc3NpZ24gPSByZXF1aXJlKFwibG9kYXNoLmFzc2lnblwiKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKFwibG9kYXNoLmNyZWF0ZVwiKTtcblxuaWYgKHdpbmRvdy5YTUwzRCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gZGVmaW5lIHRoZSBYTUwzRCBuYW1lc3BhY2UgYSBzZWNvbmQgdGltZS4gUGxlYXNlIGVuc3VyZSB4bWwzZC5qcyBpcyBvbmx5IGxvYWRlZCBvbmNlIVwiKTtcbn1cbi8qKiBAbmFtZXNwYWNlICogKi9cbnZhciBYTUwzRCA9IFhNTDNEIHx8IHt9O1xudmFyIFhmbG93ID0gWGZsb3cgfHwge307XG53aW5kb3cuWE1MM0QgPSBYTUwzRDtcbndpbmRvdy5YZmxvdyA9IFhmbG93O1xuXG5YTUwzRC52ZXJzaW9uID0gJ0RFVkVMT1BNRU5UIFNOQVBTSE9UICgyOS4wNy4yMDE1IDA5OjU4OjAzIEdNVCswMjAwKSc7XG4vKiogQGNvbnN0ICovXG5YTUwzRC54bWwzZE5TID0gJ2h0dHA6Ly93d3cueG1sM2Qub3JnLzIwMDkveG1sM2QnO1xuLyoqIEBjb25zdCAqL1xuWE1MM0QueGh0bWxOUyA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbi8qKiBAY29uc3QgKi9cblhNTDNELndlYmdsTlMgPSAnaHR0cDovL3d3dy54bWwzZC5vcmcvMjAwOS94bWwzZC93ZWJnbCc7XG5YTUwzRC5feG1sM2QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoWE1MM0QueG1sM2ROUywgXCJ4bWwzZFwiKTtcblhNTDNELl9wYXJhbGxlbCA9IFhNTDNELl9wYXJhbGxlbCAhPSB1bmRlZmluZWQgPyBYTUwzRC5fcGFyYWxsZWwgOiBmYWxzZTtcblhNTDNELnhodG1sID0gISEoZG9jdW1lbnQuZG9jdHlwZSAmJiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKGRvY3VtZW50LmRvY3R5cGUpLm1hdGNoKC94aHRtbC9pKSk7XG5cblhNTDNELmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbih0YWdOYW1lKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhYTUwzRC54bWwzZE5TLCB0YWdOYW1lKTtcbn07XG5cblhNTDNELmV4dGVuZCA9IGFzc2lnbjtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBDb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IHBhcmVudCBQYXJlbnQgY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0PX0gbWV0aG9kcyBNZXRob2RzIHRvIGFkZCB0byB0aGUgY2xhc3NcbiAqIEByZXR1cm4ge09iamVjdCF9XG4gKi9cblhNTDNELmNyZWF0ZUNsYXNzID0gZnVuY3Rpb24ob2JqLCBwYXJlbnQsIG1ldGhvZHMpIHtcbiAgICBpZighcGFyZW50KSB7XG4gICAgICAgIGFzc2lnbihvYmoucHJvdG90eXBlLCBtZXRob2RzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmoucHJvdG90eXBlID0gY3JlYXRlKHBhcmVudC5wcm90b3R5cGUsIG1ldGhvZHMpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuWE1MM0QuZGVidWcgPSByZXF1aXJlKFwiLi91dGlscy9kZWJ1Zy5qc1wiKTtcblhNTDNELnV0aWwgPSByZXF1aXJlKFwiLi91dGlscy9taXNjLmpzXCIpO1xuWE1MM0Qub3B0aW9ucyA9IHJlcXVpcmUoXCIuL3V0aWxzL29wdGlvbnMuanNcIik7XG5YTUwzRC5tYXRlcmlhbHMgPSByZXF1aXJlKFwiLi9yZW5kZXJlci93ZWJnbC9tYXRlcmlhbHMvdXJuL3JlZ2lzdGVyeS5qc1wiKTtcblhNTDNELnJlc291cmNlID0gcmVxdWlyZShcIi4vYmFzZS9yZXNvdXJjZW1hbmFnZXIuanNcIikuUmVzb3VyY2U7IC8vUmVxdWlyZWQgZm9yIHRoZSB0ZXN0IGxpYnJhcnkgYmVjYXVzZSB0aGUgUk0gbmVlZHMgdG8gXCJiZWxvbmdcIiB0byB0aGUgc2FtZSBkb2N1bWVudCBhcyB0aGUgWE1MM0QgZWxlbWVudCBpbiBvcmRlciB0byByZXNvbHZlIHJlZmVyZW5jZXMgY29ycmVjdGx5XG5YTUwzRC5yZXNvdXJjZS5yZWdpc3RlckZvcm1hdCA9IHJlcXVpcmUoXCIuL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLnJlZ2lzdGVyRm9ybWF0O1xuLy9YTUwzRC5yZXNvdXJjZS5Gb3JtYXRIYW5kbGVyXG4vL1hNTDNELnJlc291cmNlLkpTT05Gb3JtYXRIYW5kbGVyXG4vL1hNTDNELnJlc291cmNlLkFkYXB0ZXJGYWN0b3J5XG5YTUwzRC53ZWJjbCA9IHJlcXVpcmUoXCIuL3V0aWxzL3dlYmNsLmpzXCIpLndlYmNsO1xuWE1MM0QubWF0aCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIik7XG5YTUwzRC5tYXRoLmJib3ggPSByZXF1aXJlKFwiLi9tYXRoL2Jib3guanNcIik7XG5YTUwzRC5tYXRoLnJheSA9IHJlcXVpcmUoXCIuL21hdGgvcmF5LmpzXCIpO1xucmVxdWlyZShcIi4vbWF0aC9tYXRoLmpzXCIpKFhNTDNELm1hdGgpO1xuXG5YTUwzRC5NYXQyID0gcmVxdWlyZShcIi4vdHlwZXMvbWF0Mi5qc1wiKTtcblhNTDNELk1hdDMgPSByZXF1aXJlKFwiLi90eXBlcy9tYXQzLmpzXCIpO1xuWE1MM0QuTWF0NCA9IHJlcXVpcmUoXCIuL3R5cGVzL21hdDQuanNcIik7XG5YTUwzRC5WZWMyID0gcmVxdWlyZShcIi4vdHlwZXMvdmVjMi5qc1wiKTtcblhNTDNELlZlYzMgPSByZXF1aXJlKFwiLi90eXBlcy92ZWMzLmpzXCIpO1xuWE1MM0QuVmVjNCA9IHJlcXVpcmUoXCIuL3R5cGVzL3ZlYzQuanNcIik7XG5YTUwzRC5BeGlzQW5nbGUgPSByZXF1aXJlKFwiLi90eXBlcy9heGlzYW5nbGUuanNcIik7XG5YTUwzRC5RdWF0ID0gcmVxdWlyZShcIi4vdHlwZXMvcXVhdC5qc1wiKTtcblhNTDNELlJheSA9IHJlcXVpcmUoXCIuL3R5cGVzL3JheS5qc1wiKTtcblhNTDNELkJveCA9IHJlcXVpcmUoXCIuL3R5cGVzL2JveC5qc1wiKTtcblxuWE1MM0QuZXh0ZW5kKHdpbmRvdywgcmVxdWlyZShcIi4vdHlwZXMvZGF0YS1vYnNlcnZlci5qc1wiKSk7XG5cblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IgPSByZXF1aXJlKFwiLi94Zmxvdy9vcGVyYXRvci9vcGVyYXRvci5qc1wiKS5yZWdpc3Rlck9wZXJhdG9yO1xuWGZsb3cuY29uc3RhbnRzID0gcmVxdWlyZShcIi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcblhNTDNELmV4dGVuZChYZmxvdywgcmVxdWlyZShcIi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpKTtcblhNTDNELmV4dGVuZChYZmxvdywgcmVxdWlyZShcIi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikpO1xuWGZsb3cuQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcblxucmVxdWlyZShcIi4veGZsb3cvb3BlcmF0b3IvZGVmYXVsdFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgWE1MM0QgOiBYTUwzRCxcbiAgICBYZmxvdyA6IFhmbG93XG59O1xuIiwidmFyIFhNTDNEID0gcmVxdWlyZShcIi4vZ2xvYmFsLmpzXCIpLlhNTDNEO1xudmFyIENvbmZpZyA9IHJlcXVpcmUoXCIuL2ludGVyZmFjZS9lbGVtZW50cy5qc1wiKS5jb25maWc7XG52YXIgc2VuZEFkYXB0ZXJFdmVudCA9IHJlcXVpcmUoXCIuL3V0aWxzL21pc2MuanNcIikuc2VuZEFkYXB0ZXJFdmVudDtcbnZhciBPcHRpb25zID0gcmVxdWlyZShcIi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcbnZhciBDU1MgPSByZXF1aXJlKFwiLi91dGlscy9jc3MuanNcIik7XG52YXIgQ29uZmlndXJlUmVuZGVyZXIgPSByZXF1aXJlKFwiLi9yZW5kZXJlci9yZW5kZXJlci9jb25maWd1cmUuanNcIik7XG52YXIgV2ViZ2xTdXBwb3J0ZWQgPSByZXF1aXJlKFwiLi9yZW5kZXJlci93ZWJnbC9iYXNlL3V0aWxzLmpzXCIpLnN1cHBvcnRlZDtcbnJlcXVpcmUoXCIuL2ludGVyZmFjZS9kb20uanNcIik7XG5yZXF1aXJlKFwiLi91dGlscy9kZWJ1Zy5qc1wiKTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKGlQYWR8aVBob25lfGlQb2QgdG91Y2gpL2kpKSB7XG4gICAgICAgIHZhciBtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1ldGFcIik7XG4gICAgICAgIG0ubmFtZSA9IFwiZm9ybWF0LWRldGVjdGlvblwiO1xuICAgICAgICBtLmNvbnRlbnQgPSBcInRlbGVwaG9uZT1ub1wiO1xuICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG0pXG4gICAgfVxufSgpKTtcblxuZnVuY3Rpb24gZGlzcGxheVdlYkdMTm90U3VwcG9ydGVkSW5mbyh4bWwzZEVsZW1lbnQpe1xuXG4gICAgaWYoeG1sM2RFbGVtZW50Lmhhc0F0dHJpYnV0ZShcIm9udW5zdXBwb3J0ZWRcIikpe1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJldmVudFwiLCB4bWwzZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwib251bnN1cHBvcnRlZFwiKSk7XG4gICAgICAgIHhtbDNkRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd1bnN1cHBvcnRlZCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgfVxuICAgIHZhciBkb0RlZmF1bHQgPSBYTUwzRC51dGlsLmRpc3BhdGNoQ3VzdG9tRXZlbnQoeG1sM2RFbGVtZW50LCAndW5zdXBwb3J0ZWQnLCBmYWxzZSwgdHJ1ZSwgbnVsbCk7XG4gICAgaWYoZG9EZWZhdWx0KXtcbiAgICAgICAgLy8gUGxhY2UgeG1sM2RFbGVtZW50IGluc2lkZSBhbiBpbnZpc2libGUgZGl2XG4gICAgICAgIHZhciBoaWRlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFhNTDNELnhodG1sTlMsICdkaXYnKTtcblxuICAgICAgICB4bWwzZEVsZW1lbnQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaGlkZURpdiwgeG1sM2RFbGVtZW50KTtcbiAgICAgICAgaGlkZURpdi5hcHBlbmRDaGlsZCh4bWwzZEVsZW1lbnQpO1xuICAgICAgICAvL2hpZGVEaXYuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgICAgIHZhciBpbmZvRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFhNTDNELnhodG1sTlMsICdkaXYnKTtcbiAgICAgICAgaWYoeG1sM2RFbGVtZW50Lmhhc0F0dHJpYnV0ZShcImNsYXNzXCIpKXtcbiAgICAgICAgICAgIGluZm9EaXYuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgeG1sM2RFbGVtZW50LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZm9EaXYuc2V0QXR0cmlidXRlKFwic3R5bGVcIiwgeG1sM2RFbGVtZW50LmdldEF0dHJpYnV0ZShcInN0eWxlXCIpKTtcbiAgICAgICAgaW5mb0Rpdi5zdHlsZS5ib3JkZXIgPSBcIjJweCBzb2xpZCByZWRcIjtcbiAgICAgICAgaW5mb0Rpdi5zdHlsZS5mb250RmFtaWx5ID0gXCJ2ZXJkYW5hLHNhbnMtc2VyaWZcIjtcbiAgICAgICAgaW5mb0Rpdi5zdHlsZS5jb2xvciA9IFwicmVkXCI7XG4gICAgICAgIGluZm9EaXYuc3R5bGUucGFkZGluZyA9IFwiMTBweFwiO1xuICAgICAgICBpbmZvRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwicmdiYSgyNTUsIDAsIDAsIDAuMylcIjtcblxuICAgICAgICB2YXIgd2lkdGggPSB4bWwzZEVsZW1lbnQuZ2V0QXR0cmlidXRlKFwid2lkdGhcIik7XG4gICAgICAgIGlmICh3aWR0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaW5mb0Rpdi5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhlaWdodCA9IHhtbDNkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIik7XG4gICAgICAgIGlmIChoZWlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGluZm9EaXYuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgzXCIpO1xuICAgICAgICB2YXIgaFR4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiU29ycnksIHlvdXIgYnJvd3NlciBkb2Vzbid0IGFwcGVhciB0byBzdXBwb3J0IFhNTDNELlwiKTtcbiAgICAgICAgaEVsZW1lbnQuYXBwZW5kQ2hpbGQoaFR4dCk7XG5cbiAgICAgICAgdmFyIHBFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICAgIHBFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiUGxlYXNlIHZpc2l0IFwiKSk7XG4gICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIGxpbmsuc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBcImh0dHA6Ly93d3cueG1sM2Qub3JnL2hlbHBcIik7XG4gICAgICAgIGxpbmsuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJodHRwOi8vd3d3LnhtbDNkLm9yZy9oZWxwXCIpKTtcbiAgICAgICAgcEVsZW1lbnQuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICAgIHBFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKSk7XG4gICAgICAgIGluZm9EaXYuYXBwZW5kQ2hpbGQoaEVsZW1lbnQpO1xuICAgICAgICBpbmZvRGl2LmFwcGVuZENoaWxkKHBFbGVtZW50KTtcblxuICAgICAgICBoaWRlRGl2LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGluZm9EaXYsIGhpZGVEaXYpO1xuICAgIH1cblxufVxuXG4vKiAgYSBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgYXJlIGN1cnJlbnRseSBpbml0aWFsaXplZC4gTW9yZSBzcGVjaWZpY2FsbHksXG4gKiAgdGhleSdyZSBjdXJyZW50bHkgaW4gYSBjYWxsIHRvIHRoZSBtZXRob2QgYmVsb3cuXG4gKlxuICogIFdoeT9cbiAqICBJbiB3ZWJnbCB3ZSBhY3R1YWxseSByZWF0dGFjaCB0aGUgeG1sM2QgZWxlbWVudCBpbiB0aGUgRE9NLiBUaHVzLCB3aGVuXG4gKiAgd2UncmUgaW4gdGhlIG1pZGRsZSBvZiB3b3JraW5nIG9uIGEgb25Ob2RlSW5zZXJ0ZWQgZXZlbnQsIHRoZXJlIHdpbGwgcHJvYmFibHlcbiAqICBjb21lIHJpZ2h0IGFub3RoZXIgZXZlbnQgd2hpY2ggd2UgYWN0dWFsbHkgZG9uJ3QgY2FyZSBmb3IuXG4gKiAgU28gd2UgdXNlIHRoaXMgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGVsZW1lbnRzIGFyZSBjdXJyZW50bHkgaW5pdGlhbGl6aW5nLlxuICovXG52YXIgY3VyWE1MM0RJbml0RWxlbWVudHMgPSBbXTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHhtbDNkRWxlbWVudFxuICovXG5mdW5jdGlvbiBpbml0WE1MM0RFbGVtZW50KHhtbDNkRWxlbWVudCkge1xuICAgIGlmKC0xIDwgY3VyWE1MM0RJbml0RWxlbWVudHMuaW5kZXhPZih4bWwzZEVsZW1lbnQpKVxuICAgICAgICByZXR1cm47XG5cbiAgICBjdXJYTUwzREluaXRFbGVtZW50cy5wdXNoKHhtbDNkRWxlbWVudCk7XG5cbiAgICB2YXIgZGVidWcgPSBYTUwzRC5kZWJ1Zy5zZXR1cCgpO1xuXG4gICAgaWYgKCFXZWJnbFN1cHBvcnRlZCgpKSB7XG4gICAgICAgIGRlYnVnICYmIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJDb3VsZCBub3QgaW5pdGlhbGlzZSBXZWJHTCwgc29ycnkgOi0oXCIpO1xuICAgICAgICBkaXNwbGF5V2ViR0xOb3RTdXBwb3J0ZWRJbmZvKHhtbDNkRWxlbWVudCk7XG4gICAgICAgIGN1clhNTDNESW5pdEVsZW1lbnRzLnNwbGljZShjdXJYTUwzREluaXRFbGVtZW50cy5pbmRleE9mKHhtbDNkRWxlbWVudCksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgWE1MM0QuZGVidWcubG9nSW5mbyhcIkNvbmZpZ3VyaW5nXCIsIHhtbDNkRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiKlwiKS5sZW5ndGgsIFwiZWxlbWVudHNcIik7XG5cbiAgICB0cnkge1xuICAgICAgICBDb25maWcuY29uZmlndXJlKHhtbDNkRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZyAmJiBYTUwzRC5kZWJ1Zy5sb2dFeGNlcHRpb24oZSk7XG4gICAgICAgIGN1clhNTDNESW5pdEVsZW1lbnRzLnNwbGljZShjdXJYTUwzREluaXRFbGVtZW50cy5pbmRleE9mKHhtbDNkRWxlbWVudCksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIENvbmZpZ3VyZVJlbmRlcmVyKHhtbDNkRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBkZWJ1ZyAmJiBYTUwzRC5kZWJ1Zy5sb2dFeGNlcHRpb24oZSk7XG4gICAgICAgIGN1clhNTDNESW5pdEVsZW1lbnRzLnNwbGljZShjdXJYTUwzREluaXRFbGVtZW50cy5pbmRleE9mKHhtbDNkRWxlbWVudCksIDEpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW5pdGlhbGl6ZSBhbGwgYXR0YWNoZWQgYWRhcHRlcnNcbiAgICBzZW5kQWRhcHRlckV2ZW50KHhtbDNkRWxlbWVudCwge29uQ29uZmlndXJlZCA6IFtdfSk7XG5cbiAgICBjdXJYTUwzREluaXRFbGVtZW50cy5zcGxpY2UoY3VyWE1MM0RJbml0RWxlbWVudHMuaW5kZXhPZih4bWwzZEVsZW1lbnQpLCAxKTtcbiAgICBjbGVhck9ic2VydmVyKCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB4bWwzZEVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gZGVzdHJveVhNTDNERWxlbWVudCh4bWwzZEVsZW1lbnQpXG57XG4gICAgaWYoLTEgPCBjdXJYTUwzREluaXRFbGVtZW50cy5pbmRleE9mKHhtbDNkRWxlbWVudCkpXG4gICAgICAgIHJldHVybjtcblxuICAgIHhtbDNkRWxlbWVudC5fY29uZmlndXJlZCA9IHVuZGVmaW5lZDtcblxuICAgIGlmKCF4bWwzZEVsZW1lbnQucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuOyAvLyBhbHJlYWR5IHJlbW92ZWRcblxuICAgIHZhciBjYW52YXMgPSB4bWwzZEVsZW1lbnQucGFyZW50Tm9kZS5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuXG4gICAgdmFyIGdyYW5kUGFyZW50Tm9kZSA9IHhtbDNkRWxlbWVudC5wYXJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgaWYoIWdyYW5kUGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuOyAvLyBzdWJ0cmVlIGNvbnRhaW5pbmcgY2FudmFzIGlzIG5vdCBhdHRhY2hlZCwgY2FuJ3QgcmVtb3ZlIGl0XG5cbiAgICBpZighY2FudmFzIHx8IGNhbnZhcy50YWdOYW1lICE9PSBcImNhbnZhc1wiKVxuICAgICAgICByZXR1cm47IC8vIGFuIGVsZW1lbnQgd2UgZGlkbid0IGNyZWF0ZSwgc2tpcCBkZWxldGlvblxuXG4gICAgZ3JhbmRQYXJlbnROb2RlLnJlbW92ZUNoaWxkKHhtbDNkRWxlbWVudC5wYXJlbnROb2RlKTtcbiAgICBncmFuZFBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAqL1xuZnVuY3Rpb24gb25Ob2RlSW5zZXJ0ZWQoZXZ0KSB7XG5cbiAgICBpZihldnQudGFyZ2V0LnRhZ05hbWUgPT09IFwieG1sM2RcIikge1xuICAgICAgICBpbml0WE1MM0RFbGVtZW50KGV2dC50YXJnZXQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAqL1xuZnVuY3Rpb24gb25Ob2RlUmVtb3ZlZChldnQpIHtcblxuICAgIGlmKGV2dC50YXJnZXQudGFnTmFtZSA9PT0gXCJ4bWwzZFwiKSB7XG4gICAgICAgIGRlc3Ryb3lYTUwzREVsZW1lbnQoZXZ0LnRhcmdldCk7XG4gICAgfVxufVxuXG52YXIgb2JzZXJ2ZXIgPSBudWxsO1xuXG5mdW5jdGlvbiBvbkxvYWQoKSB7XG5cbiAgICBPcHRpb25zLnNldE9wdGlvbnNGcm9tUXVlcnkoKTtcblxuICAgIENTUy5pbml0KCk7XG5cbiAgICB2YXIgZGVidWcgPSBYTUwzRC5kZWJ1Zy5zZXR1cCgpO1xuICAgIGRlYnVnICYmIFhNTDNELmRlYnVnLmxvZ0luZm8oXCJ4bWwzZC5qcyB2ZXJzaW9uOiBcIiArIFhNTDNELnZlcnNpb24pO1xuXG4gICAgLyoqXG4gICAgICogRmluZCBhbGwgdGhlIFhNTDNEIHRhZ3MgaW4gdGhlIGRvY3VtZW50XG4gICAgICogQHR5cGUge05vZGVMaXN0fVxuICAgICAqL1xuICAgIHZhciB4bWwzZHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwieG1sM2RcIik7XG5cbiAgICBkZWJ1ZyAmJiBYTUwzRC5kZWJ1Zy5sb2dJbmZvKFwiRm91bmQgXCIgKyB4bWwzZHMubGVuZ3RoICsgXCIgeG1sM2Qgbm9kZShzKVwiKTtcblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB4bWwzZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5pdFhNTDNERWxlbWVudCh4bWwzZHNbaV0pO1xuICAgIH1cblxuICAgIC8vIFRPRE8oa3NvbnMpOiBSZW1vdmUgdGhpcywgbm8gTXV0YXRpb25PYnNlcnZlciBubyBYTUwzRFxuICAgIGlmKCFNdXRhdGlvbk9ic2VydmVyKXtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZUluc2VydGVkJywgb25Ob2RlSW5zZXJ0ZWQsIGZhbHNlKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTm9kZVJlbW92ZWQnLCBvbk5vZGVSZW1vdmVkLCBmYWxzZSk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIocmVzb2x2ZU11dGF0aW9ucyk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgYXR0cmlidXRlczogdHJ1ZSwgYXR0cmlidXRlRmlsdGVyOiBbIFwiY2xhc3NcIiwgXCJpZFwiLCBcInN0eWxlXCIgXSB9ICk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvblVubG9hZCgpIHtcbiAgICBpZiAoWE1MM0QuZG9jdW1lbnQpXG4gICAgICAgIFhNTDNELmRvY3VtZW50Lm9udW5sb2FkKCk7XG59XG5cblxuXG5mdW5jdGlvbiByZXNvbHZlTXV0YXRpb25zKG11dGF0aW9ucyl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG11dGF0aW9ucy5sZW5ndGg7ICsraSl7XG4gICAgICAgIHZhciBtdXRhdGlvbiA9IG11dGF0aW9uc1tpXTtcbiAgICAgICAgaWYobXV0YXRpb24udHlwZSA9PSAnY2hpbGRMaXN0Jyl7XG4gICAgICAgICAgICB2YXIgYWRkZWROb2RlcyA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XG4gICAgICAgICAgICB2YXIgaiA9IGFkZGVkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgd2hpbGUoai0tKXtcbiAgICAgICAgICAgICAgICBpZihhZGRlZE5vZGVzW2pdLnRhZ05hbWUgPT0gXCJ4bWwzZFwiKVxuICAgICAgICAgICAgICAgICAgICBpbml0WE1MM0RFbGVtZW50KGFkZGVkTm9kZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlbW92ZWROb2RlcyA9IG11dGF0aW9uLnJlbW92ZWROb2RlcztcbiAgICAgICAgICAgIHZhciBqID0gcmVtb3ZlZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlKGotLSkge1xuICAgICAgICAgICAgICAgIGlmKHJlbW92ZWROb2Rlc1tqXS50YWdOYW1lID09IFwieG1sM2RcIilcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveVhNTDNERWxlbWVudChyZW1vdmVkTm9kZXNbal0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSBpZiAobXV0YXRpb24udHlwZSA9PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIHZhciBtdXRhdGlvblRhcmdldCA9IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lID09PSBcImlkXCIgfHwgbXV0YXRpb24uYXR0cmlidXRlTmFtZSA9PT0gXCJjbGFzc1wiKVxuICAgICAgICAgICAgICAgIG11dGF0aW9uVGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB2YXIgY3NzVGFyZ2V0ID0gbXV0YXRpb25UYXJnZXQuX2NvbmZpZ3VyZWQgPyBtdXRhdGlvblRhcmdldCA6IG11dGF0aW9uVGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoXCJ4bWwzZFwiKTtcbiAgICAgICAgICAgIGlmKGNzc1RhcmdldCAmJiBjc3NUYXJnZXQuX2NvbmZpZ3VyZWQpIHsgLy8geG1sM2QgaXMgYSBjaGlsZCBub2RlXG4gICAgICAgICAgICAgICAgdmFyIGFkYXB0ZXJzTmFtZXMgPSBPYmplY3Qua2V5cyhjc3NUYXJnZXQuX2NvbmZpZ3VyZWQuYWRhcHRlcnMpLmZpbHRlcihmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLmluZGV4T2YoXCJ3ZWJnbFwiKSA9PSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFkYXB0ZXJzTmFtZXMubWFwKGZ1bmN0aW9uKG5hbWUpe3JldHVybiBjc3NUYXJnZXQuX2NvbmZpZ3VyZWQuYWRhcHRlcnNbbmFtZV07fSkuZm9yRWFjaChmdW5jdGlvbihyZW5kZXJBZGFwdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckFkYXB0ZXIudHJhdmVyc2UoZnVuY3Rpb24oYWRhcHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRhcHRlci5zdHlsZUNoYW5nZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfVxufVxuXG5YTUwzRC5mbHVzaENTU0NoYW5nZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKG9ic2VydmVyKXtcbiAgICAgICAgcmVzb2x2ZU11dGF0aW9ucyhvYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhck9ic2VydmVyKCl7XG4gICAgaWYob2JzZXJ2ZXIpe1xuICAgICAgICBvYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgIH1cbn1cblxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgb25Mb2FkLCBmYWxzZSk7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5sb2FkJywgb25VbmxvYWQsIGZhbHNlKTtcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZWxvYWQnLCBvblVubG9hZCwgZmFsc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhNTDNEO1xuXG4iLCJ2YXIgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vYmFzZS9yZXNvdXJjZW1hbmFnZXIuanNcIikuUmVzb3VyY2U7XG5cbnZhciBzdHJpbmcyYm9vbCA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGlmICghc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChzdHJpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJ0cnVlXCI6XG4gICAgY2FzZSBcIjFcIjpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSBcImZhbHNlXCI6XG4gICAgY2FzZSBcIjBcIjpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBCb29sZWFuKHN0cmluZyk7XG4gICAgfVxufTtcbnZhciBoYW5kbGVycyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRTdG9yYWdlKGVsZW0pe1xuICAgIHJldHVybiBlbGVtLl9jb25maWd1cmVkLnN0b3JhZ2U7XG59XG5cbnZhciBBdHRyaWJ1dGVIYW5kbGVyID0gZnVuY3Rpb24oZWxlbSkge1xufTtcblxuaGFuZGxlcnMuSURIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odmFsdWUsIHByZXZWYWx1ZSwgZWxlbSkge1xuICAgICAgICBSZXNvdXJjZS5ub3RpZnlOb2RlSWRDaGFuZ2UoZWxlbSwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gICAgfTtcbiAgICB0aGlzLmRlc2MgPSB7XG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGlkKSB8fCBcIlwiO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoaWQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5oYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5kZXNjID0ge1xuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShpZCkgfHwgXCJcIjtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGlkLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgZW51bU9iaikge1xuICAgIEF0dHJpYnV0ZUhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG5cbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcbiAgICAgICAgc3RvcmFnZVtpZF0gPSBlbnVtT2JqLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZShlbGVtLmdldEF0dHJpYnV0ZShpZCksIG51bGwsIGVsZW0sIHN0b3JhZ2UpO1xuICAgIH07XG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odiwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHYudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc3RvcmFnZVtpZF0gPSAodmFsdWUgJiYgZW51bU9iai52YWx1ZXNbdmFsdWVdICE9PSB1bmRlZmluZWQpID8gZW51bU9iai52YWx1ZXNbdmFsdWVdIDogZW51bU9iai5kZWZhdWx0VmFsdWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuZGVzYyA9IHtcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBlbnVtT2JqLnZhbHVlc1tzdG9yYWdlW2lkXV07XG4gICAgICAgIH0sXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICAgICAgICAvLyBBdHRyaWJ1dGUgaXMgc2V0IHRvIHdoYXRldmVyIGNvbWVzIGluXG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShpZCwgdik7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0eXBlb2YgdiA9PSAnc3RyaW5nJyA/IHYudG9Mb3dlckNhc2UoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiBlbnVtT2JqLnZhbHVlc1t2YWx1ZV0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2lkXSA9IGVudW1PYmoudmFsdWVzW3ZhbHVlXTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2lkXSA9IGVudW1PYmouZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5oYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlci5wcm90b3R5cGUgPSBuZXcgQXR0cmlidXRlSGFuZGxlcigpO1xuaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXI7XG5cbmhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgQXR0cmlidXRlSGFuZGxlci5jYWxsKHRoaXMpO1xuICAgIGlkID0gaWQudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgZXZlbnRUeXBlID0gaWQuc3Vic3RyaW5nKDIpO1xuXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oZWxlbSwgc3RvcmFnZSl7XG4gICAgICAgIHN0b3JhZ2VbaWRdID0gbnVsbDtcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZShlbGVtLmdldEF0dHJpYnV0ZShpZCksIG51bGwsIGVsZW0sIHN0b3JhZ2UpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbih2YWx1ZSwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XG4gICAgICAgIGlmKHN0b3JhZ2VbaWRdICE9IG51bGwpXG4gICAgICAgICAgICBlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBzdG9yYWdlW2lkXSk7XG4gICAgICAgIGlmKCF2YWx1ZSl7XG4gICAgICAgICAgICBzdG9yYWdlW2lkXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHN0b3JhZ2VbaWRdID0gZXZhbChcImNyeCA9IGZ1bmN0aW9uIFwiICsgaWQgKyBcIihldmVudCl7XFxuICBcIiArIHZhbHVlICsgXCJcXG59XCIpO1xuICAgICAgICAgICAgaWYgKFhNTDNELnhodG1sKSB7XG4gICAgICAgICAgICAgICAgLy8gb25seSBYSFRNTCBkb2N1bWVudHMgcmVxdWlyZSB0aGlzIHBvbHlmaWxsIGZvciBtb3VzZSBldmVudCBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgc3RvcmFnZVtpZF0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLmRlc2MgPSB7XG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZVtpZF07XG4gICAgICAgIH0sXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICBpZihYTUwzRC54aHRtbCAmJiBzdG9yYWdlW2lkXSkgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgc3RvcmFnZVtpZF0pO1xuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZihYTUwzRC54aHRtbCAmJiBzdG9yYWdlW2lkXSkgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgc3RvcmFnZVtpZF0sIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5oYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXIucHJvdG90eXBlID0gbmV3IEF0dHJpYnV0ZUhhbmRsZXIoKTtcbmhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXI7XG5cbmhhbmRsZXJzLkludEF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xuICAgICAgICBzdG9yYWdlW2lkXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZShlbGVtLmdldEF0dHJpYnV0ZShpZCksIG51bGwsIGVsZW0sIHN0b3JhZ2UpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbih2YWx1ZSwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XG4gICAgICAgIHZhciB2ID0gdmFsdWUubWF0Y2goL15cXGQrLyk7XG4gICAgICAgIGlmICghdiB8fCBpc05hTigrdlswXSkpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJJbnZhbGlkIGF0dHJpYnV0ZSBbXCIraWQrXCJdIHZhbHVlOiBcIiArIHZhbHVlLCBlbGVtKTtcbiAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKGlkLCBwcmV2VmFsdWUpO1xuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdG9yYWdlW2lkXSA9ICArdlswXTtcbiAgICAgICAgfVxuICAgICAgICBpZihlbGVtLl9jb25maWd1cmVkLmNhbnZhcylcbiAgICAgICAgICAgIGVsZW0uX2NvbmZpZ3VyZWQuY2FudmFzW2lkXSA9IHN0b3JhZ2VbaWRdO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuZGVzYyA9IHtcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2VbaWRdO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgdmFyIHYgPSArdmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNOYU4odikpIHtcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiSW52YWxpZCBhdHRyaWJ1dGUgW1wiK2lkK1wiXSB2YWx1ZTogXCIgKyB2YWx1ZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2VbaWRdID0gIE1hdGguZmxvb3Iodik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShpZCwgc3RvcmFnZVtpZF0gKyAnJyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmhhbmRsZXJzLkludEF0dHJpYnV0ZUhhbmRsZXIucHJvdG90eXBlID0gbmV3IEF0dHJpYnV0ZUhhbmRsZXIoKTtcbmhhbmRsZXJzLkludEF0dHJpYnV0ZUhhbmRsZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gaGFuZGxlcnMuSW50QXR0cmlidXRlSGFuZGxlcjtcblxuaGFuZGxlcnMuRmxvYXRBdHRyaWJ1dGVIYW5kbGVyID0gZnVuY3Rpb24oaWQsIGRlZmF1bHRWYWx1ZSkge1xuICAgIGlkID0gaWQudG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLmluaXQgPSBmdW5jdGlvbihlbGVtLCBzdG9yYWdlKXtcbiAgICAgICAgc3RvcmFnZVtpZF0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgIGlmIChlbGVtLmhhc0F0dHJpYnV0ZShpZCkpXG4gICAgICAgICAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUoZWxlbS5nZXRBdHRyaWJ1dGUoaWQpLCBudWxsLCBlbGVtLCBzdG9yYWdlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlID0gZnVuY3Rpb24odmFsdWUsIHByZXZWYWx1ZSwgZWxlbSwgc3RvcmFnZSkge1xuICAgICAgICB2YXIgdiA9ICt2YWx1ZTtcbiAgICAgICAgaWYgKGlzTmFOKHYpKSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiSW52YWxpZCBhdHRyaWJ1dGUgdmFsdWU6IFwiICsgdmFsdWUsIGVsZW0pO1xuICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoaWQsIHByZXZWYWx1ZSk7XG4gICAgICAgICAgICBzdG9yYWdlW2lkXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0b3JhZ2VbaWRdID0gIHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmRlc2MgPSB7XG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZVtpZF07XG4gICAgICAgIH0sXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICB2YXIgdiA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc05hTih2KSkge1xuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJJbnZhbGlkIGF0dHJpYnV0ZSBbXCIraWQrXCJdIHZhbHVlOiBcIiArIHZhbHVlLCB0aGlzKTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlW2lkXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSAgdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGlkLCBzdG9yYWdlW2lkXSArICcnKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5oYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciA9IGZ1bmN0aW9uKGlkLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZCA9IGlkLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24oZWxlbSwgc3RvcmFnZSl7XG4gICAgICAgIHN0b3JhZ2VbaWRdID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBpZiAoZWxlbS5oYXNBdHRyaWJ1dGUoaWQpKVxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlKGVsZW0uZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgZWxlbSwgc3RvcmFnZSk7XG4gICAgfTtcbiAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbih2YWx1ZSwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XG4gICAgICAgIHN0b3JhZ2VbaWRdID0gc3RyaW5nMmJvb2wodmFsdWUpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuZGVzYyA9IHtcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiBzdG9yYWdlW2lkXTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgIHN0b3JhZ2VbaWRdID0gQm9vbGVhbih2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShpZCwgc3RvcmFnZVtpZF0gKyAnJyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuaGFuZGxlcnMuVmVjM0F0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlkID0gaWQudG9Mb3dlckNhc2UoKTtcblxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xuICAgICAgICBzdG9yYWdlW2lkXSA9IG51bGw7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UsIGluaXQpIHtcbiAgICAgICAgaWYgKCFzdG9yYWdlW2lkXSkge1xuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBYTUwzRC5tYXRoLnZlYzMuY3JlYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBzdG9yYWdlW2lkXTtcbiAgICAgICAgdmFyIG0gPSAvXlxccyooXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccyokLy5leGVjKHZhbHVlKTtcbiAgICAgICAgaWYgKCFtICB8fCBpc05hTigrbVsxXSkgfHwgaXNOYU4oK21bMl0pIHx8IGlzTmFOKCttWzNdKSkge1xuICAgICAgICAgICAgdlswXSA9IGRlZmF1bHRWYWx1ZVswXTtcbiAgICAgICAgICAgIHZbMV0gPSBkZWZhdWx0VmFsdWVbMV07XG4gICAgICAgICAgICB2WzJdID0gZGVmYXVsdFZhbHVlWzJdO1xuICAgICAgICAgICAgIWluaXQgJiYgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIGVsZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdlswXSA9ICttWzFdO1xuICAgICAgICAgICAgdlsxXSA9ICttWzJdO1xuICAgICAgICAgICAgdlsyXSA9ICttWzNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5kZXNjID0ge1xuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFzdG9yYWdlW2lkXSkge1xuICAgICAgICAgICAgICAgIHRoYXQuc2V0RnJvbUF0dHJpYnV0ZSh0aGlzLmdldEF0dHJpYnV0ZShpZCksIG51bGwsIHRoaXMsIHN0b3JhZ2UsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBYTUwzRC5WZWMzKHN0b3JhZ2VbaWRdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgIGlmICghc3RvcmFnZVtpZF0pIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNldEZyb21BdHRyaWJ1dGUodGhpcy5nZXRBdHRyaWJ1dGUoaWQpLCBudWxsLCB0aGlzLCBzdG9yYWdlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB2ID0gc3RvcmFnZVtpZF07XG4gICAgICAgICAgICB2YXIgdmFsID0gdmFsdWUuZGF0YSA/IHZhbHVlLmRhdGEgOiB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh2YWwubGVuZ3RoICE9PSAzIHx8IGlzTmFOKHZhbFswXSkgfHwgaXNOYU4odmFsWzFdKSB8fCBpc05hTih2YWxbMl0pKSB7XG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHYgPSBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZbMF0gPSB2YWxbMF07IHZbMV0gPSB2YWxbMV07IHZbMl0gPSB2YWxbMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShpZCwgWE1MM0QubWF0aC52ZWMzLnRvRE9NU3RyaW5nKHYpKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG4vLyBOb3RlOiBBbGwgdmVjNCBhdHRyaWJ1dGVzIGFyZSBjb25zaWRlcmVkIHRvIGJlIGF4aXMtYW5nbGUsIE5PVCBxdWF0ZXJuaW9ucyFcbmhhbmRsZXJzLkF4aXNBbmdsZUF0dHJpYnV0ZUhhbmRsZXIgPSBmdW5jdGlvbihpZCwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlkID0gaWQudG9Mb3dlckNhc2UoKTtcblxuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xuICAgICAgICBzdG9yYWdlW2lkXSA9IG51bGw7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UsIGluaXQpIHtcbiAgICAgICAgaWYgKCFzdG9yYWdlW2lkXSkge1xuICAgICAgICAgICAgc3RvcmFnZVtpZF0gPSBYTUwzRC5tYXRoLnZlYzQuY3JlYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHYgPSBzdG9yYWdlW2lkXTtcbiAgICAgICAgdmFyIG0gPSAvXlxccyooXFxTKylcXHMrKFxcUyspXFxzKyhcXFMrKVxccysoXFxTKylcXHMqJC8uZXhlYyh2YWx1ZSk7XG4gICAgICAgIGlmICghbSAgfHwgaXNOYU4oK21bMV0pIHx8IGlzTmFOKCttWzJdKSB8fCBpc05hTigrbVszXSkgfHwgaXNOYU4oK21bNF0pKSB7XG4gICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzQuY29weSh2LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgIWluaXQgJiYgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIGVsZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgWE1MM0QubWF0aC52ZWM0LnNldCh2LCArbVsxXSwgK21bMl0sICttWzNdLCArbVs0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmRlc2MgPSB7XG4gICAgICAgIGdldCA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICBpZiAoIXN0b3JhZ2VbaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zZXRGcm9tQXR0cmlidXRlKHRoaXMuZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgdGhpcywgc3RvcmFnZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFhNTDNELkF4aXNBbmdsZShzdG9yYWdlW2lkXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmFnZSA9IGdldFN0b3JhZ2UodGhpcyk7XG4gICAgICAgICAgICBpZiAoIXN0b3JhZ2VbaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zZXRGcm9tQXR0cmlidXRlKHRoaXMuZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgdGhpcywgc3RvcmFnZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdiA9IHN0b3JhZ2VbaWRdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IHZhbHVlLmRhdGEgPyB2YWx1ZS5kYXRhIDogdmFsdWU7XG4gICAgICAgICAgICBpZiAodmFsLmxlbmd0aCAhPT0gNCB8fCBpc05hTih2YWxbMF0pIHx8IGlzTmFOKHZhbFsxXSkgfHwgaXNOYU4odmFsWzJdKSB8fCBpc05hTih2YWxbM10pKSB7XG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkludmFsaWQgYXR0cmlidXRlIFtcIitpZCtcIl0gdmFsdWU6IFwiICsgdmFsdWUsIHRoaXMpO1xuICAgICAgICAgICAgICAgIFhNTDNELm1hdGgudmVjNC5jb3B5KHYsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIFhNTDNELm1hdGgucXVhdC5jb3B5KHYsIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShpZCwgWE1MM0QubWF0aC52ZWM0LnRvRE9NU3RyaW5nKHYpKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG52YXIgbWl4ZWRDb250ZW50ID0gZnVuY3Rpb24oaGFuZGxlcikge1xuICAgIGhhbmRsZXIuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xuICAgICAgICBlbGVtLl9jb25maWd1cmVkLnJlZ2lzdGVyTWl4ZWQoKTtcbiAgICB9O1xuICAgIGhhbmRsZXIuZGVzYyA9IHtcbiAgICAgICAgZ2V0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gZ2V0U3RvcmFnZSh0aGlzKTtcbiAgICAgICAgICAgIGlmICghc3RvcmFnZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIHN0b3JhZ2UudmFsdWUgPSBoYW5kbGVyLnBhcnNlKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0b3JhZ2UudmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaHJvdyBlcnJvcj9cbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiQ2FuJ3Qgc2V0IFwiICsgdGhpcy5ub2RlTmFtZSArIFwiOjp2YWx1ZTogaXQncyByZWFkb25seVwiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaGFuZGxlci5yZXNldFZhbHVlID0gZnVuY3Rpb24oc3RvcmFnZSkgeyBzdG9yYWdlLnZhbHVlID0gbnVsbDsgfTtcbn07XG5cbnZhciBnZXRDb250ZW50ID0gZnVuY3Rpb24oZWxlbSkge1xuICAgIHZhciBzdHIgPSBcIlwiO1xuICAgIHZhciBrID0gZWxlbS5maXJzdENoaWxkO1xuICAgIHdoaWxlIChrKSB7XG4gICAgICAgIHN0ciArPSBrLm5vZGVUeXBlID09IDMgPyBrLnRleHRDb250ZW50IDogXCIgXCI7XG4gICAgICAgIGsgPSBrLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufTtcblxuaGFuZGxlcnMuRmxvYXRBcnJheVZhbHVlSGFuZGxlciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgbWl4ZWRDb250ZW50KHRoaXMpO1xufTtcblxuaGFuZGxlcnMuRmxvYXRBcnJheVZhbHVlSGFuZGxlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgdmFyIGV4cCA9IC8oWytcXC0wLTllRVxcLl0rKS9nO1xuICAgIHZhciBzdHIgPSBnZXRDb250ZW50KGVsZW0pO1xuICAgIHZhciBtID0gc3RyLm1hdGNoKGV4cCk7XG4gICAgcmV0dXJuIG0gPyBuZXcgRmxvYXQzMkFycmF5KG0pIDogbmV3IEZsb2F0MzJBcnJheSgpO1xufTtcblxuaGFuZGxlcnMuRmxvYXQyQXJyYXlWYWx1ZUhhbmRsZXIgPSBoYW5kbGVycy5GbG9hdEFycmF5VmFsdWVIYW5kbGVyO1xuaGFuZGxlcnMuRmxvYXQzQXJyYXlWYWx1ZUhhbmRsZXIgPSBoYW5kbGVycy5GbG9hdEFycmF5VmFsdWVIYW5kbGVyO1xuaGFuZGxlcnMuRmxvYXQ0QXJyYXlWYWx1ZUhhbmRsZXIgPSBoYW5kbGVycy5GbG9hdEFycmF5VmFsdWVIYW5kbGVyO1xuaGFuZGxlcnMuRmxvYXQ0eDRBcnJheVZhbHVlSGFuZGxlciA9IGhhbmRsZXJzLkZsb2F0QXJyYXlWYWx1ZUhhbmRsZXI7XG5cbmhhbmRsZXJzLkludEFycmF5VmFsdWVIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcbiAgICBtaXhlZENvbnRlbnQodGhpcyk7XG59O1xuaGFuZGxlcnMuSW50QXJyYXlWYWx1ZUhhbmRsZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oZWxlbSkge1xuICAgIHZhciBleHAgPSAvKFsrXFwtMC05XSspL2c7XG4gICAgdmFyIHN0ciA9IGdldENvbnRlbnQoZWxlbSk7XG4gICAgdmFyIG0gPSBzdHIubWF0Y2goZXhwKTtcbiAgICByZXR1cm4gbSA/IG5ldyBJbnQzMkFycmF5KG0pIDogbmV3IEludDMyQXJyYXkoKTtcbn07XG5cbmhhbmRsZXJzLkJvb2xBcnJheVZhbHVlSGFuZGxlciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgbWl4ZWRDb250ZW50KHRoaXMpO1xufTtcbmhhbmRsZXJzLkJvb2xBcnJheVZhbHVlSGFuZGxlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgdmFyIGV4cCA9IC8odHJ1ZXxmYWxzZXwwfDEpL2lnO1xuICAgIHZhciBzdHIgPSBnZXRDb250ZW50KGVsZW0pO1xuICAgIHZhciBtID0gc3RyLm1hdGNoKGV4cCk7XG4gICAgaWYgKCFtKVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICBtID0gbS5tYXAoc3RyaW5nMmJvb2wpO1xuICAgIHJldHVybiBtID8gbmV3IFVpbnQ4QXJyYXkobSkgOiBuZXcgVWludDhBcnJheSgpO1xufTtcblxuaGFuZGxlcnMuU3RyaW5nVmFsdWVIYW5kbGVyID0gZnVuY3Rpb24oaWQpIHtcbiAgICBtaXhlZENvbnRlbnQodGhpcyk7XG59O1xuaGFuZGxlcnMuU3RyaW5nVmFsdWVIYW5kbGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICByZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcbn07XG5cbmhhbmRsZXJzLkNhbnZhc1N0eWxlSGFuZGxlciA9IGZ1bmN0aW9uKGlkLCBkKSB7XG4gICAgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xuICAgICAgICBpZiAoZWxlbS5oYXNBdHRyaWJ1dGUoaWQpKVxuICAgICAgICAgICAgdGhpcy5zZXRGcm9tQXR0cmlidXRlKGVsZW0uZ2V0QXR0cmlidXRlKGlkKSwgbnVsbCwgZWxlbSwgc3RvcmFnZSk7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHZhbHVlLCBwcmV2VmFsdWUsIGVsZW0sIHN0b3JhZ2UpIHtcbiAgICAgICAgZWxlbS5fY29uZmlndXJlZC5jYW52YXMuc2V0QXR0cmlidXRlKGlkLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIHRoaXMuZGVzYyA9IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuX2NvbmZpZ3VyZWQuY2FudmFzLnN0eWxlOyB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7fVxuICAgIH07XG5cbn07XG5cbmhhbmRsZXJzLkNhbnZhc0NsYXNzSGFuZGxlciA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgaWQgPSBpZC50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uKGVsZW0sIHN0b3JhZ2Upe1xuICAgICAgICB2YXIgY2FudmFzID0gZWxlbS5fY29uZmlndXJlZC5jYW52YXM7XG4gICAgICAgIGNhbnZhcy5jbGFzc05hbWUgPSBcIl94bWwzZFwiOyAvLyBDbGFzcyBuYW1lIGFsd2F5cyBkZWZpbmVkIGZvciB4bWwzZCBjYW52YXNcbiAgICAgICAgaWYgKGVsZW0uaGFzQXR0cmlidXRlKGlkKSlcbiAgICAgICAgICAgIHRoaXMuc2V0RnJvbUF0dHJpYnV0ZShlbGVtLmdldEF0dHJpYnV0ZShpZCksIG51bGwsIGVsZW0sIHN0b3JhZ2UpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEZyb21BdHRyaWJ1dGUgPSBmdW5jdGlvbih2YWx1ZSwgcHJldlZhbHVlLCBlbGVtLCBzdG9yYWdlKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBlbGVtLl9jb25maWd1cmVkLmNhbnZhcztcbiAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZShpZCwgdmFsdWUgKyBcIiBfeG1sM2RcIik7XG4gICAgfTtcblxuICAgIHRoaXMuZGVzYyA9IHtcbiAgICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIG5vdCBzdHJpcCB0aGUgX3htbDNkIGNsYXNzIGhlcmU/XG4gICAgICAgIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9jb25maWd1cmVkLmNhbnZhcy5jbGFzc05hbWU7IH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHsgdGhpcy5fY29uZmlndXJlZC5jYW52YXMuY2xhc3NOYW1lID0gdmFsdWU7IH1cbiAgICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBoYW5kbGVycztcbiIsInZhciBtZXRob2RzID0gcmVxdWlyZShcIi4vbWV0aG9kcy5qc1wiKTtcclxudmFyIGhhbmRsZXJzID0gcmVxdWlyZShcIi4vYXR0cmlidXRlcy5qc1wiKTtcclxudmFyIHByb3BlcnRpZXMgPSByZXF1aXJlKFwiLi9wcm9wZXJ0aWVzLmpzXCIpO1xyXG5cclxuLy8gTWVzaFR5cGVzXHJcbnZhciBNZXNoVHlwZXMgPSB7fTtcclxuTWVzaFR5cGVzW1widHJpYW5nbGVzXCJdID0gMDtcclxuTWVzaFR5cGVzWzBdID0gXCJ0cmlhbmdsZXNcIjtcclxuTWVzaFR5cGVzW1widHJpYW5nbGVzdHJpcHNcIl0gPSAxO1xyXG5NZXNoVHlwZXNbMV0gPSBcInRyaWFuZ2xlc3RyaXBzXCI7XHJcbk1lc2hUeXBlc1tcImxpbmVzXCJdID0gMjtcclxuTWVzaFR5cGVzWzJdID0gXCJsaW5lc1wiO1xyXG5NZXNoVHlwZXNbXCJsaW5lc3RyaXBzXCJdID0gMztcclxuTWVzaFR5cGVzWzNdID0gXCJsaW5lc3RyaXBzXCI7XHJcbk1lc2hUeXBlc1tcInBvaW50c1wiXSA9IDQ7XHJcbk1lc2hUeXBlc1s0XSA9IFwicG9pbnRzXCI7XHJcbi8vIFRleHR1cmVUeXBlc1xyXG52YXIgVGV4dHVyZVR5cGVzID0ge307XHJcblRleHR1cmVUeXBlc1tcIjJkXCJdID0gMDtcclxuVGV4dHVyZVR5cGVzWzBdID0gXCIyZFwiO1xyXG5UZXh0dXJlVHlwZXNbXCIxZFwiXSA9IDE7XHJcblRleHR1cmVUeXBlc1sxXSA9IFwiMWRcIjtcclxuVGV4dHVyZVR5cGVzW1wiM2RcIl0gPSAyO1xyXG5UZXh0dXJlVHlwZXNbMl0gPSBcIjNkXCI7XHJcblxyXG4vLyBQbGF0Zm9ybVR5cGVzXHJcbnZhciBQbGF0Zm9ybVR5cGVzID0ge307XHJcblBsYXRmb3JtVHlwZXNbXCJhdXRvXCJdID0gMTtcclxuUGxhdGZvcm1UeXBlc1sxXSA9IFwiYXV0b1wiO1xyXG5QbGF0Zm9ybVR5cGVzW1wianNcIl0gPSAyO1xyXG5QbGF0Zm9ybVR5cGVzWzJdID0gXCJqc1wiO1xyXG5QbGF0Zm9ybVR5cGVzW1wiZ2xcIl0gPSAzO1xyXG5QbGF0Zm9ybVR5cGVzWzNdID0gXCJnbFwiO1xyXG5QbGF0Zm9ybVR5cGVzW1wiY2xcIl0gPSA0O1xyXG5QbGF0Zm9ybVR5cGVzWzRdID0gXCJjbFwiO1xyXG4vLyBEYXRhRmllbGRUeXBlXHJcbnZhciBEYXRhRmllbGRUeXBlID0ge307XHJcbkRhdGFGaWVsZFR5cGVbXCJmbG9hdCBcIl0gPSAwO1xyXG5EYXRhRmllbGRUeXBlWzBdID0gXCJmbG9hdCBcIjtcclxuRGF0YUZpZWxkVHlwZVtcImZsb2F0MiBcIl0gPSAxO1xyXG5EYXRhRmllbGRUeXBlWzFdID0gXCJmbG9hdDIgXCI7XHJcbkRhdGFGaWVsZFR5cGVbXCJmbG9hdDNcIl0gPSAyO1xyXG5EYXRhRmllbGRUeXBlWzJdID0gXCJmbG9hdDNcIjtcclxuRGF0YUZpZWxkVHlwZVtcImZsb2F0NFwiXSA9IDM7XHJcbkRhdGFGaWVsZFR5cGVbM10gPSBcImZsb2F0NFwiO1xyXG5EYXRhRmllbGRUeXBlW1wiZmxvYXQ0eDRcIl0gPSA0O1xyXG5EYXRhRmllbGRUeXBlWzRdID0gXCJmbG9hdDR4NFwiO1xyXG5EYXRhRmllbGRUeXBlW1wiaW50XCJdID0gMTA7XHJcbkRhdGFGaWVsZFR5cGVbMTBdID0gXCJpbnRcIjtcclxuRGF0YUZpZWxkVHlwZVtcImludDRcIl0gPSAxMTtcclxuRGF0YUZpZWxkVHlwZVsxMV0gPSBcImludDRcIjtcclxuRGF0YUZpZWxkVHlwZVtcImJvb2xcIl0gPSAyMDtcclxuRGF0YUZpZWxkVHlwZVsyMF0gPSBcImJvb2xcIjtcclxuRGF0YUZpZWxkVHlwZVtcInRleHR1cmVcIl0gPSAzMDtcclxuRGF0YUZpZWxkVHlwZVszMF0gPSBcInRleHR1cmVcIjtcclxuLy8gRGF0YUNoYW5uZWxPcmlnaW5cclxudmFyIERhdGFDaGFubmVsT3JpZ2luID0ge307XHJcbkRhdGFDaGFubmVsT3JpZ2luW1wib3JpZ2luX3ZhbHVlIFwiXSA9IDA7XHJcbkRhdGFDaGFubmVsT3JpZ2luWzBdID0gXCJvcmlnaW5fdmFsdWUgXCI7XHJcbkRhdGFDaGFubmVsT3JpZ2luW1wib3JpZ2luX2NoaWxkXCJdID0gMTtcclxuRGF0YUNoYW5uZWxPcmlnaW5bMV0gPSBcIm9yaWdpbl9jaGlsZFwiO1xyXG5EYXRhQ2hhbm5lbE9yaWdpbltcIm9yaWdpbl9zb3VyY2VcIl0gPSAyO1xyXG5EYXRhQ2hhbm5lbE9yaWdpblsyXSA9IFwib3JpZ2luX3NvdXJjZVwiO1xyXG5EYXRhQ2hhbm5lbE9yaWdpbltcIm9yaWdpbl9jb21wdXRlXCJdID0gMztcclxuRGF0YUNoYW5uZWxPcmlnaW5bM10gPSBcIm9yaWdpbl9jb21wdXRlXCI7XHJcbkRhdGFDaGFubmVsT3JpZ2luW1wib3JpZ2luX3Byb3RvXCJdID0gNDtcclxuRGF0YUNoYW5uZWxPcmlnaW5bNF0gPSBcIm9yaWdpbl9wcm90b1wiO1xyXG5cclxudmFyIGNsYXNzSW5mbyA9IHt9O1xyXG5cclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDx4bWwzZD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ3htbDNkJ10gPSB7XHJcbiAgICBpZCA6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lIDoge2E6IGhhbmRsZXJzLkNhbnZhc0NsYXNzSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgc3R5bGUgOiB7YTogaGFuZGxlcnMuQ2FudmFzU3R5bGVIYW5kbGVyfSxcclxuICAgIG9uY2xpY2sgOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9uZGJsY2xpY2sgOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2Vkb3duIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNldXAgOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdmVyIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlbW92ZSA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW91dCA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlwcmVzcyA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlkb3duIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXVwIDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmxvYWQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25mcmFtZWRyYXduOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy54bWwzZENvbXBsZXRlfSxcclxuICAgIGhlaWdodCA6IHthOiBoYW5kbGVycy5JbnRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDYwMH0sXHJcbiAgICB3aWR0aCA6IHthOiBoYW5kbGVycy5JbnRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDgwMH0sXHJcbiAgICBnZXRFbGVtZW50QnlQb2ludCA6IHttOiBtZXRob2RzLnhtbDNkR2V0RWxlbWVudEJ5UG9pbnR9LFxyXG4gICAgZ2VuZXJhdGVSYXkgOiB7bTogbWV0aG9kcy54bWwzZEdlbmVyYXRlUmF5fSxcclxuICAgIGdldEVsZW1lbnRCeVJheSA6IHttOiBtZXRob2RzLnhtbDNkR2V0RWxlbWVudEJ5UmF5fSxcclxuICAgIGdldFdvcmxkQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRXb3JsZEJvdW5kaW5nQm94fSxcclxuICAgIGdldExvY2FsQm91bmRpbmdCb3ggOiB7bTogbWV0aG9kcy5nZXRMb2NhbEJvdW5kaW5nQm94fSxcclxuICAgIGdldFJlbmRlckludGVyZmFjZSA6IHttOiBtZXRob2RzLnhtbDNkR2V0UmVuZGVySW50ZXJmYWNlfSxcclxuICAgIGFjdGl2ZVZpZXcgOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn1cclxuICAgIH07XHJcblxyXG5jbGFzc0luZm9bJ2NvbXB1dGUnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuU3RyaW5nVmFsdWVIYW5kbGVyfVxyXG4gICAgfTtcclxuXHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8ZGF0YT5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2RhdGEnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIGNvbXB1dGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBsYXRmb3JtOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge3ZhbHVlczogUGxhdGZvcm1UeXBlcywgZGVmYXVsdFZhbHVlczogMX19LFxyXG4gICAgZmlsdGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmxvYWQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25wcm9ncmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBjb21wbGV0ZToge3A6IHByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUNvbXBsZXRlfSxcclxuICAgIHByb2dyZXNzTGV2ZWw6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVQcm9ncmVzc0xldmVsfSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRDb21wdXRlSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldENvbXB1dGVJbmZvfSxcclxuICAgIGdldFByb3RvSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFByb3RvSW5mb30sXHJcbiAgICBpc091dHB1dENvbm5lY3RlZDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUlzT3V0cHV0Q29ubmVjdGVkfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFJlc3VsdH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxkYXRhZmxvdz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2RhdGFmbG93J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBwbGF0Zm9ybToge2E6IGhhbmRsZXJzLkVudW1BdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IHt2YWx1ZXM6IFBsYXRmb3JtVHlwZXMsIGRlZmF1bHRWYWx1ZXM6IDF9fSxcclxuICAgIG91dDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ucHJvZ3Jlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgY29tcGxldGU6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVDb21wbGV0ZX0sXHJcbiAgICBwcm9ncmVzc0xldmVsOiB7cDogcHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlUHJvZ3Jlc3NMZXZlbH0sXHJcbiAgICBnZXRPdXRwdXROYW1lczoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldE91dHB1dE5hbWVzfSxcclxuICAgIGdldE91dHB1dENoYW5uZWxJbmZvOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0Q2hhbm5lbEluZm99LFxyXG4gICAgZ2V0Q29tcHV0ZUluZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRDb21wdXRlSW5mb30sXHJcbiAgICBnZXRQcm90b0luZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRQcm90b0luZm99LFxyXG4gICAgaXNPdXRwdXRDb25uZWN0ZWQ6IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVJc091dHB1dENvbm5lY3RlZH0sXHJcbiAgICBnZXRSZXN1bHQ6IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRSZXN1bHR9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGRhdGE+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydhc3NldCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ucHJvZ3Jlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgY29tcGxldGU6IHtwOiBwcm9wZXJ0aWVzLkFzc2V0Q29tcGxldGV9LFxyXG4gICAgcHJvZ3Jlc3NMZXZlbDoge3A6IHByb3BlcnRpZXMuQXNzZXRQcm9ncmVzc0xldmVsfSxcclxuICAgIHNyYzoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGljazoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgdHJhbnNmb3JtOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBtYXRlcmlhbDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGRlZnM+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydkZWZzJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ31cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8Z3JvdXA+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydncm91cCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgb25jbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmRibGNsaWNrOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2Vkb3duOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2V1cDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3Zlcjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlbW92ZToge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlb3V0OiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5cHJlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlkb3duOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5dXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgZ2V0V29ybGRNYXRyaXg6IHttOiBtZXRob2RzLlhNTDNER3JhcGhUeXBlR2V0V29ybGRNYXRyaXh9LFxyXG4gICAgZ2V0TG9jYWxNYXRyaXg6IHttOiBtZXRob2RzLmdyb3VwR2V0TG9jYWxNYXRyaXh9LFxyXG4gICAgZ2V0V29ybGRCb3VuZGluZ0JveCA6IHttOiBtZXRob2RzLmdldFdvcmxkQm91bmRpbmdCb3h9LFxyXG4gICAgZ2V0TG9jYWxCb3VuZGluZ0JveCA6IHttOiBtZXRob2RzLmdldExvY2FsQm91bmRpbmdCb3h9LFxyXG4gICAgdHJhbnNmb3JtOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBtYXRlcmlhbDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPG1lc2g+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydtZXNoJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBvbmNsaWNrOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9uZGJsY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZWRvd246IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdmVyOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2Vtb3ZlOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdXQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlwcmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleWRvd246IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXl1cDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmxvYWQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25wcm9ncmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBjb21wbGV0ZToge3A6IHByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUNvbXBsZXRlfSxcclxuICAgIHByb2dyZXNzTGV2ZWw6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVQcm9ncmVzc0xldmVsfSxcclxuICAgIHR5cGU6IHthOiBoYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB7dmFsdWVzOiBNZXNoVHlwZXMsIGRlZmF1bHRWYWx1ZTogMH19LFxyXG4gICAgY29tcHV0ZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgdHJhbnNmb3JtOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBtYXRlcmlhbDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgZ2V0V29ybGRNYXRyaXg6IHttOiBtZXRob2RzLlhNTDNER3JhcGhUeXBlR2V0V29ybGRNYXRyaXh9LFxyXG4gICAgZ2V0V29ybGRCb3VuZGluZ0JveCA6IHttOiBtZXRob2RzLmdldFdvcmxkQm91bmRpbmdCb3h9LFxyXG4gICAgZ2V0TG9jYWxCb3VuZGluZ0JveCA6IHttOiBtZXRob2RzLmdldExvY2FsQm91bmRpbmdCb3h9LFxyXG4gICAgZ2V0T3V0cHV0TmFtZXM6IHttOiBtZXRob2RzLm1lc2hHZXRPdXRwdXROYW1lc30sXHJcbiAgICBnZXRPdXRwdXRDaGFubmVsSW5mbzoge206IG1ldGhvZHMubWVzaEdldE91dHB1dENoYW5uZWxJbmZvfSxcclxuICAgIGdldENvbXB1dGVJbmZvOiB7bTogbWV0aG9kcy5tZXNoR2V0Q29tcHV0ZUluZm99LFxyXG4gICAgZ2V0UHJvdG9JbmZvOiB7bTogbWV0aG9kcy5tZXNoR2V0UHJvdG9JbmZvfSxcclxuICAgIGlzT3V0cHV0Q29ubmVjdGVkOiB7bTogbWV0aG9kcy5tZXNoSXNPdXRwdXRDb25uZWN0ZWR9LFxyXG4gICAgZ2V0UmVzdWx0OiB7bTogbWV0aG9kcy5tZXNoR2V0UmVzdWx0fSxcclxuICAgIHNyYzoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPG1vZGVsPlxyXG4gKiovXHJcbmNsYXNzSW5mb1snbW9kZWwnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9uY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25kYmxjbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNldXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW92ZXI6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW1vdmU6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW91dDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXByZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5ZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubG9hZDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbnByb2dyZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXBsZXRlOiB7cDogcHJvcGVydGllcy5Bc3NldENvbXBsZXRlfSxcclxuICAgIHByb2dyZXNzTGV2ZWw6IHtwOiBwcm9wZXJ0aWVzLkFzc2V0UHJvZ3Jlc3NMZXZlbH0sXHJcbiAgICBnZXRXb3JsZE1hdHJpeDoge206IG1ldGhvZHMuWE1MM0RHcmFwaFR5cGVHZXRXb3JsZE1hdHJpeH0sXHJcbiAgICBnZXRXb3JsZEJvdW5kaW5nQm94IDoge206IG1ldGhvZHMuZ2V0V29ybGRCb3VuZGluZ0JveH0sXHJcbiAgICBnZXRMb2NhbEJvdW5kaW5nQm94IDoge206IG1ldGhvZHMuZ2V0TG9jYWxCb3VuZGluZ0JveH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBpY2s6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHRyYW5zZm9ybToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgbWF0ZXJpYWw6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDx0cmFuc2Zvcm0+XHJcbiAqKi9cclxuY2xhc3NJbmZvWyd0cmFuc2Zvcm0nXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIHRyYW5zbGF0aW9uOiB7YTogaGFuZGxlcnMuVmVjM0F0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogWzAsIDAsIDBdfSxcclxuICAgIHNjYWxlOiB7YTogaGFuZGxlcnMuVmVjM0F0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogWzEsIDEsIDFdfSxcclxuICAgIHJvdGF0aW9uOiB7YTogaGFuZGxlcnMuQXhpc0FuZ2xlQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBbMCwgMCwgMSwgMF19LFxyXG4gICAgY2VudGVyOiB7YTogaGFuZGxlcnMuVmVjM0F0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogWzAsIDAsIDBdfSxcclxuICAgIHNjYWxlT3JpZW50YXRpb246IHthOiBoYW5kbGVycy5BeGlzQW5nbGVBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IFswLCAwLCAxLCAwXX1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8bWF0ZXJpYWw+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydtYXRlcmlhbCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ucHJvZ3Jlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgY29tcGxldGU6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVDb21wbGV0ZX0sXHJcbiAgICBwcm9ncmVzc0xldmVsOiB7cDogcHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlUHJvZ3Jlc3NMZXZlbH0sXHJcbiAgICBjb21wdXRlOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBnZXRPdXRwdXROYW1lczoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRPdXRwdXROYW1lc30sXHJcbiAgICBnZXRPdXRwdXRDaGFubmVsSW5mbzoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRDb21wdXRlSW5mbzoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRDb21wdXRlSW5mb30sXHJcbiAgICBnZXRQcm90b0luZm86IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0UHJvdG9JbmZvfSxcclxuICAgIGlzT3V0cHV0Q29ubmVjdGVkOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUlzT3V0cHV0Q29ubmVjdGVkfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRSZXN1bHR9LFxyXG4gICAgc2NyaXB0OiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxsaWdodD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2xpZ2h0J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBvbmNsaWNrOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9uZGJsY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZWRvd246IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdmVyOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2Vtb3ZlOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ubW91c2VvdXQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXlwcmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleWRvd246IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25rZXl1cDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBnbG9iYWw6IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBnZXRXb3JsZE1hdHJpeDoge206IG1ldGhvZHMuWE1MM0RHcmFwaFR5cGVHZXRXb3JsZE1hdHJpeH0sXHJcbiAgICBvbmxvYWQ6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25wcm9ncmVzczoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBjb21wbGV0ZToge3A6IHByb3BlcnRpZXMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUNvbXBsZXRlfSxcclxuICAgIHByb2dyZXNzTGV2ZWw6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVQcm9ncmVzc0xldmVsfSxcclxuICAgIGNvbXB1dGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dE5hbWVzfSxcclxuICAgIGdldE91dHB1dENoYW5uZWxJbmZvOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dENoYW5uZWxJbmZvfSxcclxuICAgIGdldENvbXB1dGVJbmZvOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldENvbXB1dGVJbmZvfSxcclxuICAgIGdldFByb3RvSW5mbzoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRQcm90b0luZm99LFxyXG4gICAgaXNPdXRwdXRDb25uZWN0ZWQ6IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlSXNPdXRwdXRDb25uZWN0ZWR9LFxyXG4gICAgZ2V0UmVzdWx0OiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldFJlc3VsdH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG1vZGVsOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8bGlnaHRzaGFkZXI+XHJcbiAqIC8vIFRPRE8oa3NvbnMpOiBSZW1vdmUgaW4gWE1MM0QgNS4xXHJcbiAqKi9cclxuY2xhc3NJbmZvWydsaWdodHNoYWRlciddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgb25sb2FkOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ucHJvZ3Jlc3M6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgY29tcGxldGU6IHtwOiBwcm9wZXJ0aWVzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVDb21wbGV0ZX0sXHJcbiAgICBwcm9ncmVzc0xldmVsOiB7cDogcHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlUHJvZ3Jlc3NMZXZlbH0sXHJcbiAgICBjb21wdXRlOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBnZXRPdXRwdXROYW1lczoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRPdXRwdXROYW1lc30sXHJcbiAgICBnZXRPdXRwdXRDaGFubmVsSW5mbzoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRDb21wdXRlSW5mbzoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRDb21wdXRlSW5mb30sXHJcbiAgICBnZXRQcm90b0luZm86IHttOiBtZXRob2RzLlhNTDNEU2hhZGVyUHJvdmlkZXJUeXBlR2V0UHJvdG9JbmZvfSxcclxuICAgIGlzT3V0cHV0Q29ubmVjdGVkOiB7bTogbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUlzT3V0cHV0Q29ubmVjdGVkfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRSZXN1bHR9LFxyXG4gICAgc2NyaXB0OiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxzY3JpcHQ+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydzY3JpcHQnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuU3RyaW5nVmFsdWVIYW5kbGVyfSxcclxuICAgIHNyYzoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgdHlwZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGFzc2V0bWVzaD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2Fzc2V0bWVzaCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgbWF0Y2g6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHR5cGU6IHthOiBoYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB7dmFsdWVzOiBNZXNoVHlwZXMsIGRlZmF1bHRWYWx1ZTogMH19LFxyXG4gICAgY29tcHV0ZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgZmlsdGVyOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBpbmNsdWRlczoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgbWF0ZXJpYWw6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHRyYW5zZm9ybToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGxhdGZvcm06IHthOiBoYW5kbGVycy5FbnVtQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiB7dmFsdWVzOiBQbGF0Zm9ybVR5cGVzLCBkZWZhdWx0VmFsdWU6IDF9fSxcclxuICAgIGdldE91dHB1dE5hbWVzOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0TmFtZXN9LFxyXG4gICAgZ2V0T3V0cHV0Q2hhbm5lbEluZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mb30sXHJcbiAgICBnZXRDb21wdXRlSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldENvbXB1dGVJbmZvfSxcclxuICAgIGdldFByb3RvSW5mbzoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFByb3RvSW5mb30sXHJcbiAgICBpc091dHB1dENvbm5lY3RlZDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUlzT3V0cHV0Q29ubmVjdGVkfSxcclxuICAgIGdldFJlc3VsdDoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldFJlc3VsdH0sXHJcbiAgICBzcmM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxhc3NldGRhdGE+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydhc3NldGRhdGEnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGNvbXB1dGU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIGZpbHRlcjoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgaW5jbHVkZXM6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBsYXRmb3JtOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge3ZhbHVlczogUGxhdGZvcm1UeXBlcywgZGVmYXVsdFZhbHVlOiAxfX0sXHJcbiAgICBnZXRPdXRwdXROYW1lczoge206IG1ldGhvZHMuWE1MM0ROZXN0ZWREYXRhQ29udGFpbmVyVHlwZUdldE91dHB1dE5hbWVzfSxcclxuICAgIGdldE91dHB1dENoYW5uZWxJbmZvOiB7bTogbWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0Q2hhbm5lbEluZm99LFxyXG4gICAgZ2V0Q29tcHV0ZUluZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRDb21wdXRlSW5mb30sXHJcbiAgICBnZXRQcm90b0luZm86IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRQcm90b0luZm99LFxyXG4gICAgaXNPdXRwdXRDb25uZWN0ZWQ6IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVJc091dHB1dENvbm5lY3RlZH0sXHJcbiAgICBnZXRSZXN1bHQ6IHttOiBtZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRSZXN1bHR9LFxyXG4gICAgc3JjOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8ZmxvYXQ+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydmbG9hdCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuRmxvYXRBcnJheVZhbHVlSGFuZGxlcn0sXHJcbiAgICBzZXRTY3JpcHRWYWx1ZToge206IG1ldGhvZHMuWE1MM0REYXRhU291cmNlVHlwZVNldFNjcmlwdFZhbHVlfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxmbG9hdDI+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydmbG9hdDInXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBhcmFtOiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogZmFsc2V9LFxyXG4gICAga2V5OiB7YTogaGFuZGxlcnMuRmxvYXRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDAuMH0sXHJcbiAgICB2YWx1ZToge2E6IGhhbmRsZXJzLkZsb2F0MkFycmF5VmFsdWVIYW5kbGVyfSxcclxuICAgIHNldFNjcmlwdFZhbHVlOiB7bTogbWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWV9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGZsb2F0Mz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2Zsb2F0MyddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuRmxvYXQzQXJyYXlWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8ZmxvYXQ0PlxyXG4gKiovXHJcbmNsYXNzSW5mb1snZmxvYXQ0J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5GbG9hdDRBcnJheVZhbHVlSGFuZGxlcn0sXHJcbiAgICBzZXRTY3JpcHRWYWx1ZToge206IG1ldGhvZHMuWE1MM0REYXRhU291cmNlVHlwZVNldFNjcmlwdFZhbHVlfVxyXG4gICAgfTtcclxuLyoqXHJcbiAqIFByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZm9yIDxmbG9hdDR4ND5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2Zsb2F0NHg0J10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5GbG9hdDR4NEFycmF5VmFsdWVIYW5kbGVyfSxcclxuICAgIHNldFNjcmlwdFZhbHVlOiB7bTogbWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWV9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGludD5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2ludCddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgbmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgcGFyYW06IHthOiBoYW5kbGVycy5Cb29sQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBmYWxzZX0sXHJcbiAgICBrZXk6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC4wfSxcclxuICAgIHZhbHVlOiB7YTogaGFuZGxlcnMuSW50QXJyYXlWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8aW50ND5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2ludDQnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBhcmFtOiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogZmFsc2V9LFxyXG4gICAga2V5OiB7YTogaGFuZGxlcnMuRmxvYXRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDAuMH0sXHJcbiAgICB2YWx1ZToge2E6IGhhbmRsZXJzLkludEFycmF5VmFsdWVIYW5kbGVyfSxcclxuICAgIHNldFNjcmlwdFZhbHVlOiB7bTogbWV0aG9kcy5YTUwzRERhdGFTb3VyY2VUeXBlU2V0U2NyaXB0VmFsdWV9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGJvb2w+XHJcbiAqKi9cclxuY2xhc3NJbmZvWydib29sJ10gPSB7XHJcbiAgICBpZDoge2E6IGhhbmRsZXJzLklESGFuZGxlcn0sXHJcbiAgICBjbGFzc05hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyLCBpZDogJ2NsYXNzJ30sXHJcbiAgICBuYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBwYXJhbToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIGtleToge2E6IGhhbmRsZXJzLkZsb2F0QXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiAwLjB9LFxyXG4gICAgdmFsdWU6IHthOiBoYW5kbGVycy5Cb29sQXJyYXlWYWx1ZUhhbmRsZXJ9LFxyXG4gICAgc2V0U2NyaXB0VmFsdWU6IHttOiBtZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZX1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8dGV4dHVyZT5cclxuICoqL1xyXG5jbGFzc0luZm9bJ3RleHR1cmUnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG5hbWU6IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBhcmFtOiB7YTogaGFuZGxlcnMuQm9vbEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogZmFsc2V9LFxyXG4gICAga2V5OiB7YTogaGFuZGxlcnMuRmxvYXRBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IDAuMH0sXHJcbiAgICB0eXBlOiB7YTogaGFuZGxlcnMuRW51bUF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczoge3ZhbHVlczogVGV4dHVyZVR5cGVzLCBkZWZhdWx0VmFsdWU6IDB9fSxcclxuICAgIGZpbHRlcjoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgd3JhcDoge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgYW5pc290cm9weToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXJ9XHJcbiAgICB9O1xyXG4vKipcclxuICogUHJvcGVydGllcyBhbmQgbWV0aG9kcyBmb3IgPGltZz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ2ltZyddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgc3JjOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8dmlkZW8+XHJcbiAqKi9cclxuY2xhc3NJbmZvWyd2aWRlbyddID0ge1xyXG4gICAgaWQ6IHthOiBoYW5kbGVycy5JREhhbmRsZXJ9LFxyXG4gICAgY2xhc3NOYW1lOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlciwgaWQ6ICdjbGFzcyd9LFxyXG4gICAgc3JjOiB7YTogaGFuZGxlcnMuU3RyaW5nQXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBhdXRvcGxheToge2E6IGhhbmRsZXJzLkJvb2xBdHRyaWJ1dGVIYW5kbGVyLCBwYXJhbXM6IGZhbHNlfSxcclxuICAgIHBsYXk6IHttOiBtZXRob2RzLnZpZGVvUGxheX0sXHJcbiAgICBwYXVzZToge206IG1ldGhvZHMudmlkZW9QYXVzZX1cclxuICAgIH07XHJcbi8qKlxyXG4gKiBQcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZvciA8dmlldz5cclxuICoqL1xyXG5jbGFzc0luZm9bJ3ZpZXcnXSA9IHtcclxuICAgIGlkOiB7YTogaGFuZGxlcnMuSURIYW5kbGVyfSxcclxuICAgIGNsYXNzTmFtZToge2E6IGhhbmRsZXJzLlN0cmluZ0F0dHJpYnV0ZUhhbmRsZXIsIGlkOiAnY2xhc3MnfSxcclxuICAgIG9uY2xpY2s6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25kYmxjbGljazoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNlZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbm1vdXNldXA6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW92ZXI6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW1vdmU6IHthOiBoYW5kbGVycy5FdmVudEF0dHJpYnV0ZUhhbmRsZXJ9LFxyXG4gICAgb25tb3VzZW91dDoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXByZXNzOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIG9ua2V5ZG93bjoge2E6IGhhbmRsZXJzLkV2ZW50QXR0cmlidXRlSGFuZGxlcn0sXHJcbiAgICBvbmtleXVwOiB7YTogaGFuZGxlcnMuRXZlbnRBdHRyaWJ1dGVIYW5kbGVyfSxcclxuICAgIHBvc2l0aW9uOiB7YTogaGFuZGxlcnMuVmVjM0F0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogWzAsIDAsIDBdfSxcclxuICAgIG9yaWVudGF0aW9uOiB7YTogaGFuZGxlcnMuQXhpc0FuZ2xlQXR0cmlidXRlSGFuZGxlciwgcGFyYW1zOiBbMCwgMCwgMSwgMF19LFxyXG4gICAgZmllbGRPZlZpZXc6IHthOiBoYW5kbGVycy5GbG9hdEF0dHJpYnV0ZUhhbmRsZXIsIHBhcmFtczogMC43ODUzOTh9LFxyXG4gICAgZ2V0V29ybGRNYXRyaXg6IHttOiBtZXRob2RzLlhNTDNER3JhcGhUeXBlR2V0V29ybGRNYXRyaXh9LFxyXG4gICAgc2V0RGlyZWN0aW9uOiB7bTogbWV0aG9kcy52aWV3U2V0RGlyZWN0aW9ufSxcclxuICAgIHNldFVwVmVjdG9yOiB7bTogbWV0aG9kcy52aWV3U2V0VXBWZWN0b3J9LFxyXG4gICAgbG9va0F0OiB7bTogbWV0aG9kcy52aWV3TG9va0F0fSxcclxuICAgIGdldERpcmVjdGlvbjoge206IG1ldGhvZHMudmlld0dldERpcmVjdGlvbn0sXHJcbiAgICBnZXRVcFZlY3Rvcjoge206IG1ldGhvZHMudmlld0dldFVwVmVjdG9yfSxcclxuICAgIGdldFZpZXdNYXRyaXg6IHttOiBtZXRob2RzLnZpZXdHZXRWaWV3TWF0cml4fSxcclxuICAgIHByb2plY3Rpb246IHthOiBoYW5kbGVycy5TdHJpbmdBdHRyaWJ1dGVIYW5kbGVyfVxyXG4gICAgfTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG4gICAgY2xhc3NJbmZvIDogY2xhc3NJbmZvLFxyXG4gICAgTWVzaFR5cGVzIDogTWVzaFR5cGVzLFxyXG4gICAgVGV4dHVyZVR5cGVzIDogVGV4dHVyZVR5cGVzLFxyXG4gICAgUGxhdGZvcm1UeXBlcyA6IFBsYXRmb3JtVHlwZXMsXHJcbiAgICBEYXRhRmllbGRUeXBlcyA6IERhdGFGaWVsZFR5cGUsXHJcbiAgICBEYXRhQ2hhbm5lbE9yaWdpbiA6IERhdGFDaGFubmVsT3JpZ2luXHJcbn07XHJcbiIsInZhciBjb25maWcgPSByZXF1aXJlKFwiLi9lbGVtZW50cy5qc1wiKS5jb25maWc7XG52YXIgY2xhc3NJbmZvID0gcmVxdWlyZShcIi4vY29uZmlndXJhdGlvbi5qc1wiKS5jbGFzc0luZm87XG5cbnZhciBkb2MgPSB7fTtcbnZhciBuYXRpdmVHZXRFbGVtZW50QnlJZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkO1xuZG9jLmdldEVsZW1lbnRCeUlkID0gZnVuY3Rpb24oaWQpIHtcbiAgICB2YXIgZWxlbSA9IG5hdGl2ZUdldEVsZW1lbnRCeUlkLmNhbGwodGhpcywgaWQpO1xuICAgIGlmIChlbGVtKSB7XG4gICAgICAgIHJldHVybiBlbGVtO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBlbGVtcyA9IHRoaXMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBlbGVtc1tpXTtcbiAgICAgICAgICAgIGlmIChub2RlLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcbnZhciBuYXRpdmVDcmVhdGVFbGVtZW50TlMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlM7XG5kb2MuY3JlYXRlRWxlbWVudE5TID0gZnVuY3Rpb24obnMsIG5hbWUpIHtcbiAgICB2YXIgciA9IG5hdGl2ZUNyZWF0ZUVsZW1lbnROUy5jYWxsKHRoaXMsIG5zLCBuYW1lKTtcbiAgICBpZiAobnMgPT0gWE1MM0QueG1sM2ROUyB8fCBjbGFzc0luZm9bbmFtZS50b0xvd2VyQ2FzZSgpXSkge1xuICAgICAgICBjb25maWcuZWxlbWVudChyKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59O1xudmFyIG5hdGl2ZUNyZWF0ZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50O1xuZG9jLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIHIgPSBuYXRpdmVDcmVhdGVFbGVtZW50LmNhbGwodGhpcywgbmFtZSk7XG4gICAgaWYgKGNsYXNzSW5mb1tuYW1lLnRvTG93ZXJDYXNlKCldICkge1xuICAgICAgICBjb25maWcuZWxlbWVudChyKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG59O1xuXG5YTUwzRC5leHRlbmQod2luZG93LmRvY3VtZW50LCBkb2MpO1xuIiwidmFyIGV2ZW50cyA9IHJlcXVpcmUoXCIuL25vdGlmaWNhdGlvbi5qc1wiKTtcbnZhciBDbGFzc0luZm8gPSByZXF1aXJlKFwiLi9jb25maWd1cmF0aW9uLmpzXCIpLmNsYXNzSW5mbztcbnZhciBSZXNvdXJjZSA9IHJlcXVpcmUoXCIuLi9iYXNlL3Jlc291cmNlbWFuYWdlci5qc1wiKS5SZXNvdXJjZTtcblxudmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSAod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93Lk1vek11dGF0aW9uT2JzZXJ2ZXIpLFxuICAgIG11dE9ic2VydmVyO1xuXG5pZihNdXRhdGlvbk9ic2VydmVyKXtcbiAgICBtdXRPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGhhbmRsZU11dGF0aW9ucyk7XG59IGVsc2Uge1xuICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiWE1MM0QgcmVxdWlyZXMgTXV0YXRpb25PYnNlcnZlcnMsIHdoaWNoIHlvdXIgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0LiBQbGVhc2UgY29uc2lkZXIgdXBncmFkaW5nIHRvIGEgbmV3ZXIgdmVyc2lvbi5cIik7XG4gICAgbXV0T2JzZXJ2ZXIgPSB7XG4gICAgICAgIHRha2VSZWNvcmRzOmZ1bmN0aW9uKCl7cmV0dXJuIFtdfSxcbiAgICAgICAgb2JzZXJ2ZTogZnVuY3Rpb24oYSxiKSB7fVxuICAgIH1cbn1cblxuWE1MM0QuZmx1c2hET01DaGFuZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcmVjb3JkcyA9IG11dE9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgcmVjb3Jkcy5sZW5ndGggJiYgaGFuZGxlTXV0YXRpb25zKHJlY29yZHMpO1xufTtcblxuZnVuY3Rpb24gaGFuZGxlTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyArK2kpe1xuICAgICAgICB2YXIgbXV0YXRpb25SZWNvcmQgPSBtdXRhdGlvbnNbaV07XG4gICAgICAgIGlmIChtdXRhdGlvblJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZUNoYW5nZWQobXV0YXRpb25SZWNvcmQpO1xuICAgICAgICB9IGVsc2UgaWYgKG11dGF0aW9uUmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICBoYW5kbGVDaGlsZExpc3RDaGFuZ2VkKG11dGF0aW9uUmVjb3JkKTtcbiAgICAgICAgfSBlbHNlIGlmKG11dGF0aW9uUmVjb3JkLnR5cGUgPT0gJ2NoYXJhY3RlckRhdGEnKXtcbiAgICAgICAgICAgIGhhbmRsZUNoYXJhY3RlckRhdGFDaGFuZ2VkKG11dGF0aW9uUmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2hhcmFjdGVyRGF0YUNoYW5nZWQobXV0YXRpb24pIHtcbiAgICB2YXIgdGFyZ2V0ID0gbXV0YXRpb24udGFyZ2V0O1xuICAgIHdoaWxlKCF0YXJnZXQuX2NvbmZpZ3VyZWQgJiYgdGFyZ2V0LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICAgIHZhciBlbGVtZW50SGFuZGxlciA9IHRhcmdldC5fY29uZmlndXJlZDtcbiAgICBpZiAoIWVsZW1lbnRIYW5kbGVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG4gPSBuZXcgZXZlbnRzLk5vdGlmaWNhdGlvbldyYXBwZXIobXV0YXRpb24sIGV2ZW50cy5WQUxVRV9NT0RJRklFRCwgdGFyZ2V0KTtcbiAgICBpZiAoZWxlbWVudEhhbmRsZXIuaGFuZGxlcnMudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlbGVtZW50SGFuZGxlci5oYW5kbGVycy52YWx1ZS5yZXNldFZhbHVlKGVsZW1lbnRIYW5kbGVyLnN0b3JhZ2UpO1xuICAgIH1cbiAgICBlbGVtZW50SGFuZGxlci5ub3RpZnkobik7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNoaWxkTGlzdENoYW5nZWQobXV0YXRpb24pIHtcbiAgICB2YXIgYWRkZWROb2RlcyA9IG11dGF0aW9uLmFkZGVkTm9kZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhZGRlZE5vZGVzW2ldLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSl7XG4gICAgICAgICAgICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gdGhlIHZhbHVlIG9mIGVnLiBhIGZsb2F0MyBlbGVtZW50LCB3ZSBzaG91bGQgdHJlYXQgaXQgYXMgYSBjaGFyYWN0ZXJEYXRhQ2hhbmdlZCBldmVudFxuICAgICAgICAgICAgaGFuZGxlQ2hhcmFjdGVyRGF0YUNoYW5nZWQobXV0YXRpb24pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlTm9kZUluc2VydGVkKGFkZGVkTm9kZXNbaV0sIG11dGF0aW9uKTtcbiAgICB9XG5cbiAgICB2YXIgcmVtb3ZlZE5vZGVzID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzO1xuICAgIGZvciAodmFyIGk9MDsgaSA8IHJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocmVtb3ZlZE5vZGVzW2ldLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSl7XG4gICAgICAgICAgICBjb250aW51ZTsgLy8gY2hhcmFjdGVyRGF0YUNoYW5nZWQgZXZlbnRzIHdlcmUgYWxyZWFkeSBoYW5kbGVkIGluIGFkZGVkTm9kZXNcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVOb2RlUmVtb3ZlZChyZW1vdmVkTm9kZXNbaV0sIG11dGF0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU5vZGVJbnNlcnRlZChub2RlLCBtdXRhdGlvbikge1xuICAgIHZhciB0YXJnZXRIYW5kbGVyID0gbXV0YXRpb24udGFyZ2V0Ll9jb25maWd1cmVkO1xuICAgIGlmICghdGFyZ2V0SGFuZGxlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbmZpZy5lbGVtZW50KG5vZGUpO1xuICAgIGFkZFJlY3Vyc2l2ZShub2RlKTtcbiAgICB2YXIgbiA9IG5ldyBldmVudHMuTm90aWZpY2F0aW9uV3JhcHBlcihtdXRhdGlvbiwgZXZlbnRzLk5PREVfSU5TRVJURUQsIG5vZGUpO1xuICAgIHRhcmdldEhhbmRsZXIubm90aWZ5KG4pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOb2RlUmVtb3ZlZChub2RlLCBtdXRhdGlvbikge1xuICAgIHZhciB0YXJnZXRIYW5kbGVyID0gbXV0YXRpb24udGFyZ2V0Ll9jb25maWd1cmVkO1xuICAgIGlmICghdGFyZ2V0SGFuZGxlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuID0gbmV3IGV2ZW50cy5Ob3RpZmljYXRpb25XcmFwcGVyKG11dGF0aW9uLCBldmVudHMuTk9ERV9SRU1PVkVELCBub2RlKTtcbiAgICB0YXJnZXRIYW5kbGVyLm5vdGlmeShuKTtcbiAgICBpZihub2RlLl9jb25maWd1cmVkKSB7XG4gICAgICAgIG4udHlwZSA9IGV2ZW50cy5USElTX1JFTU9WRUQ7XG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZShub2RlLCBuKTtcbiAgICAgICAgbm90aWZ5Tm9kZUlkQ2hhbmdlUmVjdXJzaXZlKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpe1xuICAgICAgICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gdGhlIHZhbHVlIG9mIGVnLiBhIGZsb2F0MyBlbGVtZW50LCB3ZSBzaG91bGQgYWxzbyB0cmVhdCBpdCBhcyBhIGNoYXJhY3RlckRhdGFDaGFuZ2VkIGV2ZW50XG4gICAgICAgIGhhbmRsZUNoYXJhY3RlckRhdGFDaGFuZ2VkKG11dGF0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vdGlmeU5vZGVJZENoYW5nZVJlY3Vyc2l2ZShlbGVtZW50KXtcbiAgICBSZXNvdXJjZS5ub3RpZnlOb2RlSWRDaGFuZ2UoZWxlbWVudCwgZWxlbWVudC5pZCwgbnVsbCk7XG4gICAgdmFyIG4gPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgIHdoaWxlKG4pIHtcbiAgICAgICAgbm90aWZ5Tm9kZUlkQ2hhbmdlUmVjdXJzaXZlKG4pO1xuICAgICAgICBuID0gbi5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVSZWN1cnNpdmUoZWxlbWVudCwgZXZ0KSB7XG4gICAgaWYoZWxlbWVudC5fY29uZmlndXJlZCkge1xuICAgICAgICBlbGVtZW50Ll9jb25maWd1cmVkLm5vdGlmeShldnQpO1xuICAgICAgICBlbGVtZW50Ll9jb25maWd1cmVkLnJlbW92ZShldnQpO1xuICAgIH1cbiAgICB2YXIgY2hpbGQgPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgIHdoaWxlKGNoaWxkKSB7XG4gICAgICAgIHJlbW92ZVJlY3Vyc2l2ZShjaGlsZCwgZXZ0KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhZGRSZWN1cnNpdmUoZWxlbWVudCl7XG4gICAgdmFyIG4gPSBlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkO1xuICAgIHdoaWxlKG4pIHtcbiAgICAgICAgYWRkUmVjdXJzaXZlKG4pO1xuICAgICAgICBuID0gbi5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgfVxuICAgIC8vIFdlIGNhbGwgdGhpcyBoZXJlIGluIGFkZGl0aW9uIHRvIG5vZGVJbnNlcnRlZEludG9Eb2N1bWVudCwgc2luY2UgdGhlIGxhdGVyIGlzIG5vdCBzdXBwb3J0ZWQgYnkgRmlyZWZveFxuICAgIFJlc291cmNlLm5vdGlmeU5vZGVJZENoYW5nZShlbGVtZW50LCBudWxsLCBlbGVtZW50LmlkKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtNdXRhdGlvblJlY29yZH0gbXV0YXRpb25cbiAqL1xuZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlQ2hhbmdlZChtdXRhdGlvbikge1xuICAgIHZhciB0YXJnZXQgPSBtdXRhdGlvbi50YXJnZXQ7XG4gICAgdmFyIGVsZW1lbnRIYW5kbGVyID0gdGFyZ2V0Ll9jb25maWd1cmVkO1xuICAgIGlmICghZWxlbWVudEhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhdHRyaWJ1dGVIYW5kbGVyID0gZWxlbWVudEhhbmRsZXIuaGFuZGxlcnNbbXV0YXRpb24uYXR0cmlidXRlTmFtZV0gfHwgZWxlbWVudEhhbmRsZXIuaGFuZGxlcnNbbXV0YXRpb24uYXR0cmlidXRlTmFtZS50b0xvd2VyQ2FzZSgpXTtcbiAgICBpZiAoYXR0cmlidXRlSGFuZGxlciAmJiBhdHRyaWJ1dGVIYW5kbGVyLnNldEZyb21BdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgdmFyIG5vdGlmaWVkID0gYXR0cmlidXRlSGFuZGxlci5zZXRGcm9tQXR0cmlidXRlKG5ld1ZhbHVlLCBtdXRhdGlvbi5vbGRWYWx1ZSwgdGFyZ2V0LCBlbGVtZW50SGFuZGxlci5zdG9yYWdlKTtcbiAgICAgICAgWE1MM0QuZGVidWcuYXNzZXJ0KCFub3RpZmllZCwgXCJXZSBhc3N1bWUgbm8gYXR0cmlidXRlIGhhbmRsZXIgbm90aWZpZXMgYWRhcHRlcnMgYW55bW9yZS5cIik7XG4gICAgfVxuICAgIGVsZW1lbnRIYW5kbGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhtdXRhdGlvbik7XG59XG5cblxudmFyIEVsZW1lbnRIYW5kbGVyID0gZnVuY3Rpb24oZWxlbSkge1xuICAgIGlmICghZWxlbSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudCA9IGVsZW07XG4gICAgdGhpcy5oYW5kbGVycyA9IG51bGw7XG4gICAgdGhpcy5zdG9yYWdlID0ge307XG4gICAgdGhpcy5hZGFwdGVycyA9IHt9O1xuICAgIG11dE9ic2VydmVyLm9ic2VydmUoZWxlbSwgeyBjaGlsZExpc3Q6IHRydWUsICBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZX0gKTtcblxufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyQXR0cmlidXRlcyA9IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBlbGVtID0gdGhpcy5lbGVtZW50O1xuXG4gICAgdmFyIGlzSFRNTCA9IChlbGVtIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpO1xuICAgIHZhciBrZXlQcmVmaXggPSAoaXNIVE1MID8gXCJfaHRtbFwiIDogXCJfeG1sXCIpO1xuICAgIHZhciBoYW5kbGVyS2V5ID0ga2V5UHJlZml4ICsgXCJoYW5kbGVyc1wiLFxuICAgICAgICBwcm90b0tleSA9IGtleVByZWZpeCArIFwicHJvdG9cIjtcblxuICAgIHZhciBjYW5Qcm90byA9ICEhZWxlbS5fX3Byb3RvX187XG5cbiAgICBpZighY29uZmlnLl9jYWNoZSkgY29uZmlnLl9jYWNoZSA9IHt9O1xuXG4gICAgaWYoIWNvbmZpZy5fY2FjaGVbaGFuZGxlcktleV0pe1xuICAgICAgICAvLyBDcmVhdGUgaGFuZGxlcnMgYW5kIHByb3RvdHlwZSBvbmx5IG9uY2UgcGVyIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgdmFyIHByb3RvO1xuICAgICAgICBpZihjYW5Qcm90byl7XG4gICAgICAgICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBGLnByb3RvdHlwZSA9IGVsZW0uX19wcm90b19fO1xuICAgICAgICAgICAgcHJvdG8gPSBuZXcgRigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhhbmRsZXJzID0ge307XG4gICAgICAgIGZvciAoIHZhciBwcm9wIGluIGNvbmZpZykge1xuICAgICAgICAgICAgaWYocHJvcCA9PVwiX2NhY2hlXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGNvbmZpZ1twcm9wXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYocHJvdG8pIGRlbGV0ZSBwcm90b1twcm9wXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbmZpZ1twcm9wXS5hICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gY29uZmlnW3Byb3BdLmlkIHx8IHByb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gbmV3IGNvbmZpZ1twcm9wXS5hKGF0dHJOYW1lLCBjb25maWdbcHJvcF0ucGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbYXR0ck5hbWUudG9Mb3dlckNhc2UoKV0gPSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICBpZihwcm90bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIHByb3AsIGhhbmRsZXIuZGVzYyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkNhbid0IGNvbmZpZ3VyZSBcIiArIGVsZW0ubm9kZU5hbWUgKyBcIjo6XCIgKyBwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjb25maWdbcHJvcF0ubSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHByb3RvKSBwcm90b1twcm9wXSA9IGNvbmZpZ1twcm9wXS5tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnW3Byb3BdLnAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZihwcm90byl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgcHJvcCwgY29uZmlnW3Byb3BdLnApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJDYW4ndCBjb25maWd1cmUgXCIgKyBlbGVtLm5vZGVOYW1lICsgXCI6OlwiICsgcHJvcCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ZWxzZVxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkNhbid0IGNvbmZpZ3VyZSBcIiArIGVsZW0ubm9kZU5hbWUgKyBcIjo6XCIgKyBwcm9wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25maWcuX2NhY2hlW2hhbmRsZXJLZXldID0gaGFuZGxlcnM7XG4gICAgICAgIGNvbmZpZy5fY2FjaGVbcHJvdG9LZXldID0gcHJvdG87XG4gICAgfVxuICAgIC8vIFNldCBhbmQgaW5pdGlhbGl6ZSBoYW5kbGVycyBmb3IgZWxlbWVudFxuICAgIHRoaXMuaGFuZGxlcnMgPSBjb25maWcuX2NhY2hlW2hhbmRsZXJLZXldO1xuICAgIGlmKGNhblByb3RvKXtcbiAgICAgICAgZWxlbS5fX3Byb3RvX18gPSBjb25maWcuX2NhY2hlW3Byb3RvS2V5XTtcbiAgICAgICAgZm9yICggdmFyIHByb3AgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZihwcm9wID09XCJfY2FjaGVcIikgY29udGludWU7XG4gICAgICAgICAgICBpZihjb25maWdbcHJvcF0gJiYgY29uZmlnW3Byb3BdLmEgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gY29uZmlnW3Byb3BdLmlkIHx8IHByb3A7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzW2F0dHJOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuaW5pdCAmJiBoYW5kbGVyLmluaXQoZWxlbSwgdGhpcy5zdG9yYWdlKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZWxlbVtwcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBmb3IgKCB2YXIgcHJvcCBpbiBjb25maWcpIHtcbiAgICAgICAgICAgIGlmKHByb3AgPT1cIl9jYWNoZVwiKSBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjb25maWdbcHJvcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBlbGVtW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29uZmlnW3Byb3BdLmEgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gY29uZmlnW3Byb3BdLmlkIHx8IHByb3A7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLmhhbmRsZXJzW2F0dHJOYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICAgICAgICAgIGhhbmRsZXIuaW5pdCAmJiBoYW5kbGVyLmluaXQoZWxlbSwgdGhpcy5zdG9yYWdlKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbSwgcHJvcCwgaGFuZGxlci5kZXNjKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJDYW4ndCBjb25maWd1cmUgXCIgKyBlbGVtLm5vZGVOYW1lICsgXCI6OlwiICsgcHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2UgaWYgKGNvbmZpZ1twcm9wXS5tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBlbGVtW3Byb3BdID0gY29uZmlnW3Byb3BdLm07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpZ1twcm9wXS5wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbSwgcHJvcCwgY29uZmlnW3Byb3BdLnApO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkNhbid0IGNvbmZpZ3VyZSBcIiArIGVsZW0ubm9kZU5hbWUgKyBcIjo6XCIgKyBwcm9wKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbTtcbn07XG5cblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlZ2lzdGVyTWl4ZWQgPSBmdW5jdGlvbigpIHtcbiAgICBtdXRPYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCwgeyBjaGlsZExpc3Q6IHRydWUsICBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSwgY2hhcmFjdGVyRGF0YTogdHJ1ZSwgc3VidHJlZTogdHJ1ZX0gKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIGV2dFxuICovXG5FbGVtZW50SGFuZGxlci5wcm90b3R5cGUubm90aWZ5ID0gIGZ1bmN0aW9uKGV2dCkge1xuICAgIHZhciBhZGFwdGVycyA9IHRoaXMuYWRhcHRlcnM7XG4gICAgZm9yKHZhciBhIGluIGFkYXB0ZXJzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhZGFwdGVyc1thXS5ub3RpZnlDaGFuZ2VkKGV2dCk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0V4Y2VwdGlvbihlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtNdXRhdGlvblJlY29yZH0gbXV0YXRpb25cbiAqL1xuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9ICBmdW5jdGlvbihtdXRhdGlvbikge1xuICAgIHZhciBhZGFwdGVycyA9IHRoaXMuYWRhcHRlcnM7XG4gICAgZm9yKHZhciBhIGluIGFkYXB0ZXJzKSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmFzc2VydChhZGFwdGVyc1thXS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2ssIFwiQWRhcHRlciBpbXBsZW1lbnRzICdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snOiBcIiArIHRoaXMuZWxlbWVudC5ub2RlTmFtZSArIFwiIChcIiArIGEgKyBcIilcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhZGFwdGVyc1thXS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobXV0YXRpb24uYXR0cmlidXRlTmFtZSwgbXV0YXRpb24ub2xkVmFsdWUsIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUobXV0YXRpb24uYXR0cmlidXRlTmFtZSksIG11dGF0aW9uLmF0dHJpYnV0ZU5hbWVzcGFjZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0V4Y2VwdGlvbihlKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qXG4gKiBHZXQgY2FsbGVkLCBpZiB0aGUgcmVsYXRlZCBub2RlIGdldHMgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAqL1xuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgIGZvcih2YXIgaCBpbiB0aGlzLmFkYXB0ZXJzKSB7XG4gICAgICAgIHZhciBhZGFwdGVyID0gdGhpcy5hZGFwdGVyc1toXTtcbiAgICAgICAgaWYoYWRhcHRlci5vbkRpc3Bvc2UpXG4gICAgICAgICAgICBhZGFwdGVyLm9uRGlzcG9zZSgpO1xuICAgICAgICBpZihhZGFwdGVyLmNsZWFyQWRhcHRlckhhbmRsZXMpXG4gICAgICAgICAgICBhZGFwdGVyLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcbiAgICB9XG4gICAgdGhpcy5hZGFwdGVycyA9IHt9O1xuICAgIGZvcih2YXIgaCBpbiB0aGlzLmhhbmRsZXJzKSB7XG4gICAgICAgIHZhciBoYW5kbGVyID0gdGhpcy5oYW5kbGVyc1toXTtcbiAgICAgICAgaWYoaGFuZGxlci5yZW1vdmUpXG4gICAgICAgICAgICBoYW5kbGVyLnJlbW92ZSgpO1xuICAgIH1cblxufTtcblxuRWxlbWVudEhhbmRsZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiRWxlbWVudEhhbmRsZXIgKFwiK3RoaXMuZWxlbWVudC5ub2RlTmFtZSArIFwiLCBpZDogXCIrdGhpcy5lbGVtZW50LmlkK1wiKVwiO1xufTtcblxudmFyIGRlbGVnYXRlUHJvcGVydGllcyA9IFtcImNsaWVudEhlaWdodFwiLCBcImNsaWVudExlZnRcIiwgXCJjbGllbnRUb3BcIiwgXCJjbGllbnRXaWR0aFwiLFxuICAgIFwib2Zmc2V0SGVpZ2h0XCIsIFwib2Zmc2V0TGVmdFwiLCBcIm9mZnNldFRvcFwiLCBcIm9mZnNldFdpZHRoXCJdO1xuZnVuY3Rpb24gZGVsZWdhdGVQcm9wKG5hbWUsIGVsZW0sIGNhbnZhcykge1xuICAgIHZhciBkZXNjID0ge1xuICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBjYW52YXNbbmFtZV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtLCBuYW1lLCBkZXNjKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkNhbid0IGNvbmZpZ3VyZSBcIiArIGVsZW0ubm9kZU5hbWUgKyBcIjo6XCIgKyBuYW1lKTtcbiAgICB9XG59XG5cbnZhciBYTUwzREhhbmRsZXIgPSBmdW5jdGlvbihlbGVtKSB7XG4gICAgRWxlbWVudEhhbmRsZXIuY2FsbCh0aGlzLCBlbGVtKTtcbiAgICB2YXIgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgYy53aWR0aCA9IDgwMDtcbiAgICBjLmhlaWdodCA9IDYwMDtcbiAgICB0aGlzLmNhbnZhcyA9IGM7XG5cbiAgICBmb3IodmFyIGkgaW4gZGVsZWdhdGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGRlbGVnYXRlUHJvcChkZWxlZ2F0ZVByb3BlcnRpZXNbaV0sIGVsZW0sIGMpO1xuICAgIH1cblxuICAgIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH07XG59O1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhYTUwzREhhbmRsZXIsIEVsZW1lbnRIYW5kbGVyKTtcblxuXG52YXIgY29uZmlnID0ge307XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmNvbmZpZy5lbGVtZW50ID0gZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50Ll9jb25maWd1cmVkID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHZhciBjbGFzc0luZm8gPSBDbGFzc0luZm9bZWxlbWVudC5sb2NhbE5hbWVdO1xuICAgICAgICBpZiAoY2xhc3NJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0luZm8oXCJVbnJlY29nbmlzZWQgZWxlbWVudCBcIiArIGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuX2NvbmZpZ3VyZWQgPSBlbGVtZW50LmxvY2FsTmFtZSA9PSBcInhtbDNkXCIgP1xuICAgICAgICAgICAgICAgIG5ldyBYTUwzREhhbmRsZXIoZWxlbWVudClcbiAgICAgICAgICAgICAgICA6IG5ldyBFbGVtZW50SGFuZGxlcihlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnQuX2NvbmZpZ3VyZWQucmVnaXN0ZXJBdHRyaWJ1dGVzKGNsYXNzSW5mbyk7XG4gICAgICAgICAgICAvLyBGaXggZGlmZmVyZW5jZSBpbiBGaXJlZm94ICh1bmRlZmluZWQpIGFuZCBDaHJvbWUgKG51bGwpXG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3R5bGUgPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnN0eWxlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoKGUpe1xuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggdGhyb3dzIGV4Y2VwdGlvbiBoZXJlLi4uXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuID0gZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcblxuICAgICAgICAgICAgUmVzb3VyY2Uubm90aWZ5Tm9kZUlkQ2hhbmdlKGVsZW1lbnQsIG51bGwsIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiaWRcIikpO1xuXG4gICAgICAgICAgICB3aGlsZShuKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmVsZW1lbnQobik7XG4gICAgICAgICAgICAgICAgbiA9IG4ubmV4dEVsZW1lbnRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuY29uZmlnLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50LmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgIGNvbmZpZy5lbGVtZW50KGVsKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uZmlnLmVsZW1lbnQoZWxlbWVudCk7XG4gICAgfVxufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFbGVtZW50SGFuZGxlciA6IEVsZW1lbnRIYW5kbGVyLFxuICAgIFhNTDNESGFuZGxlciA6IFhNTDNESGFuZGxlcixcbiAgICBjb25maWcgOiBjb25maWdcbn07XG4iLCJ2YXIgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vYmFzZS9yZXNvdXJjZW1hbmFnZXIuanNcIikuUmVzb3VyY2U7XG52YXIgc2VuZEFkYXB0ZXJFdmVudCA9IHJlcXVpcmUoXCIuLi91dGlscy9taXNjLmpzXCIpLnNlbmRBZGFwdGVyRXZlbnQ7XG52YXIgY2FsbEFkYXB0ZXJGdW5jID0gcmVxdWlyZShcIi4uL3V0aWxzL21pc2MuanNcIikuY2FsbEFkYXB0ZXJGdW5jO1xudmFyIFZlYzMgPSByZXF1aXJlKFwiLi4vdHlwZXMvdmVjMy5qc1wiKTtcbnZhciBRdWF0ID0gcmVxdWlyZShcIi4uL3R5cGVzL3F1YXQuanNcIik7XG52YXIgTWF0NCA9IHJlcXVpcmUoXCIuLi90eXBlcy9tYXQ0LmpzXCIpO1xudmFyIEF4aXNBbmdsZSA9IHJlcXVpcmUoXCIuLi90eXBlcy9heGlzYW5nbGUuanNcIik7XG52YXIgdmVjMyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjMztcblxudmFyIG1ldGhvZHMgPSB7fTtcblxubWV0aG9kcy54bWwzZEdldEVsZW1lbnRCeVJheSA9IGZ1bmN0aW9uKHJheSwgaGl0UG9pbnQsIGhpdE5vcm1hbCkge1xuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuICAgIFhNTDNELmZsdXNoQ1NTQ2hhbmdlcygpO1xuICAgIHZhciBhZGFwdGVycyA9IHRoaXMuX2NvbmZpZ3VyZWQuYWRhcHRlcnMgfHwge307XG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xuICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0RWxlbWVudEJ5UmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0RWxlbWVudEJ5UmF5KHJheSwgaGl0UG9pbnQsIGhpdE5vcm1hbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5tZXRob2RzLnZpZXdHZXREaXJlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZGlyID0gVmVjMy5mcm9tVmFsdWVzKDAsMCwtMSk7XG4gICAgdmFyIG9yaWVudGF0aW9uID0gUXVhdC5mcm9tQXhpc0FuZ2xlKHRoaXMub3JpZW50YXRpb24pO1xuICAgIHJldHVybiBkaXIudHJhbnNmb3JtUXVhdChvcmllbnRhdGlvbik7XG59O1xuXG5tZXRob2RzLnZpZXdTZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKHBvcykge1xuICAgIHRoaXMucG9zaXRpb24gPSBwb3M7XG59O1xuXG5tZXRob2RzLnZpZXdTZXREaXJlY3Rpb24gPSBmdW5jdGlvbihkaXJlY3Rpb24pIHtcbiAgICBkaXJlY3Rpb24gPSBkaXJlY3Rpb24ubm9ybWFsaXplKCk7XG4gICAgdmFyIHVwID0gVmVjMy5mcm9tVmFsdWVzKDAsMSwwKTtcbiAgICB2YXIgb3JpZW50YXRpb24gPSBRdWF0LmZyb21BeGlzQW5nbGUodGhpcy5vcmllbnRhdGlvbik7XG4gICAgdXAgPSB1cC50cmFuc2Zvcm1RdWF0KG9yaWVudGF0aW9uKS5ub3JtYWxpemUoKTtcblxuICAgIHZhciBiYXNpc1ggPSBuZXcgVmVjMyhkaXJlY3Rpb24pLmNyb3NzKHVwKTtcbiAgICBpZiAoIWJhc2lzWC5sZW5ndGgoKSkge1xuICAgICAgICBiYXNpc1ggPSBWZWMzLmZyb21WYWx1ZXMoMSwwLDApLnRyYW5zZm9ybVF1YXQob3JpZW50YXRpb24pO1xuICAgIH1cbiAgICB2YXIgYmFzaXNZID0gYmFzaXNYLmNsb25lKCkuY3Jvc3MoZGlyZWN0aW9uKTtcbiAgICB2YXIgYmFzaXNaID0gbmV3IFZlYzMoZGlyZWN0aW9uKS5uZWdhdGUoKTtcblxuICAgIHZhciBxID0gUXVhdC5mcm9tQmFzaXMoYmFzaXNYLCBiYXNpc1ksIGJhc2lzWik7XG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IEF4aXNBbmdsZS5mcm9tUXVhdChxKTtcbn07XG5cbm1ldGhvZHMudmlld1NldFVwVmVjdG9yID0gZnVuY3Rpb24odXApIHtcbiAgICB1cCA9IHVwLm5vcm1hbGl6ZSgpO1xuICAgIHZhciBvcmllbnRhdGlvbiA9IFF1YXQuZnJvbUF4aXNBbmdsZSh0aGlzLm9yaWVudGF0aW9uKTtcbiAgICB2YXIgciA9IFF1YXQuZnJvbVJvdGF0aW9uVG8oWzAsMSwwXSwgdXApO1xuICAgIG9yaWVudGF0aW9uID0gb3JpZW50YXRpb24ubXVsKHIpLm5vcm1hbGl6ZSgpO1xuICAgIHRoaXMub3JpZW50YXRpb24gPSBBeGlzQW5nbGUuZnJvbVF1YXQob3JpZW50YXRpb24pO1xufTtcblxubWV0aG9kcy52aWV3R2V0VXBWZWN0b3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdXAgPSBWZWMzLmZyb21WYWx1ZXMoMCwgMSwgMCk7XG4gICAgdmFyIG9yaWVudGF0aW9uID0gUXVhdC5mcm9tQXhpc0FuZ2xlKHRoaXMub3JpZW50YXRpb24pO1xuICAgIHJldHVybiB1cC50cmFuc2Zvcm1RdWF0KG9yaWVudGF0aW9uKTtcbn07XG5cbm1ldGhvZHMudmlld0xvb2tBdCA9IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgdmFyIGRpciA9IG5ldyBWZWMzKCk7XG4gICAgdmVjMy5zdWIoZGlyLmRhdGEsIHBvaW50LmRhdGEsIHRoaXMucG9zaXRpb24uZGF0YSk7XG4gICAgdGhpcy5zZXREaXJlY3Rpb24oZGlyKTtcbn07XG5cbm1ldGhvZHMudmlld0dldFZpZXdNYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xuICAgIGZvciAoIHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRWaWV3TWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0Vmlld01hdHJpeCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEZhbGxiYWNrIGltcGxlbWVudGF0aW9uXG4gICAgdmFyIHAgPSB0aGlzLnBvc2l0aW9uO1xuICAgIHZhciByID0gUXVhdC5mcm9tQXhpc0FuZ2xlKHRoaXMub3JpZW50YXRpb24pO1xuICAgIHJldHVybiBNYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKHIscCkuaW52ZXJ0KCk7XG59O1xuXG5tZXRob2RzLnhtbDNkR2V0RWxlbWVudEJ5UG9pbnQgPSBmdW5jdGlvbih4LCB5LCBoaXRQb2ludCwgaGl0Tm9ybWFsKSB7XG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgWE1MM0QuZmx1c2hDU1NDaGFuZ2VzKCk7XG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcbiAgICBmb3IgKHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRFbGVtZW50QnlQb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldEVsZW1lbnRCeVBvaW50KHgsIHksIGhpdFBvaW50LCBoaXROb3JtYWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufTtcblxubWV0aG9kcy54bWwzZEdlbmVyYXRlUmF5ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHZhciBhZGFwdGVycyA9IHRoaXMuX2NvbmZpZ3VyZWQuYWRhcHRlcnMgfHwge307XG4gICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xuICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2VuZXJhdGVSYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZW5lcmF0ZVJheSh4LCB5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFhNTDNELlJheSgpO1xufTtcblxubWV0aG9kcy5ncm91cEdldExvY2FsTWF0cml4ID0gZnVuY3Rpb24oKSB7XG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcbiAgICBmb3IgKCB2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xuICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0TG9jYWxNYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXRMb2NhbE1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWF0NCgpO1xufTtcblxuLyoqXG4gKiByZXR1cm4gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgb3duaW5nIHNwYWNlIGluIHdvcmxkIHNwYWNlXG4gKi9cbm1ldGhvZHMuZ2V0V29ybGRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKCkge1xuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuICAgIC8vIFZpc2liaWxpdHkgaW5mbHVlbmNlcyBib3VuZGluZyBib3hcbiAgICBYTUwzRC5mbHVzaENTU0NoYW5nZXMoKTtcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xuICAgIGZvciAodmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcbiAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldFdvcmxkQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXRXb3JsZEJvdW5kaW5nQm94KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBYTUwzRC5Cb3goKTtcbn07XG5cbi8qKlxuICogcmV0dXJuIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIG93bmluZyBzcGFjZSBpbiBsb2NhbCBzcGFjZSAob2JqZWN0IEJCKVxuICovXG5tZXRob2RzLmdldExvY2FsQm91bmRpbmdCb3ggPSBmdW5jdGlvbigpIHtcbiAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICAvLyBWaXNpYmlsaXR5IGluZmx1ZW5jZXMgYm91bmRpbmcgYm94XG4gICAgWE1MM0QuZmx1c2hDU1NDaGFuZ2VzKCk7XG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcbiAgICBmb3IgKHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XG4gICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRMb2NhbEJvdW5kaW5nQm94KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0TG9jYWxCb3VuZGluZ0JveCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgWE1MM0QuQm94KCk7XG59O1xuXG5tZXRob2RzLnhtbDNkR2V0UmVuZGVySW50ZXJmYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcbiAgICBmb3IgKCB2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xuICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0UmVuZGVySW50ZXJmYWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0UmVuZGVySW50ZXJmYWNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufTtcblxuXG5tZXRob2RzLlhNTDNER3JhcGhUeXBlR2V0V29ybGRNYXRyaXggPSBmdW5jdGlvbigpIHtcbiAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xuICAgIGZvciAodmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcbiAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldFdvcmxkTWF0cml4KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0V29ybGRNYXRyaXgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IE1hdDQoKTtcbn07XG5cbm1ldGhvZHMudmlkZW9QbGF5ID0gZnVuY3Rpb24oKSB7XG4gICAgc2VuZEFkYXB0ZXJFdmVudCh0aGlzLCB7cGxheTogW119KTtcbn07XG5cbm1ldGhvZHMudmlkZW9QYXVzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHNlbmRBZGFwdGVyRXZlbnQodGhpcywge3BhdXNlOiBbXX0pO1xufTtcblxubWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlR2V0T3V0cHV0TmFtZXMgPVxubWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dE5hbWVzID1cbm1ldGhvZHMubWVzaEdldE91dHB1dE5hbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLCBcImRhdGFcIik7XG4gICAgaWYoZGF0YUFkYXB0ZXIpe1xuICAgICAgICByZXR1cm4gZGF0YUFkYXB0ZXIuZ2V0T3V0cHV0TmFtZXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5tZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRSZXN1bHQgPVxubWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldFJlc3VsdCA9XG5tZXRob2RzLm1lc2hHZXRSZXN1bHQgPSBmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICB2YXIgZGF0YUFkYXB0ZXIgPSBSZXNvdXJjZS5nZXRBZGFwdGVyKHRoaXMsIFwiZGF0YVwiKTtcbiAgICBpZihkYXRhQWRhcHRlcil7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhQWRhcHRlci5nZXRDb21wdXRlUmVzdWx0KGZpbHRlcik7XG4gICAgICAgIGlmKCFyZXN1bHQpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IHdpbmRvdy5YTUwzRERhdGFSZXN1bHQocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG5tZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRPdXRwdXRDaGFubmVsSW5mbyA9XG4gICAgbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldE91dHB1dENoYW5uZWxJbmZvID1cbiAgICAgICAgbWV0aG9kcy5tZXNoR2V0T3V0cHV0Q2hhbm5lbEluZm8gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgICAgICAgICB2YXIgZGF0YUFkYXB0ZXIgPSBSZXNvdXJjZS5nZXRBZGFwdGVyKHRoaXMsIFwiZGF0YVwiKTtcbiAgICAgICAgICAgIGlmIChkYXRhQWRhcHRlcikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBkYXRhQWRhcHRlci5nZXRPdXRwdXRDaGFubmVsSW5mbyhuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuWE1MM0REYXRhQ2hhbm5lbEluZm8ocmVzdWx0LnR5cGUsIHJlc3VsdC5vcmlnaW4sIHJlc3VsdC5vcmlnaW5hbE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5zZXFMZW5ndGgsIHJlc3VsdC5zZXFNaW5LZXksIHJlc3VsdC5zZXFNYXhLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4vLyBUT0RPOiBHZXQgcmlkIG9mIHRoZXNlXG5tZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRDb21wdXRlSW5mbyA9XG4gICAgbWV0aG9kcy5YTUwzRFNoYWRlclByb3ZpZGVyVHlwZUdldENvbXB1dGVJbmZvID1cbiAgICAgICAgbWV0aG9kcy5tZXNoR2V0Q29tcHV0ZUluZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKHRoaXMubm9kZU5hbWUgKyBcIjo6Z2V0Q29tcHV0ZUluZm8gaXMgbm90IGltcGxlbWV0ZWQgeWV0LlwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuXG5tZXRob2RzLlhNTDNETmVzdGVkRGF0YUNvbnRhaW5lclR5cGVHZXRQcm90b0luZm8gPVxuICAgIG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVHZXRQcm90b0luZm8gPVxuICAgICAgICBtZXRob2RzLm1lc2hHZXRQcm90b0luZm8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKHRoaXMubm9kZU5hbWUgKyBcIjo6Z2V0UHJvdG9JbmZvIGlzIG5vdCBpbXBsZW1ldGVkIHlldC5cIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfTtcblxubWV0aG9kcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlSXNPdXRwdXRDb25uZWN0ZWQgPVxuICAgIG1ldGhvZHMuWE1MM0RTaGFkZXJQcm92aWRlclR5cGVJc091dHB1dENvbm5lY3RlZCA9XG4gICAgICAgIG1ldGhvZHMubWVzaElzT3V0cHV0Q29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcih0aGlzLm5vZGVOYW1lICsgXCI6OmlzT3V0cHV0Q29ubmVjdGVkIGlzIG5vdCBpbXBsZW1ldGVkIHlldC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG5cblxuZnVuY3Rpb24gY3JlYXRlVmFsdWVzKHJlc3VsdCwgbmFtZXMpIHtcbiAgICB2YXIgdmFsdWVzID0ge307XG4gICAgZm9yICh2YXIgaSBpbiBuYW1lcykge1xuICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2ldO1xuICAgICAgICB2YXIgZGF0YSA9IHJlc3VsdC5nZXRPdXRwdXREYXRhKG5hbWUpICYmIHJlc3VsdC5nZXRPdXRwdXREYXRhKG5hbWUpLmdldFZhbHVlKCk7XG4gICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqIFJlZ2lzdGVyIGRhdGEgbGlzdGVuZXIgZm9yIGRhdGEgZmllbGRzIHNwZWNpZmllZCBieSBuYW1lcy5cbiAqXG4gKiBAcGFyYW0gbmFtZXMgICBzaW5nbGUgbmFtZSBvciBhcnJheSBvZiBuYW1lcyB0aGF0IGFyZSBtb25pdG9yZWQuXG4gKiBAcGFyYW0gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiBzZWxlY3RlZCBkYXRhIGFyZSBjaGFuZ2VkLlxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xubWV0aG9kcy5kYXRhQWRkT3V0cHV0RmllbGRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5hbWVzLCBjYWxsYmFjaykge1xuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuICAgIGlmICghbmFtZXMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGNoZWNrIGlmIG5hbWVzIGlzIGEgc2luZ2xlIHN0cmluZywgYW5kIGNvbnZlcnQgaXQgdG8gYXJyYXkgdGhlblxuICAgIHZhciB0eXBlT2ZOYW1lcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYW1lcykuc2xpY2UoOCwgLTEpO1xuICAgIGlmICh0eXBlT2ZOYW1lcyA9PT0gXCJTdHJpbmdcIikge1xuICAgICAgICBuYW1lcyA9IFtuYW1lc107XG4gICAgfVxuICAgIGlmIChuYW1lcy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIHJlcXVlc3QgPSBjYWxsQWRhcHRlckZ1bmModGhpcywge1xuICAgICAgICBnZXRDb21wdXRlUmVxdWVzdCA6IFtuYW1lcywgZnVuY3Rpb24ocmVxdWVzdCwgY2hhbmdlVHlwZSkge1xuICAgICAgICAgICAgY2FsbGJhY2soY3JlYXRlVmFsdWVzKHJlcXVlc3QuZ2V0UmVzdWx0KCksIG5hbWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgXX0pO1xuICAgIGlmIChyZXF1ZXN0Lmxlbmd0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHJlc3VsdCA9IHJlcXVlc3RbMF0uZ2V0UmVzdWx0KCk7XG4gICAgdmFyIHZhbHVlcyA9IGNyZWF0ZVZhbHVlcyhyZXN1bHQsIG5hbWVzKTtcbiAgICBpZiAoT2JqZWN0LmtleXModmFsdWVzKS5sZW5ndGgpXG4gICAgICAgIGNhbGxiYWNrKHZhbHVlcyk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tZXRob2RzLlhNTDNERGF0YVNvdXJjZVR5cGVTZXRTY3JpcHRWYWx1ZSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciBjb25maWdEYXRhID0gdGhpcy5fY29uZmlndXJlZDtcblxuICAgIGlmKCFjb25maWdEYXRhKVxuICAgICAgICByZXR1cm47XG5cbiAgICBpZih0aGlzLnRleHRDb250ZW50ICE9IFwiW3ZhbHVlIHNldCBieSBzY3JpcHRdXCIpXG4gICAgICAgIHRoaXMudGV4dENvbnRlbnQgPSBcIlt2YWx1ZSBzZXQgYnkgc2NyaXB0XVwiO1xuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuICAgIGNvbmZpZ0RhdGEuc2NyaXB0VmFsdWUgPSBkYXRhO1xuXG4gICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcih0aGlzLCBcImRhdGFcIik7XG4gICAgaWYoZGF0YUFkYXB0ZXIpXG4gICAgICAgIGRhdGFBZGFwdGVyLnNldFNjcmlwdFZhbHVlKGRhdGEpO1xuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1ldGhvZHM7XG4iLCJcbi8qKlxuICogVHlwZXMgb2YgY2hhbmdlIGV2ZW50c1xuICogQGVudW0ge251bWJlcn1cbiAqL1xudmFyIGV2ZW50cyA9IHtcbiAgICAgIE5PREVfSU5TRVJURUQ6IDAsXG4gICAgICBWQUxVRV9NT0RJRklFRDogIDEsXG4gICAgICBOT0RFX1JFTU9WRUQ6IDIsXG4gICAgICBUSElTX1JFTU9WRUQ6IDMsXG4gICAgICBBREFQVEVSX0hBTkRMRV9DSEFOR0VEOiA0LFxuICAgICAgQURBUFRFUl9WQUxVRV9DSEFOR0VEOiA1XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vL0NsYXNzIE5vdGlmaWNhdGlvblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXZlbnRzLk5vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xufTtcbmV2ZW50cy5Ob3RpZmljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiTm90aWZpY2F0aW9uICh0eXBlOlwiICsgdGhpcy50eXBlICsgXCIpXCI7XG59O1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZXZlbnRzLk5vdGlmaWNhdGlvbldyYXBwZXIgPSBmdW5jdGlvbihtdXRhdGlvbiwgdHlwZSwgYWZmZWN0ZWROb2RlKSB7XG4gICAgdGhpcy5tdXRhdGlvbiA9IG11dGF0aW9uO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5hZmZlY3RlZE5vZGUgPSBhZmZlY3RlZE5vZGU7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoZXZlbnRzLk5vdGlmaWNhdGlvbldyYXBwZXIsIGV2ZW50cy5Ob3RpZmljYXRpb24pO1xuZXZlbnRzLk5vdGlmaWNhdGlvbldyYXBwZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiTm90aWZpY2F0aW9uV3JhcHBlciAodHlwZTpcIiArIHRoaXMudHlwZSArIFwiLCB3cmFwcGVkOiBcIisgdGhpcy5tdXRhdGlvbiArXCIpXCI7XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQHBhcmFtIHtBZGFwdGVySGFuZGxlfSBoYW5kbGVcbiAqIEBwYXJhbSB7aW50fSB0eXBlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZXZlbnRzLkFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24gPSBmdW5jdGlvbiAoaGFuZGxlLCB0eXBlKSB7XG4gICAgdGhpcy5hZGFwdGVySGFuZGxlID0gaGFuZGxlO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoZXZlbnRzLkFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24sIGV2ZW50cy5Ob3RpZmljYXRpb24pO1xuZXZlbnRzLkFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIkFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24gKHR5cGU6XCIgKyB0aGlzLnR5cGUgKyBcIilcIjtcbn07XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmV2ZW50cy5Db25uZWN0ZWRBZGFwdGVyTm90aWZpY2F0aW9uID0gZnVuY3Rpb24oYWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbiwga2V5KSB7XG4gICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbi5hZGFwdGVySGFuZGxlLmdldEFkYXB0ZXIoKTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnVybCA9IGFkYXB0ZXJIYW5kbGVOb3RpZmljYXRpb24uYWRhcHRlckhhbmRsZS51cmw7XG4gICAgdGhpcy50eXBlID0gYWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbi50eXBlO1xuICAgIHRoaXMuaGFuZGxlU3RhdHVzID0gYWRhcHRlckhhbmRsZU5vdGlmaWNhdGlvbi5hZGFwdGVySGFuZGxlLnN0YXR1cztcbn07XG5YTUwzRC5jcmVhdGVDbGFzcyhldmVudHMuQ29ubmVjdGVkQWRhcHRlck5vdGlmaWNhdGlvbiwgZXZlbnRzLk5vdGlmaWNhdGlvbik7XG5ldmVudHMuQ29ubmVjdGVkQWRhcHRlck5vdGlmaWNhdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJDb25uZWN0ZWRBZGFwdGVyTm90aWZpY2F0aW9uICh0eXBlOlwiICsgdGhpcy50eXBlICsgXCIsIGtleTogXCIgKyB0aGlzLmtleSArIFwiKVwiO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBldmVudHM7IiwidmFyIHByb3BlcnRpZXMgPSB7fTtcblxucHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlQ29tcGxldGUgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICAgICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcbiAgICAgICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xuICAgICAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldERhdGFDb21wbGV0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGFwdGVyc1thZGFwdGVyXS5nZXREYXRhQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7fVxufTtcblxucHJvcGVydGllcy5YTUwzRE5lc3RlZERhdGFDb250YWluZXJUeXBlUHJvZ3Jlc3NMZXZlbCA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuICAgICAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xuICAgICAgICBmb3IgKHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0RGF0YVByb2dyZXNzTGV2ZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNbYWRhcHRlcl0uZ2V0RGF0YVByb2dyZXNzTGV2ZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7fVxufTtcblxucHJvcGVydGllcy5Bc3NldENvbXBsZXRlID0ge1xuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgWE1MM0QuZmx1c2hET01DaGFuZ2VzKCk7XG4gICAgICAgIHZhciBhZGFwdGVycyA9IHRoaXMuX2NvbmZpZ3VyZWQuYWRhcHRlcnMgfHwge307XG4gICAgICAgIGZvciAodmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcbiAgICAgICAgICAgIGlmIChhZGFwdGVyc1thZGFwdGVyXS5nZXRBc3NldENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldEFzc2V0Q29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7fVxufTtcblxuXG5wcm9wZXJ0aWVzLkFzc2V0UHJvZ3Jlc3NMZXZlbCA9IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7XG4gICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuICAgICAgICB2YXIgYWRhcHRlcnMgPSB0aGlzLl9jb25maWd1cmVkLmFkYXB0ZXJzIHx8IHt9O1xuICAgICAgICBmb3IgKHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XG4gICAgICAgICAgICBpZiAoYWRhcHRlcnNbYWRhcHRlcl0uZ2V0QXNzZXRQcm9ncmVzc0xldmVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldEFzc2V0UHJvZ3Jlc3NMZXZlbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oKXt9XG59O1xuXG5wcm9wZXJ0aWVzLnhtbDNkQ29tcGxldGUgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICBYTUwzRC5mbHVzaERPTUNoYW5nZXMoKTtcbiAgICAgICAgdmFyIGFkYXB0ZXJzID0gdGhpcy5fY29uZmlndXJlZC5hZGFwdGVycyB8fCB7fTtcbiAgICAgICAgZm9yICh2YXIgYWRhcHRlciBpbiBhZGFwdGVycykge1xuICAgICAgICAgICAgaWYgKGFkYXB0ZXJzW2FkYXB0ZXJdLmdldENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkYXB0ZXJzW2FkYXB0ZXJdLmdldENvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbigpe31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvcGVydGllcztcbiIsIihmdW5jdGlvbiAobW9kdWxlKSB7XG5cbiAgICAvKipcbiAgICAgKiBAY2xhc3MgQW4gYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBpbiB0aGUgc3R5bGUgb2YgZ2xNYXRyaXhcbiAgICAgKiBAbmFtZSBiYm94XG4gICAgICovXG4gICAgdmFyIGJib3ggPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IGJvdW5kaW5nIGJveFxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jib3h9IGEgbmV3IGVtcHR5IGJvdW5kaW5nIGJveFxuICAgICAqL1xuICAgIGJib3guY3JlYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg2KTtcbiAgICAgICAgb3V0WzBdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgb3V0WzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgb3V0WzJdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgb3V0WzNdID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIG91dFs0XSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBvdXRbNV0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgYmJveC5jbG9uZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDYpO1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzFdO1xuICAgICAgICBvdXRbMl0gPSBhWzJdO1xuICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBiYm94LmNvcHkgPSBmdW5jdGlvbiAob3V0LCBhKSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMV07XG4gICAgICAgIG91dFsyXSA9IGFbMl07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgICAgIG91dFs0XSA9IGFbNF07XG4gICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIGJib3guY29weU1pbiA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB0YXJnZXRbMF0gPSBzb3VyY2VbMF07XG4gICAgICAgIHRhcmdldFsxXSA9IHNvdXJjZVsxXTtcbiAgICAgICAgdGFyZ2V0WzJdID0gc291cmNlWzJdO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICBiYm94LmNvcHlNYXggPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgICAgdGFyZ2V0WzBdID0gc291cmNlWzNdO1xuICAgICAgICB0YXJnZXRbMV0gPSBzb3VyY2VbNF07XG4gICAgICAgIHRhcmdldFsyXSA9IHNvdXJjZVs1XTtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9O1xuXG4gICAgYmJveC5taW4gPSBmdW5jdGlvbihib3gpIHtcbiAgICAgICAgcmV0dXJuIGJveC5zdWJhcnJheSgwLDMpO1xuICAgIH07XG5cbiAgICBiYm94Lm1heCA9IGZ1bmN0aW9uKGJveCkge1xuICAgICAgICByZXR1cm4gYm94LnN1YmFycmF5KDMsNik7XG4gICAgfTtcblxuICAgIGJib3guZXh0ZW5kV2l0aEJveCA9IGZ1bmN0aW9uICh0YXJnZXQsIG90aGVyKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICB0YXJnZXRbaV0gPSBNYXRoLm1pbihvdGhlcltpXSwgdGFyZ2V0W2ldKTtcbiAgICAgICAgICAgIHRhcmdldFtpICsgM10gPSBNYXRoLm1heChvdGhlcltpICsgM10sIHRhcmdldFtpICsgM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIGJib3guZW1wdHkgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICBiWzBdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgYlsxXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGJbMl0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICBiWzNdID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgIGJbNF0gPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgYls1XSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICByZXR1cm4gYjtcbiAgICB9O1xuXG4gICAgYmJveC5pc0VtcHR5ID0gZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgcmV0dXJuIChiWzBdID4gYlszXSB8fCBiWzFdID4gYls0XSB8fCBiWzJdID4gYls1XSk7XG4gICAgfTtcblxuICAgIGJib3guY2VudGVyID0gZnVuY3Rpb24gKHRhcmdldCwgYikge1xuICAgICAgICB0YXJnZXRbMF0gPSAoYlswXSArIGJbM10pICogMC41O1xuICAgICAgICB0YXJnZXRbMV0gPSAoYlsxXSArIGJbNF0pICogMC41O1xuICAgICAgICB0YXJnZXRbMl0gPSAoYlsyXSArIGJbNV0pICogMC41O1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICBiYm94LnNpemUgPSBmdW5jdGlvbiAodGFyZ2V0LCBiKSB7XG4gICAgICAgIHRhcmdldFswXSA9IE1hdGgubWF4KGJbM10gLSBiWzBdLCAwKTtcbiAgICAgICAgdGFyZ2V0WzFdID0gTWF0aC5tYXgoYls0XSAtIGJbMV0sIDApO1xuICAgICAgICB0YXJnZXRbMl0gPSBNYXRoLm1heChiWzVdIC0gYlsyXSwgMCk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfTtcblxuICAgIGJib3guZXh0ZW50ID0gZnVuY3Rpb24gKHRhcmdldCwgYikge1xuICAgICAgICB0YXJnZXRbMF0gPSBNYXRoLm1heChiWzNdIC0gYlswXSwgMCkgKiAwLjU7XG4gICAgICAgIHRhcmdldFsxXSA9IE1hdGgubWF4KGJbNF0gLSBiWzFdLCAwKSAqIDAuNTtcbiAgICAgICAgdGFyZ2V0WzJdID0gTWF0aC5tYXgoYls1XSAtIGJbMl0sIDApICogMC41O1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICBiYm94LnRyYW5zZm9ybUF4aXNBbGlnbmVkID0gZnVuY3Rpb24gKG91dCwgbWF0LCBib3gpIHtcbiAgICAgICAgaWYgKGJib3guaXNFbXB0eShib3gpKSB7XG4gICAgICAgICAgICBiYm94LmNvcHkob3V0LCBib3gpOyAvLyBhbiBlbXB0eSBib3ggcmVtYWlucyBlbXB0eVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdXQgPT09IGJveCkge1xuICAgICAgICAgICAgLy9UaGUgYWxnb3JpdGhtIGJyZWFrcyBpZiBzb3VyY2UgYW5kIGRlc3QgYXJlIHRoZSBzYW1lIHNvIGNyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgc291cmNlIGJveFxuICAgICAgICAgICAgYm94ID0gYmJveC5jbG9uZShib3gpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXRbM10gPT0gMCAmJiBtYXRbN10gPT0gMCAmJiBtYXRbMTFdID09IDAgJiYgbWF0WzE1XSA9PSAxKSB7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb3V0W2ldID0gb3V0W2kgKyAzXSA9IG1hdFsxMiArIGldO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGEsIGI7XG5cbiAgICAgICAgICAgICAgICAgICAgYSA9IG1hdFtqICogNCArIGldICogYm94W2pdO1xuICAgICAgICAgICAgICAgICAgICBiID0gbWF0W2ogKiA0ICsgaV0gKiBib3hbaiArIDNdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhIDwgYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0W2ldICs9IGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbaSArIDNdICs9IGI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRbaV0gKz0gYjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dFtpICsgM10gKz0gYTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWF0cml4IGlzIG5vdCBhZmZpbmVcIik7XG4gICAgfTtcblxuICAgIGJib3gudHJhbnNmb3JtID0gZnVuY3Rpb24gKG91dCwgbWF0LCBib3gpIHtcbiAgICAgICAgaWYgKGJib3guaXNFbXB0eShib3gpKSB7XG4gICAgICAgICAgICBiYm94LmNvcHkob3V0LCBib3gpOyAvLyBhbiBlbXB0eSBib3ggcmVtYWlucyBlbXB0eVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgWE1MM0QubWF0aC52ZWMzLnRyYW5zZm9ybU1hdDQob3V0LCBib3gsIG1hdCk7XG4gICAgICAgIFhNTDNELm1hdGgudmVjMy50cmFuc2Zvcm1NYXQ0KGJib3gubWF4KG91dCksIGJib3gubWF4KGJveCksIG1hdCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIGJib3gubG9uZ2VzdFNpZGUgPSBmdW5jdGlvbiAoYikge1xuICAgICAgICB2YXIgeCA9IE1hdGguYWJzKGJbM10gLSBiWzBdKTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLmFicyhiWzRdIC0gYlsxXSk7XG4gICAgICAgIHZhciB6ID0gTWF0aC5hYnMoYls1XSAtIGJbMl0pO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoeCwgTWF0aC5tYXgoeSwgeikpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBhIGdpdmVuIHJheSBhZ2FpbnN0IGEgZ2l2ZW4gYm91bmRpbmcgYm94IGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIHJheSBpbnRlcnNlY3RzIGl0LCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICogQHBhcmFtIGJiIFRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IHRvIHRlc3QgYWdhaW5zdFxuICAgICAqIEBwYXJhbSB4bWwzZFJheSBUaGUgcmF5IHRvIHRlc3QgZm9yIGludGVyc2VjdGlvbiB3aXRoXG4gICAgICogQHBhcmFtIG9wdCB7b2JqZWN0fSBJZiBvcHQuZGlzdCBpcyBwcm92aWRlZCB0aGUgZnVuY3Rpb24gd2lsbCBmaWxsIGl0IHdpdGggdGhlIGRpc3RhbmNlIGZyb20gdGhlIHJheSBvcmlnaW4gdG9cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHRoZSBoaXQgcG9pbnQgb24gdGhlIGJvdW5kaW5nIGJveCwgb3IgTUFYX1ZBTFVFIGlmIHRoZSByYXkgZG9lcyBub3QgaW50ZXJzZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGJib3guaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKGJiLCB4bWwzZFJheSwgb3B0KSB7XG4gICAgICAgIHZhciBvcmlnaW4gPSBYTUwzRC5tYXRoLnJheS5vcmlnaW4oeG1sM2RSYXkpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gWE1MM0QubWF0aC5yYXkuZGlyZWN0aW9uKHhtbDNkUmF5KTtcbiAgICAgICAgdmFyIGludmVyc2VEaXJYID0gMSAvIGRpcmVjdGlvblswXTtcbiAgICAgICAgdmFyIGludmVyc2VEaXJZID0gMSAvIGRpcmVjdGlvblsxXTtcbiAgICAgICAgdmFyIGludmVyc2VEaXJaID0gMSAvIGRpcmVjdGlvblsyXTtcblxuICAgICAgICB2YXIgdDEgPSAoYmJbMF0gLSBvcmlnaW5bMF0pICogaW52ZXJzZURpclg7XG4gICAgICAgIHZhciB0MiA9IChiYlszXSAtIG9yaWdpblswXSkgKiBpbnZlcnNlRGlyWDtcbiAgICAgICAgdmFyIHQzID0gKGJiWzFdIC0gb3JpZ2luWzFdKSAqIGludmVyc2VEaXJZO1xuICAgICAgICB2YXIgdDQgPSAoYmJbNF0gLSBvcmlnaW5bMV0pICogaW52ZXJzZURpclk7XG4gICAgICAgIHZhciB0NSA9IChiYlsyXSAtIG9yaWdpblsyXSkgKiBpbnZlcnNlRGlyWjtcbiAgICAgICAgdmFyIHQ2ID0gKGJiWzVdIC0gb3JpZ2luWzJdKSAqIGludmVyc2VEaXJaO1xuXG4gICAgICAgIHZhciB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSksIE1hdGgubWluKHQ1LCB0NikpO1xuICAgICAgICB2YXIgdG1heCA9IE1hdGgubWluKE1hdGgubWluKE1hdGgubWF4KHQxLCB0MiksIE1hdGgubWF4KHQzLCB0NCkpLCBNYXRoLm1heCh0NSwgdDYpKTtcblxuICAgICAgICBpZiAob3B0ID09PSB1bmRlZmluZWQgfHwgb3B0LmRpc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRtYXggPiAwICYmIHRtaW4gPD0gdG1heDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0bWF4IDwgMCkge1xuICAgICAgICAgICAgb3B0LmRpc3QgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRtaW4gPiB0bWF4KSB7XG4gICAgICAgICAgICBvcHQuZGlzdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBvcHQuZGlzdCA9IHRtaW47XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICBiYm94LnN0ciA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiAnYmJveCgnICsgYVswXSArICcsICcgKyBhWzFdICsgJywgJyArIGFbMl0gKyAnLCAnICsgYVszXSArICcsICcgK1xuICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJyknO1xuICAgIH07XG5cbiAgICBiYm94LkVNUFRZX0JPWCA9IGJib3guY3JlYXRlKCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJib3g7XG5cblxufShtb2R1bGUpKTtcblxuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobWF0aCkge1xuXG4vLyBBZGRpdGlvbmFsIG1ldGhvZHMgaW4gZ2xNYXRyaXggc3R5bGVcbiAgICBtYXRoLnZlYzMucmVjaXByb2NhbCA9IGZ1bmN0aW9uIChkZXN0LCB2ZWMpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdmVjO1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdFswXSA9IDEgLyB2ZWNbMF07XG4gICAgICAgIGRlc3RbMV0gPSAxIC8gdmVjWzFdO1xuICAgICAgICBkZXN0WzJdID0gMSAvIHZlY1syXTtcbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfTtcblxuICAgIHZhciB0b0RPTVN0cmluZyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5qb2luLmNhbGwoZGF0YSwgJyAnKTtcbiAgICB9O1xuXG4gICAgbWF0aC52ZWMyLnRvRE9NU3RyaW5nID0gdG9ET01TdHJpbmc7XG5cbiAgICBtYXRoLnZlYzIuZnJvbURPTVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgcyA9IHN0ci5zcGxpdCgnICcpO1xuICAgICAgICBpZiAocy5sZW5ndGggIT09IDIgfHwgaXNOYU4oK3NbMF0pIHx8IGlzTmFOKCtzWzFdKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJDb3VsZCBub3QgcGFyc2UgJ1wiK3N0citcIicgaW50byBhIHZhbGlkIHZlYzIgb2JqZWN0XCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGgudmVjMi5mcm9tVmFsdWVzKCtzWzBdLCArc1sxXSk7XG4gICAgfTtcblxuICAgIG1hdGgudmVjMy50b0RPTVN0cmluZyA9IHRvRE9NU3RyaW5nO1xuXG4gICAgbWF0aC52ZWMzLmZyb21ET01TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIHMgPSBzdHIuc3BsaXQoJyAnKTtcbiAgICAgICAgaWYgKHMubGVuZ3RoICE9PSAzIHx8IGlzTmFOKCtzWzBdKSB8fCBpc05hTigrc1sxXSkgfHwgaXNOYU4oK3NbMl0pKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBwYXJzZSAnXCIrc3RyK1wiJyBpbnRvIGEgdmFsaWQgdmVjMyBvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF0aC52ZWMzLmZyb21WYWx1ZXMoK3NbMF0sICtzWzFdLCArc1syXSk7XG4gICAgfTtcblxuXG4gICAgbWF0aC52ZWM0LnRvRE9NU3RyaW5nID0gdG9ET01TdHJpbmc7XG5cbiAgICBtYXRoLnZlYzQuZnJvbURPTVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgcyA9IHN0ci5zcGxpdCgnICcpO1xuICAgICAgICBpZiAocy5sZW5ndGggIT09IDQgfHwgaXNOYU4oK3NbMF0pIHx8IGlzTmFOKCtzWzFdKSB8fCBpc05hTigrc1syXSkgfHwgaXNOYU4oK3NbM10pKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBwYXJzZSAnXCIrc3RyK1wiJyBpbnRvIGEgdmFsaWQgdmVjNCBvciBxdWF0IG9iamVjdFwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXRoLnZlYzQuZnJvbVZhbHVlcygrc1swXSwgK3NbMV0sICtzWzJdLCArc1szXSk7XG4gICAgfTtcblxuICAgIG1hdGgucXVhdC50b0RPTVN0cmluZyA9IHRvRE9NU3RyaW5nO1xuXG4gICAgbWF0aC5xdWF0LmZyb21ET01TdHJpbmcgPSBtYXRoLnZlYzQuZnJvbURPTVN0cmluZztcblxuICAgIG1hdGgubWF0My50b0RPTVN0cmluZyA9IHRvRE9NU3RyaW5nO1xuXG4gICAgbWF0aC5tYXQzLmZyb21ET01TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgdmFyIHMgPSBzdHIuc3BsaXQoJyAnKTtcbiAgICAgICAgaWYgKHMubGVuZ3RoICE9PSA5KSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBwYXJzZSAnXCIrc3RyK1wiJyBpbnRvIGEgdmFsaWQgbWF0MyBvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0ID0gbWF0aC5tYXQzLmNyZWF0ZSgpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8OTsgaSsrKSB7XG4gICAgICAgICAgICBtYXRbaV0gPSArc1tpXTtcbiAgICAgICAgICAgIGlmIChpc05hTihtYXRbaV0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgXCJDb3VsZCBub3QgcGFyc2UgJ1wiK3N0citcIicgaW50byBhIHZhbGlkIG1hdDMgb2JqZWN0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdDtcbiAgICB9O1xuXG4gICAgbWF0aC5tYXQ0LnRvRE9NU3RyaW5nID0gdG9ET01TdHJpbmc7XG5cbiAgICBtYXRoLm1hdDQuZnJvbURPTVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICB2YXIgcyA9IHN0ci5zcGxpdCgnICcpO1xuICAgICAgICBpZiAocy5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNvdWxkIG5vdCBwYXJzZSAnXCIrc3RyK1wiJyBpbnRvIGEgdmFsaWQgbWF0NCBvYmplY3RcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF0ID0gbWF0aC5tYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBmb3IgKHZhciBpPTA7IGk8MTY7IGkrKykge1xuICAgICAgICAgICAgbWF0W2ldID0gK3NbaV07XG4gICAgICAgICAgICBpZiAoaXNOYU4obWF0W2ldKSkge1xuICAgICAgICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IHBhcnNlICdcIitzdHIrXCInIGludG8gYSB2YWxpZCBtYXQ0IG9iamVjdFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXQ7XG4gICAgfTtcblxuXG4gICAgbWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0VmVjMyA9IGZ1bmN0aW9uIChtYXQsIG1hdE9mZnNldCwgdmVjLCB2ZWNPZmZzZXQsIGRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gdmVjO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmVjT2Zmc2V0KSB7XG4gICAgICAgICAgICB2ZWNPZmZzZXQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHggPSB2ZWNbdmVjT2Zmc2V0ICsgMF0sIHkgPSB2ZWNbdmVjT2Zmc2V0ICsgMV0sIHogPSB2ZWNbdmVjT2Zmc2V0ICsgMl07XG5cbiAgICAgICAgZGVzdFswXSA9IG1hdFttYXRPZmZzZXQgKyAwXSAqIHggKyBtYXRbbWF0T2Zmc2V0ICsgNF0gKiB5ICsgbWF0W21hdE9mZnNldCArIDhdICogeiArIG1hdFttYXRPZmZzZXQgKyAxMl07XG4gICAgICAgIGRlc3RbMV0gPSBtYXRbbWF0T2Zmc2V0ICsgMV0gKiB4ICsgbWF0W21hdE9mZnNldCArIDVdICogeSArIG1hdFttYXRPZmZzZXQgKyA5XSAqIHogKyBtYXRbbWF0T2Zmc2V0ICsgMTNdO1xuICAgICAgICBkZXN0WzJdID0gbWF0W21hdE9mZnNldCArIDJdICogeCArIG1hdFttYXRPZmZzZXQgKyA2XSAqIHkgKyBtYXRbbWF0T2Zmc2V0ICsgMTBdICogeiArIG1hdFttYXRPZmZzZXQgKyAxNF07XG5cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfTtcblxuXG4gICAgbWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKG1hdCwgbWF0T2Zmc2V0LCB2ZWMsIHZlY09mZnNldCwgZGVzdCkge1xuICAgICAgICBpZiAoIWRlc3QpIHtcbiAgICAgICAgICAgIGRlc3QgPSB2ZWM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2ZWNPZmZzZXQpIHtcbiAgICAgICAgICAgIHZlY09mZnNldCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHZlY1t2ZWNPZmZzZXQgKyAwXSwgeSA9IHZlY1t2ZWNPZmZzZXQgKyAxXSwgeiA9IHZlY1t2ZWNPZmZzZXQgKyAyXSwgdztcblxuICAgICAgICBkZXN0WzBdID0gbWF0W21hdE9mZnNldCArIDBdICogeCArIG1hdFttYXRPZmZzZXQgKyA0XSAqIHkgKyBtYXRbbWF0T2Zmc2V0ICsgOF0gKiB6O1xuICAgICAgICBkZXN0WzFdID0gbWF0W21hdE9mZnNldCArIDFdICogeCArIG1hdFttYXRPZmZzZXQgKyA1XSAqIHkgKyBtYXRbbWF0T2Zmc2V0ICsgOV0gKiB6O1xuICAgICAgICBkZXN0WzJdID0gbWF0W21hdE9mZnNldCArIDJdICogeCArIG1hdFttYXRPZmZzZXQgKyA2XSAqIHkgKyBtYXRbbWF0T2Zmc2V0ICsgMTBdICogejtcblxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9O1xuXG4gICAgbWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0ID0gZnVuY3Rpb24gKGRlc3QsIGRlc3RPZmZzZXQsIG1hdCwgb2Zmc2V0MSwgbWF0Miwgb2Zmc2V0Mikge1xuICAgICAgICB2YXIgYTAwID0gbWF0MltvZmZzZXQyICsgMF0sIGEwMSA9IG1hdDJbb2Zmc2V0MiArIDFdLCBhMDIgPSBtYXQyW29mZnNldDIgKyAyXSwgYTAzID0gbWF0MltvZmZzZXQyICsgM107XG4gICAgICAgIHZhciBhMTAgPSBtYXQyW29mZnNldDIgKyA0XSwgYTExID0gbWF0MltvZmZzZXQyICsgNV0sIGExMiA9IG1hdDJbb2Zmc2V0MiArIDZdLCBhMTMgPSBtYXQyW29mZnNldDIgKyA3XTtcbiAgICAgICAgdmFyIGEyMCA9IG1hdDJbb2Zmc2V0MiArIDhdLCBhMjEgPSBtYXQyW29mZnNldDIgKyA5XSwgYTIyID0gbWF0MltvZmZzZXQyICsgMTBdLCBhMjMgPSBtYXQyW29mZnNldDIgKyAxMV07XG4gICAgICAgIHZhciBhMzAgPSBtYXQyW29mZnNldDIgKyAxMl0sIGEzMSA9IG1hdDJbb2Zmc2V0MiArIDEzXSwgYTMyID0gbWF0MltvZmZzZXQyICsgMTRdLCBhMzMgPSBtYXQyW29mZnNldDIgKyAxNV07XG5cbiAgICAgICAgdmFyIGIwMCA9IG1hdFtvZmZzZXQxICsgMF0sIGIwMSA9IG1hdFtvZmZzZXQxICsgMV0sIGIwMiA9IG1hdFtvZmZzZXQxICsgMl0sIGIwMyA9IG1hdFtvZmZzZXQxICsgM107XG4gICAgICAgIHZhciBiMTAgPSBtYXRbb2Zmc2V0MSArIDRdLCBiMTEgPSBtYXRbb2Zmc2V0MSArIDVdLCBiMTIgPSBtYXRbb2Zmc2V0MSArIDZdLCBiMTMgPSBtYXRbb2Zmc2V0MSArIDddO1xuICAgICAgICB2YXIgYjIwID0gbWF0W29mZnNldDEgKyA4XSwgYjIxID0gbWF0W29mZnNldDEgKyA5XSwgYjIyID0gbWF0W29mZnNldDEgKyAxMF0sIGIyMyA9IG1hdFtvZmZzZXQxICsgMTFdO1xuICAgICAgICB2YXIgYjMwID0gbWF0W29mZnNldDEgKyAxMl0sIGIzMSA9IG1hdFtvZmZzZXQxICsgMTNdLCBiMzIgPSBtYXRbb2Zmc2V0MSArIDE0XSwgYjMzID0gbWF0W29mZnNldDEgKyAxNV07XG5cbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjAgKyBiMDMgKiBhMzA7XG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxICsgYjAzICogYTMxO1xuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMiArIGIwMyAqIGEzMjtcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgM10gPSBiMDAgKiBhMDMgKyBiMDEgKiBhMTMgKyBiMDIgKiBhMjMgKyBiMDMgKiBhMzM7XG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDRdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwICsgYjEzICogYTMwO1xuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyA1XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMSArIGIxMyAqIGEzMTtcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgNl0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjIgKyBiMTMgKiBhMzI7XG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDddID0gYjEwICogYTAzICsgYjExICogYTEzICsgYjEyICogYTIzICsgYjEzICogYTMzO1xuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyA4XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMCArIGIyMyAqIGEzMDtcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgOV0gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjEgKyBiMjMgKiBhMzE7XG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDEwXSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMiArIGIyMyAqIGEzMjtcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMTFdID0gYjIwICogYTAzICsgYjIxICogYTEzICsgYjIyICogYTIzICsgYjIzICogYTMzO1xuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAxMl0gPSBiMzAgKiBhMDAgKyBiMzEgKiBhMTAgKyBiMzIgKiBhMjAgKyBiMzMgKiBhMzA7XG4gICAgICAgIGRlc3RbZGVzdE9mZnNldCArIDEzXSA9IGIzMCAqIGEwMSArIGIzMSAqIGExMSArIGIzMiAqIGEyMSArIGIzMyAqIGEzMTtcbiAgICAgICAgZGVzdFtkZXN0T2Zmc2V0ICsgMTRdID0gYjMwICogYTAyICsgYjMxICogYTEyICsgYjMyICogYTIyICsgYjMzICogYTMyO1xuICAgICAgICBkZXN0W2Rlc3RPZmZzZXQgKyAxNV0gPSBiMzAgKiBhMDMgKyBiMzEgKiBhMTMgKyBiMzIgKiBhMjMgKyBiMzMgKiBhMzM7XG4gICAgfTtcblxuICAgIG1hdGgucXVhdC5zbGVycE9mZnNldCA9IGZ1bmN0aW9uIChxdWF0LCBvZmZzZXQxLCBxdWF0Miwgb2Zmc2V0MiwgdCwgZGVzdCwgZGVzdE9mZnNldCwgc2hvcnRlc3QpIHtcbiAgICAgICAgaWYgKCFkZXN0KSB7XG4gICAgICAgICAgICBkZXN0ID0gcXVhdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpeDEgPSBvZmZzZXQxLCBpeTEgPSBvZmZzZXQxICsgMSwgaXoxID0gb2Zmc2V0MSArIDIsIGl3MSA9IG9mZnNldDEgKyAzO1xuICAgICAgICB2YXIgaXgyID0gb2Zmc2V0MiwgaXkyID0gb2Zmc2V0MiArIDEsIGl6MiA9IG9mZnNldDIgKyAyLCBpdzIgPSBvZmZzZXQyICsgMztcbiAgICAgICAgdmFyIGl4ZCA9IGRlc3RPZmZzZXQsIGl5ZCA9IGRlc3RPZmZzZXQgKyAxLCBpemQgPSBkZXN0T2Zmc2V0ICsgMiwgaXdkID0gZGVzdE9mZnNldCArIDM7XG5cbiAgICAgICAgdmFyIGNvc0FuZ2xlID0gcXVhdFtpeDFdICogcXVhdDJbaXgyXSArIHF1YXRbaXkxXSAqIHF1YXQyW2l5Ml0gKyBxdWF0W2l6MV0gKiBxdWF0MltpejJdICsgcXVhdFtpdzFdICogcXVhdDJbaXcyXTtcblxuICAgICAgICB2YXIgYzEsIGMyO1xuXG4gICAgICAgIC8vIExpbmVhciBpbnRlcnBvbGF0aW9uIGZvciBjbG9zZSBvcmllbnRhdGlvbnNcbiAgICAgICAgaWYgKCgxLjAgLSBNYXRoLmFicyhjb3NBbmdsZSkpIDwgMC4wMSkge1xuICAgICAgICAgICAgYzEgPSAxLjAgLSB0O1xuICAgICAgICAgICAgYzIgPSB0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gU3BoZXJpY2FsIGludGVycG9sYXRpb25cbiAgICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguYWNvcyhNYXRoLmFicyhjb3NBbmdsZSkpO1xuICAgICAgICAgICAgdmFyIHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgICAgICAgYzEgPSBNYXRoLnNpbihhbmdsZSAqICgxLjAgLSB0KSkgLyBzaW5BbmdsZTtcbiAgICAgICAgICAgIGMyID0gTWF0aC5zaW4oYW5nbGUgKiB0KSAvIHNpbkFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVXNlIHRoZSBzaG9ydGVzdCBwYXRoXG4gICAgICAgIGlmIChzaG9ydGVzdCAmJiAoY29zQW5nbGUgPCAwLjApKVxuICAgICAgICAgICAgYzEgPSAtYzE7XG5cbiAgICAgICAgZGVzdFtpeGRdID0gYzEgKiBxdWF0W2l4MV0gKyBjMiAqIHF1YXQyW2l4Ml07XG4gICAgICAgIGRlc3RbaXlkXSA9IGMxICogcXVhdFtpeTFdICsgYzIgKiBxdWF0MltpeTJdO1xuICAgICAgICBkZXN0W2l6ZF0gPSBjMSAqIHF1YXRbaXoxXSArIGMyICogcXVhdDJbaXoyXTtcbiAgICAgICAgZGVzdFtpd2RdID0gYzEgKiBxdWF0W2l3MV0gKyBjMiAqIHF1YXQyW2l3Ml07XG4gICAgfTtcblxuICAgIG1hdGgucXVhdC5mcm9tQXhpc0FuZ2xlID0gZnVuY3Rpb24oYXhpcywgYW5nbGUpIHtcbiAgICAgICAgdmFyIHEgPSBtYXRoLnF1YXQuY3JlYXRlKCk7XG4gICAgICAgIGlmIChheGlzLmxlbmd0aCA9PT0gNCAmJiBhbmdsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtYXRoLnF1YXQuc2V0QXhpc0FuZ2xlKHEsIGF4aXMsIGF4aXNbM10pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF0aC5xdWF0LnNldEF4aXNBbmdsZShxLCBheGlzLCBhbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hdGgucXVhdC5ub3JtYWxpemUocSxxKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAgICAgKiA0dGggdmVjdG9yIGNvbXBvbmVudCBpcyBpbXBsaWNpdGx5ICcwJ1xuICAgICAqXG4gICAgICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAgICAgKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gICAgICogQHJldHVybnMge3ZlYzN9IG91dFxuICAgICAqL1xuICAgIG1hdGgudmVjMy50cmFuc2Zvcm1EaXJlY3Rpb24gPSBmdW5jdGlvbihvdXQsIGEsIG0pIHtcbiAgICAgICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl07XG4gICAgICAgIG91dFswXSA9IChtWzBdICogeCArIG1bNF0gKiB5ICsgbVs4XSAqIHopO1xuICAgICAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6KTtcbiAgICAgICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHopO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBtYXRoLnF1YXQuc2V0RnJvbU1hdDMgPSBmdW5jdGlvbihkZXN0LCBtKSB7XG4gICAgICAgIHZhciB0ciA9IG1bMF0gKyBtWzRdICsgbVs4XTtcblxuICAgICAgICBpZiAodHIgPiAwKSB7XG4gICAgICAgICAgICB2YXIgcyA9IE1hdGguc3FydCh0ciArIDEuMCkgKiAyOyAvLyBzPTQqZGVzdFszXVxuICAgICAgICAgICAgZGVzdFswXSA9IChtWzddIC0gbVs1XSkgLyBzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IChtWzJdIC0gbVs2XSkgLyBzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IChtWzNdIC0gbVsxXSkgLyBzO1xuICAgICAgICAgICAgZGVzdFszXSA9IDAuMjUgKiBzO1xuICAgICAgICB9IGVsc2UgaWYgKChtWzBdID4gbVs0XSkgJiYgKG1bMF0gPiBtWzhdKSkge1xuICAgICAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMS4wICsgbVswXSAtIG1bNF0gLSBtWzhdKSAqIDI7IC8vIHM9NCpxeFxuICAgICAgICAgICAgZGVzdFszXSA9IChtWzddIC0gbVs1XSkgLyBzO1xuICAgICAgICAgICAgZGVzdFswXSA9IDAuMjUgKiBzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IChtWzFdICsgbVszXSkgLyBzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IChtWzJdICsgbVs2XSkgLyBzO1xuICAgICAgICB9IGVsc2UgaWYgKG1bNF0gPiBtWzhdKSB7XG4gICAgICAgICAgICB2YXIgcyA9IE1hdGguc3FydCgxLjAgKyBtWzRdIC0gbVswXSAtIG1bOF0pICogMjsgLy8gcz00KnF5XG4gICAgICAgICAgICBkZXN0WzNdID0gKG1bMl0gLSBtWzZdKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzBdID0gKG1bMV0gKyBtWzNdKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzFdID0gMC4yNSAqIHM7XG4gICAgICAgICAgICBkZXN0WzJdID0gKG1bNV0gKyBtWzddKSAvIHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcyA9IE1hdGguc3FydCgxLjAgKyBtWzhdIC0gbVswXSAtIG1bNF0pICogMjsgLy8gcz00KnF6XG4gICAgICAgICAgICBkZXN0WzNdID0gKG1bM10gLSBtWzFdKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzBdID0gKG1bMl0gKyBtWzZdKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzFdID0gKG1bNV0gKyBtWzddKSAvIHM7XG4gICAgICAgICAgICBkZXN0WzJdID0gMC4yNSAqIHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfTtcblxuICAgIG1hdGgucXVhdC5zZXRGcm9tQmFzaXMgPSBmdW5jdGlvbihkZXN0LCBYLFksWikge1xuICAgICAgICB2YXIgbHggPSAxLjAgLyBYTUwzRC5tYXRoLnZlYzMubGVuZ3RoKFgpO1xuICAgICAgICB2YXIgbHkgPSAxLjAgLyBYTUwzRC5tYXRoLnZlYzMubGVuZ3RoKFkpO1xuICAgICAgICB2YXIgbHogPSAxLjAgLyBYTUwzRC5tYXRoLnZlYzMubGVuZ3RoKFopO1xuICAgICAgICB2YXIgbSA9IFhNTDNELm1hdGgubWF0My5jcmVhdGUoKTtcbiAgICAgICAgbVswXSA9IFhbMF0gKiBseDtcbiAgICAgICAgbVsxXSA9IFlbMF0gKiBseTtcbiAgICAgICAgbVsyXSA9IFpbMF0gKiBsejtcbiAgICAgICAgbVszXSA9IFhbMV0gKiBseDtcbiAgICAgICAgbVs0XSA9IFlbMV0gKiBseTtcbiAgICAgICAgbVs1XSA9IFpbMV0gKiBsejtcbiAgICAgICAgbVs2XSA9IFhbMl0gKiBseDtcbiAgICAgICAgbVs3XSA9IFlbMl0gKiBseTtcbiAgICAgICAgbVs4XSA9IFpbMl0gKiBsejtcbiAgICAgICAgcmV0dXJuIFhNTDNELm1hdGgucXVhdC5zZXRGcm9tTWF0MyhkZXN0LCBtKTtcbiAgICB9O1xuXG4gICAgbWF0aC52ZWM0LmZyb21RdWF0ID0gZnVuY3Rpb24ocSkge1xuICAgICAgICB2YXIgZGVzdCA9IFhNTDNELm1hdGgudmVjNC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHFbM10gPiAxKSB7XG4gICAgICAgICAgICBYTUwzRC5tYXRoLnF1YXQubm9ybWFsaXplKHEscSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMgPSBNYXRoLnNxcnQoMS1xWzNdKnFbM10pO1xuICAgICAgICB2YXIgYW5nbGUgPSAyKk1hdGguYWNvcyhxWzNdKTtcbiAgICAgICAgaWYgKHMgPCAwLjAwMDEpIHtcbiAgICAgICAgICAgIC8vIEF4aXMgaXMgcHJhY3RpY2FsbHkgMCBzbyB3ZSByZXR1cm4gdGhlIGlkZW50aXR5IGF4aXMgYW5nbGVcbiAgICAgICAgICAgIGRlc3RbMF0gPSAwO1xuICAgICAgICAgICAgZGVzdFsxXSA9IDA7XG4gICAgICAgICAgICBkZXN0WzJdID0gMTtcbiAgICAgICAgICAgIGRlc3RbM10gPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVzdFswXSA9IHFbMF0gLyBzO1xuICAgICAgICAgICAgZGVzdFsxXSA9IHFbMV0gLyBzO1xuICAgICAgICAgICAgZGVzdFsyXSA9IHFbMl0gLyBzO1xuICAgICAgICAgICAgZGVzdFszXSA9IGFuZ2xlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH07XG5cblxufTtcbiIsIihmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgLyoqXG4gICAgICogQGNsYXNzIEEgcmF5IGluIHRoZSBzdHlsZSBvZiBnbE1hdHJpeFxuICAgICAqIEBuYW1lIHJheVxuICAgICAqL1xuICAgIHZhciByYXkgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcsIHJheSB3aXRoIG9yaWdpbiAoMCwwLDApIGFuZCBkaXJlY3Rpb24gKDAsMCwtMSlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtyYXl9IGEgbmV3IGRlZmF1bHQgcmF5XG4gICAgICovXG4gICAgcmF5LmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoNik7XG4gICAgICAgIG91dFswXSA9IDA7XG4gICAgICAgIG91dFsxXSA9IDA7XG4gICAgICAgIG91dFsyXSA9IDA7XG4gICAgICAgIG91dFszXSA9IDA7XG4gICAgICAgIG91dFs0XSA9IDA7XG4gICAgICAgIG91dFs1XSA9IC0xO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICByYXkuZnJvbU9yaWdpbkRpcmVjdGlvbiA9IGZ1bmN0aW9uKG9yaWdpbiwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBvdXQgPSByYXkuY3JlYXRlKCk7XG4gICAgICAgIHJheS5zZXRPcmlnaW4ob3V0LCBvcmlnaW4pO1xuICAgICAgICByYXkuc2V0RGlyZWN0aW9uKG91dCwgZGlyZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgcmF5LmNsb25lID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoNik7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbMV07XG4gICAgICAgIG91dFsyXSA9IGFbMl07XG4gICAgICAgIG91dFszXSA9IGFbM107XG4gICAgICAgIG91dFs0XSA9IGFbNF07XG4gICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIHJheS5jb3B5ID0gZnVuY3Rpb24gKG91dCwgYSkge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzFdO1xuICAgICAgICBvdXRbMl0gPSBhWzJdO1xuICAgICAgICBvdXRbM10gPSBhWzNdO1xuICAgICAgICBvdXRbNF0gPSBhWzRdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICByYXkuY29weU9yaWdpbiA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB0YXJnZXRbMF0gPSBzb3VyY2VbMF07XG4gICAgICAgIHRhcmdldFsxXSA9IHNvdXJjZVsxXTtcbiAgICAgICAgdGFyZ2V0WzJdID0gc291cmNlWzJdO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByYXkuY29weURpcmVjdGlvbiA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB0YXJnZXRbM10gPSBzb3VyY2VbM107XG4gICAgICAgIHRhcmdldFs0XSA9IHNvdXJjZVs0XTtcbiAgICAgICAgdGFyZ2V0WzVdID0gc291cmNlWzVdO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByYXkub3JpZ2luID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gYS5zdWJhcnJheSgwLDMpO1xuICAgIH07XG5cbiAgICByYXkuZGlyZWN0aW9uID0gZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gYS5zdWJhcnJheSgzLDYpO1xuICAgIH07XG5cbiAgICByYXkuc2V0T3JpZ2luID0gZnVuY3Rpb24ocmF5LCBvcmlnaW4pIHtcbiAgICAgICAgcmF5WzBdID0gb3JpZ2luWzBdO1xuICAgICAgICByYXlbMV0gPSBvcmlnaW5bMV07XG4gICAgICAgIHJheVsyXSA9IG9yaWdpblsyXTtcbiAgICAgICAgcmV0dXJuIHJheTtcbiAgICB9O1xuXG4gICAgcmF5LnNldERpcmVjdGlvbiA9IGZ1bmN0aW9uKHJheSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIFhNTDNELm1hdGgudmVjMy5ub3JtYWxpemUocmF5LnN1YmFycmF5KDMsNiksIGRpcmVjdGlvbik7XG4gICAgfTtcblxuICAgIHJheS5zdHIgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gJ3JheShvcmlnaW46ICcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsIGRpcmVjdGlvbjogJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcpJztcbiAgICB9O1xuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSByYXk7XG5cbn0pKG1vZHVsZSk7IiwidmFyIE5vZGVBZGFwdGVyID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvYWRhcHRlci5qc1wiKS5Ob2RlQWRhcHRlcjtcblxudmFyIFJlbmRlckFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xuICAgIE5vZGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG59O1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhSZW5kZXJBZGFwdGVyLCBOb2RlQWRhcHRlciwge1xuXG4gICAgZ2V0UGFyZW50UmVuZGVyQWRhcHRlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIodGhpcy5ub2RlLnBhcmVudE5vZGUsIFJlbmRlckFkYXB0ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZWxlbWVudFxuICAgICAqL1xuICAgIGluaXRFbGVtZW50OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmZhY3RvcnkuZ2V0QWRhcHRlcihlbGVtZW50KTtcbiAgICAgICAgdGhpcy5pbml0Q2hpbGRFbGVtZW50cyhlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICovXG4gICAgaW5pdENoaWxkRWxlbWVudHM6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0RWxlbWVudChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICB9LFxuXG4gICAgc3R5bGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICB9LFxuXG4gICAgYXBwbHlUcmFuc2Zvcm1NYXRyaXg6IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybTtcbiAgICB9LFxuXG4gICAgZ2V0U2NlbmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmFjdG9yeS5yZW5kZXJlci5zY2VuZTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJBZGFwdGVyO1xuIiwidmFyIFJlbmRlckFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xuXG4vL0FkYXB0ZXIgZm9yIDxkZWZzPlxudmFyIERlZnNSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcbiAgICBSZW5kZXJBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoRGVmc1JlbmRlckFkYXB0ZXIsIFJlbmRlckFkYXB0ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZnNSZW5kZXJBZGFwdGVyO1xuIiwidmFyIE5vZGVBZGFwdGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXIuanNcIikuTm9kZUFkYXB0ZXJGYWN0b3J5O1xudmFyIERhdGFBZGFwdGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9kYXRhL2FkYXB0ZXIvZmFjdG9yeS5qc1wiKTtcbnJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2Zvcm1hdGhhbmRsZXIuanNcIikueG1sM2RGb3JtYXRIYW5kbGVyLnJlZ2lzdGVyRmFjdG9yeUNsYXNzKERhdGFBZGFwdGVyRmFjdG9yeSk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7WE1MM0QuYmFzZS5JRmFjdG9yeX1cbiAqIEBleHRlbmRzIFhNTDNELmJhc2UuTm9kZUFkYXB0ZXJGYWN0b3J5XG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzSWRcbiAqL1xudmFyIFJlbmRlckFkYXB0ZXJGYWN0b3J5ID0gZnVuY3Rpb24gKGNhbnZhc0lkKSB7XG4gICAgTm9kZUFkYXB0ZXJGYWN0b3J5LmNhbGwodGhpcywgXCJ3ZWJnbFwiLCBjYW52YXNJZCk7XG4gICAgdGhpcy50eXBlID0gXCJSZW5kZXJBZGFwdGVyRmFjdG9yeVwiO1xufTtcblhNTDNELmNyZWF0ZUNsYXNzKFJlbmRlckFkYXB0ZXJGYWN0b3J5LCBOb2RlQWRhcHRlckZhY3RvcnkpO1xuUmVuZGVyQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLmFzcGVjdCA9IFwid2ViZ2xcIjtcblxuXG52YXIgcmVnaXN0cnkgPSB7XG4gICAgICAgIHhtbDNkOiByZXF1aXJlKFwiLi94bWwzZC5qc1wiKSxcbiAgICAgICAgdmlldzogcmVxdWlyZShcIi4vdmlldy5qc1wiKSxcbiAgICAgICAgZGVmczogcmVxdWlyZShcIi4vZGVmcy5qc1wiKSxcbiAgICAgICAgbWVzaDogcmVxdWlyZShcIi4vbWVzaC5qc1wiKSxcbiAgICAgICAgbW9kZWw6IHJlcXVpcmUoXCIuL21vZGVsLmpzXCIpLFxuICAgICAgICBtYXRlcmlhbDogcmVxdWlyZShcIi4vbWF0ZXJpYWwuanNcIiksXG4gICAgICAgIHNoYWRlcjogcmVxdWlyZShcIi4vbWF0ZXJpYWwuanNcIiksIC8vIFRPRE8oa3NvbnMpOiBSZW1vdmUgaW4gNS4xXG4gICAgICAgIGdyb3VwOiByZXF1aXJlKFwiLi9ncm91cC5qc1wiKSxcbiAgICAgICAgbGlnaHQ6IHJlcXVpcmUoXCIuL2xpZ2h0LmpzXCIpLFxuICAgICAgICBsaWdodHNoYWRlcjogcmVxdWlyZShcIi4vbGlnaHRzaGFkZXIuanNcIikgLy8gVE9ETyhrc29ucyk6IFJlbW92ZSBpbiA1LjFcbiAgICB9O1xuXG4vKipcbiAqIEBwYXJhbSBub2RlXG4gKiBAcmV0dXJuIHtYTUwzRC5iYXNlLkFkYXB0ZXJ8bnVsbH1cbiAqL1xuUmVuZGVyQWRhcHRlckZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUFkYXB0ZXIgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBhZGFwdGVyQ29uc3RydWN0b3IgPSByZWdpc3RyeVtub2RlLmxvY2FsTmFtZV07XG4gICAgaWYgKGFkYXB0ZXJDb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBuZXcgYWRhcHRlckNvbnN0cnVjdG9yKHRoaXMsIG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblJlbmRlckFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5zZXRTY2VuZSA9IGZ1bmN0aW9uIChzY2VuZSkge1xuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbn07XG5cblJlbmRlckFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5nZXRTY2VuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2VuZTtcbn07XG5cblJlbmRlckFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5zZXRSZW5kZXJlciA9IGZ1bmN0aW9uIChyZW5kZXJlcikge1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbn07XG5cblJlbmRlckFkYXB0ZXJGYWN0b3J5LnByb3RvdHlwZS5nZXRSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJlcjtcbn07XG5cbi8vIEV4cG9ydFxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJBZGFwdGVyRmFjdG9yeTtcbiIsInZhciBUcmFuc2Zvcm1hYmxlQWRhcHRlciA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybWFibGUuanNcIik7XG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcblxudmFyIEdyb3VwUmVuZGVyQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XG4gICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlLCB0cnVlLCB0cnVlKTtcbiAgICB0aGlzLnN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgdGhpcy5jcmVhdGVSZW5kZXJOb2RlKCk7XG59O1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhHcm91cFJlbmRlckFkYXB0ZXIsIFRyYW5zZm9ybWFibGVBZGFwdGVyLCB7XG5cbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vVE9ETzogU2hvdWxkbid0IGhhdmUgdG8gZ28gdGhyb3VnaCB0aGUgcmVuZGVyZXIuLi5cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHBhcmVudC5nZXRSZW5kZXJOb2RlICYmIHBhcmVudC5nZXRSZW5kZXJOb2RlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTm9kZSA9IHRoaXMuZ2V0U2NlbmUoKS5jcmVhdGVSZW5kZXJHcm91cCh7XG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGUsIG5hbWU6IHRoaXMubm9kZS5pZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy51cGRhdGVMb2NhbE1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsSGFuZGxlcigpO1xuICAgICAgICB2YXIgYmJveCA9IG5ldyBYTUwzRC5Cb3goKTtcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnNldFdvcmxkU3BhY2VCb3VuZGluZ0JveChiYm94KTtcbiAgICB9LFxuXG4gICAgbm90aWZ5Q2hhbmdlZDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZC5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUNvbm5lY3RlZEFkYXB0ZXJFdmVudChldnQpO1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgfSxcblxuICAgIGhhbmRsZUNvbm5lY3RlZEFkYXB0ZXJFdmVudDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5OT0RFX0lOU0VSVEVEOlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBpbml0aWFsaXplcyB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB0aGlzLmluaXRFbGVtZW50KGV2dC5tdXRhdGlvbi50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFdmVudHMuVEhJU19SRU1PVkVEOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIlVuaGFuZGxlZCBjb25uZWN0ZWQgYWRhcHRlciBldmVudCBmb3IgXCIgKyBldnQua2V5ICsgXCIgaW4gZ3JvdXAgYWRhcHRlclwiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAgc3R5bGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5wcm90b3R5cGUuc3R5bGVDaGFuZ2VkQ2FsbGJhY2suY2FsbCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBub25lID0gdGhpcy5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiZGlzcGxheVwiKS50cmltKCkgPT0gXCJub25lXCI7XG4gICAgICAgIHZhciBoaWRkZW4gID0gdGhpcy5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwidmlzaWJpbGl0eVwiKS50cmltKCkgPT0gXCJoaWRkZW5cIjtcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnNldExvY2FsVmlzaWJsZSghKG5vbmUgfHwgaGlkZGVuKSk7XG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRGlzcG9zZSBhbGwgY2hpbGRyZW4gYXMgd2VsbFxuICAgICAgICB0aGlzLnRyYXZlcnNlKGZ1bmN0aW9uIChhZGFwdGVyKSB7XG4gICAgICAgICAgICBpZiAoYWRhcHRlciAmJiBhZGFwdGVyLmRlc3Ryb3kpXG4gICAgICAgICAgICAgICAgYWRhcHRlci5kaXNwb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jbGVhckFkYXB0ZXJIYW5kbGVzKCk7XG4gICAgfSxcblxuICAgIC8qIEludGVyZmFjZSBtZXRob2RzICovXG4gICAgZ2V0V29ybGRCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYmJveCA9IG5ldyBYTUwzRC5Cb3goKTtcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLmdldFdvcmxkU3BhY2VCb3VuZGluZ0JveChiYm94KTtcbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfSxcblxuICAgIGdldExvY2FsQm91bmRpbmdCb3g6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NhbE1hdCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjaGlsZEJCID0gbmV3IFhNTDNELkJveCgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYmJveCA9IG5ldyBYTUwzRC5Cb3goKTtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgICAgICAgICAgaWYgKGMuZ2V0TG9jYWxCb3VuZGluZ0JveCkge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZEJCID0gYy5nZXRMb2NhbEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGJib3guZXh0ZW5kKGNoaWxkQkIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLmdldExvY2FsTWF0cml4KGxvY2FsTWF0KTtcbiAgICAgICAgICAgIGJib3gudHJhbnNmb3JtQXhpc0FsaWduZWQobG9jYWxNYXQpO1xuICAgICAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgICAgIH1cbiAgICB9KSgpLFxuXG4gICAgZ2V0TG9jYWxNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgWE1MM0QuTWF0NCgpO1xuICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0TG9jYWxNYXRyaXgobS5kYXRhKTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIGdldFdvcmxkTWF0cml4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtID0gbmV3IFhNTDNELk1hdDQoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLmdldFdvcmxkTWF0cml4KG0uZGF0YSk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdyb3VwUmVuZGVyQWRhcHRlcjtcbiIsInZhciBUcmFuc2Zvcm1hYmxlQWRhcHRlciA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybWFibGUuanNcIik7XG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9yZXNvdXJjZW1hbmFnZXIuanNcIikuUmVzb3VyY2U7XG52YXIgTGlnaHRDb25maWd1cmF0aW9uID0gcmVxdWlyZShcIi4uL3NjZW5lL2xpZ2h0LWNvbmZpZ3VyYXRpb24uanNcIik7XG5cbnZhciBERUZBVUxUX0xJR0hUX01PREVMID0gXCJ1cm46eG1sM2Q6bGlnaHQ6ZGlyZWN0aW9uYWxcIjtcbi8qKlxuICogQWRhcHRlciBmb3IgPGxpZ2h0PlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1JlbmRlckFkYXB0ZXJGYWN0b3J5fSBmYWN0b3J5XG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqL1xudmFyIExpZ2h0UmVuZGVyQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XG4gICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5kYXRhQWRhcHRlciA9IFJlc291cmNlLmdldEFkYXB0ZXIobm9kZSwgXCJkYXRhXCIpO1xuICAgIHRoaXMuc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKExpZ2h0UmVuZGVyQWRhcHRlciwgVHJhbnNmb3JtYWJsZUFkYXB0ZXIsIHtcblxuICAgIGNyZWF0ZVJlbmRlck5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmVudEFkYXB0ZXIgPSB0aGlzLmdldFBhcmVudFJlbmRlckFkYXB0ZXIoKTtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBwYXJlbnRBZGFwdGVyLmdldFJlbmRlck5vZGUgJiYgcGFyZW50QWRhcHRlci5nZXRSZW5kZXJOb2RlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTm9kZSA9IHRoaXMuZmFjdG9yeS5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlckxpZ2h0KHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYXRpb246IHRoaXMuY3JlYXRlTGlnaHRDb25maWd1cmF0aW9uKCksXG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG5cbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW50ZW5zaXR5XCI6IC8vIFRPRE8oa3NvbnMpOiByZW1vdmUgaW4gNS4xXG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIlRoZSA8bGlnaHQ+IGF0dHJpYnV0ZSBpbnRlbnNpdHkgaXMgZGVwcmVjYXRlZCBpbiBYTUwzRCA1LjAuXCIsIHRoaXMubm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibW9kZWxcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVSZW5kZXJOb2RlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc3R5bGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIucHJvdG90eXBlLnN0eWxlQ2hhbmdlZENhbGxiYWNrLmNhbGwoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVZpc2liaWxpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5vbmUgPSB0aGlzLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpLnRyaW0oKSA9PSBcIm5vbmVcIjtcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnNldExvY2FsVmlzaWJsZSghbm9uZSk7XG4gICAgICAgIHRoaXMuZmFjdG9yeS5yZW5kZXJlci5yZXF1ZXN0UmVkcmF3KFwiTGlnaHQgdmlzaWJpbGl0eSBjaGFuZ2VkLlwiKTtcbiAgICB9LFxuXG5cbiAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5USElTX1JFTU9WRUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNyZWF0ZUxpZ2h0Q29uZmlndXJhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLm5vZGUuaGFzQXR0cmlidXRlKFwibW9kZWxcIikgPyB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwibW9kZWxcIikgOiBERUZBVUxUX0xJR0hUX01PREVMO1xuICAgICAgICB2YXIgb3B0ID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5ub2RlLmlkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgTGlnaHRDb25maWd1cmF0aW9uKG1vZGVsLCB0aGlzLmRhdGFBZGFwdGVyLmdldFhmbG93Tm9kZSgpLCBvcHQpO1xuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyTm9kZSgpLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7WE1MM0QuTWF0NH1cbiAgICAgKi9cbiAgICBnZXRXb3JsZE1hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IG5ldyBYTUwzRC5NYXQ0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyTm9kZS5nZXRXb3JsZE1hdHJpeChtLmRhdGEpO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG59KTtcblxuLy8gRXhwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0UmVuZGVyQWRhcHRlcjtcblxuIiwidmFyIFJlbmRlckFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIDxsaWdodHNoYWRlcj5cbiAqIFRPRE8oa3NvbnMpOiBSZW1vdmUgaW4gNS4xXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7UmVuZGVyQWRhcHRlckZhY3Rvcnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICogQGV4dGVuZHMgUmVuZGVyQWRhcHRlclxuICovXG52YXIgTGlnaHRTaGFkZXJSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcbiAgICBSZW5kZXJBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG4gICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIlRoZSA8bGlnaHRzaGFkZXI+IGVsZW1lbnQgaXMgZGVwcmVjYXRlZCBpbiBYTUwzRCA1LjAuXCIsIG5vZGUpO1xufTtcblxuLy8gRXhwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0U2hhZGVyUmVuZGVyQWRhcHRlcjtcblxuIiwidmFyIFJlbmRlckFkYXB0ZXIgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xudmFyIFVSSSA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy91cmkuanNcIikuVVJJO1xudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xudmFyIEFkYXB0ZXJIYW5kbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9hZGFwdGVyaGFuZGxlLmpzXCIpO1xuXG4vKipcbiAqIEBwYXJhbSBmYWN0b3J5XG4gKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAqIEBleHRlbmRzIFJlbmRlckFkYXB0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWF0ZXJpYWxSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcbiAgICBSZW5kZXJBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG4gICAgdGhpcy5fZGF0YUFkYXB0ZXIgPSBSZXNvdXJjZS5nZXRBZGFwdGVyKG5vZGUsIFwiZGF0YVwiKTtcbiAgICAvKiogQHR5cGUgTWF0ZXJpYWxDb25maWd1cmF0aW9uIHwgbnVsbCAqKi9cbiAgICB0aGlzLl9tYXRlcmlhbENvbmZpZ3VyYXRpb24gPSBudWxsO1xuICAgIHRoaXMuX21hdGVyaWFsTW9kZWwgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVNYXRlcmlhbENvbmZpZ3VyYXRpb24oKTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKE1hdGVyaWFsUmVuZGVyQWRhcHRlciwgUmVuZGVyQWRhcHRlciwgIHtcblxuICAgIGdldE1hdGVyaWFsQ29uZmlndXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXRlcmlhbENvbmZpZ3VyYXRpb247XG4gICAgfSxcblxuICAgIHVwZGF0ZU1hdGVyaWFsQ29uZmlndXJhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBtb2RlbFxuICAgICAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsTW9kZWwoKTtcbiAgICAgICAgaWYgKCF0aGlzLl9tYXRlcmlhbE1vZGVsKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbENvbmZpZ3VyYXRpb24gPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWF0ZXJpYWxDb25maWd1cmF0aW9uID0gdGhpcy5nZXRTY2VuZSgpLmNyZWF0ZU1hdGVyaWFsQ29uZmlndXJhdGlvbih0aGlzLl9tYXRlcmlhbE1vZGVsLCB0aGlzLl9kYXRhQWRhcHRlci5nZXRYZmxvd05vZGUoKSwge25hbWU6IHRoaXMubm9kZS5pZH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5T3Bwb3NpdGVBZGFwdGVycygpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVNYXRlcmlhbE1vZGVsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21hdGVyaWFsTW9kZWwgPSBudWxsO1xuXG4gICAgICAgIHZhciB1cmkgPSB0aGlzLmdldE1hdGVyaWFsU2NyaXB0KCk7XG4gICAgICAgIGlmICh1cmkuc2NoZW1lID09IFwidXJuXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFkYXB0ZXJIYW5kbGUoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbE1vZGVsID0geyBcInR5cGVcIjogXCJ1cm5cIiwgXCJ1cm5cIjogdXJpIH07XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNvbm5lY3RBZGFwdGVySGFuZGxlKFwic2NyaXB0XCIsIHRoaXMuZ2V0QWRhcHRlckhhbmRsZSh1cmksIFwiZGF0YVwiLCAwKSk7XG4gICAgICAgIHZhciBhZGFwdGVyID0gdGhpcy5nZXRDb25uZWN0ZWRBZGFwdGVyKCdzY3JpcHQnKTtcbiAgICAgICAgaWYgKGFkYXB0ZXIgJiYgYWRhcHRlci5nZXRTY3JpcHRUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXRlcmlhbE1vZGVsID0geyB0eXBlOiBhZGFwdGVyLmdldFNjcmlwdFR5cGUoKSwgc2NyaXB0OiBhZGFwdGVyLmdldFNjcmlwdCgpIH07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TWF0ZXJpYWxTY3JpcHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVUkkodGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcInNjcmlwdFwiKSk7XG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmFtZSA9PSBcInNjcmlwdFwiKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsQ29uZmlndXJhdGlvbigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5vdGlmeUNoYW5nZWQ6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRDpcbiAgICAgICAgICAgICAgICBpZiAoZXZ0LmhhbmRsZVN0YXR1cyA9PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgZmluZCBtYXRlcmlhbCBmb3IgdXJsICdcIiArIGV2dC51cmwgKyBcIidcIik7XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRlcmlhbENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG4vLyBFeHBvcnRcbm1vZHVsZS5leHBvcnRzID0gTWF0ZXJpYWxSZW5kZXJBZGFwdGVyO1xuXG4iLCJ2YXIgVHJhbnNmb3JtYWJsZUFkYXB0ZXIgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1hYmxlLmpzXCIpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTWVzaFJlbmRlckFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSkge1xuICAgIFRyYW5zZm9ybWFibGVBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgdGhpcy5zdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIHRoaXMuY3JlYXRlUmVuZGVyTm9kZSgpO1xufTtcblxuWE1MM0QuY3JlYXRlQ2xhc3MoTWVzaFJlbmRlckFkYXB0ZXIsIFRyYW5zZm9ybWFibGVBZGFwdGVyLCB7XG5cbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhQWRhcHRlciA9IFJlc291cmNlLmdldEFkYXB0ZXIodGhpcy5ub2RlLCBcImRhdGFcIik7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHBhcmVudC5nZXRSZW5kZXJOb2RlICYmIHBhcmVudC5nZXRSZW5kZXJOb2RlKCk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gdGhpcy5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlck9iamVjdCh7XG4gICAgICAgICAgICBwYXJlbnQ6IHBhcmVudE5vZGUsIG5vZGU6IHRoaXMubm9kZSwgb2JqZWN0OiB7XG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YUFkYXB0ZXIuZ2V0WGZsb3dOb2RlKCksIHR5cGU6IHRoaXMuZ2V0TWVzaFR5cGUoKVxuICAgICAgICAgICAgfSwgbmFtZTogdGhpcy5ub2RlLmlkXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy51cGRhdGVMb2NhbE1hdHJpeCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1hdGVyaWFsSGFuZGxlcigpO1xuICAgIH0sXG5cbiAgICBnZXRNZXNoVHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmhhc0F0dHJpYnV0ZShcInR5cGVcIikgPyB0aGlzLm5vZGUuZ2V0QXR0cmlidXRlKFwidHlwZVwiKSA6IFwidHJpYW5nbGVzXCI7XG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgaWYgKG5hbWUgPT0gXCJ0eXBlXCIpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS5zZXRUeXBlKG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzdHlsZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24oKSB7XG4gICAgICAgIFRyYW5zZm9ybWFibGVBZGFwdGVyLnByb3RvdHlwZS5zdHlsZUNoYW5nZWRDYWxsYmFjay5jYWxsKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVWaXNpYmlsaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vbmUgPSB0aGlzLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpLnRyaW0oKSA9PSBcIm5vbmVcIjtcbiAgICAgICAgdmFyIGhpZGRlbiAgPSB0aGlzLnN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJ2aXNpYmlsaXR5XCIpLnRyaW0oKSA9PSBcImhpZGRlblwiO1xuICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0TG9jYWxWaXNpYmxlKCEobm9uZSB8fCBoaWRkZW4pKTtcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnNldFBpY2thYmxlKCFub25lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudHMuTm90aWZpY2F0aW9ufSBldnRcbiAgICAgKi9cbiAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIFRyYW5zZm9ybWFibGVBZGFwdGVyLnByb3RvdHlwZS5ub3RpZnlDaGFuZ2VkLmNhbGwodGhpcywgZXZ0KTtcbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAgRXZlbnRzLk5PREVfSU5TRVJURUQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FzZSBFdmVudHMuVEhJU19SRU1PVkVEOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmNyZWF0ZVBlck9iamVjdERhdGEoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5jbGVhckFkYXB0ZXJIYW5kbGVzKCk7XG4gICAgfSxcblxuXG4gICAgLy8gSW50ZXJmYWNlIG1ldGhvZHNcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1hNTDNELkJveH1cbiAgICAgKi9cbiAgICBnZXRMb2NhbEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYm94ID0gbmV3IFhNTDNELkJveCgpO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJOb2RlICYmIHRoaXMucmVuZGVyTm9kZS52aXNpYmxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveChiYm94KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmJveDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7WE1MM0QuQm94fVxuICAgICAqL1xuICAgIGdldFdvcmxkQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgWE1MM0QuQm94KCk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlck5vZGUgJiYgdGhpcy5yZW5kZXJOb2RlLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS5nZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goYmJveCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge21hdDR9XG4gICAgICovXG4gICAgZ2V0V29ybGRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgWE1MM0QuTWF0NCgpLCBvYmogPSB0aGlzLnJlbmRlck5vZGU7XG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIG9iai5nZXRXb3JsZE1hdHJpeChtLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbn0pO1xuXG4vLyBFeHBvcnRcbm1vZHVsZS5leHBvcnRzID0gTWVzaFJlbmRlckFkYXB0ZXI7XG5cbiIsInZhciBUcmFuc2Zvcm1hYmxlQWRhcHRlciA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybWFibGUuanNcIik7XG52YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG52YXIgUmVzb3VyY2UgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9yZXNvdXJjZW1hbmFnZXIuanNcIikuUmVzb3VyY2U7XG52YXIgQWRhcHRlckhhbmRsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9iYXNlL2FkYXB0ZXJoYW5kbGUuanNcIik7XG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcblxudmFyIE1vZGVsUmVuZGVyQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XG4gICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5hc3NldCA9IG51bGw7XG4gICAgdGhpcy5wb3N0VHJhbnNmb3JtWGZsb3dSZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMucG9zdFRyYW5zZm9ybVJlbmRlckdyb3VwcyA9IFtdO1xuICAgIHRoaXMuc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKTtcbiAgICB0aGlzLl9iaW5kZWRSZXF1ZXN0Q2FsbGJhY2sgPSB0aGlzLm9uWGZsb3dSZXF1ZXN0Q2hhbmdlLmJpbmQodGhpcyk7XG4gICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyLnVwZGF0ZSgpO1xufTtcblxudmFyIGNfSURFTlRJVFkgPSBtYXQ0LmNyZWF0ZSgpO1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhNb2RlbFJlbmRlckFkYXB0ZXIsIFRyYW5zZm9ybWFibGVBZGFwdGVyLCB7XG5cbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhQWRhcHRlciA9IFJlc291cmNlLmdldEFkYXB0ZXIodGhpcy5ub2RlLCBcImRhdGFcIik7XG4gICAgICAgIHRoaXMuYXNzZXQgPSBkYXRhQWRhcHRlci5nZXRBc3NldCgpO1xuXG4gICAgICAgIHRoaXMuYXNzZXQuYWRkQ2hhbmdlTGlzdGVuZXIodGhpcyk7XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50UmVuZGVyQWRhcHRlcigpO1xuICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHBhcmVudC5nZXRSZW5kZXJOb2RlICYmIHBhcmVudC5nZXRSZW5kZXJOb2RlKCk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gdGhpcy5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlckdyb3VwKHtcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50Tm9kZSwgbmFtZTogdGhpcy5ub2RlLmlkXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0TG9jYWxNYXRyaXgoY19JREVOVElUWSk7XG4gICAgICAgIHRoaXMuY3JlYXRlTW9kZWxSZW5kZXJOb2RlcygpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcblxuICAgIH0sXG5cbiAgICBjbGVhck1vZGVsUmVuZGVyTm9kZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckFkYXB0ZXJIYW5kbGVzKCk7XG4gICAgICAgIHRoaXMuX3N1YlJlbmRlck5vZGVzID0gW107XG4gICAgICAgIHZhciBpID0gdGhpcy5wb3N0VHJhbnNmb3JtWGZsb3dSZXF1ZXN0cy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIHRoaXMucG9zdFRyYW5zZm9ybVhmbG93UmVxdWVzdHNbaV0uY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZWNfcmVtb3ZlUmVuZGVyTm9kZXModGhpcy5yZW5kZXJOb2RlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5wb3N0VHJhbnNmb3JtWGZsb3dSZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvc3RUcmFuc2Zvcm1SZW5kZXJHcm91cHMubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgY3JlYXRlTW9kZWxSZW5kZXJOb2RlczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNsZWFyTW9kZWxSZW5kZXJOb2RlcygpO1xuICAgICAgICBpZiAoIXRoaXMuYXNzZXQuaXNTdWJ0cmVlTG9hZGluZygpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzZXQuY2hlY2tWYWxpZGl0eSgpO1xuICAgICAgICAgICAgICAgIHZhciBhc3NldFJlc3VsdCA9IHRoaXMuYXNzZXQuZ2V0UmVzdWx0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGFUcmVlID0gYXNzZXRSZXN1bHQuZ2V0RGF0YVRyZWUoKTtcbiAgICAgICAgICAgICAgICByZWNfY3JlYXRlUmVuZGVyTm9kZXModGhpcywgdGhpcy5yZW5kZXJOb2RlLCBkYXRhVHJlZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJBc3NldCBFcnJvcjogXCIgKyBlLm1lc3NhZ2UsIGUubm9kZSB8fCB0aGlzLm5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJNb2RlbFJlbmRlck5vZGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uOiBmdW5jdGlvbiAobWF0ZXJpYWxVUkksIGluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAobWF0ZXJpYWxVUkkpIHtcbiAgICAgICAgICAgIHZhciBhZGFwdGVySGFuZGxlID0gdGhpcy5nZXRBZGFwdGVySGFuZGxlKG1hdGVyaWFsVVJJKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdEFkYXB0ZXJIYW5kbGUoXCJtYXRlcmlhbF9cIiArIGluZGV4LCBhZGFwdGVySGFuZGxlKTtcblxuICAgICAgICAgICAgc3dpdGNoIChhZGFwdGVySGFuZGxlLnN0YXR1cykge1xuXG4gICAgICAgICAgICAgICAgY2FzZSBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQ6XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGZpbmQgPG1hdGVyaWFsPiBvZiB1cmwgJ1wiICsgYWRhcHRlckhhbmRsZS51cmwgKyBcIicgXCIsIHRoaXMubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQWRhcHRlckhhbmRsZS5TVEFUVVMuUkVBRFk6XG4gICAgICAgICAgICAgICAgICAgIHZhciBhZGFwdGVyID0gYWRhcHRlckhhbmRsZS5nZXRBZGFwdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGFwdGVyICYmIGFkYXB0ZXIuZ2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBhZGFwdGVyLmdldE1hdGVyaWFsQ29uZmlndXJhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQWRhcHRlckhhbmRsZS5TVEFUVVMuTE9BRElORzpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgfSxcblxuICAgIHN0eWxlQ2hhbmdlZENhbGxiYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIucHJvdG90eXBlLnN0eWxlQ2hhbmdlZENhbGxiYWNrLmNhbGwoKTtcbiAgICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVZpc2liaWxpdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbm9uZSA9IHRoaXMuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcImRpc3BsYXlcIikudHJpbSgpID09IFwibm9uZVwiO1xuICAgICAgICB2YXIgaGlkZGVuICA9IHRoaXMuc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInZpc2liaWxpdHlcIikudHJpbSgpID09IFwiaGlkZGVuXCI7XG4gICAgICAgIHZhciB2aXNpYmxlID0gIShub25lIHx8IGhpZGRlbik7XG4gICAgICAgIHZhciBwcm9wYWdhdGUgPSBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5zZXRMb2NhbFZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgbm9kZS5zZXRMb2NhbFZpc2libGUodmlzaWJsZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKHByb3BhZ2F0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb3BhZ2F0ZSh0aGlzLnJlbmRlck5vZGUpO1xuICAgICAgICAvLyBUT0RPKGtzb25zKTogdGhpcy5yZW5kZXJOb2RlLnNldFBpY2thYmxlKCFub25lKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZXZ0XG4gICAgICovXG4gICAgbm90aWZ5Q2hhbmdlZDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5wcm90b3R5cGUubm90aWZ5Q2hhbmdlZC5jYWxsKHRoaXMsIGV2dCk7XG4gICAgICAgIHN3aXRjaCAoZXZ0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgIEV2ZW50cy5OT0RFX0lOU0VSVEVEOlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgRXZlbnRzLlRISVNfUkVNT1ZFRDpcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlIEV2ZW50cy5BREFQVEVSX0hBTkRMRV9DSEFOR0VEOlxuICAgICAgICAgICAgICAgIHZhciBzcGxpdHMgPSBldnQua2V5LnNwbGl0KFwiX1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRzWzBdID09IFwibWF0ZXJpYWxcIikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyTm9kZUlkID0gK3NwbGl0c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaWRlbnRpZnkgdGhlIGNvcnJlc3BvbmRpbmcgcmVuZGVybm9kZSBieSB0aGUgaGFuZGxlciBrZXlcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCBpZiB0aGVyZSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gY3VzdG9tIGNhbGxiYWNrcyBmb3JcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlck5vZGUgPSB0aGlzLl9zdWJSZW5kZXJOb2Rlc1tyZW5kZXJOb2RlSWRdO1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQocmVuZGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldnQuaGFuZGxlU3RhdHVzID09IEFkYXB0ZXJIYW5kbGUuU1RBVFVTLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyTm9kZS5zZXRNYXRlcmlhbChudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGFwdGVyID0gZXZ0LmFkYXB0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWRhcHRlciAmJiBhZGFwdGVyLmdldE1hdGVyaWFsQ29uZmlndXJhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlck5vZGUuc2V0TWF0ZXJpYWwoYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWN0b3J5LnJlbmRlcmVyLnJlcXVlc3RSZWRyYXcoXCJNYXRlcmlhbCBtb2RlbCBjaGFuZ2VkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgb25Bc3NldENoYW5nZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgaWYgKCF0aGlzLnJlbmRlck5vZGUpIHtcbiAgICAgICAgICAgIC8vVGhpcyBtb2RlbCBoYXNuJ3QgZXZlbiBiZWVuIGluaXRpYWxpemVkIHlldCBzbyB3ZSBkZWZlciBidWlsZGluZyB0aGUgcmVuZGVyIG5vZGVzIHRvIHRoYXQgc3RlcFxuICAgICAgICAgICAgLy9UaGlzIGNhbiBoYXBwZW4gZm9yIGV4LiB3aGVuIGNoYW5naW5nIHRoZSBcInNyY1wiIGF0dHJpYnV0ZSBiZWZvcmUgdGhlIG1vZGVsIGlzIGFwcGVuZGVkIGludG8gdGhlIERPTVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jcmVhdGVNb2RlbFJlbmRlck5vZGVzKCk7XG4gICAgfSxcblxuICAgIG9uWGZsb3dSZXF1ZXN0Q2hhbmdlOiBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLnBvc3RUcmFuc2Zvcm1YZmxvd1JlcXVlc3RzLmluZGV4T2YocmVxdWVzdCk7XG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3N0VHJhbnNmb3JtKHRoaXMucG9zdFRyYW5zZm9ybVJlbmRlckdyb3Vwc1tpbmRleF0sIHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHVwZGF0ZVBvc3RUcmFuc2Zvcm06IGZ1bmN0aW9uIChyZW5kZXJOb2RlLCB4Zmxvd1JlcXVlc3QpIHtcbiAgICAgICAgdmFyIGRhdGFSZXN1bHQgPSB4Zmxvd1JlcXVlc3QuZ2V0UmVzdWx0KCk7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1EYXRhID0gKGRhdGFSZXN1bHQuZ2V0T3V0cHV0RGF0YShcInRyYW5zZm9ybVwiKSAmJiBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEoXCJ0cmFuc2Zvcm1cIikuZ2V0VmFsdWUoKSk7XG4gICAgICAgIGlmICghdHJhbnNmb3JtRGF0YSkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIlBvc3QgVHJhbnNmb3JtIGVudHJ5IGRvZXMgbm90IGNvbnRhaW4gYW55ICd0cmFuc2Zvcm0nIHZhbHVlLlwiLCB0aGlzLm5vZGUpO1xuICAgICAgICAgICAgcmVuZGVyTm9kZS5zZXRMb2NhbE1hdHJpeChjX0lERU5USVRZKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJOb2RlLnNldExvY2FsTWF0cml4KHRyYW5zZm9ybURhdGEpO1xuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYXNzZXQucmVtb3ZlQ2hhbmdlTGlzdGVuZXIodGhpcyk7XG4gICAgICAgIHRoaXMuY2xlYXJNb2RlbFJlbmRlck5vZGVzKCk7XG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyTm9kZSgpLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gcmVjX3JlbW92ZVJlbmRlck5vZGVzKG5vZGUsIGtlZXBDdXJyZW50Tm9kZSkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgha2VlcEN1cnJlbnROb2RlKVxuICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHJlY19yZW1vdmVSZW5kZXJOb2RlcyhjaGlsZHJlbltpXSwgZmFsc2UpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVjX2NyZWF0ZVJlbmRlck5vZGVzKGFkYXB0ZXIsIHBhcmVudE5vZGUsIGRhdGFUcmVlTm9kZSkge1xuXG4gICAgaWYgKGRhdGFUcmVlTm9kZS5wb3N0VHJhbnNmb3JtWGZsb3dOb2RlKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KGRhdGFUcmVlTm9kZS5wb3N0VHJhbnNmb3JtWGZsb3dOb2RlLCBbXCJ0cmFuc2Zvcm1cIl0sIGFkYXB0ZXIuX2JpbmRlZFJlcXVlc3RDYWxsYmFjayk7XG4gICAgICAgIHBhcmVudE5vZGUgPSBhZGFwdGVyLmdldFNjZW5lKCkuY3JlYXRlUmVuZGVyR3JvdXAoe1xuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlLCB2aXNpYmxlOiB0cnVlLCBuYW1lOiB1bmRlZmluZWRcbiAgICAgICAgfSk7XG4gICAgICAgIGFkYXB0ZXIucG9zdFRyYW5zZm9ybVhmbG93UmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgYWRhcHRlci5wb3N0VHJhbnNmb3JtUmVuZGVyR3JvdXBzLnB1c2gocGFyZW50Tm9kZSk7XG4gICAgICAgIGFkYXB0ZXIudXBkYXRlUG9zdFRyYW5zZm9ybShwYXJlbnROb2RlLCByZXF1ZXN0KTtcbiAgICB9XG5cbiAgICB2YXIgZ3JvdXBOb2RlID0gYWRhcHRlci5nZXRTY2VuZSgpLmNyZWF0ZVJlbmRlckdyb3VwKHtcbiAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlLFxuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgICBuYW1lOiBhZGFwdGVyLm5vZGUuaWRcbiAgICB9KTtcbiAgICBncm91cE5vZGUuc2V0TG9jYWxNYXRyaXgoZGF0YVRyZWVOb2RlLnRyYW5zZm9ybSB8fCBjX0lERU5USVRZKTtcbiAgICBncm91cE5vZGUuc2V0TWF0ZXJpYWwoYWRhcHRlci5nZXRNYXRlcmlhbENvbmZpZ3VyYXRpb24oZGF0YVRyZWVOb2RlLm1hdGVyaWFsLCBhZGFwdGVyLl9zdWJSZW5kZXJOb2Rlcy5sZW5ndGgpKTtcbiAgICBhZGFwdGVyLl9zdWJSZW5kZXJOb2Rlcy5wdXNoKGdyb3VwTm9kZSk7XG5cbiAgICB2YXIgbWVzaFNldHMgPSBkYXRhVHJlZU5vZGUubWVzaGVzLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXNoU2V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IGFkYXB0ZXIuZ2V0U2NlbmUoKS5jcmVhdGVSZW5kZXJPYmplY3Qoe1xuICAgICAgICAgICAgcGFyZW50OiBncm91cE5vZGUsXG4gICAgICAgICAgICBub2RlOiBtZXNoU2V0c1tpXS5yZWZOb2RlIHx8IGFkYXB0ZXIubm9kZSxcbiAgICAgICAgICAgIG9iamVjdDoge1xuICAgICAgICAgICAgICAgIGRhdGE6IG1lc2hTZXRzW2ldLnhmbG93Tm9kZSwgdHlwZTogbWVzaFNldHNbaV0udHlwZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IGFkYXB0ZXIubm9kZS5pZCxcbiAgICAgICAgICAgIHZpc2libGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJlbmRlck5vZGUuc2V0TG9jYWxNYXRyaXgobWVzaFNldHNbaV0udHJhbnNmb3JtIHx8IGNfSURFTlRJVFkpO1xuICAgICAgICByZW5kZXJOb2RlLnNldE1hdGVyaWFsKGFkYXB0ZXIuZ2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uKG1lc2hTZXRzW2ldLm1hdGVyaWFsLCBhZGFwdGVyLl9zdWJSZW5kZXJOb2Rlcy5sZW5ndGgpKTtcbiAgICAgICAgYWRhcHRlci5fc3ViUmVuZGVyTm9kZXMucHVzaChyZW5kZXJOb2RlKTtcbiAgICB9XG4gICAgdmFyIGdyb3VwcyA9IGRhdGFUcmVlTm9kZS5ncm91cHM7XG4gICAgZm9yIChpID0gMDsgaSA8IGdyb3Vwcy5sZW5ndGg7ICsraSkge1xuICAgICAgICByZWNfY3JlYXRlUmVuZGVyTm9kZXMoYWRhcHRlciwgZ3JvdXBOb2RlLCBncm91cHNbaV0pO1xuICAgIH1cbn1cblxuXG4vLyBJbnRlcmZhY2UgbWV0aG9kc1xuXG5YTUwzRC5leHRlbmQoTW9kZWxSZW5kZXJBZGFwdGVyLnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge1hNTDNELkJveH1cbiAgICAgKi9cbiAgICBnZXRMb2NhbEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBiYm94ID0gbmV3IFhNTDNELkJveCgpO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveChiYm94KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmJveDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7WE1MM0QuQm94fVxuICAgICAqL1xuICAgIGdldFdvcmxkQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgWE1MM0QuQm94KCk7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS5nZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goYmJveCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJib3g7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge21hdDR9XG4gICAgICovXG4gICAgZ2V0V29ybGRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgWE1MM0QuTWF0NCgpLCBvYmogPSB0aGlzLnJlbmRlck5vZGU7XG4gICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgIG9iai5nZXRXb3JsZE1hdHJpeChtLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbn0pO1xuXG4vLyBFeHBvcnRcbm1vZHVsZS5leHBvcnRzID0gTW9kZWxSZW5kZXJBZGFwdGVyO1xuXG4iLCJ2YXIgUmVuZGVyQWRhcHRlciA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG52YXIgRE9NVHJhbnNmb3JtRmV0Y2hlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9kYXRhL3RyYW5zZm9ybS1mZXRjaGVyLmpzXCIpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xudmFyIEFkYXB0ZXJIYW5kbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vYmFzZS9hZGFwdGVyaGFuZGxlLmpzXCIpO1xuXG52YXIgVHJhbnNmb3JtYWJsZUFkYXB0ZXIgPSBmdW5jdGlvbiAoZmFjdG9yeSwgbm9kZSwgaGFuZGxlTWF0ZXJpYWwsIGhhbmRsZVRyYW5zZm9ybSkge1xuICAgIFJlbmRlckFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlKTtcbiAgICB0aGlzLnJlbmRlck5vZGUgPSBudWxsO1xuICAgIHRoaXMubWF0ZXJpYWxIYW5kbGVyID0gbnVsbDtcbiAgICB0aGlzLmhhbmRsZU1hdGVyaWFsID0gaGFuZGxlTWF0ZXJpYWwgfHwgZmFsc2U7XG4gICAgaWYgKGhhbmRsZVRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIgPSBuZXcgRE9NVHJhbnNmb3JtRmV0Y2hlcih0aGlzLCBcInRyYW5zZm9ybVwiLCBcInRyYW5zZm9ybVwiKTtcbiAgICB9XG5cbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKFRyYW5zZm9ybWFibGVBZGFwdGVyLCBSZW5kZXJBZGFwdGVyLCB7XG5cbiAgICB1cGRhdGVNYXRlcmlhbEhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hdGVyaWFsVVJJID0gZ2V0TWF0ZXJpYWxVUkkodGhpcy5ub2RlKTtcbiAgICAgICAgaWYgKCFtYXRlcmlhbFVSSSkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWRhcHRlckhhbmRsZShcIm1hdGVyaWFsXCIpO1xuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbEhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXRlcmlhbEhhbmRsZXIgPSB0aGlzLmdldEFkYXB0ZXJIYW5kbGUobWF0ZXJpYWxVUkkpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0QWRhcHRlckhhbmRsZShcIm1hdGVyaWFsXCIsIHRoaXMubWF0ZXJpYWxIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZmVyZW5jZWRNYXRlcmlhbENoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgcmVmZXJlbmNlZE1hdGVyaWFsQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubWF0ZXJpYWxIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5zZXRNYXRlcmlhbChudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdHVzID0gdGhpcy5tYXRlcmlhbEhhbmRsZXIuc3RhdHVzO1xuICAgICAgICBpZiAoc3RhdHVzID09PSBBZGFwdGVySGFuZGxlLlNUQVRVUy5OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ291bGQgbm90IGZpbmQgZWxlbWVudCBvZiB1cmwgJ1wiICsgdGhpcy5tYXRlcmlhbEhhbmRsZXIudXJsICsgXCInIGZvciBtYXRlcmlhbFwiLCB0aGlzLm5vZGUpO1xuICAgICAgICAgICAgdGhpcy5nZXRSZW5kZXJOb2RlKCkuc2V0TWF0ZXJpYWwobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkYXB0ZXIgPSB0aGlzLm1hdGVyaWFsSGFuZGxlci5nZXRBZGFwdGVyKCk7XG4gICAgICAgIGlmIChhZGFwdGVyICYmIGFkYXB0ZXIuZ2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmdldFJlbmRlck5vZGUoKS5zZXRNYXRlcmlhbChhZGFwdGVyLmdldE1hdGVyaWFsQ29uZmlndXJhdGlvbigpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0UmVuZGVyTm9kZSgpLnNldE1hdGVyaWFsKG51bGwpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG9uRGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUZldGNoZXIgJiYgdGhpcy50cmFuc2Zvcm1GZXRjaGVyLmNsZWFyKCk7XG4gICAgfSxcblxuICAgIG9uQ29uZmlndXJlZDogZnVuY3Rpb24gKCkge1xuICAgIH0sXG5cbiAgICBnZXRSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUgPSB0aGlzLmNyZWF0ZVJlbmRlck5vZGUgPyB0aGlzLmNyZWF0ZVJlbmRlck5vZGUoKSA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxvY2FsTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyTm9kZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlTG9jYWxNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1GZXRjaGVyICYmIHRoaXMudHJhbnNmb3JtRmV0Y2hlci51cGRhdGUoKTtcbiAgICB9LFxuXG4gICAgb25UcmFuc2Zvcm1DaGFuZ2U6IGZ1bmN0aW9uIChhdHRyTmFtZSwgbWF0cml4KSB7XG4gICAgICAgIGlmIChhdHRyTmFtZSA9PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0TG9jYWxNYXRyaXgobWF0cml4KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suY2FsbCh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUpO1xuXG4gICAgICAgIGlmIChuYW1lID09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRmV0Y2hlciAmJiB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcInN0eWxlXCIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtRmV0Y2hlciAmJiB0aGlzLnRyYW5zZm9ybUZldGNoZXIudXBkYXRlTWF0cml4KCk7XG4gICAgICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcIm1hdGVyaWFsXCIgJiYgdGhpcy5oYW5kbGVNYXRlcmlhbCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVNYXRlcmlhbEhhbmRsZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZmFjdG9yeS5yZW5kZXJlci5yZXF1ZXN0UmVkcmF3KFwiVHJhbnNmb3JtYWJsZSBtYXRlcmlhbCBjaGFuZ2VkLlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBub3RpZnlDaGFuZ2VkOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgIGlmIChldnQudHlwZSA9PSBFdmVudHMuQURBUFRFUl9IQU5ETEVfQ0hBTkdFRCkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGV2dC5rZXk7XG4gICAgICAgICAgICBpZiAoa2V5ID09IFwibWF0ZXJpYWxcIikge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTWF0ZXJpYWxIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWN0b3J5LnJlbmRlcmVyLnJlcXVlc3RSZWRyYXcoXCJNYXRlcmlhbCByZWZlcmVuY2UgY2hhbmdlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuZnVuY3Rpb24gZ2V0TWF0ZXJpYWxVUkkobm9kZSkge1xuICAgIHZhciBtYXRlcmlhbFVSSSA9IG5vZGUuZ2V0QXR0cmlidXRlKFwibWF0ZXJpYWxcIik7XG4gICAgaWYgKCFtYXRlcmlhbFVSSSkge1xuICAgICAgICB2YXIgc3R5bGVWYWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIHBhdHRlcm4gPSAvbWF0ZXJpYWxcXHMqOlxccyp1cmxcXHMqXFwoXFxzKihcXFMrKVxccypcXCkvaTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBwYXR0ZXJuLmV4ZWMoc3R5bGVWYWx1ZSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgICAgIG1hdGVyaWFsVVJJID0gcmVzdWx0WzFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXRlcmlhbFVSSTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm1hYmxlQWRhcHRlcjtcbiIsInZhciBUcmFuc2Zvcm1hYmxlQWRhcHRlciA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybWFibGUuanNcIik7XG52YXIgRE9NVHJhbnNmb3JtRmV0Y2hlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9kYXRhL3RyYW5zZm9ybS1mZXRjaGVyLmpzXCIpO1xudmFyIEV2ZW50cyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9pbnRlcmZhY2Uvbm90aWZpY2F0aW9uLmpzXCIpO1xudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XG5cbnZhciBWaWV3UmVuZGVyQWRhcHRlciA9IGZ1bmN0aW9uIChmYWN0b3J5LCBub2RlKSB7XG4gICAgVHJhbnNmb3JtYWJsZUFkYXB0ZXIuY2FsbCh0aGlzLCBmYWN0b3J5LCBub2RlLCBmYWxzZSwgZmFsc2UpO1xuICAgIHRoaXMucHJvamVjdGlvbkZldGNoZXIgPSBuZXcgRE9NVHJhbnNmb3JtRmV0Y2hlcih0aGlzLCBcInByb2plY3Rpb25cIiwgXCJwcm9qZWN0aW9uXCIsIHRydWUpO1xuICAgIHRoaXMuY3JlYXRlUmVuZGVyTm9kZSgpO1xufTtcblxuWE1MM0QuY3JlYXRlQ2xhc3MoVmlld1JlbmRlckFkYXB0ZXIsIFRyYW5zZm9ybWFibGVBZGFwdGVyLCB7XG5cbiAgICBjcmVhdGVSZW5kZXJOb2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldFBhcmVudFJlbmRlckFkYXB0ZXIoKTtcbiAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBwYXJlbnQuZ2V0UmVuZGVyTm9kZSA/IHBhcmVudC5nZXRSZW5kZXJOb2RlKCkgOiB0aGlzLmZhY3RvcnkucmVuZGVyZXIuc2NlbmUuY3JlYXRlUm9vdE5vZGUoKTtcbiAgICAgICAgdmFyIHJvdCA9IHRoaXMubm9kZS5vcmllbnRhdGlvbi5kYXRhO1xuICAgICAgICB2YXIgbSA9IG1hdDQuZnJvbVJvdGF0aW9uKG1hdDQuY3JlYXRlKCksIHJvdFszXSwgcm90KTtcbiAgICAgICAgdGhpcy5yZW5kZXJOb2RlID0gdGhpcy5mYWN0b3J5LnJlbmRlcmVyLnNjZW5lLmNyZWF0ZVJlbmRlclZpZXcoe1xuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMubm9kZS5wb3NpdGlvbi5kYXRhLFxuICAgICAgICAgICAgb3JpZW50YXRpb246IG0sXG4gICAgICAgICAgICBmaWVsZE9mVmlldzogdGhpcy5ub2RlLmZpZWxkT2ZWaWV3LFxuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnROb2RlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnByb2plY3Rpb25GZXRjaGVyLnVwZGF0ZSgpO1xuICAgIH0sXG5cbiAgICAvKiBJbnRlcmZhY2UgbWV0aG9kICovXG4gICAgZ2V0Vmlld01hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbSA9IG5ldyBYTUwzRC5NYXQ0KCk7XG4gICAgICAgIHRoaXMucmVuZGVyTm9kZS5nZXRXb3JsZFRvVmlld01hdHJpeChtLmRhdGEpO1xuICAgICAgICByZXR1cm4gbTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB2aWV3MndvcmxkIG1hdHJpeFxuICAgICAqIEByZXR1cm4ge21hdDR9XG4gICAgICovXG4gICAgZ2V0V29ybGRNYXRyaXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG0gPSBuZXcgWE1MM0QuTWF0NCgpO1xuICAgICAgICB0aGlzLnJlbmRlck5vZGUuZ2V0Vmlld1RvV29ybGRNYXRyaXgobS5kYXRhKTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazogZnVuY3Rpb24gKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwodGhpcywgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwib3JpZW50YXRpb25cIjpcbiAgICAgICAgICAgICAgICB2YXIgcm90ID0gdGhpcy5ub2RlLm9yaWVudGF0aW9uLmRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIG0gPSBtYXQ0LmZyb21Sb3RhdGlvbihtYXQ0LmNyZWF0ZSgpLCByb3RbM10sIHJvdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnVwZGF0ZU9yaWVudGF0aW9uKG0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBvc2l0aW9uXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJOb2RlLnVwZGF0ZVBvc2l0aW9uKHRoaXMubm9kZS5wb3NpdGlvbi5kYXRhKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwcm9qZWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRmV0Y2hlci51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaWVsZG9mdmlld1wiOlxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTm9kZS51cGRhdGVGaWVsZE9mVmlldyh0aGlzLm5vZGUuZmllbGRPZlZpZXcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiVW5oYW5kbGVkIHZhbHVlIGNoYW5nZWQgZXZlbnQgaW4gdmlldyBhZGFwdGVyIGZvciBhdHRyaWJ1dGU6XCIgKyB0YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIG5vdGlmeUNoYW5nZWQ6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgc3dpdGNoIChldnQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBFdmVudHMuVEhJU19SRU1PVkVEOlxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFjdG9yeS5nZXRSZW5kZXJlcigpLnJlcXVlc3RSZWRyYXcoXCJWaWV3IGNoYW5nZWRcIik7XG4gICAgfSxcblxuICAgIG9uVHJhbnNmb3JtQ2hhbmdlOiBmdW5jdGlvbiAoYXR0ck5hbWUsIG1hdHJpeCkge1xuICAgICAgICBUcmFuc2Zvcm1hYmxlQWRhcHRlci5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UuY2FsbCh0aGlzLCBhdHRyTmFtZSwgbWF0cml4KTtcbiAgICAgICAgaWYgKGF0dHJOYW1lID09IFwicHJvamVjdGlvblwiKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vZGUuc2V0UHJvamVjdGlvbk92ZXJyaWRlKG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcG9zZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2plY3Rpb25GZXRjaGVyLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyTm9kZSgpLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmNsZWFyQWRhcHRlckhhbmRsZXMoKTtcbiAgICB9XG59KTtcblxuLy8gRXhwb3J0XG5tb2R1bGUuZXhwb3J0cyA9IFZpZXdSZW5kZXJBZGFwdGVyO1xuXG4iLCJ2YXIgUmVuZGVyQWRhcHRlciA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMuanNcIik7XG52YXIgRXZlbnRzID0gcmVxdWlyZShcIi4uLy4uLy4uL2ludGVyZmFjZS9ub3RpZmljYXRpb24uanNcIik7XG52YXIgZGlzcGF0Y2hDdXN0b21FdmVudCA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9taXNjLmpzXCIpLmRpc3BhdGNoQ3VzdG9tRXZlbnQ7XG52YXIgZ2V0T3JDcmVhdGVBY3RpdmVWaWV3ID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxzL21pc2MuanNcIikuZ2V0T3JDcmVhdGVBY3RpdmVWaWV3O1xudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uLy4uLy4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xuXG52YXIgWE1MM0RSZW5kZXJBZGFwdGVyID0gZnVuY3Rpb24gKGZhY3RvcnksIG5vZGUpIHtcbiAgICBSZW5kZXJBZGFwdGVyLmNhbGwodGhpcywgZmFjdG9yeSwgbm9kZSk7XG4gICAgdGhpcy5maXJlTG9hZEV2ZW50QWZ0ZXJEcmF3ID0gZmFsc2U7XG4gICAgdGhpcy5maXJzdExvYWRGaXJlZCA9IGZhbHNlO1xufTtcblhNTDNELmNyZWF0ZUNsYXNzKFhNTDNEUmVuZGVyQWRhcHRlciwgUmVuZGVyQWRhcHRlciwge1xuICAgIHVwZGF0ZUFjdGl2ZVZpZXdBZGFwdGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBocmVmID0gdGhpcy5ub2RlLmdldEF0dHJpYnV0ZShcImFjdGl2ZVZpZXdcIik7XG4gICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RBZGFwdGVySGFuZGxlKFwiYWN0aXZlVmlld1wiLCB0aGlzLmdldEFkYXB0ZXJIYW5kbGUoaHJlZikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWRhcHRlckhhbmRsZShcImFjdGl2ZVZpZXdcIik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0Vmlld0FkYXB0ZXI6IGZ1bmN0aW9uIChhZGFwdGVyKSB7XG4gICAgICAgIGFkYXB0ZXIgPSBhZGFwdGVyIHx8IHRoaXMuZ2V0Q29ubmVjdGVkQWRhcHRlcihcImFjdGl2ZVZpZXdcIik7XG4gICAgICAgIGlmICghKGFkYXB0ZXIgJiYgYWRhcHRlci5nZXRSZW5kZXJOb2RlKSkge1xuICAgICAgICAgICAgdmFyIHZpZXdFbGVtZW50ID0gZ2V0T3JDcmVhdGVBY3RpdmVWaWV3KHRoaXMubm9kZSk7XG4gICAgICAgICAgICBhZGFwdGVyID0gdGhpcy5mYWN0b3J5LmdldEFkYXB0ZXIodmlld0VsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmFjdG9yeS5nZXRTY2VuZSgpLnNldEFjdGl2ZVZpZXcoYWRhcHRlci5nZXRSZW5kZXJOb2RlKCkpO1xuICAgIH0sXG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6IGZ1bmN0aW9uKG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSkge1xuICAgICAgICBpZihuYW1lLnRvTG93ZXJDYXNlKCkgPT0gXCJhY3RpdmV2aWV3XCIpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQWN0aXZlVmlld0FkYXB0ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0Vmlld0FkYXB0ZXIoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJBZGFwdGVySGFuZGxlcygpO1xuICAgIH1cbn0pO1xuXG5YTUwzRFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLm5vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbiAoZXZ0KSB7XG5cbiAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICAgIGNhc2UgRXZlbnRzLkFEQVBURVJfSEFORExFX0NIQU5HRUQ6XG4gICAgICAgICAgICB0aGlzLnNldFZpZXdBZGFwdGVyKGV2dC5hZGFwdGVyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY2FzZSBFdmVudHMuTk9ERV9JTlNFUlRFRDpcbiAgICAgICAgICAgIC8vIFRoaXMgYWxzbyBpbml0aWFsaXplcyB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgIHRoaXMuaW5pdEVsZW1lbnQoZXZ0Lm11dGF0aW9uLnRhcmdldCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgRXZlbnRzLk5PREVfUkVNT1ZFRDpcbiAgICAgICAgICAgIC8vIEhhbmRsZWQgaW4gcmVtb3ZlZCBub2RlXG4gICAgICAgICAgICByZXR1cm47XG4gICAgfVxufTtcblxuLyogSW50ZXJmYWNlIG1ldGhvZHMgKi9cblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW4gc2NlbmUgRE9NIGlzIGxvYWRlZCBhbmQgYWxsIGFkYXB0ZXJzIGFyZSBhdHRhY2hlZFxuICovXG5YTUwzRFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLm9uQ29uZmlndXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVwZGF0ZUFjdGl2ZVZpZXdBZGFwdGVyKCk7XG4gICAgdGhpcy5zZXRWaWV3QWRhcHRlcigpO1xuXG4gICAgLy8gZW1pdCBsb2FkIGV2ZW50IHdoZW4gYWxsIHJlc291cmNlcyBjdXJyZW50bHkgbG9hZGluZyBhcmUgY29tcGxldGVkXG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5vbkxvYWRDb21wbGV0ZS5iaW5kKHRoaXMpO1xuICAgIC8vIHJlZ2lzdGVyIGNhbGxiYWNrIGZvciBjYW52YXNJZCA9PSAwIGkuZS4gZ2xvYmFsIHJlc291cmNlc1xuICAgIFJlc291cmNlLmFkZExvYWRDb21wbGV0ZUxpc3RlbmVyKDAsIGNhbGxiYWNrKTtcbiAgICAvLyByZWdpc3RlciBjYWxsYmFjayBmb3IgY2FudmFzSWQgb2YgdGhpcyBub2RlXG4gICAgUmVzb3VyY2UuYWRkTG9hZENvbXBsZXRlTGlzdGVuZXIodGhpcy5mYWN0b3J5LmNhbnZhc0lkLCBjYWxsYmFjayk7XG4gICAgdGhpcy5vbkxvYWRDb21wbGV0ZSgpO1xufTtcblxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5vbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChjYW52YXNJZCkge1xuICAgIGlmIChSZXNvdXJjZS5pc0xvYWRDb21wbGV0ZSgwKSAmJiBSZXNvdXJjZS5pc0xvYWRDb21wbGV0ZSh0aGlzLmZhY3RvcnkuY2FudmFzSWQpKSB7XG4gICAgICAgIHRoaXMuZmlyZUxvYWRFdmVudEFmdGVyRHJhdyA9IHRydWU7XG4gICAgfVxufTtcblxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5vbkZyYW1lRHJhd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmlyZUxvYWRFdmVudEFmdGVyRHJhdykge1xuICAgICAgICB0aGlzLmZpcmVMb2FkRXZlbnRBZnRlckRyYXcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maXJzdExvYWRGaXJlZCA9IHRydWU7XG4gICAgICAgIGRpc3BhdGNoQ3VzdG9tRXZlbnQodGhpcy5ub2RlLCAnbG9hZCcsIGZhbHNlLCB0cnVlLCBudWxsKTtcbiAgICB9XG59O1xuXG5cblhNTDNEUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuZmlyZUxvYWRFdmVudEFmdGVyRHJhdykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdGhpcy5maXJzdExvYWRGaXJlZCkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiBSZXNvdXJjZS5pc0xvYWRDb21wbGV0ZSgwKSAmJiBSZXNvdXJjZS5pc0xvYWRDb21wbGV0ZSh0aGlzLmZhY3RvcnkuY2FudmFzSWQpO1xufTtcblxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRXb3JsZEJvdW5kaW5nQm94ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBiYm94ID0gbmV3IFhNTDNELkJveCgpO1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwodGhpcy5ub2RlLmNoaWxkTm9kZXMsIGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmIChjLmdldFdvcmxkQm91bmRpbmdCb3gpIHtcbiAgICAgICAgICAgIGJib3guZXh0ZW5kKGMuZ2V0V29ybGRCb3VuZGluZ0JveCgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBiYm94O1xufTtcbi8vWE1MM0QgZWxlbWVudCBpcyB0aGUgcm9vdCB3aXRoIG5vIHRyYW5zZm9ybSBvZiBpdHMgb3duIHNvIGJ5IGRlZmluaXRpb24gaXQncyBhbHdheXMgaW4gd29ybGQgc3BhY2VcblhNTDNEUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0TG9jYWxCb3VuZGluZ0JveCA9IFhNTDNEUmVuZGVyQWRhcHRlci5wcm90b3R5cGUuZ2V0V29ybGRCb3VuZGluZ0JveDtcblxuLyoqXG4gKlxuICogQHBhcmFtIHggbnVtYmVyIHggY29vcmRpbmF0ZSBpbiBzY3JlZW4gc3BhY2VcbiAqIEBwYXJhbSB5IG51bWJlciB5IGNvb3JkaW5hdGUgaW4gc2NyZWVuIHNwYWNlXG4gKiBAcGFyYW0gaGl0UG9pbnQ/IFhNTDNELlZlYzNcbiAqIEBwYXJhbSBoaXROb3JtYWw/IFhNTDNELlZlYzNcbiAqIEByZXR1cm5zIHsqfVxuICovXG5YTUwzRFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRCeVBvaW50ID0gZnVuY3Rpb24gKHgsIHksIGhpdFBvaW50LCBoaXROb3JtYWwpIHtcbiAgICB2YXIgcmVsYXRpdmVNb3VzZVBvcyA9IFV0aWxzLmNvbnZlcnRQYWdlQ29vcmRzKHRoaXMubm9kZSwgeCwgeSk7XG5cbiAgICB2YXIgcmVsWCA9IHJlbGF0aXZlTW91c2VQb3MueDtcbiAgICB2YXIgcmVsWSA9IHJlbGF0aXZlTW91c2VQb3MueTtcblxuICAgIHZhciByZW5kZXJlciA9IHRoaXMuZmFjdG9yeS5nZXRSZW5kZXJlcigpO1xuICAgIHZhciBvYmplY3QgPSByZW5kZXJlci5nZXRSZW5kZXJPYmplY3RGcm9tUGlja2luZ0J1ZmZlcihyZWxYLCByZWxZKTtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICAgIGlmIChoaXRQb2ludCkge1xuICAgICAgICAgICAgdmFyIHZlYyA9IHJlbmRlcmVyLmdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UG9pbnQocmVsWCwgcmVsWSwgb2JqZWN0KTtcbiAgICAgICAgICAgIFhNTDNELm1hdGgudmVjMy5jb3B5KGhpdFBvaW50LmRhdGEsIHZlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhpdE5vcm1hbCkge1xuICAgICAgICAgICAgdmFyIHZlYyA9IHJlbmRlcmVyLmdldFdvcmxkU3BhY2VOb3JtYWxCeVBvaW50KHJlbFgsIHJlbFksIG9iamVjdCk7XG4gICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzMuY29weShoaXROb3JtYWwuZGF0YSwgdmVjKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoaXRQb2ludCkge1xuICAgICAgICAgICAgaGl0UG9pbnQueCA9IE5hTjtcbiAgICAgICAgICAgIGhpdFBvaW50LnkgPSBOYU47XG4gICAgICAgICAgICBoaXRQb2ludC56ID0gTmFOO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoaXROb3JtYWwpIHtcbiAgICAgICAgICAgIGhpdE5vcm1hbC54ID0gTmFOO1xuICAgICAgICAgICAgaGl0Tm9ybWFsLnkgPSBOYU47XG4gICAgICAgICAgICBoaXROb3JtYWwueiA9IE5hTjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0ID8gb2JqZWN0Lm5vZGUgOiBudWxsO1xufTtcblxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZXRSZW5kZXJJbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRSZW5kZXJlcigpLmdldFJlbmRlckludGVyZmFjZSgpO1xufTtcblxuWE1MM0RSZW5kZXJBZGFwdGVyLnByb3RvdHlwZS5nZW5lcmF0ZVJheSA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIHJlbGF0aXZlTW91c2VQb3MgPSBVdGlscy5jb252ZXJ0UGFnZUNvb3Jkcyh0aGlzLm5vZGUsIHgsIHkpO1xuICAgIHJldHVybiB0aGlzLmZhY3RvcnkuZ2V0UmVuZGVyZXIoKS5nZW5lcmF0ZVJheShyZWxhdGl2ZU1vdXNlUG9zLngsIHJlbGF0aXZlTW91c2VQb3MueSk7XG59O1xuXG5YTUwzRFJlbmRlckFkYXB0ZXIucHJvdG90eXBlLmdldEVsZW1lbnRCeVJheSA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNfdmlld01hdCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcbiAgICB2YXIgY19wcm9qTWF0ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4bWwzZFJheSwgaGl0UG9pbnQsIGhpdE5vcm1hbCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLmZhY3RvcnkuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgcmVuZGVyZXIuY2FsY3VsYXRlTWF0cmljZXNGb3JSYXkoeG1sM2RSYXksIGNfdmlld01hdCwgY19wcm9qTWF0KTtcbiAgICAgICAgdmFyIGhpdE9iamVjdCA9IHJlbmRlcmVyLmdldFJlbmRlck9iamVjdEJ5UmF5KHhtbDNkUmF5LCBjX3ZpZXdNYXQsIGNfcHJvak1hdCk7XG4gICAgICAgIGlmIChoaXRPYmplY3QgIT09IG51bGwgJiYgKGhpdFBvaW50IHx8IGhpdE5vcm1hbCkpIHtcbiAgICAgICAgICAgIGlmIChoaXRQb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciB2ZWMgPSByZW5kZXJlci5nZXRXb3JsZFNwYWNlUG9zaXRpb25CeVJheSh4bWwzZFJheSwgaGl0T2JqZWN0LCBjX3ZpZXdNYXQsIGNfcHJvak1hdCk7XG4gICAgICAgICAgICAgICAgWE1MM0QubWF0aC52ZWMzLmNvcHkoaGl0UG9pbnQuZGF0YSwgdmVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaXROb3JtYWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmVjID0gcmVuZGVyZXIuZ2V0V29ybGRTcGFjZU5vcm1hbEJ5UmF5KHhtbDNkUmF5LCBoaXRPYmplY3QsIGNfdmlld01hdCwgY19wcm9qTWF0KTtcbiAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzMuY29weShoaXROb3JtYWwuZGF0YSwgdmVjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoaXRQb2ludCkge1xuICAgICAgICAgICAgICAgIGhpdFBvaW50LnggPSBOYU47XG4gICAgICAgICAgICAgICAgaGl0UG9pbnQueSA9IE5hTjtcbiAgICAgICAgICAgICAgICBoaXRQb2ludC56ID0gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhpdE5vcm1hbCkge1xuICAgICAgICAgICAgICAgIGhpdE5vcm1hbC54ID0gTmFOO1xuICAgICAgICAgICAgICAgIGhpdE5vcm1hbC55ID0gTmFOO1xuICAgICAgICAgICAgICAgIGhpdE5vcm1hbC56ID0gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaXRPYmplY3QgIT09IG51bGwgPyBoaXRPYmplY3Qubm9kZSA6IG51bGw7XG4gICAgfVxufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBYTUwzRFJlbmRlckFkYXB0ZXI7XG5cblxuIiwidmFyIE1vdXNlRXZlbnRzID0gcmVxdWlyZShcIi4vZXZlbnRzL21vdXNlLmpzXCIpO1xudmFyIFRvdWNoRXZlbnRzID0gcmVxdWlyZShcIi4vZXZlbnRzL3RvdWNoLmpzXCIpO1xuXG52YXIgY19nbG9iYWxDYW52YXNJZCA9IDA7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSB4bWwzZEVsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBBYnN0cmFjdENhbnZhc0hhbmRsZXIoeG1sM2RFbGVtZW50LCBjYW52YXMpIHtcbiAgICB0aGlzLl94bWwzZEVsZW1lbnQgPSB4bWwzZEVsZW1lbnQ7XG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgIHRoaXMuaWQgPSArK2NfZ2xvYmFsQ2FudmFzSWQ7IC8vIGdsb2JhbCBjYW52YXMgaWQgc3RhcnRzIGF0IDFcblxuICAgIHRoaXMuX21vdXNlSGFuZGxlciA9IG5ldyBNb3VzZUV2ZW50cy5Nb3VzZUV2ZW50SGFuZGxlcih4bWwzZEVsZW1lbnQsIHRoaXMpO1xuICAgIHRoaXMuX3JlZ2lzdGVyQ2FudmFzTGlzdGVuZXJzKHRoaXMuX21vdXNlSGFuZGxlciwgTW91c2VFdmVudHMuRVZFTlRTKTtcbiAgICBpZih0aGlzLmhhc1RvdWNoRXZlbnRzKCkpIHtcbiAgICAgICAgdGhpcy5fdG91Y2hIYW5kbGVyID0gbmV3IFRvdWNoRXZlbnRzLlRvdWNoRXZlbnRIYW5kbGVyKHhtbDNkRWxlbWVudCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyQ2FudmFzTGlzdGVuZXJzKHRoaXMuX3RvdWNoSGFuZGxlciwgVG91Y2hFdmVudHMuRVZFTlRTKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkFic3RyYWN0Q2FudmFzSGFuZGxlci5wcm90b3R5cGUuaGFzVG91Y2hFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xufTtcblxuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5nZXRDYW52YXMgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiB0aGlzLl9jYW52YXM7XG59O1xuXG5BYnN0cmFjdENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuX3htbDNkRWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbn07XG5cbkFic3RyYWN0Q2FudmFzSGFuZGxlci5wcm90b3R5cGUuX3JlZ2lzdGVyQ2FudmFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKGhhbmRsZXIsIGV2ZW50cykge1xuICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGhhbmRsZXJbbmFtZV0gJiYgaGFuZGxlcltuYW1lXS5jYWxsKGhhbmRsZXIsIGUpO1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuXG5BYnN0cmFjdENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmRpc3BhdGNoQ3VzdG9tRXZlbnQgPSBmdW5jdGlvbih0eXBlLCBkZXRhaWwpIHtcbiAgICBkZXRhaWwgPSBkZXRhaWwgfHwgbnVsbDtcbiAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgZGV0YWlsKTtcbiAgICB0aGlzLl94bWwzZEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG59O1xuXG5cbi8qKlxuICogVGhlIHVwZGF0ZSBldmVudCBjYW4gYmUgdXNlZCBieSB1c2VyIHRvIHN5bmMgYWN0aW9uc1xuICogd2l0aCByZW5kZXJpbmdcbiAqL1xuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5kaXNwYXRjaFVwZGF0ZUV2ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzcGF0Y2hDdXN0b21FdmVudChcInVwZGF0ZVwiKTtcbn07XG5cblxuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5kaXNwYXRjaFJlc2l6ZUV2ZW50ID0gZnVuY3Rpb24gKGRpbWVuc2lvbnMpIHtcbiAgICB0aGlzLmRpc3BhdGNoQ3VzdG9tRXZlbnQoXCJyZXNpemVcIiwgZGltZW5zaW9ucyk7XG59O1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYSBGcmFtZURyYXduRXZlbnQgdG8gbGlzdGVuZXJzXG4gKlxuICogQHBhcmFtIHN0YXJ0XG4gKiBAcGFyYW0gZW5kXG4gKiBAcGFyYW0gc3RhdHNcbiAqIEByZXR1cm5cbiAqL1xuQWJzdHJhY3RDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5kaXNwYXRjaEZyYW1lRHJhd25FdmVudCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBzdGF0cykge1xuICAgIHN0YXRzID0gc3RhdHMgfHwge1xuICAgICAgICBjb3VudDoge1xuICAgICAgICAgICAgcHJpbWl0aXZlczogMCwgb2JqZWN0czogMFxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgdGltZVN0YXJ0OiBzdGFydCwgdGltZUVuZDogZW5kLCByZW5kZXJUaW1lSW5NaWxsaXNlY29uZHM6IGVuZCAtIHN0YXJ0LCBjb3VudDogc3RhdHMuY291bnRcbiAgICB9O1xuICAgIHRoaXMuZGlzcGF0Y2hDdXN0b21FdmVudChcImZyYW1lZHJhd25cIiwgZGF0YSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0Q2FudmFzSGFuZGxlcjtcbiIsInZhciBSZW5kZXJBZGFwdGVyRmFjdG9yeSA9IHJlcXVpcmUoXCIuL2FkYXB0ZXIvZmFjdG9yeS5qc1wiKTtcbnZhciB4bWwzZEZvcm1hdEhhbmRsZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9mb3JtYXRoYW5kbGVyLmpzXCIpLnhtbDNkRm9ybWF0SGFuZGxlcjtcblxueG1sM2RGb3JtYXRIYW5kbGVyLnJlZ2lzdGVyRmFjdG9yeUNsYXNzKFJlbmRlckFkYXB0ZXJGYWN0b3J5KTtcblxudmFyIGZhY3RvcnkgPSByZXF1aXJlKFwiLi9yZW5kZXJlci1mYWN0b3J5LmpzXCIpO1xuXG52YXIgY29uZmlndXJlID0gZnVuY3Rpb24oeG1sM2RzKSB7XG4gICAgaWYgKCEoeG1sM2RzIGluc3RhbmNlb2YgQXJyYXkpKVxuICAgICAgICB4bWwzZHMgPSBbeG1sM2RzXTtcblxuICAgIHhtbDNkcy5mb3JFYWNoKGZ1bmN0aW9uKHhtbDNkRWxlbWVudCkge1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIkNvbmZpZ3VyaW5nIFJlbmRlcmVyIGZvclwiLCB4bWwzZEVsZW1lbnQuaWQpO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBmYWN0b3J5LmNyZWF0ZVJlbmRlcmVyKHhtbDNkRWxlbWVudClcblxuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb25maWd1cmU7IiwidmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcblxudmFyIE9QVElPTl9NT1VTRU1PVkVfUElDS0lORyA9IFwicmVuZGVyZXItbW91c2Vtb3ZlLXBpY2tpbmdcIjtcbnZhciBPUFRJT05fTU9WRU1FTlRfQVdBUkVfQ0xJQ0tfSEFORExFUiA9IFwicmVuZGVyZXItbW92ZW1lbnQtYXdhcmUtY2xpY2staGFuZGxlclwiO1xuT3B0aW9ucy5yZWdpc3RlcihPUFRJT05fTU9VU0VNT1ZFX1BJQ0tJTkcsIHRydWUpO1xuT3B0aW9ucy5yZWdpc3RlcihPUFRJT05fTU9WRU1FTlRfQVdBUkVfQ0xJQ0tfSEFORExFUiwgZmFsc2UpO1xuXG52YXIgRVZFTlRTID0gW1wiY2xpY2tcIiwgXCJkYmxjbGlja1wiLCBcIm1vdXNlZG93blwiLCBcIm1vdXNldXBcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZW1vdmVcIiwgXCJtb3VzZW91dFwiLCBcIndoZWVsXCJdO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRlZmF1bHRUYXJnZXRcbiAqIEBwYXJhbSB7QWJzdHJhY3RDYW52YXNIYW5kbGVyfSBjYW52YXNIYW5kbGVyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE1vdXNlRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oZGVmYXVsdFRhcmdldCwgY2FudmFzSGFuZGxlcikge1xuICAgIHRoaXMuX2RlZmF1bHRUYXJnZXQgPSBkZWZhdWx0VGFyZ2V0O1xuICAgIHRoaXMuX2NhbnZhc0hhbmRsZXIgPSBjYW52YXNIYW5kbGVyO1xuICAgIHRoaXMuX2xhc3RNb3VzZVBvc2l0aW9uID0gIHt4OiAwLCB5OiAwfTtcbn07XG5cbnZhciBzdXBwb3J0c0V2ZW50Q29uc3RydWN0b3JzID0gKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIiwge30pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pKCk7XG5cbk1vdXNlRXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9ICB7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50ICBUaGUgb3JpZ2luYWwgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAgdGFyZ2V0IHRvIGRpc3BhdGNoIG9uXG4gICAgICogQHBhcmFtIHtvYmplY3Q/fSAgICAgb3B0ICAgIE9wdGlvbnNcbiAgICAgKi9cbiAgICBkaXNwYXRjaE1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCBvcHQpIHtcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5fZGVmYXVsdFRhcmdldDtcbiAgICAgICAgdmFyIHggPSBvcHQueCAhPT0gdW5kZWZpbmVkID8gb3B0LnggOiBldmVudC5jbGllbnRYO1xuICAgICAgICB2YXIgeSA9IG9wdC55ICE9PSB1bmRlZmluZWQgPyBvcHQueSA6IGV2ZW50LmNsaWVudFk7XG4gICAgICAgIHZhciBub0NvcHkgPSBvcHQubm9Db3B5IHx8IGZhbHNlO1xuICAgICAgICAvLyBDb3B5IGV2ZW50IHRvIGF2b2lkIERPTSBkaXNwYXRjaCBlcnJvcnMgKGNhbm5vdCBkaXNwYXRjaCBldmVudCBtb3JlXG4gICAgICAgIC8vIHRoYW4gb25jZSlcbiAgICAgICAgaWYgKCFub0NvcHkpIHtcbiAgICAgICAgICAgIGV2ZW50ID0gdGhpcy5jb3B5TW91c2VFdmVudChldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0RXh0ZW5kZWRNb3VzZUV2ZW50KGV2ZW50LCB4LCB5KTtcblxuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudHxXaGVlbEV2ZW50fSBldmVudCB0aGUgZXZlbnQgdG8gY29weVxuICAgICAqIEByZXR1cm4ge01vdXNlRXZlbnR9IHRoZSBuZXcgZXZlbnRcbiAgICAgKi9cbiAgICBjb3B5TW91c2VFdmVudDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldnQ7XG4gICAgICAgIGlmIChzdXBwb3J0c0V2ZW50Q29uc3RydWN0b3JzKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IFdoZWVsRXZlbnRdXCIpIHtcbiAgICAgICAgICAgICAgICBldnQgPSBuZXcgV2hlZWxFdmVudChldmVudC50eXBlLCBldmVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2dCA9IG5ldyBNb3VzZUV2ZW50KGV2ZW50LnR5cGUsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vVGhlc2UgZXZlbnQgQVBJcyBhcmUgZGVwcmVjYXRlZCBidXQgc3RpbGwgcmVxdWlyZWQgYnkgSUUsIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBldmVudCBjb25zdHJ1Y3RvcnMgeWV0XG4gICAgICAgICAgICBpZiAoZXZlbnQudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IFdoZWVsRXZlbnRdXCIpIHtcbiAgICAgICAgICAgICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIldoZWVsRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgZXZ0LmluaXRXaGVlbEV2ZW50KGV2ZW50LnR5cGUsIGV2ZW50LmJ1YmJsZXMsIGV2ZW50LmNhbmNlbGFibGUsIGV2ZW50LnZpZXcsIGV2ZW50LmRldGFpbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWSwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgZXZlbnQuYnV0dG9uLCBldmVudC5yZWxhdGVkVGFyZ2V0LCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBldmVudC5kZWx0YVgsIGV2ZW50LmRlbHRhWSwgZXZlbnQuZGVsdGFaLCBldmVudC5kZWx0YU1vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7XG4gICAgICAgICAgICAgICAgZXZ0LmluaXRNb3VzZUV2ZW50KGV2ZW50LnR5cGUsIGV2ZW50LmJ1YmJsZXMsIGV2ZW50LmNhbmNlbGFibGUsIGV2ZW50LnZpZXcsIGV2ZW50LmRldGFpbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc2NyZWVuWCwgZXZlbnQuc2NyZWVuWSwgZXZlbnQuY2xpZW50WCwgZXZlbnQuY2xpZW50WSwgZXZlbnQuY3RybEtleSwgZXZlbnQuYWx0S2V5LFxuICAgICAgICAgICAgICAgICAgICBldmVudC5zaGlmdEtleSwgZXZlbnQubWV0YUtleSwgZXZlbnQuYnV0dG9uLCBldmVudC5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICAgICAgZXZ0LmRhdGEgPSB7dXJsOiBldmVudC5kYXRhVHJhbnNmZXIuZ2V0RGF0YShcIlVSTFwiKSwgdGV4dDogZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpfTtcbiAgICAgICAgLy8gb3ZlcnJpZGUgcHJldmVudERlZmF1bHQgdG8gYWN0dWFsbHkgcHJldmVudCB0aGUgZGVmYXVsdCBvZiB0aGUgb3JpZ2luYWwgZXZlbnRcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGV2dDtcbiAgICB9LFxuXG4gICAgY3JlYXRlTW91c2VFdmVudDogZnVuY3Rpb24gKHR5cGUsIG9wdHMpIHtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIHZhciBkaWN0ID0ge1xuICAgICAgICAgICAgYnViYmxlc1x0XHQ6IG9wdHMuYnViYmxlcyAhPT0gdW5kZWZpbmVkID8gb3B0cy5idWJibGVzIDogdHJ1ZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGUgXHQ6IG9wdHMuY2FuY2VsYWJsZSAhPT0gdW5kZWZpbmVkID8gb3B0cy5jYW5jZWxhYmxlIDogdHJ1ZSxcbiAgICAgICAgICAgIHZpZXcgXHRcdDogb3B0cy52aWV3IHx8IHdpbmRvdyxcbiAgICAgICAgICAgIGRldGFpbCBcdFx0OiBvcHRzLmRldGFpbCAhPT0gdW5kZWZpbmVkID8gb3B0cy5kZXRhaWwgOiAwLFxuICAgICAgICAgICAgc2NyZWVuWFx0XHQ6IG9wdHMuc2NyZWVuWCAhPT0gdW5kZWZpbmVkID8gb3B0cy5zY3JlZW5YIDogMCxcbiAgICAgICAgICAgIHNjcmVlbllcdFx0OiBvcHRzLnNjcmVlblkgIT09IHVuZGVmaW5lZCA/IG9wdHMuc2NyZWVuWSA6IDAsXG4gICAgICAgICAgICBjbGllbnRYXHRcdDogb3B0cy5jbGllbnRYICE9PSB1bmRlZmluZWQgPyBvcHRzLmNsaWVudFggOiAwLFxuICAgICAgICAgICAgY2xpZW50WVx0XHQ6IG9wdHMuY2xpZW50WSAhPT0gdW5kZWZpbmVkID8gb3B0cy5jbGllbnRZIDogMCxcbiAgICAgICAgICAgIGN0cmwgXHRcdDogb3B0cy5jdHJsICE9PSB1bmRlZmluZWQgPyBvcHRzLmN0cmwgOiBmYWxzZSxcbiAgICAgICAgICAgIGFsdCBcdFx0OiBvcHRzLmFsdCAhPT0gdW5kZWZpbmVkID8gb3B0cy5hbHQgOiBmYWxzZSxcbiAgICAgICAgICAgIHNoaWZ0IFx0XHQ6IG9wdHMuc2hpZnQgIT09IHVuZGVmaW5lZCA/IG9wdHMuc2hpZnQgOiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGEgXHRcdDogb3B0cy5tZXRhICE9PSB1bmRlZmluZWQgPyBvcHRzLm1ldGEgOiBmYWxzZSxcbiAgICAgICAgICAgIGJ1dHRvbiBcdFx0OiBvcHRzLmJ1dHRvbiAhPT0gdW5kZWZpbmVkID8gb3B0cy5idXR0b24gOiAwLFxuICAgICAgICAgICAgcmVsYXRlZFRhcmdldCA6IG9wdHMucmVsYXRlZFRhcmdldFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc3VwcG9ydHNFdmVudENvbnN0cnVjdG9ycykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb3VzZUV2ZW50KHR5cGUsIGRpY3QpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtcbiAgICAgICAgICAgIGV2dC5pbml0TW91c2VFdmVudCh0eXBlLCBkaWN0LmJ1YmJsZXMsIGRpY3QuY2FuY2VsYWJsZSwgZGljdC52aWV3LCBkaWN0LmRldGFpbCxcbiAgICAgICAgICAgICAgICBkaWN0LnNjcmVlblgsIGRpY3Quc2NyZWVuWSwgZGljdC5jbGllbnRYLCBkaWN0LmNsaWVudFksIGRpY3QuY3RybEtleSwgZGljdC5hbHRLZXksXG4gICAgICAgICAgICAgICAgZGljdC5zaGlmdEtleSwgZGljdC5tZXRhS2V5LCBkaWN0LmJ1dHRvbiwgZGljdC5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIHJldHVybiBldnQ7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBwb3NpdGlvbiBhbmQgbm9ybWFsIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7WE1MM0QuVmVjM31cbiAgICAgKi9cbiAgICBpbml0RXh0ZW5kZWRNb3VzZUV2ZW50OiBmdW5jdGlvbiAoZXZlbnQsIHgsIHkpIHtcbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLl9jYW52YXNIYW5kbGVyO1xuXG4gICAgICAgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVkUG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgY2FjaGVkTm9ybWFsID0gdW5kZWZpbmVkO1xuXG4gICAgICAgICAgICBldmVudC5fX2RlZmluZUdldHRlcl9fKFwibm9ybWFsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlZE5vcm1hbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9ybSA9IChoYW5kbGVyLmdldFdvcmxkU3BhY2VOb3JtYWxCeVBvaW50KHgsIHkpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkTm9ybWFsID0gbm9ybSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FjaGVkTm9ybWFsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBldmVudC5fX2RlZmluZUdldHRlcl9fKFwicG9zaXRpb25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghY2FjaGVkUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGhhbmRsZXIuZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlQb2ludCh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkUG9zaXRpb24gPSBwb3MgfHwgbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFBvc2l0aW9uO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XG4gICAgICogQHBhcmFtIHtvYmplY3Q/fSBvcHRcbiAgICAgKi9cbiAgICBkaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdDogZnVuY3Rpb24gKGV2dCwgb3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldnQpO1xuXG4gICAgICAgIHZhciBwaWNrZWQgPSBudWxsO1xuICAgICAgICBpZiAoIW9wdC5vbWl0VXBkYXRlKVxuICAgICAgICAgICAgcGlja2VkID0gdGhpcy5fY2FudmFzSGFuZGxlci5nZXRQaWNrT2JqZWN0QnlQb2ludChwb3MueCwgcG9zLnkpO1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50KGV2dCwgcGlja2VkICYmIHBpY2tlZC5ub2RlLCBwb3MpO1xuICAgIH0sXG5cbiAgICBnZXRNb3VzZVBvc2l0aW9uOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXNIYW5kbGVyLmdldE1vdXNlUG9zaXRpb24oZXZ0KVxuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XG4gICAgICovXG4gICAgbW91c2V1cDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XG4gICAgICovXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHRoaXMuX2xhc3RNb3VzZVBvc2l0aW9uID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50T25QaWNrZWRPYmplY3QoZXZ0KTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxuICAgICAqL1xuICAgIGNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChPcHRpb25zLmdldFZhbHVlKFwicmVuZGVyZXItbW92ZW1lbnQtYXdhcmUtY2xpY2staGFuZGxlclwiKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZ2V0TW91c2VQb3NpdGlvbihldnQpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHBvcy54IC0gdGhpcy5fbGFzdE1vdXNlUG9zaXRpb24ueCkgPiA0IHx8IE1hdGguYWJzKHBvcy55IC0gdGhpcy5fbGFzdE1vdXNlUG9zaXRpb24ueSkgPiA0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZ0XG4gICAgICovXG4gICAgZGJsY2xpY2s6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdChldnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgZWFjaCB0aW1lIGEgbW91c2VNb3ZlIGV2ZW50IGlzIHRyaWdnZXJlZCBvbiB0aGVcbiAgICAgKiBjYW52YXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIHRyaWdnZXJzIG1vdXNlb3ZlciBhbmQgbW91c2VvdXQgZXZlbnRzIG9mIG9iamVjdHMgaW4gdGhlXG4gICAgICogc2NlbmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2dFxuICAgICAqL1xuICAgIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2dCk7XG5cbiAgICAgICAgdmFyIGRvTW91c2VNb3ZlUGljayA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX01PVVNFTU9WRV9QSUNLSU5HKTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudE9uUGlja2VkT2JqZWN0KGV2dCwge29taXRVcGRhdGU6ICFkb01vdXNlTW92ZVBpY2t9KTtcbiAgICAgICAgaWYgKCFkb01vdXNlTW92ZVBpY2spXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgdmFyIGN1ck9iaiA9IHRoaXMuX2NhbnZhc0hhbmRsZXIuZ2V0UGlja2VkT2JqZWN0KCk7XG5cbiAgICAgICAgLy8gdHJpZ2dlciBtb3VzZW92ZXIgYW5kIG1vdXNlb3V0XG4gICAgICAgIGlmIChjdXJPYmogIT09IHRoaXMubGFzdFBpY2tPYmopIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhc3RQaWNrT2JqKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIG1vdXNlIGhhcyBsZWZ0IHRoZSBsYXN0IG9iamVjdFxuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMuY3JlYXRlTW91c2VFdmVudChcIm1vdXNlb3V0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogcG9zLngsIGNsaWVudFk6IHBvcy55LCBidXR0b246IGV2dC5idXR0b25cbiAgICAgICAgICAgICAgICB9KSwgdGhpcy5sYXN0UGlja09iaik7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJPYmopIHsgLy8gTm90aGluZyBwaWNrZWQsIHRoaXMgbWVhbnMgd2UgZW50ZXIgdGhlIHhtbDNkIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoTW91c2VFdmVudCh0aGlzLmNyZWF0ZU1vdXNlRXZlbnQoXCJtb3VzZW92ZXJcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogcG9zLngsIGNsaWVudFk6IHBvcy55LCBidXR0b246IGV2dC5idXR0b25cbiAgICAgICAgICAgICAgICAgICAgfSksIHRoaXMuX2RlZmF1bHRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdXJPYmopIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgbW91c2UgaXMgbm93IG92ZXIgYSBkaWZmZXJlbnQgb2JqZWN0LCBzbyBjYWxsIHRoZSBuZXdcbiAgICAgICAgICAgICAgICAvLyBvYmplY3QncyBtb3VzZW92ZXIgbWV0aG9kXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnQodGhpcy5jcmVhdGVNb3VzZUV2ZW50KFwibW91c2VvdmVyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogcG9zLngsIGNsaWVudFk6IHBvcy55LCBidXR0b246IGV2dC5idXR0b25cbiAgICAgICAgICAgICAgICB9KSwgY3VyT2JqKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGFzdFBpY2tPYmopIHsgLy8gTm90aGluZyB3YXMgcGlja2VkIGJlZm9yZSwgdGhpcyBtZWFucyB3ZSBsZWF2ZSB0aGUgeG1sM2QgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50KHRoaXMuY3JlYXRlTW91c2VFdmVudChcIm1vdXNlb3V0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IHBvcy54LCBjbGllbnRZOiBwb3MueSwgYnV0dG9uOiBldnQuYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIH0pLCB0aGlzLl9kZWZhdWx0VGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubGFzdFBpY2tPYmogPSBjdXJPYmo7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldnRcbiAgICAgKi9cbiAgICBtb3VzZW91dDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB2YXIgcG9zID0gdGhpcy5nZXRNb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hNb3VzZUV2ZW50KGV2dCwgdGhpcy5sYXN0UGlja09iaiwgcG9zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldnRcbiAgICAgKi9cbiAgICBtb3VzZW92ZXI6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIGRvTW91c2VNb3ZlUGljayA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX01PVVNFTU9WRV9QSUNLSU5HKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdChldnQsIHtvbWl0VXBkYXRlOiAhZG9Nb3VzZU1vdmVQaWNrfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7V2hlZWxFdmVudH0gZXZ0XG4gICAgICovXG4gICAgd2hlZWw6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE1vdXNlRXZlbnRPblBpY2tlZE9iamVjdChldnQsIHsgdHlwZTogXCJ3aGVlbFwiIH0pO1xuICAgIH1cblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFVkVOVFM6IEVWRU5UUywgTW91c2VFdmVudEhhbmRsZXI6IE1vdXNlRXZlbnRIYW5kbGVyXG59O1xuIiwiLyoqXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBkZWZhdWx0VGFyZ2V0XG4gKiBAcGFyYW0ge0Fic3RyYWN0Q2FudmFzSGFuZGxlcn0gY2FudmFzSGFuZGxlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUb3VjaEV2ZW50SGFuZGxlciA9IGZ1bmN0aW9uIChkZWZhdWx0VGFyZ2V0LCBjYW52YXNIYW5kbGVyKSB7XG4gICAgdGhpcy5fZGVmYXVsdFRhcmdldCA9IGRlZmF1bHRUYXJnZXQ7XG4gICAgdGhpcy5fY2FudmFzSGFuZGxlciA9IGNhbnZhc0hhbmRsZXI7XG59O1xuXG5cbnZhciBFVkVOVFMgPSBbXCJ0b3VjaHN0YXJ0XCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hlbmRcIiwgXCJ0b3VjaGNhbmNlbFwiXTtcblxuVG91Y2hFdmVudEhhbmRsZXIucHJvdG90eXBlID0ge1xuXG4gICAgY29weVRvdWNoRXZlbnQ6IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgdG91Y2hFdmVudERhdGEgPSB0aGlzLmNvcHlUb3VjaEV2ZW50RGF0YShldmVudCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRvdWNoRXZlbnQodG91Y2hFdmVudERhdGEpO1xuICAgIH0sXG5cblxuICAgIGNvcHlUb3VjaEV2ZW50RGF0YTogZnVuY3Rpb24gKGV2ZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBvcHRpb25zLnR5cGUgfHwgZXZlbnQudHlwZSxcbiAgICAgICAgICAgIHRpbWVTdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIGJ1YmJsZXM6IGV2ZW50LmJ1YmJsZXMsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiBldmVudC5jYW5jZWxhYmxlLFxuICAgICAgICAgICAgZGV0YWlsOiBldmVudC5kZXRhaWwsXG4gICAgICAgICAgICBzY3JlZW5YOiBldmVudC5zY3JlZW5YLFxuICAgICAgICAgICAgc2NyZWVuWTogZXZlbnQuc2NyZWVuWSxcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5wYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBldmVudC5wYWdlWSxcbiAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZLFxuICAgICAgICAgICAgY3RybEtleTogZXZlbnQuY3RybEtleSxcbiAgICAgICAgICAgIGFsdEtleTogZXZlbnQuYWx0S2V5LFxuICAgICAgICAgICAgc2hpZnRLZXk6IGV2ZW50LnNoaWZ0S2V5LFxuICAgICAgICAgICAgbWV0YUtleTogZXZlbnQubWV0YUtleSxcbiAgICAgICAgICAgIHNjYWxlOiBldmVudC5zY2FsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBldmVudC5yb3RhdGlvbixcbiAgICAgICAgICAgIHZpZXc6IGV2ZW50LnZpZXcsXG4gICAgICAgICAgICB0b3VjaGVzOiBldmVudC50b3VjaGVzLFxuICAgICAgICAgICAgY2hhbmdlZFRvdWNoZXM6IGV2ZW50LmNoYW5nZWRUb3VjaGVzLFxuICAgICAgICAgICAgdGFyZ2V0VG91Y2hlczogZXZlbnQudGFyZ2V0VG91Y2hlc1xuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBjcmVhdGVUb3VjaEV2ZW50OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgdG91Y2hFdmVudDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdG91Y2hFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdUb3VjaEV2ZW50Jyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJDcmVhdGUgVG91Y2ggRXZlbnQgZmFpbGVkLCBjcmVhdGluZyBVSSBpbnN0ZWFkXCIpO1xuICAgICAgICAgICAgdG91Y2hFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdVSUV2ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG91Y2hFdmVudCAmJiB0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodG91Y2hFdmVudC5pbml0VG91Y2hFdmVudC5sZW5ndGggPT0gMCkgeyAvL2Nocm9tZVxuICAgICAgICAgICAgICAgIHRvdWNoRXZlbnQuaW5pdFRvdWNoRXZlbnQoZGF0YS50b3VjaGVzLCBkYXRhLnRhcmdldFRvdWNoZXMsIGRhdGEuY2hhbmdlZFRvdWNoZXMsIGRhdGEudHlwZSwgZGF0YS52aWV3LCBkYXRhLnNjcmVlblgsIGRhdGEuc2NyZWVuWSwgZGF0YS5jbGllbnRYLCBkYXRhLmNsaWVudFkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50Lmxlbmd0aCA9PSAxMikgeyAvL2ZpcmVmb3hcbiAgICAgICAgICAgICAgICB0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50KGRhdGEudHlwZSwgZGF0YS5idWJibGVzLCBkYXRhLmNhbmNlbGFibGUsIGRhdGEudmlldywgZGF0YS5kZXRhaWwsIGRhdGEuY3RybEtleSwgZGF0YS5hbHRLZXksIGRhdGEuc2hpZnRLZXksIGRhdGEubWV0YUtleSwgZGF0YS50b3VjaGVzLCBkYXRhLnRhcmdldFRvdWNoZXMsIGRhdGEuY2hhbmdlZFRvdWNoZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHsgLy9pT1MgbGVuZ3RoID0gMThcbiAgICAgICAgICAgICAgICB0b3VjaEV2ZW50LmluaXRUb3VjaEV2ZW50KGRhdGEudHlwZSwgZGF0YS5idWJibGVzLCBkYXRhLmNhbmNlbGFibGUsIGRhdGEudmlldywgZGF0YS5kZXRhaWwsIGRhdGEuc2NyZWVuWCwgZGF0YS5zY3JlZW5ZLCBkYXRhLnBhZ2VYLCBkYXRhLnBhZ2VZLCBkYXRhLmN0cmxLZXksIGRhdGEuYWx0S2V5LCBkYXRhLnNoaWZ0S2V5LCBkYXRhLm1ldGFLZXksIGRhdGEudG91Y2hlcywgZGF0YS50YXJnZXRUb3VjaGVzLCBkYXRhLmNoYW5nZWRUb3VjaGVzLCBkYXRhLnNjYWxlLCBkYXRhLnJvdGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG91Y2hFdmVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZ0XG4gICAgICogQHBhcmFtIHtvYmplY3Q/fSBvcHRcbiAgICAgKi9cbiAgICBkaXNwYXRjaFRvdWNoRXZlbnRPblBpY2tlZE9iamVjdDogZnVuY3Rpb24gKGV2dCwgb3B0KSB7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHRvdWNoRXZlbnQgPSB0aGlzLmNvcHlUb3VjaEV2ZW50KGV2dCwgb3B0KTtcbiAgICAgICAgdG91Y2hFdmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9kZWZhdWx0VGFyZ2V0LmRpc3BhdGNoRXZlbnQodG91Y2hFdmVudCk7XG4gICAgfSxcblxuICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFRvdWNoRXZlbnRPblBpY2tlZE9iamVjdChldnQpO1xuICAgIH0sXG5cbiAgICB0b3VjaGVuZDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoVG91Y2hFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XG4gICAgfSxcblxuICAgIHRvdWNobW92ZTogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoVG91Y2hFdmVudE9uUGlja2VkT2JqZWN0KGV2dCk7XG4gICAgfSxcblxuICAgIHRvdWNoY2FuY2VsOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUb3VjaEV2ZW50T25QaWNrZWRPYmplY3QoZXZ0KTtcbiAgICB9XG5cbn07XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgRVZFTlRTOiBFVkVOVFMsIFRvdWNoRXZlbnRIYW5kbGVyOiBUb3VjaEV2ZW50SGFuZGxlclxufTtcbiIsImZ1bmN0aW9uIExpZ2h0TWFuYWdlcigpIHtcbiAgICB0aGlzLl9saWdodHMgPSBbXTtcbiAgICB0aGlzLl9tb2RlbHMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0aW5nIGxpZ2h0IHBhcmFtZXRlcnMgY2FuIGxlYWQgdG8gdXBkYXRpbmcgdGhlIChsYXp5KSBzY2VuZSBzdHJ1Y3R1cmUsIHdoaWNoXG4gICAgICogaW4gdHVybiB1cGRhdGVzIHRoZSBsaWdodHMuIElmIHdlIGFyZSBpbiB1cGRhdGluZyB0aGUgbGlnaHRzLCBmbGFnIGlzIHNldCB0byB0cnVlLlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcbn1cblxuTGlnaHRNYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICBhZGQ6IGZ1bmN0aW9uIChsaWdodCkge1xuICAgICAgICB0aGlzLl9saWdodHMucHVzaChsaWdodCk7XG4gICAgICAgIHRoaXMuX2FkZE1vZGVsKGxpZ2h0Lm1vZGVsKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAobGlnaHQpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5fbGlnaHRzLmluZGV4T2YobGlnaHQpO1xuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpZ2h0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW92ZU1vZGVsKGxpZ2h0Lm1vZGVsKTtcbiAgICB9LFxuXG4gICAgZmlsbEdsb2JhbFBhcmFtZXRlcnM6IGZ1bmN0aW9uIChnbG9iYWxzLCBmb3JjZSkge1xuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9tb2RlbHMpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX21vZGVsc1tpZF07XG4gICAgICAgICAgICAvKiBGaWxsIGdsb2JhbHMgb25seSBpZiB0aGlzIHdhcyBub3QgYWxyZWFkeSBkb25lIGJlZm9yZSAqL1xuICAgICAgICAgICAgaWYgKGVudHJ5LmNoYW5nZWQgfHwgZm9yY2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcHJlZml4ID0gaWQgKyBcIkxpZ2h0XCI7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcGFyYW0gaW4gZW50cnkucGFyYW1ldGVycykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IHByZWZpeCArIHBhcmFtLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcGFyYW0uc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgICAgIGdsb2JhbHNbbmFtZV0gPSBlbnRyeS5wYXJhbWV0ZXJzW3BhcmFtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW50cnkuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxpZ2h0VmFsdWVDaGFuZ2VkOiBmdW5jdGlvbiAobGlnaHQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luVXBkYXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9pblVwZGF0ZSA9IHRydWU7XG5cbiAgICAgICAgdmFyIGxpZ2h0cyA9IGxpZ2h0ID8gW2xpZ2h0XSA6IHRoaXMuX2xpZ2h0cztcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgICAgIGxpZ2h0cy5mb3JFYWNoKGZ1bmN0aW9uKGxpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSBsaWdodC5tb2RlbDtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHRoYXQuZ2V0TW9kZWxFbnRyeShtb2RlbC5pZCk7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gZW50cnkubGlnaHRNb2RlbHMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5hc3NlcnQob2Zmc2V0ICE9IC0xLCBcIkxpZ2h0IHZhbHVlcyBjaGFuZ2VkIGZvciBhIGxpZ2h0IHRoYXQgaXMgbm90IG1hbmFnZWQgYnkgdGhpcyBMaWdodE1hbmFnZXJcIik7XG4gICAgICAgICAgICBtb2RlbC5maWxsTGlnaHRQYXJhbWV0ZXJzKGVudHJ5LnBhcmFtZXRlcnMsIG9mZnNldCk7XG4gICAgICAgICAgICBtb2RlbC5nZXRMaWdodERhdGEoZW50cnkucGFyYW1ldGVycywgb2Zmc2V0KTtcbiAgICAgICAgICAgIGVudHJ5LmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgZ2V0TW9kZWxFbnRyeTogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlbHNbaWRdO1xuICAgIH0sXG5cbiAgICBnZXRNb2RlbHM6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fbW9kZWxzKTtcbiAgICB9LFxuXG4gICAgZ2V0TW9kZWxDb3VudDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXMuZ2V0TW9kZWxFbnRyeShpZCk7XG4gICAgICAgIHJldHVybiBtb2RlbCA/IG1vZGVsLmxpZ2h0TW9kZWxzLmxlbmd0aCA6IDA7XG4gICAgfSxcblxuICAgIF9hZGRNb2RlbDogZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX21vZGVsc1ttb2RlbC5pZF07XG4gICAgICAgIGlmICghZW50cnkpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5fbW9kZWxzW21vZGVsLmlkXSA9IHtsaWdodE1vZGVsczogW10sIHBhcmFtZXRlcnM6IHt9fTtcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5saWdodE1vZGVscy5wdXNoKG1vZGVsKTtcbiAgICAgICAgdGhpcy5fbGlnaHRTdHJ1Y3R1cmVDaGFuZ2VkKGVudHJ5KTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZU1vZGVsOiBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5nZXRNb2RlbEVudHJ5KG1vZGVsLmlkKTtcbiAgICAgICAgdmFyIGluZGV4ID0gZW50cnkubGlnaHRNb2RlbHMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgIGlmIChpbmRleCAhPSAtMSkge1xuICAgICAgICAgICAgZW50cnkubGlnaHRNb2RlbHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saWdodFN0cnVjdHVyZUNoYW5nZWQoZW50cnkpO1xuICAgIH0sXG5cbiAgICBfbGlnaHRTdHJ1Y3R1cmVDaGFuZ2VkOiBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgdGhpcy5faW5VcGRhdGUgPSB0cnVlO1xuICAgICAgICB2YXIgbGVuZ3RoID0gZW50cnkubGlnaHRNb2RlbHMubGVuZ3RoO1xuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgZW50cnkucGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtb2RlbCA9IGVudHJ5LmxpZ2h0TW9kZWxzWzBdO1xuICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzID0gbW9kZWwuYWxsb2NhdGVQYXJhbWV0ZXJBcnJheShsZW5ndGgpO1xuICAgICAgICBlbnRyeS5saWdodE1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChsaWdodE1vZGVsLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIGxpZ2h0TW9kZWwuZmlsbExpZ2h0UGFyYW1ldGVycyhlbnRyeS5wYXJhbWV0ZXJzLCBvZmZzZXQpXG4gICAgICAgICAgICBsaWdodE1vZGVsLmdldExpZ2h0RGF0YShlbnRyeS5wYXJhbWV0ZXJzLCBvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZW50cnkuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XG5cbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpZ2h0TWFuYWdlcjtcbiIsInZhciBGcnVzdHVtID0gcmVxdWlyZShcIi4uL3Rvb2xzL2ZydXN0dW0uanNcIikuRnJ1c3R1bTtcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xudmFyIERhdGFOb2RlID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9ncmFwaC5qc1wiKS5EYXRhTm9kZTtcbnZhciBJbnB1dE5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLklucHV0Tm9kZTtcbnZhciBCdWZmZXJFbnRyeSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qc1wiKS5CdWZmZXJFbnRyeTtcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xudmFyIHZlYzMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzM7XG52YXIgcXVhdCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikucXVhdDtcblxudmFyIFBvaW50TGlnaHREYXRhID0ge1xuICAgIFwiaW50ZW5zaXR5XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFsxLCAxLCAxXX0sXG4gICAgXCJhdHRlbnVhdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgMV19LFxuICAgIFwicG9zaXRpb25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogWzAsIDAsIDBdfSxcbiAgICBcInNoYWRvd0JpYXNcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVCwgJ2RlZmF1bHQnOiBbMC4wMDAxXX0sXG4gICAgXCJkaXJlY3Rpb25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogWzAsIDAsIC0xXX0sXG4gICAgXCJjYXN0U2hhZG93XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuQk9PTCwgJ2RlZmF1bHQnOiBbZmFsc2VdfSxcbiAgICBcIm9uXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuQk9PTCwgJ2RlZmF1bHQnOiBbdHJ1ZV19LFxuICAgIFwibWF0cml4XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsICdkZWZhdWx0JzogWzEsIDAsIDAsIDAsICAgMCwgMSwgMCwgMCwgICAgMCwgMCwgMSwgMCwgIDAsIDAsIDAsIDFdfSxcbiAgICBcIm5lYXJGYXJcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDIsICdkZWZhdWx0JzogWzEuMCwgMTAwLjBdfVxufTtcblxudmFyIFNwb3RMaWdodERhdGEgPSB7XG4gICAgXCJpbnRlbnNpdHlcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogWzEsIDEsIDFdfSxcbiAgICBcImF0dGVudWF0aW9uXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFswLCAwLCAxXX0sXG4gICAgXCJwb3NpdGlvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUMywgJ2RlZmF1bHQnOiBbMCwgMCwgMF19LFxuICAgIFwiZGlyZWN0aW9uXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFswLCAwLCAtMV19LFxuICAgIFwiZmFsbG9mZkFuZ2xlXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQsICdkZWZhdWx0JzogW01hdGguUEkgLyA0XX0sXG4gICAgXCJzb2Z0bmVzc1wiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FULCAnZGVmYXVsdCc6IFswLjBdfSxcbiAgICBcInNoYWRvd0JpYXNcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVCwgJ2RlZmF1bHQnOiBbMC4wMDAxXX0sXG4gICAgXCJjYXN0U2hhZG93XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuQk9PTCwgJ2RlZmF1bHQnOiBbZmFsc2VdfSxcbiAgICBcIm1hdHJpeFwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkZMT0FUNFg0LCAnZGVmYXVsdCc6IFsxLCAwLCAwLCAwLCAgIDAsIDEsIDAsIDAsICAgIDAsIDAsIDEsIDAsICAwLCAwLCAwLCAxXX0sXG4gICAgXCJvblwiOiB7dHlwZTogWEMuREFUQV9UWVBFLkJPT0wsICdkZWZhdWx0JzogW3RydWVdfVxufTtcblxudmFyIERpcmVjdGlvbmFsTGlnaHREYXRhID0ge1xuICAgIFwiaW50ZW5zaXR5XCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQzLCAnZGVmYXVsdCc6IFsxLCAxLCAxXX0sXG4gICAgXCJkaXJlY3Rpb25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogWzAsIDAsIC0xXX0sXG4gICAgXCJzaGFkb3dCaWFzXCI6IHt0eXBlOiBYQy5EQVRBX1RZUEUuRkxPQVQsICdkZWZhdWx0JzogWzAuMDAwMV19LFxuICAgIFwicG9zaXRpb25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDMsICdkZWZhdWx0JzogWzAsIDAsIDBdfSxcbiAgICBcImNhc3RTaGFkb3dcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5CT09MLCAnZGVmYXVsdCc6IFtmYWxzZV19LFxuICAgIFwib25cIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5CT09MLCAnZGVmYXVsdCc6IFt0cnVlXX0sXG4gICAgXCJtYXRyaXhcIjoge3R5cGU6IFhDLkRBVEFfVFlQRS5GTE9BVDRYNCwgJ2RlZmF1bHQnOiBbMSwgMCwgMCwgMCwgICAwLCAxLCAwLCAwLCAgICAwLCAwLCAxLCAwLCAgMCwgMCwgMCwgMV19XG59O1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZVhmbG93RGF0YShjb25maWcpIHtcbiAgICB2YXIgZGF0YSA9IG5ldyBEYXRhTm9kZSgpO1xuICAgIGZvciAodmFyIG5hbWUgaW4gY29uZmlnKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGNvbmZpZ1tuYW1lXTtcbiAgICAgICAgY3JlYXRlWGZsb3dWYWx1ZShkYXRhLCBuYW1lLCBlbnRyeS50eXBlLCBlbnRyeVsnZGVmYXVsdCddKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVhmbG93VmFsdWUoZGF0YU5vZGUsIG5hbWUsIHR5cGUsIHZhbHVlKSB7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBCdWZmZXJFbnRyeSh0eXBlLCBuZXcgWEMuVFlQRURfQVJSQVlfTUFQW3R5cGVdKHZhbHVlKSk7XG4gICAgdmFyIGlucHV0Tm9kZSA9IG5ldyBJbnB1dE5vZGUoKTtcbiAgICBpbnB1dE5vZGUuZGF0YSA9IGJ1ZmZlcjtcbiAgICBpbnB1dE5vZGUubmFtZSA9IG5hbWU7XG4gICAgZGF0YU5vZGUuYXBwZW5kQ2hpbGQoaW5wdXROb2RlKTtcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsaWdodCBtb2RlbHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBVbmlxdWUgaWQgdGhhdCBpZGVudGlmaWVzIHRoZSBsaWdodCBtb2RlbFxuICogQHBhcmFtIHtSZW5kZXJMaWdodH0gbGlnaHRcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIENvbmZpZ3VyYXRpb24gdGhhdCBjb250YWlucyB0aGUgbGlnaHQgbW9kZWwncyBwYXJhbWV0ZXJzIGFuZCBkZWZhdWx0IHZhbHVlc1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMaWdodE1vZGVsID0gZnVuY3Rpb24gKGlkLCBsaWdodCwgZGF0YU5vZGUsIGNvbmZpZykge1xuICAgIHRoaXMuaWQgPSBpZDtcbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gICAgdGhpcy5jb25maWd1cmF0aW9uID0gY29uZmlnO1xuICAgIHRoaXMucGFyYW1ldGVycyA9IE9iamVjdC5rZXlzKGNvbmZpZyk7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGxpZ2h0IGhhcyBub3QgZGF0YSwganVzdCB1c2UgdGhlIGRlZmF1bHQgcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGlmIChkYXRhTm9kZSkge1xuICAgICAgICB2YXIgZGF0YSA9IG5ldyBEYXRhTm9kZSgpO1xuICAgICAgICBkYXRhLmluc2VydEJlZm9yZShjcmVhdGVYZmxvd0RhdGEoY29uZmlnKSwgbnVsbCk7XG4gICAgICAgIGRhdGEuaW5zZXJ0QmVmb3JlKGRhdGFOb2RlLCBudWxsKTtcbiAgICAgICAgdGhpcy5kYXRhTm9kZSA9IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kYXRhTm9kZSA9IGNyZWF0ZVhmbG93RGF0YShjb25maWcpO1xuICAgIH1cblxuICAgIC8vIEhvcml6b250YWwgb3BlbmluZyBhbmdsZSBvZiB0aGUgbGlnaHQgY2FtZXJhLiBEZXJpdmVkIGZyb20gZmFsbG9mZkFuZ2xlIGluIGNhc2Ugb2Ygc3BvdCBsaWdodFxuICAgIHRoaXMuZm92eSA9ICBNYXRoLlBJLzIuMDtcblxuICAgIHRoaXMubGlnaHRQYXJhbWV0ZXJSZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KHRoaXMuZGF0YU5vZGUsIHRoaXMucGFyYW1ldGVycywgdGhpcy5saWdodFBhcmFtZXRlcnNDaGFuZ2VkLmJpbmQodGhpcykpO1xuICAgIHRoaXMubGlnaHRQYXJhbWV0ZXJzQ2hhbmdlZCh0aGlzLmxpZ2h0UGFyYW1ldGVyUmVxdWVzdCwgbnVsbCk7XG59O1xuXG5MaWdodE1vZGVsLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIGxpZ2h0IHBhcmFtZXRlcnMgaW4gYW4gYXJyYXkgb2YgdGhlIHNhbWUgc2l6ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgTmFtZSB0byB0eXBlZCBhcnJheSBtYXAgY29udGFpbmluZyB0aGUgZGF0YVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgU2xvdCBpbiB0aGUgYXJyYXkgdG8gYmUgZmlsbGVkXG4gICAgICovXG4gICAgZmlsbExpZ2h0UGFyYW1ldGVyczogZnVuY3Rpb24gKHRhcmdldCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmxpZ2h0UGFyYW1ldGVyUmVxdWVzdC5nZXRSZXN1bHQoKTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IHJlc3VsdC5nZXRPdXRwdXREYXRhKG5hbWUpO1xuICAgICAgICAgICAgdmFyIHNpemUgPSBYQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtlbnRyeS50eXBlXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudHJ5LmdldFZhbHVlKCk7XG4gICAgICAgICAgICB0YXJnZXRbbmFtZV0uc2V0KHZhbHVlLnN1YmFycmF5KDAsIHNpemUpLCBvZmZzZXQgKiBzaXplKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUGFyYW1ldGVycyh0YXJnZXQsIG9mZnNldCk7XG4gICAgfSxcblxuICAgIGFsbG9jYXRlUGFyYW1ldGVyQXJyYXk6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHZhciBwYXJhbWV0ZXJBcnJheXMgPSB7fTtcbiAgICAgICAgdmFyIGNvbmZpZyA9IHRoaXMuY29uZmlndXJhdGlvbjtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gY29uZmlnW25hbWVdLnR5cGU7XG4gICAgICAgICAgICB2YXIgdHVwbGVTaXplID0gWEMuREFUQV9UWVBFX1RVUExFX1NJWkVbdHlwZV07XG4gICAgICAgICAgICBwYXJhbWV0ZXJBcnJheXNbbmFtZV0gPSBuZXcgWEMuVFlQRURfQVJSQVlfTUFQW3R5cGVdKHR1cGxlU2l6ZSAqIHNpemUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBhcmFtZXRlckFycmF5cztcbiAgICB9LFxuXG4gICAgZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGlmKG5hbWUgaW4gdGhpcy5jb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAvLyBObyBvdGhlciBjaGVja3MgcmVxdWlyZWQgYmVjYXVzZSBwYXJhbWV0ZXJzIGFyZSBhbHdheXMgZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGlnaHRQYXJhbWV0ZXJSZXF1ZXN0LmdldFJlc3VsdCgpLmdldE91dHB1dERhdGEobmFtZSkuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgbGlnaHRQYXJhbWV0ZXJzQ2hhbmdlZDogZnVuY3Rpb24gKHJlcXVlc3QsIGNoYW5nZVR5cGUpIHtcbiAgICAgICAgaWYgKGNoYW5nZVR5cGUpIHtcbiAgICAgICAgICAgIHRoaXMubGlnaHQubGlnaHRWYWx1ZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXhwYW5kTmVhckZhcjpmdW5jdGlvbihuZm9iamVjdCl7XG4gICAgICAgIHZhciBleHBhbmQgPSBNYXRoLm1heCgobmZvYmplY3QuZmFyIC0gbmZvYmplY3QubmVhcikgKiAwLjMwLCAwLjA1KTtcbiAgICAgICAgbmZvYmplY3QubmVhciAtPSBleHBhbmQ7XG4gICAgICAgIG5mb2JqZWN0LmZhciAgKz0gZXhwYW5kO1xuICAgIH0sXG5cbiAgICBnZXRMaWdodERhdGE6IGZ1bmN0aW9uICh0YXJnZXQsIG9mZnNldCkge1xuICAgICAgICB2YXIgbWF0cml4ID0gdGFyZ2V0W1wibWF0cml4XCJdLnN1YmFycmF5KG9mZnNldCAqIDE2LCBvZmZzZXQgKiAxNiArIDE2KTtcbiAgICAgICAgdGhpcy5nZXRMaWdodFZpZXdQcm9qZWN0aW9uTWF0cml4KG1hdHJpeCk7XG4gICAgfSxcblxuICAgIGdldExpZ2h0Vmlld1Byb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgdmFyIExWTSA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBMUE0gPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLmdldExpZ2h0Vmlld01hdHJpeChMVk0pO1xuICAgICAgICB0aGlzLmdldExpZ2h0UHJvamVjdGlvbk1hdHJpeChMUE0pO1xuICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHkodGFyZ2V0LCBMUE0sIExWTSk7XG4gICAgfSxcblxuICAgIGdldExpZ2h0UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICB0aGlzLmxpZ2h0LmdldEZydXN0dW0oMSkuZ2V0UHJvamVjdGlvbk1hdHJpeCh0YXJnZXQpO1xuICAgIH0sXG5cbiAgICBnZXRMaWdodFZpZXdNYXRyaXg6IChmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHRtcCA9IG1hdDQuY3JlYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtYXQpIHtcbiAgICAgICAgICAgIHZhciBwX2RpciA9IHRoaXMuZ2V0UGFyYW1ldGVyKFwiZGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgdmFyIHBfcG9zID0gdGhpcy5nZXRQYXJhbWV0ZXIoXCJwb3NpdGlvblwiKTtcblxuICAgICAgICAgICAgLy8gR2V0IHRoZSB3b3JsZCBtYXRyaXggZnJvbSB0aGUgbGlnaHQgaW4gdGhlIHRyYW5zZm9ybWF0aW9uIGhpZXJhcmNoeVxuICAgICAgICAgICAgLy8gd29ybGQgPT4gbGlnaHRcbiAgICAgICAgICAgIHRoaXMubGlnaHQuZ2V0V29ybGRNYXRyaXgobWF0KTtcblxuICAgICAgICAgICAgLy8gRGVyaXZlIHJvdGF0aW9uIGZyb20gdGhlIGRpcmVjdGlvbiBhbmQgc3RhbmRhcmQgZGlyZWN0aW9uICgteiA9PiBubyByb3RhdGlvbilcbiAgICAgICAgICAgIHZhciBxX3JvdCA9IFhNTDNELm1hdGgucXVhdC5yb3RhdGlvblRvKHF1YXQuY3JlYXRlKCksY19zdGFuZGFyZERpcmVjdGlvbiwgcF9kaXIpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIG1hdHJpeCBmcm9tIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGlvblxuICAgICAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbih0bXAsIHFfcm90LCBwX3Bvcyk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gd29ybGQgbWF0cml4XFxcbiAgICAgICAgICAgIG1hdDQubXVsKG1hdCwgbWF0LCB0bXApO1xuXG4gICAgICAgICAgICAvLyBJbnZlcnQ6ICBsaWdodCA9PiB3b3JsZFxuICAgICAgICAgICAgbWF0NC5pbnZlcnQobWF0LCBtYXQpO1xuICAgICAgICB9XG4gICAgfSkoKVxuXG59O1xuXG52YXIgY190bXBXb3JsZE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG52YXIgY19zdGFuZGFyZERpcmVjdGlvbiA9IHZlYzMuZnJvbVZhbHVlcygwLDAsLTEpO1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvc2UobGlnaHQsIHBvc2l0aW9uLCBkaXJlY3Rpb24pIHtcbiAgICBsaWdodC5nZXRXb3JsZE1hdHJpeChjX3RtcFdvcmxkTWF0cml4KTtcbiAgICBpZiAocG9zaXRpb24pIHtcbiAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHBvc2l0aW9uLCBwb3NpdGlvbiwgY190bXBXb3JsZE1hdHJpeCk7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24pIHtcbiAgICAgICAgWE1MM0QubWF0aC52ZWMzLnRyYW5zZm9ybURpcmVjdGlvbihkaXJlY3Rpb24sIGRpcmVjdGlvbiwgY190bXBXb3JsZE1hdHJpeCk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKGRpcmVjdGlvbiwgZGlyZWN0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybURlZmF1bHQodGFyZ2V0LCBvZmZzZXQsIGxpZ2h0KSB7XG4gICAgdGFyZ2V0W1wib25cIl1bb2Zmc2V0XSA9IGxpZ2h0LnZpc2libGU7XG59XG5cblxuLyoqXG4gKiBJbXBsZW1lbnQgWE1MM0QncyBwcmVkZWZpbmVkIHBvaW50IGxpZ2h0IG1vZGVsIHVybjp4bWwzZDpsaWdodDpwb2ludFxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcbiAqIEBwYXJhbSB7UmVuZGVyTGlnaHR9IGxpZ2h0XG4gKiBAZXh0ZW5kcyBMaWdodE1vZGVsXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFBvaW50TGlnaHRNb2RlbCA9IGZ1bmN0aW9uIChkYXRhTm9kZSwgbGlnaHQpIHtcbiAgICBMaWdodE1vZGVsLmNhbGwodGhpcywgXCJwb2ludFwiLCBsaWdodCwgZGF0YU5vZGUsIFBvaW50TGlnaHREYXRhKTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKFBvaW50TGlnaHRNb2RlbCwgTGlnaHRNb2RlbCwge1xuICAgIGdldEZydXN0dW06IGZ1bmN0aW9uIChhc3BlY3QsIHNjZW5lQm91bmRpbmdCb3gpIHtcbiAgICAgICAgdmFyIG9ydGhvZ29uYWwgPSBmYWxzZTtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5saWdodC5zY2VuZS5saWdodHMuZ2V0TW9kZWxFbnRyeSh0aGlzLmlkKTtcblxuICAgICAgICBpZiAoc2NlbmVCb3VuZGluZ0JveC5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIGVudHJ5LnBhcmFtZXRlcnNbXCJuZWFyRmFyXCJdWzBdID0gMS4wO1xuICAgICAgICAgICAgZW50cnkucGFyYW1ldGVyc1tcIm5lYXJGYXJcIl1bMV0gPSAxMTAuMDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnJ1c3R1bSgxLjAsIDExMC4wLCAwLCB0aGlzLmZvdnksIGFzcGVjdCwgb3J0aG9nb25hbClcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIHRfbWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5nZXRMaWdodFZpZXdNYXRyaXgodF9tYXQpO1xuICAgICAgICBzY2VuZUJvdW5kaW5nQm94LnRyYW5zZm9ybUF4aXNBbGlnbmVkKHRfbWF0KTtcblxuICAgICAgICB2YXIgbmYgPSB7XG4gICAgICAgICAgICBuZWFyOiAtc2NlbmVCb3VuZGluZ0JveC5tYXgueiwgZmFyOiAtc2NlbmVCb3VuZGluZ0JveC5taW4uelxuICAgICAgICB9O1xuICAgICAgICAvLyBFeHBhbmQgdGhlIHZpZXcgZnJ1c3R1bSBhIGJpdCB0byBlbnN1cmUgMkQgb2JqZWN0cyBwYXJhbGxlbCB0byB0aGUgY2FtZXJhIGFyZSByZW5kZXJlZFxuICAgICAgICB0aGlzLl9leHBhbmROZWFyRmFyKG5mKTtcblxuICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzW1wibmVhckZhclwiXVswXSA9IDEuMDtcbiAgICAgICAgZW50cnkucGFyYW1ldGVyc1tcIm5lYXJGYXJcIl1bMV0gPSBuZi5mYXI7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgbmYuZmFyLCAwLCB0aGlzLmZvdnksIGFzcGVjdCwgb3J0aG9nb25hbCk7XG4gICAgfSxcblxuICAgIHRyYW5zZm9ybVBhcmFtZXRlcnM6IGZ1bmN0aW9uICh0YXJnZXQsIG9mZnNldCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0YXJnZXRbXCJwb3NpdGlvblwiXS5zdWJhcnJheShvZmZzZXQgKiAzLCBvZmZzZXQgKiAzICsgMyk7XG4gICAgICAgIHRyYW5zZm9ybVBvc2UodGhpcy5saWdodCwgcG9zaXRpb24sIG51bGwpO1xuICAgICAgICB0cmFuc2Zvcm1EZWZhdWx0KHRhcmdldCwgb2Zmc2V0LCB0aGlzLmxpZ2h0KTtcbiAgICB9XG59KTtcblxuXG5cblxuLyoqXG4gKiBJbXBsZW1lbnQgWE1MM0QncyBwcmVkZWZpbmVkIHNwb3QgbGlnaHQgbW9kZWwgdXJuOnhtbDNkOmxpZ2h0OnNwb3RcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXG4gKiBAcGFyYW0ge1JlbmRlckxpZ2h0fSBsaWdodFxuICogQGV4dGVuZHMgTGlnaHRNb2RlbFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTcG90TGlnaHRNb2RlbCA9IGZ1bmN0aW9uIChkYXRhTm9kZSwgbGlnaHQpIHtcbiAgICBMaWdodE1vZGVsLmNhbGwodGhpcywgXCJzcG90XCIsIGxpZ2h0LCBkYXRhTm9kZSwgU3BvdExpZ2h0RGF0YSk7XG59O1xuXG5cblhNTDNELmNyZWF0ZUNsYXNzKFNwb3RMaWdodE1vZGVsLCBMaWdodE1vZGVsLCB7XG4gICAgZ2V0RnJ1c3R1bTogZnVuY3Rpb24gKGFzcGVjdCwgc2NlbmVCb3VuZGluZ0JveCkge1xuXG4gICAgICAgIGlmIChzY2VuZUJvdW5kaW5nQm94LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgMTEwLjAsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBmYWxzZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0X21hdCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuZ2V0TGlnaHRWaWV3TWF0cml4KHRfbWF0KTtcbiAgICAgICAgc2NlbmVCb3VuZGluZ0JveC50cmFuc2Zvcm1BeGlzQWxpZ25lZCh0X21hdCk7XG5cbiAgICAgICAgdmFyIG5mID0ge1xuICAgICAgICAgICAgbmVhcjogLXNjZW5lQm91bmRpbmdCb3gubWF4LnosIGZhcjogLXNjZW5lQm91bmRpbmdCb3gubWluLnpcbiAgICAgICAgfTtcbiAgICAgICAgLy8gRXhwYW5kIHRoZSB2aWV3IGZydXN0dW0gYSBiaXQgdG8gZW5zdXJlIDJEIG9iamVjdHMgcGFyYWxsZWwgdG8gdGhlIGNhbWVyYSBhcmUgcmVuZGVyZWRcbiAgICAgICAgdGhpcy5fZXhwYW5kTmVhckZhcihuZik7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgbmYuZmFyLCAwLCB0aGlzLmZvdnksIGFzcGVjdCwgZmFsc2UpO1xuICAgIH0sXG5cbiAgICB0cmFuc2Zvcm1QYXJhbWV0ZXJzOiBmdW5jdGlvbiAodGFyZ2V0LCBvZmZzZXQpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0W1wicG9zaXRpb25cIl0uc3ViYXJyYXkob2Zmc2V0ICogMywgb2Zmc2V0ICogMyArIDMpO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gdGFyZ2V0W1wiZGlyZWN0aW9uXCJdLnN1YmFycmF5KG9mZnNldCAqIDMsIG9mZnNldCAqIDMgKyAzKTtcbiAgICAgICAgLy8gVHJhbnNmb3JtIHBvc2l0aW9uIGFuZCBkaXJlY3Rpb24gZnJvbSBvYmplY3QgdG8gd29ybGQgc3BhY2VcbiAgICAgICAgdHJhbnNmb3JtUG9zZSh0aGlzLmxpZ2h0LCBwb3NpdGlvbiwgZGlyZWN0aW9uKTtcbiAgICAgICAgdHJhbnNmb3JtRGVmYXVsdCh0YXJnZXQsIG9mZnNldCwgdGhpcy5saWdodCk7XG4gICAgfSxcblxuICAgIGxpZ2h0UGFyYW1ldGVyc0NoYW5nZWQ6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjaGFuZ2VUeXBlKSB7XG4gICAgICAgIHRoaXMuZm92eSA9IHRoaXMuZ2V0UGFyYW1ldGVyKFwiZmFsbG9mZkFuZ2xlXCIpWzBdICogMjtcbiAgICAgICAgTGlnaHRNb2RlbC5wcm90b3R5cGUubGlnaHRQYXJhbWV0ZXJzQ2hhbmdlZC5jYWxsKHRoaXMsIHJlcXVlc3QsIGNoYW5nZVR5cGUpO1xuICAgIH1cbn0pO1xuXG5cblxuXG4vKipcbiAqIEltcGxlbWVudCBYTUwzRCdzIHByZWRlZmluZWQgc3BvdCBsaWdodCBtb2RlbCB1cm46eG1sM2Q6bGlnaHQ6ZGlyZWN0aW9uYWxcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXG4gKiBAcGFyYW0ge1JlbmRlckxpZ2h0fSBsaWdodFxuICogQGV4dGVuZHMgTGlnaHRNb2RlbFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEaXJlY3Rpb25hbExpZ2h0TW9kZWwgPSBmdW5jdGlvbiAoZGF0YU5vZGUsIGxpZ2h0KSB7XG4gICAgTGlnaHRNb2RlbC5jYWxsKHRoaXMsIFwiZGlyZWN0aW9uYWxcIiwgbGlnaHQsIGRhdGFOb2RlLCBEaXJlY3Rpb25hbExpZ2h0RGF0YSk7XG59O1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhEaXJlY3Rpb25hbExpZ2h0TW9kZWwsIExpZ2h0TW9kZWwsIHtcbiAgICBnZXRGcnVzdHVtOiBmdW5jdGlvbihhc3BlY3QsIHNjZW5lQm91bmRpbmdCb3gpIHtcbiAgICAgICAgdmFyIG9ydGhvZ29uYWwgPSB0cnVlO1xuXG4gICAgICAgIGlmIChzY2VuZUJvdW5kaW5nQm94LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcnVzdHVtKDEuMCwgMTEwLjAsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBvcnRob2dvbmFsKVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRfbWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5nZXRMaWdodFZpZXdNYXRyaXgodF9tYXQpO1xuICAgICAgICBzY2VuZUJvdW5kaW5nQm94LnRyYW5zZm9ybUF4aXNBbGlnbmVkKHRfbWF0KTtcblxuICAgICAgICB2YXIgbmYgPSB7ICBuZWFyOiAtc2NlbmVCb3VuZGluZ0JveC5tYXgueixcbiAgICAgICAgICAgICAgICAgICAgZmFyOiAgLXNjZW5lQm91bmRpbmdCb3gubWluLnp9O1xuICAgICAgICAvLyBFeHBhbmQgdGhlIHZpZXcgZnJ1c3R1bSBhIGJpdCB0byBlbnN1cmUgMkQgb2JqZWN0cyBwYXJhbGxlbCB0byB0aGUgY2FtZXJhIGFyZSByZW5kZXJlZFxuICAgICAgICB0aGlzLl9leHBhbmROZWFyRmFyKG5mKTtcblxuICAgICAgICByZXR1cm4gbmV3IEZydXN0dW0oMS4wLCBuZi5mYXIsIDAsIHRoaXMuZm92eSwgYXNwZWN0LCBvcnRob2dvbmFsKTtcbiAgICB9LFxuXG4gICAgdHJhbnNmb3JtUGFyYW1ldGVyczogZnVuY3Rpb24gKHRhcmdldCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSB0YXJnZXRbXCJkaXJlY3Rpb25cIl0uc3ViYXJyYXkob2Zmc2V0ICogMywgb2Zmc2V0ICogMyArIDMpO1xuICAgICAgICB0cmFuc2Zvcm1Qb3NlKHRoaXMubGlnaHQsIG51bGwsIGRpcmVjdGlvbik7XG4gICAgICAgIHRyYW5zZm9ybURlZmF1bHQodGFyZ2V0LCBvZmZzZXQsIHRoaXMubGlnaHQpO1xuICAgIH0sXG5cblxuXG4gICAgZ2V0TGlnaHRWaWV3TWF0cml4OiBmdW5jdGlvbiAobWF0KSB7XG4gICAgICAgIHZhciBtYW5hZ2VyID0gdGhpcy5saWdodC5zY2VuZS5saWdodHM7XG4gICAgICAgIHZhciBlbnRyeSA9IG1hbmFnZXIuZ2V0TW9kZWxFbnRyeSh0aGlzLmlkKTtcbiAgICAgICAgdmFyIHBfZGlyID0gZW50cnkucGFyYW1ldGVyc1tcImRpcmVjdGlvblwiXTtcbiAgICAgICAgdmFyIHBfcG9zID0gZW50cnkucGFyYW1ldGVyc1tcInBvc2l0aW9uXCJdO1xuXG4gICAgICAgIHZhciBiYiA9IG5ldyBYTUwzRC5Cb3goKTtcbiAgICAgICAgdGhpcy5saWdodC5zY2VuZS5nZXRCb3VuZGluZ0JveChiYik7XG4gICAgICAgIHZhciBvZmYgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgICAgICB2YXIgYmJDZW50ZXIgPSBiYi5jZW50ZXIoKTtcbiAgICAgICAgdmFyIGJiU2l6ZSA9IGJiLnNpemUoKTtcbiAgICAgICAgdmFyIGQgPSBiYlNpemUubGVuZ3RoKCk7IC8vZGlhbWV0ZXIgb2YgYm91bmRpbmcgc3BoZXJlIG9mIHRoZSBzY2VuZVxuICAgICAgICB2ZWMzLnNjYWxlKG9mZiwgcF9kaXIsIC0wLjU1ICogZCk7IC8vZW5sYXJnZSBhIGJpdCBvbiB0aGUgcmFkaXVzIG9mIHRoZSBzY2VuZVxuICAgICAgICBwX3BvcyA9IHZlYzMuYWRkKHBfcG9zLCBiYkNlbnRlci5kYXRhLCBvZmYpO1xuICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzW1wicG9zaXRpb25cIl0gPSBwX3BvcztcblxuXG4gICAgICAgIC8vY3JlYXRlIG5ldyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggZGVwZW5kaW5nIG9uIHRoZSB1cGRhdGVkIHBhcmFtZXRlcnNcbiAgICAgICAgbWF0NC5pZGVudGl0eShtYXQpO1xuICAgICAgICB2YXIgbG9va2F0X21hdCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciB0b3BfdmVjID0gdmVjMy5mcm9tVmFsdWVzKDAuMCwgMS4wLCAwLjApO1xuICAgICAgICBpZiAoKHBfZGlyWzBdID09IDAuMCkgJiYgKHBfZGlyWzJdID09IDAuMCkpIC8vY2hlY2sgaWYgdG9wX3ZlYyBjb2xpbmVhciB3aXRoIGRpcmVjdGlvblxuICAgICAgICAgICAgdG9wX3ZlYyA9IHZlYzMuZnJvbVZhbHVlcygwLjAsIDAuMCwgMS4wKTtcbiAgICAgICAgdmFyIHVwX3ZlYyA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHZhciBkaXJfbGVuID0gdmVjMy5sZW4ocF9kaXIpO1xuICAgICAgICB2ZWMzLnNjYWxlKHVwX3ZlYywgcF9kaXIsIC12ZWMzLmRvdCh0b3BfdmVjLCBwX2RpcikgLyAoZGlyX2xlbiAqIGRpcl9sZW4pKTtcbiAgICAgICAgdmVjMy5hZGQodXBfdmVjLCB1cF92ZWMsIHRvcF92ZWMpO1xuICAgICAgICB2ZWMzLm5vcm1hbGl6ZSh1cF92ZWMsIHVwX3ZlYyk7XG4gICAgICAgIG1hdDQubG9va0F0KGxvb2thdF9tYXQsIHZlYzMuZnJvbVZhbHVlcygwLjAsIDAuMCwgMC4wKSwgcF9kaXIsIHVwX3ZlYyk7XG4gICAgICAgIG1hdDQuaW52ZXJ0KGxvb2thdF9tYXQsIGxvb2thdF9tYXQpO1xuICAgICAgICBtYXQ0LnRyYW5zbGF0ZShtYXQsIG1hdCwgcF9wb3MpO1xuICAgICAgICBtYXQ0Lm11bHRpcGx5KG1hdCwgbWF0LCBsb29rYXRfbWF0KTtcblxuICAgICAgICBiYiA9IG5ldyBYTUwzRC5Cb3goKTtcbiAgICAgICAgdGhpcy5saWdodC5zY2VuZS5nZXRCb3VuZGluZ0JveChiYik7XG4gICAgICAgIGJiLnRyYW5zZm9ybUF4aXNBbGlnbmVkKG1hdCk7XG4gICAgICAgIGJiU2l6ZSA9IGJiLnNpemUoKS5kYXRhO1xuICAgICAgICB2YXIgbWF4ID0gKGJiU2l6ZVswXSA+IGJiU2l6ZVsxXSkgPyBiYlNpemVbMF0gOiBiYlNpemVbMV07XG4gICAgICAgIG1heCA9IDAuNTUgKiAobWF4KTsvL2VubGFyZ2UgMTBwZXJjZW50IHRvIG1ha2Ugc3VyZSBub3RoaW5nIGdldHMgY3V0IG9mZlxuICAgICAgICB0aGlzLmZvdnkgPSBtYXggPD0gMCA/IE1hdGguUEkgOiBNYXRoLmF0YW4obWF4KSoyLjA7XG5cbiAgICAgICAgZW50cnkucGFyYW1ldGVyc1tcImRpcmVjdGlvblwiXSA9IHBfZGlyO1xuICAgICAgICBlbnRyeS5wYXJhbWV0ZXJzW1wicG9zaXRpb25cIl0gID0gcF9wb3M7XG5cbiAgICAgICAgbWF0NC5pbnZlcnQobWF0LCBtYXQpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFBvaW50TGlnaHRNb2RlbDogUG9pbnRMaWdodE1vZGVsLCBTcG90TGlnaHRNb2RlbDogU3BvdExpZ2h0TW9kZWwsIERpcmVjdGlvbmFsTGlnaHRNb2RlbDogRGlyZWN0aW9uYWxMaWdodE1vZGVsXG5cbn07XG4iLCJ2YXIgR0xSZW5kZXJlciA9IHJlcXVpcmUoXCIuLi93ZWJnbC9yZW5kZXJlci5qc1wiKTtcbnZhciBHTENhbnZhc0hhbmRsZXIgPSByZXF1aXJlKFwiLi4vd2ViZ2wvY2FudmFzLWhhbmRsZXIuanNcIik7XG5cbnZhciBSZW5kZXJlckZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jcmVhdGVSZW5kZXJlciA9IGZ1bmN0aW9uICh4bWwzZEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHhtbDNkRWxlbWVudC5fY29uZmlndXJlZC5jYW52YXM7XG4gICAgICAgIHZhciBjYW52YXNIYW5kbGVyID0gbmV3IEdMQ2FudmFzSGFuZGxlcih4bWwzZEVsZW1lbnQsIGNhbnZhcyk7XG4gICAgICAgIHZhciByZW5kZXJlciA9IG5ldyBHTFJlbmRlcmVyKHhtbDNkRWxlbWVudCwgY2FudmFzSGFuZGxlcik7XG4gICAgICAgIGNhbnZhc0hhbmRsZXIuc2V0UmVuZGVyZXIocmVuZGVyZXIpO1xuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNhbnZhc0hhbmRsZXIudGljayk7XG4gICAgICAgIHJldHVybiByZW5kZXJlcjtcbiAgICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBuZXcgUmVuZGVyZXJGYWN0b3J5KCk7XG5cblxuXG5cblxuXG5cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIE5PREVfVFlQRToge1xuICAgICAgICBHUk9VUDogXCJncm91cFwiLCBPQkpFQ1Q6IFwib2JqZWN0XCIsIExJR0hUOiBcImxpZ2h0XCIsIFZJRVc6IFwidmlld1wiXG4gICAgfSxcblxuICAgIEVWRU5UX1RZUEU6IHtcbiAgICAgICAgVklFV19DSEFOR0VEOiBcInZpZXdfY2hhbmdlZFwiLFxuICAgICAgICBMSUdIVF9TVFJVQ1RVUkVfQ0hBTkdFRDogXCJsaWdodF9zdHJ1Y3R1cmVfY2hhbmdlZFwiLFxuICAgICAgICBMSUdIVF9WQUxVRV9DSEFOR0VEOiBcImxpZ2h0X3ZhbHVlX2NoYW5nZWRcIixcbiAgICAgICAgU0NFTkVfU0hBUEVfQ0hBTkdFRDogXCJzY2VuZV9zaGFwZV9jaGFuZ2VkXCIsXG4gICAgICAgIFNDRU5FX1NUUlVDVFVSRV9DSEFOR0VEOiBcInNjZW5lX3N0cnVjdHVyZV9jaGFuZ2VkXCIsXG4gICAgICAgIERSQVdBQkxFX1NUQVRFX0NIQU5HRUQ6IFwiZHJhd2FibGVfc3RhdGVfY2hhbmdlZFwiXG5cbiAgICB9XG59O1xuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIERyYXdhYmxlQ2xvc3VyZSA9IGZ1bmN0aW9uIChjb250ZXh0LCB0eXBlKSB7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICB0aGlzLl92YWxpZCA9IGZhbHNlO1xuICAgIC8vIERvIG5vdCBsaW1pdCB0aGUgbnVtYmVyIG9mIGxpc3RlbmVyc1xuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDApO1xufTtcblxuRHJhd2FibGVDbG9zdXJlLlRZUEVTID0ge1xuICAgIE1FU0g6IFwibWVzaFwiLCBWT0xVTUU6IFwidm9sdW1lXCJcbn07XG5cbkRyYXdhYmxlQ2xvc3VyZS5SRUFEWV9TVEFURSA9IHtcbiAgICBDT01QTEVURTogXCJjb21wbGV0ZVwiLCBJTkNPTVBMRVRFOiBcImluY29tcGxldGVcIlxufTtcblxuWE1MM0QuY3JlYXRlQ2xhc3MoRHJhd2FibGVDbG9zdXJlLCBFdmVudEVtaXR0ZXIsIHtcbiAgICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH0sIGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICAgIH0sIHNldFNoYWRlckNvbXBvc2VyOiBmdW5jdGlvbiAoc2hhZGVyQ29tcG9zZXIpIHtcbiAgICAgICAgLy8gaW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NcbiAgICB9LCB1cGRhdGU6IGZ1bmN0aW9uIChzY2VuZSkge1xuICAgICAgICAvLyBpbXBsZW1lbnRlZCBieSBzdWJjbGFzc1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERyYXdhYmxlQ2xvc3VyZTtcblxuIiwidmFyIHVuaXF1ZU9iamVjdElkID0gcmVxdWlyZShcIi4uLy4uL3dlYmdsL2Jhc2UvdXRpbHMuanNcIikuZ2V0VW5pcXVlQ291bnRlcigpO1xuLyoqXG4gKiBDb25uZWN0cyBhIGxpZ2h0IG1vZGVsIHdpdGggYSBkYXRhIG5vZGUgY29udGFpbmluZyBsaWdodCBwYXJhbXRlcnNcbiAqIGFuZCBhIHJlbmRlciBsaWdodCB0byBldmFsdWF0ZSB0aGUgd29ybGQgcG9zaXRpb24gb2YgdGhlIGxpZ2h0LlxuICogVGhlIExpZ2h0Q29uZmlndXJhdGlvbiBpcyBpbW11dGFibGVcbiAqXG4gKiBAcGFyYW0gbW9kZWwgVGhlIGxpZ2h0IG1vZGVsXG4gKiBAcGFyYW0ge1hmbG93LkRhdGFOb2RlfSBkYXRhTm9kZSAgVGhlIGxpZ2h0IHBhcmFtZXRlcnMgb2YgdGhpcyBub2RlXG4gKiBAcGFyYW0ge1JlbmRlckxpZ2h0fSBsaWdodCAgVGhlIGxpZ2h0IGluIHRoZSB0cmFuc2Zvcm1hdGlvbiBoaWVyYXJjaHlcbiAqIEBwYXJhbSB7e319IG9wdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMaWdodENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbihtb2RlbCwgZGF0YU5vZGUsIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVPYmplY3RJZCgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3t0eXBlOiBzdHJpbmd9fVxuICAgICAqL1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcblxuICAgIC8qKlxuICAgICAqIERhdGEgTm9kZSBvZiB0aGUgcmVuZGVyT2JqZWN0XG4gICAgICogQHR5cGUge1hmbG93LkRhdGFOb2RlfVxuICAgICAqL1xuICAgIHRoaXMuZGF0YU5vZGUgPSBkYXRhTm9kZTtcblxuICAgIC8qKlxuICAgICAqIEEgbmFtZSBmb3IgZGVidWcgcHVycG9zZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gb3B0Lm5hbWUgfHwgbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTGlnaHRDb25maWd1cmF0aW9uO1xuIiwidmFyIHVuaXF1ZU9iamVjdElkID0gcmVxdWlyZShcIi4uLy4uL3dlYmdsL2Jhc2UvdXRpbHMuanNcIikuZ2V0VW5pcXVlQ291bnRlcigpO1xuLyoqXG4gKiBDb25uZWN0cyBhIG1hdGVyaWFsIG1vZGVsIHdpdGggYSBzZXQgb2YgZGVmYXVsdCBwYXJhbWV0ZXJzIGRlZmluZWQgYnlcbiAqIGFuIFhmbG93IERhdGFOb2RlLiBUaGUgTWF0ZXJpYWxDb25maWd1cmF0aW9uIGlzIGltbXV0YWJsZVxuICpcbiAqIEBwYXJhbSBtb2RlbCBUaGUgbWF0ZXJpYWwgbW9kZWxcbiAqIEBwYXJhbSB7WGZsb3cuRGF0YU5vZGV9IGRhdGFOb2RlICBUaGUgbWF0ZXJpYWwgcGFyYW1ldGVycyBvZiB0aGlzIG5vZGVcbiAqIEBwYXJhbSB7e319IG9wdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNYXRlcmlhbENvbmZpZ3VyYXRpb24gPSBmdW5jdGlvbihtb2RlbCwgZGF0YU5vZGUsIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIHRoaXMuaWQgPSB1bmlxdWVPYmplY3RJZCgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3t0eXBlOiBzdHJpbmd9fVxuICAgICAqL1xuICAgIHRoaXMubW9kZWwgPSBtb2RlbDtcblxuICAgIC8qKlxuICAgICAqIERhdGEgTm9kZSBvZiB0aGUgcmVuZGVyT2JqZWN0XG4gICAgICogQHR5cGUge1hmbG93LkRhdGFOb2RlfVxuICAgICAqL1xuICAgIHRoaXMuZGF0YU5vZGUgPSBkYXRhTm9kZTtcblxuICAgIC8qKlxuICAgICAqIEEgbmFtZSBmb3IgZGVidWcgcHVycG9zZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5uYW1lID0gb3B0Lm5hbWUgfHwgbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0ZXJpYWxDb25maWd1cmF0aW9uO1xuIiwidmFyIERFRkFVTFRfUEFHRV9TSVpFID0gMSA8PCAxMjtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFBhZ2VyID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIHRoaXMucGFnZVNpemUgPSBvcHQucGFnZVNpemUgfHwgREVGQVVMVF9QQUdFX1NJWkU7XG5cbiAgICAvKiogQHR5cGUgQXJyYXk8RmxvYXQzMkFycmF5PiAqL1xuICAgIHRoaXMucGFnZXMgPSBbXTtcbiAgICAvKiogQHR5cGUgbnVtYmVyICovXG4gICAgdGhpcy5uZXh0T2Zmc2V0ID0gMDtcbiAgICAvKiogQHR5cGUgQXJyYXk8Kj4gKi9cbiAgICB0aGlzLmZyZWVFbnRyaWVzID0gW107XG4gICAgLy8gQWRkIGEgZmlyc3QgcGFnZVxuICAgIHRoaXMuYWRkUGFnZSgpO1xufTtcblxuWE1MM0QuZXh0ZW5kKFBhZ2VyLnByb3RvdHlwZSwge1xuICAgIGFkZFBhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhZ2UgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMucGFnZVNpemUpO1xuICAgICAgICB0aGlzLnBhZ2VzLnB1c2gocGFnZSk7XG4gICAgICAgIHRoaXMubmV4dE9mZnNldCA9IDA7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0luZm8oXCJBZGRpbmcgcGFnZVwiLCB0aGlzLnBhZ2VzLmxlbmd0aCwgXCIoXCIsIHRoaXMucGFnZVNpemUgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgKiB0aGlzLnBhZ2VzLmxlbmd0aCAvIDEwMjQsIFwia0IpXCIpO1xuICAgIH0sXG5cbiAgICBnZXRQYWdlRW50cnk6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmICghc2l6ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHNpemUgZ2l2ZW4gZm9yIHBhZ2UgZW50cnlcIik7XG4gICAgICAgIHJldHVybiB0aGlzLnJldXNlUGFnZUVudHJ5KHNpemUpIHx8IHRoaXMuY3JlYXRlUGFnZUVudHJ5KHNpemUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc2l6ZSBSZXF1ZXN0ZWQgc2l6ZSBpbiBudW1iZXIgb2YgZmxvYXRzXG4gICAgICogQHJldHVybnMge3sgcGFnZTogRmxvYXQzMkFycmF5LCBvZmZzZXQ6IG51bWJlciwgc2l6ZTogbnVtYmVyIH19XG4gICAgICovXG4gICAgcmV1c2VQYWdlRW50cnk6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIHZhciBzYW1lU2l6ZUVudHJpZXMgPSB0aGlzLmZyZWVFbnRyaWVzW3NpemVdO1xuICAgICAgICBpZiAoc2FtZVNpemVFbnRyaWVzICYmIHNhbWVTaXplRW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBzYW1lU2l6ZUVudHJpZXMucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplICBTaXplIGluIG51bWJlciBvZiBmbG9hdHNcbiAgICAgKiBAcmV0dXJucyB7eyBwYWdlOiBGbG9hdDMyQXJyYXksIG9mZnNldDogbnVtYmVyLCBzaXplOiBudW1iZXIgfX1cbiAgICAgKi9cbiAgICBjcmVhdGVQYWdlRW50cnk6IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHRPZmZzZXQgKyBzaXplID4gdGhpcy5wYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5hZGRQYWdlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRQYWdlRW50cnkoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZ2UgPSB0aGlzLnBhZ2VzW3RoaXMucGFnZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBsb2NhbE9mZnNldCA9IHRoaXMubmV4dE9mZnNldDtcbiAgICAgICAgdGhpcy5uZXh0T2Zmc2V0ICs9IHNpemU7XG4gICAgICAgIHJldHVybiB7cGFnZTogcGFnZSwgb2Zmc2V0OiBsb2NhbE9mZnNldCwgc2l6ZTogc2l6ZX07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHt7IHBhZ2U6IEZsb2F0MzJBcnJheSwgb2Zmc2V0OiBudW1iZXIsIHNpemU6IG51bWJlciB9fSBlbnRyeUluZm9cbiAgICAgKi9cbiAgICBmcmVlUGFnZUVudHJ5OiBmdW5jdGlvbiAoZW50cnlJbmZvKSB7XG4gICAgICAgIHZhciBzYW1lU2l6ZUVudHJpZXMgPSB0aGlzLmZyZWVFbnRyaWVzW2VudHJ5SW5mby5zaXplXTtcbiAgICAgICAgaWYgKCFzYW1lU2l6ZUVudHJpZXMpIHtcbiAgICAgICAgICAgIHNhbWVTaXplRW50cmllcyA9IHRoaXMuZnJlZUVudHJpZXNbZW50cnlJbmZvLnNpemVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgc2FtZVNpemVFbnRyaWVzLnB1c2goZW50cnlJbmZvKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQYWdlcjtcblxuIiwidmFyIFJlbmRlck5vZGUgPSByZXF1aXJlKFwiLi9yZW5kZXJub2RlLmpzXCIpO1xudmFyIENvbnN0YW50cyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcblxudmFyIE5PREVfVFlQRSA9IENvbnN0YW50cy5OT0RFX1RZUEU7XG52YXIgRVZFTlRfVFlQRSA9IENvbnN0YW50cy5FVkVOVF9UWVBFO1xuXG4vKiogQGNvbnN0ICovXG52YXIgV09STERfTUFUUklYX09GRlNFVCA9IDA7XG4vKiogQGNvbnN0ICovXG52YXIgTE9DQUxfTUFUUklYX09GRlNFVCA9IFdPUkxEX01BVFJJWF9PRkZTRVQgKyAxNjtcbi8qKiBAY29uc3QgKi9cbnZhciBXT1JMRF9CQl9PRkZTRVQgPSBMT0NBTF9NQVRSSVhfT0ZGU0VUICsgMTY7XG4vKiogQGNvbnN0ICovXG52YXIgRU5UUllfU0laRSA9IFdPUkxEX0JCX09GRlNFVCArIDY7XG5cbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1JlbmRlck5vZGV9XG4gKi9cbnZhciBSZW5kZXJHcm91cCA9IGZ1bmN0aW9uIChzY2VuZSwgcGFnZUVudHJ5LCBvcHQpIHtcbiAgICBSZW5kZXJOb2RlLmNhbGwodGhpcywgTk9ERV9UWVBFLkdST1VQLCBzY2VuZSwgcGFnZUVudHJ5LCBvcHQpO1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXRlcmlhbCBhdHRhY2hlZCB0byB0aGlzIGdyb3VwXG4gICAgICogQHR5cGUge01hdGVyaWFsQ29uZmlndXJhdGlvbnxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX21hdGVyaWFsID0gb3B0Lm1hdGVyaWFsIHx8IG51bGw7XG4gICAgdGhpcy5ib3VuZGluZ0JveERpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5zZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goWE1MM0QuQm94LkVNUFRZX0JPWCk7XG59O1xuUmVuZGVyR3JvdXAuRU5UUllfU0laRSA9IEVOVFJZX1NJWkU7XG5cblhNTDNELmNyZWF0ZUNsYXNzKFJlbmRlckdyb3VwLCBSZW5kZXJOb2RlKTtcblxuWE1MM0QuZXh0ZW5kKFJlbmRlckdyb3VwLnByb3RvdHlwZSwge1xuICAgIGdldExvY2FsTWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgICB0aGlzLmdldE1hdDRGcm9tUGFnZShkZXN0LCBMT0NBTF9NQVRSSVhfT0ZGU0VUKTtcbiAgICB9LFxuXG4gICAgc2V0TG9jYWxNYXRyaXg6IGZ1bmN0aW9uIChzb3VyY2VNYXQ0KSB7XG4gICAgICAgIHRoaXMuc2V0TWF0NEluUGFnZShzb3VyY2VNYXQ0LCBMT0NBTF9NQVRSSVhfT0ZGU0VUKTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xuICAgICAgICB0aGlzLnNldEJvdW5kaW5nQm94RGlydHkoKTtcbiAgICB9LFxuXG4gICAgZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xuICAgICAgICBpZiAodGhpcy5ib3VuZGluZ0JveERpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkU3BhY2VCb3VuZGluZ0JveCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBXT1JMRF9CQl9PRkZTRVQ7XG4gICAgICAgIGJib3guZGF0YVswXSA9IHRoaXMucGFnZVtvXTtcbiAgICAgICAgYmJveC5kYXRhWzFdID0gdGhpcy5wYWdlW28gKyAxXTtcbiAgICAgICAgYmJveC5kYXRhWzJdID0gdGhpcy5wYWdlW28gKyAyXTtcbiAgICAgICAgYmJveC5kYXRhWzNdID0gdGhpcy5wYWdlW28gKyAzXTtcbiAgICAgICAgYmJveC5kYXRhWzRdID0gdGhpcy5wYWdlW28gKyA0XTtcbiAgICAgICAgYmJveC5kYXRhWzVdID0gdGhpcy5wYWdlW28gKyA1XTtcbiAgICB9LFxuXG4gICAgc2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgV09STERfQkJfT0ZGU0VUO1xuICAgICAgICB0aGlzLnBhZ2Vbb10gPSBiYm94LmRhdGFbMF07XG4gICAgICAgIHRoaXMucGFnZVtvICsgMV0gPSBiYm94LmRhdGFbMV07XG4gICAgICAgIHRoaXMucGFnZVtvICsgMl0gPSBiYm94LmRhdGFbMl07XG4gICAgICAgIHRoaXMucGFnZVtvICsgM10gPSBiYm94LmRhdGFbM107XG4gICAgICAgIHRoaXMucGFnZVtvICsgNF0gPSBiYm94LmRhdGFbNF07XG4gICAgICAgIHRoaXMucGFnZVtvICsgNV0gPSBiYm94LmRhdGFbNV07XG4gICAgfSxcblxuXG4gICAgdXBkYXRlV29ybGRTcGFjZUJvdW5kaW5nQm94OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2hpbGRCQiA9IG5ldyBYTUwzRC5Cb3goKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxvY2FsQkIgPSBuZXcgWE1MM0QuQm94KCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBqID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBvYmouZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGNoaWxkQkIpO1xuICAgICAgICAgICAgICAgIGxvY2FsQkIuZXh0ZW5kKGNoaWxkQkIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRXb3JsZFNwYWNlQm91bmRpbmdCb3gobG9jYWxCQik7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94RGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pKCksXG5cbiAgICBhZGRDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xuICAgICAgICB0aGlzLnNjZW5lLmVtaXQoRVZFTlRfVFlQRS5TQ0VORV9TVFJVQ1RVUkVfQ0hBTkdFRCwgY2hpbGQsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmNoaWxkcmVuLmluZGV4T2YoY2hpbGQpO1xuICAgICAgICBpZiAoaW5kZXggIT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjZW5lLmVtaXQoRVZFTlRfVFlQRS5TQ0VORV9TVFJVQ1RVUkVfQ0hBTkdFRCwgY2hpbGQsIHRydWUpO1xuICAgIH0sXG5cbiAgICBnZXRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbjtcbiAgICB9LFxuXG4gICAgdXBkYXRlV29ybGRNYXRyaXg6IGZ1bmN0aW9uIChzb3VyY2VNYXQ0KSB7XG4gICAgICAgIHZhciBwYWdlID0gdGhpcy5wYWdlO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseU9mZnNldChwYWdlLCBvZmZzZXQgKyBXT1JMRF9NQVRSSVhfT0ZGU0VULCBwYWdlLCBvZmZzZXQgKyBMT0NBTF9NQVRSSVhfT0ZGU0VULCBzb3VyY2VNYXQ0LCAwKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1EaXJ0eSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBzZXRUcmFuc2Zvcm1EaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1EaXJ0eSkge1xuICAgICAgICAgICAgLy9XZSBjYW4gYmUgc3VyZSBhbGwgY2hpbGQgbm9kZXMgYXJlIGFscmVhZHkgc2V0IHRvIHRyYW5zZm9ybURpcnR5IGZyb20gaGVyZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSB0cnVlO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICBmb3IodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZHJlbltpXS5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWF0ZXJpYWxDb25maWd1cmF0aW9ufG51bGx9IG1hdGVyaWFsXG4gICAgICovXG4gICAgc2V0TWF0ZXJpYWw6IGZ1bmN0aW9uIChtYXRlcmlhbCkge1xuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbCA9PT0gbWF0ZXJpYWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX21hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBvYmoucGFyZW50TWF0ZXJpYWxDaGFuZ2VkICYmIG9iai5wYXJlbnRNYXRlcmlhbENoYW5nZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHBhcmVudE1hdGVyaWFsQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIC8vIExvY2FsIG1hdGVyaWFsIG92ZXJyaWRlcyBhbnl0aGluZyBjb21pbmcgZnJvbSB1cHN0cmVhbVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBvYmoucGFyZW50TWF0ZXJpYWxDaGFuZ2VkICYmIG9iai5wYXJlbnRNYXRlcmlhbENoYW5nZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtNYXRlcmlhbENvbmZpZ3VyYXRpb259XG4gICAgICovXG4gICAgZ2V0TWF0ZXJpYWw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hdGVyaWFsIHx8IHRoaXMucGFyZW50LmdldE1hdGVyaWFsKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgZ3JvdXAgcHJvcGFnYXRlcyBpdHMgdmlzaWJpbGl0eVxuICAgICAqL1xuICAgIHZpc2liaWxpdHlDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZHJlbltpXS5ldmFsdWF0ZVZpc2liaWxpdHkoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuXG4gICAgc2V0Qm91bmRpbmdCb3hEaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJvdW5kaW5nQm94RGlydHkgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnNldEJvdW5kaW5nQm94RGlydHkoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaW5kUmF5SW50ZXJzZWN0aW9uczogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgWE1MM0QuQm94KCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyYXksIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xuICAgICAgICAgICAgaWYgKHJheS5pbnRlcnNlY3RzKGJib3gpKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZmluZFJheUludGVyc2VjdGlvbnMocmF5LCBpbnRlcnNlY3Rpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgpXG5cbn0pO1xuXG4vLyBFeHBvcnRcbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyR3JvdXA7XG5cbiIsInZhciBSZW5kZXJOb2RlID0gcmVxdWlyZShcIi4vcmVuZGVybm9kZS5qc1wiKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG52YXIgTGlnaHRNb2RlbHMgPSByZXF1aXJlKFwiLi4vbGlnaHRzL2xpZ2h0LW1vZGVscy5qc1wiKTtcblxudmFyIE5PREVfVFlQRSA9IENvbnN0YW50cy5OT0RFX1RZUEU7XG52YXIgRVZFTlRfVFlQRSA9IENvbnN0YW50cy5FVkVOVF9UWVBFO1xuXG52YXIgdG1wX3dvcmxkTWF0cml4ID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xuXG52YXIgU0hBRE9XTUFQX09GRlNFVF9NQVRSSVggPSBuZXcgRmxvYXQzMkFycmF5KFswLjUsIDAuMCwgMC4wLCAwLjAsIDAuMCwgMC41LCAwLjAsIDAuMCwgMC4wLCAwLjAsIDAuNSwgMC4wLCAwLjUsIDAuNSwgMC41LCAxLjBdKTtcblxuLyoqIEBjb25zdCAqL1xudmFyIENMSVBQTEFORV9ORUFSX01JTiA9IDEuMDtcblxuLyoqIEBjb25zdCAqL1xudmFyIEVOVFJZX1NJWkUgPSAxNjtcblxudmFyIGNfQm91bmRpbmdCb3ggPSBuZXcgWE1MM0QuQm94KCk7XG5cblxuZnVuY3Rpb24gY3JlYXRlTGlnaHRNb2RlbCh0eXBlLCBkYXRhLCBsaWdodCkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwidXJuOnhtbDNkOmxpZ2h0OnBvaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpZ2h0TW9kZWxzLlBvaW50TGlnaHRNb2RlbChkYXRhLCBsaWdodCk7XG4gICAgICAgIGNhc2UgXCJ1cm46eG1sM2Q6bGlnaHQ6c3BvdFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaWdodE1vZGVscy5TcG90TGlnaHRNb2RlbChkYXRhLCBsaWdodCk7XG4gICAgICAgIGNhc2UgXCJ1cm46eG1sM2Q6bGlnaHQ6ZGlyZWN0aW9uYWxcIjpcbiAgICAgICAgICAgIHJldHVybiBuZXcgTGlnaHRNb2RlbHMuRGlyZWN0aW9uYWxMaWdodE1vZGVsKGRhdGEsIGxpZ2h0KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJVbmtub3duIGxpZ2h0IG1vZGVsOiBcIiwgdHlwZSwgXCIuIFVzaW5nIGRpcmVjdGlvbmFsIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBMaWdodE1vZGVscy5EaXJlY3Rpb25hbExpZ2h0TW9kZWwoZGF0YSwgbGlnaHQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gKiBAcGFyYW0ge09iamVjdH0gcGFnZUVudHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gKiBAZXh0ZW5kcyB7UmVuZGVyTm9kZX1cbiAqL1xudmFyIFJlbmRlckxpZ2h0ID0gZnVuY3Rpb24gKHNjZW5lLCBwYWdlRW50cnksIG9wdCkge1xuICAgIFJlbmRlck5vZGUuY2FsbCh0aGlzLCBOT0RFX1RZUEUuTElHSFQsIHNjZW5lLCBwYWdlRW50cnksIG9wdCk7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgIHZhciBjb25maWd1cmF0aW9uID0gb3B0LmNvbmZpZ3VyYXRpb24gfHwge307XG4gICAgdGhpcy5zZXRMaWdodFR5cGUoY29uZmlndXJhdGlvbi5tb2RlbCwgY29uZmlndXJhdGlvbi5kYXRhTm9kZSk7XG59O1xuUmVuZGVyTGlnaHQuRU5UUllfU0laRSA9IEVOVFJZX1NJWkU7XG5cblhNTDNELmNyZWF0ZUNsYXNzKFJlbmRlckxpZ2h0LCBSZW5kZXJOb2RlKTtcblhNTDNELmV4dGVuZChSZW5kZXJMaWdodC5wcm90b3R5cGUsIHtcblxuICAgIHNldExpZ2h0VHlwZTogZnVuY3Rpb24gKG1vZGVsSWQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vZGVsLmlkID09IG1vZGVsSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIE5vdGhpbmcgY2hhbmdlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zY2VuZS5saWdodHMucmVtb3ZlKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5saWdodFN0cnVjdHVyZUNoYW5nZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb2RlbCA9IGNyZWF0ZUxpZ2h0TW9kZWwobW9kZWxJZCwgZGF0YSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2NlbmUubGlnaHRzLmFkZCh0aGlzKTtcbiAgICAgICAgdGhpcy5saWdodFN0cnVjdHVyZUNoYW5nZWQoZmFsc2UpO1xuICAgIH0sXG5cbiAgICBzZXRMb2NhbE1hdHJpeDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlJlbmRlckxpZ2h0OjpzZXRMb2NhbE1hdHJpeCBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfSxcblxuXG4gICAgZ2V0RnJ1c3R1bTogZnVuY3Rpb24gKGFzcGVjdCkge1xuICAgICAgICB0aGlzLnNjZW5lLmdldEJvdW5kaW5nQm94KGNfQm91bmRpbmdCb3gpO1xuICAgICAgICByZXR1cm4gdGhpcy5tb2RlbC5nZXRGcnVzdHVtKGFzcGVjdCwgY19Cb3VuZGluZ0JveCk7XG4gICAgfSxcblxuICAgIGxpZ2h0VmFsdWVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGVsKSB7IC8vIEZJWE1FOiBDb21wbGV4IGRlcGVuZGVuY3lcbiAgICAgICAgICAgIHRoaXMuc2NlbmUuZW1pdChFVkVOVF9UWVBFLkxJR0hUX1ZBTFVFX0NIQU5HRUQsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxpZ2h0U3RydWN0dXJlQ2hhbmdlZDogZnVuY3Rpb24gKHJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5zY2VuZS5lbWl0KEVWRU5UX1RZUEUuTElHSFRfU1RSVUNUVVJFX0NIQU5HRUQsIHRoaXMsIHJlbW92ZWQpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVXb3JsZE1hdHJpeDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KHRtcF93b3JsZE1hdHJpeCk7XG4gICAgICAgICAgICB0aGlzLnNldFdvcmxkTWF0cml4KHRtcF93b3JsZE1hdHJpeCk7XG4gICAgICAgICAgICAvLyBXZSBjaGFuZ2UgcG9zaXRpb24gLyBkaXJlY3Rpb24gb2YgdGhlIGxpZ2h0XG4gICAgICAgICAgICB0aGlzLmxpZ2h0VmFsdWVDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmlzaWJpbGl0eUNoYW5nZWQ6IGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgLy8gVmlzaWJpbGl0eSBpcyBhIGxpZ2h0IHBhcmFtZXRlclxuICAgICAgICB0aGlzLmxpZ2h0VmFsdWVDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIHNldFRyYW5zZm9ybURpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoKTtcbiAgICB9LFxuXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHRoaXMuc2NlbmUubGlnaHRzLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgdGhpcy5saWdodFN0cnVjdHVyZUNoYW5nZWQodHJ1ZSk7XG4gICAgfSxcblxuXG4gICAgZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xuICAgICAgICBiYm94LnNldEVtcHR5KCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVuZGVyTGlnaHQ7XG5cblxuIiwiLyoqIEBjb25zdCAqL1xudmFyIFdPUkxEX01BVFJJWF9PRkZTRVQgPSAwO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHR5cGVcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gKiBAcGFyYW0ge09iamVjdH0gcGFnZUVudHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0XG4gKi9cbnZhciBSZW5kZXJOb2RlID0gZnVuY3Rpb24gKHR5cGUsIHNjZW5lLCBwYWdlRW50cnksIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcblxuICAgIHRoaXMuc2NlbmUgPSBzY2VuZTtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMubmFtZSA9IG9wdC5uYW1lIHx8IFwiXCI7XG4gICAgdGhpcy5wYWdlID0gcGFnZUVudHJ5LnBhZ2U7XG4gICAgdGhpcy5vZmZzZXQgPSBwYWdlRW50cnkub2Zmc2V0O1xuICAgIHRoaXMuZW50cnlTaXplID0gcGFnZUVudHJ5LnNpemU7XG4gICAgdGhpcy50cmFuc2Zvcm1EaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcblxuICAgIHRoaXMuc2V0UGFyZW50KG9wdC5wYXJlbnQgfHwgc2NlbmUucm9vdE5vZGUpO1xuXG4gICAgdGhpcy5sb2NhbFZpc2libGUgPSB0cnVlO1xuICAgIC8vIFRoZSBnbG9iYWwgdmlzaWJpbGl0eSBkZXBlbmRzIG9uIHZpc2liaWxpdHkgb2YgcGFyZW50c1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5ldmFsdWF0ZVZpc2liaWxpdHkoKTtcbn07XG5cblhNTDNELmV4dGVuZChSZW5kZXJOb2RlLnByb3RvdHlwZSwge1xuXG4gICAgZ2V0Q2hpbGRyZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW47XG4gICAgfSxcblxuICAgIGV2YWx1YXRlVmlzaWJpbGl0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvbGRWaXNpYmxlID0gdGhpcy52aXNpYmxlO1xuICAgICAgICBpZih0aGlzLnBhcmVudCAmJiAhdGhpcy5wYXJlbnQudmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSB0aGlzLmxvY2FsVmlzaWJsZTtcbiAgICAgICAgfVxuICAgICAgICBpZihvbGRWaXNpYmxlICE9PSB0aGlzLnZpc2libGUpIHtcbiAgICAgICAgICAgIHRoaXMudmlzaWJpbGl0eUNoYW5nZWQoKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUucmVxdWVzdFJlZHJhdyAmJiB0aGlzLnNjZW5lLnJlcXVlc3RSZWRyYXcoXCJWaXNpYmlsaXR5IGNoYW5nZWQuXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldExvY2FsVmlzaWJsZTogZnVuY3Rpb24obmV3VmlzaWJsZSkge1xuICAgICAgICBpZiAodGhpcy5sb2NhbFZpc2libGUgPT09IG5ld1Zpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvY2FsVmlzaWJsZSA9IG5ld1Zpc2libGU7XG4gICAgICAgIHRoaXMuZXZhbHVhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSxcblxuICAgIC8vIE5lZWRzIHRvIGJlIG92ZXJ3cml0dGVuXG4gICAgdmlzaWJpbGl0eUNoYW5nZWQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgICBnZXRQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgIH0sXG5cbiAgICBzZXRQYXJlbnQ6IGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50LmFkZENoaWxkKSB7XG4gICAgICAgICAgICBwYXJlbnQuYWRkQ2hpbGQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVldmFsdWF0ZSB2aXNpYmlsaXR5LCB3aGljaCBtaWdodCBjaGFuZ2UgZHVlIHRvXG4gICAgICAgIC8vIGludmlzaWJpbGl0eSBvZiBwYXJlbnRcbiAgICAgICAgdGhpcy5ldmFsdWF0ZVZpc2liaWxpdHkoKTtcbiAgICB9LFxuXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayh0aGlzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQudHJhdmVyc2UoY2FsbGJhY2spO1xuICAgICAgICB9KVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge01hdDR9IHNvdXJjZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICAgKi9cbiAgICBzZXRNYXQ0SW5QYWdlOiBmdW5jdGlvbihzb3VyY2UsIG9mZnNldCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgb2Zmc2V0O1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgMTY7IGkrKywgbysrKSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2Vbb10gPSBzb3VyY2VbaV07XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtNYXQ0fSBkZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgICAqL1xuICAgIGdldE1hdDRGcm9tUGFnZTogZnVuY3Rpb24oZGVzdCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBvZmZzZXQ7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCAxNjsgaSsrLCBvKyspIHtcbiAgICAgICAgICAgIGRlc3RbaV0gPSB0aGlzLnBhZ2Vbb107XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0V29ybGRNYXRyaXg6IGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybURpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeChkZXN0KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlV29ybGRNYXRyaXgoZGVzdCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRNYXQ0RnJvbVBhZ2UoZGVzdCwgV09STERfTUFUUklYX09GRlNFVCk7XG4gICAgfSxcblxuICAgIHNldFdvcmxkTWF0cml4OiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICAgIHRoaXMuc2V0TWF0NEluUGFnZShzb3VyY2UsIFdPUkxEX01BVFJJWF9PRkZTRVQpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybURpcnR5ID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLnNldEJvdW5kaW5nQm94RGlydHkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldFRyYW5zZm9ybURpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSB0cnVlO1xuICAgIH0sXG5cbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgICAgIHRoaXMuc2NlbmUucGFnZXIuZnJlZVBhZ2VFbnRyeSh7cGFnZTogdGhpcy5wYWdlLCBvZmZzZXQ6IHRoaXMub2Zmc2V0LCBzaXplOiB0aGlzLmVudHJ5U2l6ZX0pO1xuICAgIH0sXG5cbiAgICBmaW5kUmF5SW50ZXJzZWN0aW9uczogZnVuY3Rpb24gKC8qIHJheSwgY2xvc2VzdEludGVyc2VjdGlvbiovKSB7XG4gICAgICAgIC8vVGhpcyBmdW5jdGlvbiBpcyBvdmVycmlkZGVuIGJ5IGdyb3VwcyBhbmQgZHJhd2FibGVzXG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJOb2RlO1xuIiwidmFyIFN5c3RlbU5vdGlmaWVyID0gcmVxdWlyZShcIi4uLy4uL3dlYmdsL3N5c3RlbS9zeXN0ZW0tbm90aWZpZXIuanNcIik7XG52YXIgUmVuZGVyTm9kZSA9IHJlcXVpcmUoXCIuL3JlbmRlcm5vZGUuanNcIik7XG52YXIgRHJhd2FibGVDbG9zdXJlPSByZXF1aXJlKFwiLi9kcmF3YWJsZWNsb3N1cmUuanNcIik7XG52YXIgQyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcbnZhciBTY2VuZT0gcmVxdWlyZShcIi4vc2NlbmUuanNcIik7XG52YXIgQ29tcHV0ZVJlcXVlc3QgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL3JlcXVlc3QuanNcIikuQ29tcHV0ZVJlcXVlc3Q7XG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcblxuLy8gRW50cnk6XG4vKiogQGNvbnN0ICovXG52YXIgV09STERfTUFUUklYX09GRlNFVCA9IDA7XG4vKiogQGNvbnN0ICovXG52YXIgTE9DQUxfTUFUUklYX09GRlNFVCA9IFdPUkxEX01BVFJJWF9PRkZTRVQgKyAxNjtcbi8qKiBAY29uc3QgKi9cbnZhciBPQkpFQ1RfQkJfT0ZGU0VUID0gTE9DQUxfTUFUUklYX09GRlNFVCArIDE2O1xuLyoqIEBjb25zdCAqL1xudmFyIFdPUkxEX0JCX09GRlNFVCA9IE9CSkVDVF9CQl9PRkZTRVQgKyA2O1xuLyoqIEBjb25zdCAqL1xudmFyIE1PREVMVklFV19NQVRSSVhfT0ZGU0VUID0gV09STERfQkJfT0ZGU0VUICsgNjtcbi8qKiBAY29uc3QgKi9cbnZhciBNT0RFTFZJRVdQUk9KRUNUSU9OX01BVFJJWF9PRkZTRVQgPSBNT0RFTFZJRVdfTUFUUklYX09GRlNFVCArIDE2O1xuLyoqIEBjb25zdCAqL1xudmFyIE1PREVMX01BVFJJWF9OX09GRlNFVCA9IE1PREVMVklFV1BST0pFQ1RJT05fTUFUUklYX09GRlNFVCArIDE2O1xuLyoqIEBjb25zdCAqL1xudmFyIE1PREVMVklFV19NQVRSSVhfTl9PRkZTRVQgPSBNT0RFTF9NQVRSSVhfTl9PRkZTRVQgKyAxNjtcbi8qKiBAY29uc3QgKi9cbnZhciBFTlRSWV9TSVpFID0gTU9ERUxWSUVXX01BVFJJWF9OX09GRlNFVCArIDE2O1xuXG4vL25vaW5zcGVjdGlvbiBKU0Nsb3N1cmVDb21waWxlclN5bnRheCxKU0Nsb3N1cmVDb21waWxlclN5bnRheFxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcmVuZGVyYWJsZSBvYmplY3QgaW4gdGhlIHNjZW5lLlxuICogVGhlIFJlbmRlck9iamVjdCBoYXMgdGhlc2UgcmVzcG9uc2liaWxpdGllczpcbiAqICAxLiBLZWVwIHRyYWNrIG9mIHRoZSB0cmFuc2Zvcm1hdGlvbiBoaWVyYXJjaHkgYW5kIGJvdW5kaW5nIGJveGVzXG4gKiAgMi4gQ29ubmVjdCB0aGUgRHJhd2FibGVDbG9zdXJlIHdpdGggdGhlIFNoYWRlckNsb3N1cmVcbiAqXG4gKiAgVGhlIHtAbGluayBEcmF3YWJsZUNsb3N1cmV9IGlzIGEgRHJhd2FibGVPYmplY3QgcGx1cyBpdCdzIGRhdGFcbiAqICBUaGUge0BsaW5rIFNoYWRlckNsb3N1cmV9IGlzIGEgUHJvZ3JhbU9iamVjdCBwbHVzIGl0J3MgZGF0YVxuICogIFRoZSBjb25jcmV0ZSBTaGFkZXJDbG9zdXJlIGNhbiB2YXJ5IHBlciBEcmF3YWJsZU9iamVjdCBhbmQgY2hhbmdlXG4gKiAgZHVlIHRvIHNjZW5lIG9yIG9iamVjdCBjaGFuZ2VzLiBUaHVzIHdlIGhhdmUgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqICByZWxhdGVkIHtAbGluayBJU2hhZGVyQ29tcG9zZXJ9LlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge0lSZW5kZXJPYmplY3R9XG4gKiBAcGFyYW0ge1NjZW5lfSBzY2VuZVxuICogQHBhcmFtIHtPYmplY3R9IHBhZ2VFbnRyeVxuICogQHBhcmFtIHtPYmplY3R9IG9wdFxuICovXG52YXIgUmVuZGVyT2JqZWN0ID0gZnVuY3Rpb24gKHNjZW5lLCBwYWdlRW50cnksIG9wdCkge1xuICAgIFJlbmRlck5vZGUuY2FsbCh0aGlzLCBDLk5PREVfVFlQRS5PQkpFQ1QsIHNjZW5lLCBwYWdlRW50cnksIG9wdCk7XG4gICAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gICAgLyoqXG4gICAgICogS2VlcCByZWZlcmVuY2UgdG8gRE9NIEVsZW1lbnQgbmVlZCBlLmcuIGZvciBwaWNraW5nXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5ub2RlID0gb3B0Lm5vZGU7XG5cbiAgICAvKipcbiAgICAgKiBPYmplY3QgcmVsYXRlZCBkYXRhXG4gICAgICogQHR5cGUge3tkYXRhOiBEYXRhTm9kZXxudWxsLCB0eXBlOiBzdHJpbmd9fVxuICAgICAqL1xuICAgIHRoaXMub2JqZWN0ID0gb3B0Lm9iamVjdCB8fCB7ZGF0YTogbnVsbCwgdHlwZTogXCJ0cmlhbmdsZXNcIn07XG5cbiAgICAvKipcbiAgICAgKiBDYW4gd2UgcmVseSBvbiBjdXJyZW50IFdvcmxkTWF0cml4P1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtRGlydHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogQ2FuIHdlIHJlbHkgb24gY3VycmVudCBCb3VuZGluZyBCb3hlcz9cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmJvdW5kaW5nQm94RGlydHkgPSB0cnVlO1xuXG4gICAgdGhpcy50cmFuc2Zvcm1EYXRhUmVxdWVzdCA9IHRoaXMuY3JlYXRlVHJhbnNmb3JtUmVxdWVzdCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGRyYXdhYmxlIGNsb3N1cmUgdHJhbnNmb3JtcyBvYmplY3QgZGF0YSBhbmQgdHlwZSBpbnRvXG4gICAgICogYSBkcmF3YWJsZSBlbnRpdHlcbiAgICAgKiBAdHlwZSB7RHJhd2FibGVDbG9zdXJlfVxuICAgICAqL1xuICAgIHRoaXMuZHJhd2FibGUgPSB0aGlzLmNyZWF0ZURyYXdhYmxlKCk7XG5cbiAgICB0aGlzLl9tYXRlcmlhbCA9IG9wdC5tYXRlcmlhbCB8fCBudWxsO1xuICAgIHRoaXMuX2FjdHVhbE1hdGVyaWFsID0gbnVsbDtcbiAgICB0aGlzLmluaXRNYXRlcmlhbCgpO1xuXG4gICAgLyoqIHtPYmplY3Q/fSAqKi9cbiAgICB0aGlzLm92ZXJyaWRlID0gbnVsbDtcblxuICAgIHRoaXMucGlja2FibGUgPSB0cnVlO1xufTtcblJlbmRlck9iamVjdC5FTlRSWV9TSVpFID0gRU5UUllfU0laRTtcblxuUmVuZGVyT2JqZWN0LklERU5USVRZX01BVFJJWCA9IG1hdDQuY3JlYXRlKCk7XG5cblhNTDNELmNyZWF0ZUNsYXNzKFJlbmRlck9iamVjdCwgUmVuZGVyTm9kZSwge1xuICAgIGNyZWF0ZVRyYW5zZm9ybVJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9iamVjdC5kYXRhKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHV0ZVJlcXVlc3QodGhpcy5vYmplY3QuZGF0YSwgW1wibWVzaFRyYW5zZm9ybVwiXSwgdGhpcy5vblRyYW5zZm9ybURhdGFDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZURyYXdhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNjZW5lLmNyZWF0ZURyYXdhYmxlKHRoaXMpO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICAgICAgICByZXN1bHQub24oQy5FVkVOVF9UWVBFLkRSQVdBQkxFX1NUQVRFX0NIQU5HRUQsIGZ1bmN0aW9uIChuZXdTdGF0ZSwgb2xkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RhdGUgPT09IERyYXdhYmxlQ2xvc3VyZS5SRUFEWV9TVEFURS5DT01QTEVURSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LnNjZW5lLm1vdmVGcm9tUXVldWVUb1JlYWR5KHRoYXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3U3RhdGUgPT09IERyYXdhYmxlQ2xvc3VyZS5SRUFEWV9TVEFURS5JTkNPTVBMRVRFICYmIG9sZFN0YXRlID09PSBEcmF3YWJsZUNsb3N1cmUuUkVBRFlfU1RBVEUuQ09NUExFVEUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5zY2VuZS5tb3ZlRnJvbVJlYWR5VG9RdWV1ZSh0aGF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC51cGRhdGVUeXBlUmVxdWVzdCgpO1xuICAgICAgICAgICAgcmVzdWx0LmNhbGN1bGF0ZUJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgICByZXN1bHQub24oQy5FVkVOVF9UWVBFLlNDRU5FX1NIQVBFX0NIQU5HRUQsIGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnNjZW5lLmVtaXQoQy5FVkVOVF9UWVBFLlNDRU5FX1NIQVBFX0NIQU5HRUQpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHNldFR5cGU6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMub2JqZWN0LnR5cGUgPSB0eXBlO1xuICAgICAgICAvLyBUT0RPOiB0aGlzLnR5cGVDaGFuZ2VkRXZlbnRcbiAgICB9LFxuXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vYmplY3QudHlwZTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YU5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2JqZWN0ID8gdGhpcy5vYmplY3QuZGF0YSA6IG51bGw7XG4gICAgfSxcblxuICAgIGdldExvY2FsTWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgICB0aGlzLmdldE1hdDRGcm9tUGFnZShkZXN0LCBMT0NBTF9NQVRSSVhfT0ZGU0VUKTtcbiAgICB9LFxuXG4gICAgc2V0TG9jYWxNYXRyaXg6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zZXRNYXQ0SW5QYWdlKHNvdXJjZSwgTE9DQUxfTUFUUklYX09GRlNFVCk7XG4gICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcbiAgICAgICAgdGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KCk7XG4gICAgfSxcblxuICAgIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1EYXRhUmVxdWVzdCAmJiB0aGlzLnRyYW5zZm9ybURhdGFSZXF1ZXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMuc2NlbmUucmVtb3ZlKHRoaXMpO1xuICAgIH0sXG5cbiAgICBvblRyYW5zZm9ybURhdGFDaGFuZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xuICAgIH0sXG5cbiAgICBnZXRNb2RlbFZpZXdNYXRyaXg6IGZ1bmN0aW9uIChkZXN0KSB7XG4gICAgICAgIHRoaXMuZ2V0TWF0NEZyb21QYWdlKGRlc3QsIE1PREVMVklFV19NQVRSSVhfT0ZGU0VUKTtcbiAgICB9LFxuXG4gICAgZ2V0TW9kZWxNYXRyaXhOOiBmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgTU9ERUxfTUFUUklYX05fT0ZGU0VUO1xuICAgICAgICBkZXN0WzBdID0gdGhpcy5wYWdlW29dO1xuICAgICAgICBkZXN0WzFdID0gdGhpcy5wYWdlW28gKyAxXTtcbiAgICAgICAgZGVzdFsyXSA9IHRoaXMucGFnZVtvICsgMl07XG4gICAgICAgIGRlc3RbM10gPSB0aGlzLnBhZ2VbbyArIDRdO1xuICAgICAgICBkZXN0WzRdID0gdGhpcy5wYWdlW28gKyA1XTtcbiAgICAgICAgZGVzdFs1XSA9IHRoaXMucGFnZVtvICsgNl07XG4gICAgICAgIGRlc3RbNl0gPSB0aGlzLnBhZ2VbbyArIDhdO1xuICAgICAgICBkZXN0WzddID0gdGhpcy5wYWdlW28gKyA5XTtcbiAgICAgICAgZGVzdFs4XSA9IHRoaXMucGFnZVtvICsgMTBdO1xuICAgIH0sXG5cbiAgICBnZXRNb2RlbFZpZXdNYXRyaXhOOiBmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMub2Zmc2V0ICsgTU9ERUxWSUVXX01BVFJJWF9OX09GRlNFVDtcbiAgICAgICAgZGVzdFswXSA9IHRoaXMucGFnZVtvXTtcbiAgICAgICAgZGVzdFsxXSA9IHRoaXMucGFnZVtvICsgMV07XG4gICAgICAgIGRlc3RbMl0gPSB0aGlzLnBhZ2VbbyArIDJdO1xuICAgICAgICBkZXN0WzNdID0gdGhpcy5wYWdlW28gKyA0XTtcbiAgICAgICAgZGVzdFs0XSA9IHRoaXMucGFnZVtvICsgNV07XG4gICAgICAgIGRlc3RbNV0gPSB0aGlzLnBhZ2VbbyArIDZdO1xuICAgICAgICBkZXN0WzZdID0gdGhpcy5wYWdlW28gKyA4XTtcbiAgICAgICAgZGVzdFs3XSA9IHRoaXMucGFnZVtvICsgOV07XG4gICAgICAgIGRlc3RbOF0gPSB0aGlzLnBhZ2VbbyArIDEwXTtcbiAgICB9LFxuXG5cbiAgICBnZXRNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgICB0aGlzLmdldE1hdDRGcm9tUGFnZShkZXN0LCBNT0RFTFZJRVdQUk9KRUNUSU9OX01BVFJJWF9PRkZTRVQpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVXb3JsZFNwYWNlTWF0cmljZXM6IGZ1bmN0aW9uICh2aWV3LCBwcm9qZWN0aW9uKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zZm9ybURpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVNb2RlbFZpZXdNYXRyaXgodmlldyk7XG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWxNYXRyaXhOKCk7XG4gICAgICAgIHRoaXMudXBkYXRlTW9kZWxWaWV3TWF0cml4TigpO1xuICAgICAgICB0aGlzLnVwZGF0ZU1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgocHJvamVjdGlvbik7XG4gICAgfSxcblxuICAgIHVwZGF0ZVdvcmxkTWF0cml4OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG1wX21hdCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC5nZXRXb3JsZE1hdHJpeCh0bXBfbWF0KTtcbiAgICAgICAgICAgIHZhciBwYWdlID0gdGhpcy5wYWdlO1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMub2Zmc2V0O1xuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHRtcF9tYXQsIDAsIHBhZ2UsIG9mZnNldCArIExPQ0FMX01BVFJJWF9PRkZTRVQsIHRtcF9tYXQsIDApO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNmb3JtRGF0YVJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy50cmFuc2Zvcm1EYXRhUmVxdWVzdC5nZXRSZXN1bHQoKTtcbiAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtRGF0YSA9IHJlc3VsdC5nZXRPdXRwdXREYXRhKFwibWVzaFRyYW5zZm9ybVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtRGF0YSAmJiB0cmFuc2Zvcm1EYXRhLmdldFZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5KHRtcF9tYXQsIHRtcF9tYXQsIHRyYW5zZm9ybURhdGEuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRXb3JsZE1hdHJpeCh0bXBfbWF0KTtcbiAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnRyYW5zZm9ybURpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KSgpLFxuXG4gICAgLyoqIFJlbGllcyBvbiBhbiB1cC10by1kYXRlIHRyYW5zZm9ybSBtYXRyaXggKiovXG4gICAgdXBkYXRlTW9kZWxWaWV3TWF0cml4OiBmdW5jdGlvbiAodmlldykge1xuICAgICAgICBpZiAodGhpcy50cmFuc2Zvcm1EaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVXb3JsZE1hdHJpeCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYWdlID0gdGhpcy5wYWdlO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseU9mZnNldChwYWdlLCBvZmZzZXQgKyBNT0RFTFZJRVdfTUFUUklYX09GRlNFVCwgcGFnZSwgb2Zmc2V0ICsgV09STERfTUFUUklYX09GRlNFVCwgdmlldywgMCk7XG4gICAgfSxcblxuICAgIHVwZGF0ZU1vZGVsTWF0cml4TjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNfdG1wTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRNYXRyaXgoY190bXBNYXRyaXgpO1xuICAgICAgICAgICAgbWF0NC5pbnZlcnQoY190bXBNYXRyaXgsIGNfdG1wTWF0cml4KTtcbiAgICAgICAgICAgIHZhciBub3JtYWxNYXRyaXggPSBjX3RtcE1hdHJpeCA/IG1hdDQudHJhbnNwb3NlKGNfdG1wTWF0cml4LCBjX3RtcE1hdHJpeCkgOiBSZW5kZXJPYmplY3QuSURFTlRJVFlfTUFUUklYO1xuICAgICAgICAgICAgdGhpcy5zZXRNYXQ0SW5QYWdlKG5vcm1hbE1hdHJpeCwgTU9ERUxfTUFUUklYX05fT0ZGU0VUKTtcbiAgICAgICAgfVxuICAgIH0pKCksXG5cbiAgICAvKiogUmVsaWVzIG9uIGFuIHVwLXRvLWRhdGUgdmlldyBtYXRyaXggKiovXG4gICAgdXBkYXRlTW9kZWxWaWV3TWF0cml4TjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNfdG1wTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0TW9kZWxWaWV3TWF0cml4KGNfdG1wTWF0cml4KTtcbiAgICAgICAgICAgIG1hdDQuaW52ZXJ0KGNfdG1wTWF0cml4LCBjX3RtcE1hdHJpeCk7XG4gICAgICAgICAgICB2YXIgbm9ybWFsTWF0cml4ID0gY190bXBNYXRyaXggPyBtYXQ0LnRyYW5zcG9zZShjX3RtcE1hdHJpeCwgY190bXBNYXRyaXgpIDogUmVuZGVyT2JqZWN0LklERU5USVRZX01BVFJJWDtcbiAgICAgICAgICAgIHRoaXMuc2V0TWF0NEluUGFnZShub3JtYWxNYXRyaXgsIE1PREVMVklFV19NQVRSSVhfTl9PRkZTRVQpO1xuICAgICAgICB9XG4gICAgfSkoKSxcblxuXG4gICAgLyoqIFJlbGllcyBvbiBhbiB1cC10by1kYXRlIHZpZXcgbWF0cml4ICoqL1xuICAgIHVwZGF0ZU1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uIChwcm9qZWN0aW9uKSB7XG4gICAgICAgIHZhciBwYWdlID0gdGhpcy5wYWdlO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIFhNTDNELm1hdGgubWF0NC5tdWx0aXBseU9mZnNldChwYWdlLCBvZmZzZXQgKyBNT0RFTFZJRVdQUk9KRUNUSU9OX01BVFJJWF9PRkZTRVQsIHBhZ2UsIG9mZnNldCArIE1PREVMVklFV19NQVRSSVhfT0ZGU0VULCBwcm9qZWN0aW9uLCAwKTtcbiAgICB9LFxuXG4gICAgc2V0VHJhbnNmb3JtRGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1EaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xuICAgICAgICB0aGlzLnNjZW5lLmVtaXQoQy5FVkVOVF9UWVBFLlNDRU5FX1NIQVBFX0NIQU5HRUQpO1xuICAgICAgICB0aGlzLnNjZW5lLnJlcXVlc3RSZWRyYXcoXCJUcmFuc2Zvcm1hdGlvbiBjaGFuZ2VkXCIpO1xuICAgIH0sXG5cbiAgICBzZXRPYmplY3RTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYm94KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBPQkpFQ1RfQkJfT0ZGU0VUO1xuICAgICAgICB0aGlzLnBhZ2Vbb10gPSBib3guZGF0YVswXTtcbiAgICAgICAgdGhpcy5wYWdlW28gKyAxXSA9IGJveC5kYXRhWzFdO1xuICAgICAgICB0aGlzLnBhZ2VbbyArIDJdID0gYm94LmRhdGFbMl07XG4gICAgICAgIHRoaXMucGFnZVtvICsgM10gPSBib3guZGF0YVszXTtcbiAgICAgICAgdGhpcy5wYWdlW28gKyA0XSA9IGJveC5kYXRhWzRdO1xuICAgICAgICB0aGlzLnBhZ2VbbyArIDVdID0gYm94LmRhdGFbNV07XG4gICAgICAgIHRoaXMuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xuICAgIH0sXG5cbiAgICBnZXRPYmplY3RTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYm94KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBPQkpFQ1RfQkJfT0ZGU0VUO1xuICAgICAgICBib3guZGF0YVswXSA9IHRoaXMucGFnZVtvXTtcbiAgICAgICAgYm94LmRhdGFbMV0gPSB0aGlzLnBhZ2VbbyArIDFdO1xuICAgICAgICBib3guZGF0YVsyXSA9IHRoaXMucGFnZVtvICsgMl07XG4gICAgICAgIGJveC5kYXRhWzNdID0gdGhpcy5wYWdlW28gKyAzXTtcbiAgICAgICAgYm94LmRhdGFbNF0gPSB0aGlzLnBhZ2VbbyArIDRdO1xuICAgICAgICBib3guZGF0YVs1XSA9IHRoaXMucGFnZVtvICsgNV07XG4gICAgfSxcblxuICAgIHNldEJvdW5kaW5nQm94RGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5ib3VuZGluZ0JveERpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wYXJlbnQuc2V0Qm91bmRpbmdCb3hEaXJ0eSgpO1xuICAgIH0sXG5cbiAgICBzZXRXb3JsZFNwYWNlQm91bmRpbmdCb3g6IGZ1bmN0aW9uIChiYm94KSB7XG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBXT1JMRF9CQl9PRkZTRVQ7XG4gICAgICAgIHRoaXMucGFnZVtvXSA9IGJib3guZGF0YVswXTtcbiAgICAgICAgdGhpcy5wYWdlW28gKyAxXSA9IGJib3guZGF0YVsxXTtcbiAgICAgICAgdGhpcy5wYWdlW28gKyAyXSA9IGJib3guZGF0YVsyXTtcbiAgICAgICAgdGhpcy5wYWdlW28gKyAzXSA9IGJib3guZGF0YVszXTtcbiAgICAgICAgdGhpcy5wYWdlW28gKyA0XSA9IGJib3guZGF0YVs0XTtcbiAgICAgICAgdGhpcy5wYWdlW28gKyA1XSA9IGJib3guZGF0YVs1XTtcbiAgICB9LFxuXG4gICAgZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94OiBmdW5jdGlvbiAoYmJveCkge1xuICAgICAgICBpZiAodGhpcy5ib3VuZGluZ0JveERpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVdvcmxkU3BhY2VCb3VuZGluZ0JveCgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvID0gdGhpcy5vZmZzZXQgKyBXT1JMRF9CQl9PRkZTRVQ7XG4gICAgICAgIGJib3guZGF0YVswXSA9IHRoaXMucGFnZVtvXTtcbiAgICAgICAgYmJveC5kYXRhWzFdID0gdGhpcy5wYWdlW28gKyAxXTtcbiAgICAgICAgYmJveC5kYXRhWzJdID0gdGhpcy5wYWdlW28gKyAyXTtcbiAgICAgICAgYmJveC5kYXRhWzNdID0gdGhpcy5wYWdlW28gKyAzXTtcbiAgICAgICAgYmJveC5kYXRhWzRdID0gdGhpcy5wYWdlW28gKyA0XTtcbiAgICAgICAgYmJveC5kYXRhWzVdID0gdGhpcy5wYWdlW28gKyA1XTtcblxuICAgIH0sXG5cbiAgICB1cGRhdGVXb3JsZFNwYWNlQm91bmRpbmdCb3g6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjX2JveCA9IG5ldyBYTUwzRC5Cb3goKTtcbiAgICAgICAgdmFyIGNfdHJhbnMgPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZighdGhpcy52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY19ib3guc2V0RW1wdHkoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRPYmplY3RTcGFjZUJvdW5kaW5nQm94KGNfYm94KTtcbiAgICAgICAgICAgICAgICB0aGlzLmdldFdvcmxkTWF0cml4KGNfdHJhbnMpO1xuICAgICAgICAgICAgICAgIGNfYm94LnRyYW5zZm9ybUF4aXNBbGlnbmVkKGNfdHJhbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goY19ib3gpO1xuICAgICAgICAgICAgdGhpcy5ib3VuZGluZ0JveERpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KSgpLFxuXG4gICAgdmlzaWJpbGl0eUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRCb3VuZGluZ0JveERpcnR5KCk7XG4gICAgfSxcblxuICAgIHNldFBpY2thYmxlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucGlja2FibGUgPT0gdmFsdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucGlja2FibGUgPSB2YWx1ZTtcbiAgICB9LFxuXG5cbiAgICBnZXRQcm9ncmFtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdhYmxlLmdldFByb2dyYW0oKTtcbiAgICB9LFxuXG4gICAgaGFzVHJhbnNwYXJlbmN5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5nZXRQcm9ncmFtKCk7XG4gICAgICAgIHJldHVybiBwcm9ncmFtID8gcHJvZ3JhbS5oYXNUcmFuc3BhcmVuY3koKSA6IGZhbHNlO1xuICAgIH0sXG5cbiAgICB1cGRhdGVGb3JSZW5kZXJpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgU3lzdGVtTm90aWZpZXIuc2V0Tm9kZSh0aGlzLm5vZGUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kcmF3YWJsZSAmJiB0aGlzLmRyYXdhYmxlLnVwZGF0ZSh0aGlzLnNjZW5lKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJNZXNoIEVycm9yOiBcIiArIGUubWVzc2FnZSwgdGhpcy5ub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBTeXN0ZW1Ob3RpZmllci5zZXROb2RlKG51bGwpO1xuICAgIH0sXG5cbiAgICBmaW5kUmF5SW50ZXJzZWN0aW9uczogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJib3ggPSBuZXcgWE1MM0QuQm94KCk7XG4gICAgICAgIHZhciBvcHQgPSB7ZGlzdDogMH07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChyYXksIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGJib3gpO1xuICAgICAgICAgICAgaWYgKHJheS5pbnRlcnNlY3RzKGJib3gsIG9wdCkpIHtcbiAgICAgICAgICAgICAgICBpbnRlcnNlY3Rpb25zLnB1c2godGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgpLFxuXG4gICAgICAgIC8qKlxuICAgICAqIEBwYXJhbSB7TWF0ZXJpYWxDb25maWd1cmF0aW9ufG51bGx9IG1hdGVyaWFsXG4gICAgICovXG4gICAgc2V0TWF0ZXJpYWw6IGZ1bmN0aW9uIChtYXRlcmlhbCkge1xuICAgICAgICBpZih0aGlzLl9tYXRlcmlhbCA9PT0gbWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXRlcmlhbCA9IG1hdGVyaWFsO1xuICAgICAgICBpZiAobWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdHVhbE1hdGVyaWFsID0gbWF0ZXJpYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hY3R1YWxNYXRlcmlhbCA9IHRoaXMucGFyZW50LmdldE1hdGVyaWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRlcmlhbENoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgcGFyZW50TWF0ZXJpYWxDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXRlcmlhbCkge1xuICAgICAgICAgICAgLy8gTG9jYWwgbWF0ZXJpYWwgb3ZlcnJpZGVzIHRoZSBjaGFuZ2UgZnJvbSBhYm92ZVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdE1hdGVyaWFsKCk7XG4gICAgfSxcblxuICAgIGluaXRNYXRlcmlhbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fbWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdHVhbE1hdGVyaWFsID0gdGhpcy5fbWF0ZXJpYWw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9hY3R1YWxNYXRlcmlhbCA9IHRoaXMucGFyZW50LmdldE1hdGVyaWFsKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYXRlcmlhbENoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgbWF0ZXJpYWxDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJtYXRlcmlhbCBjaGFuZ2VkXCIsIHRoaXMuX2FjdHVhbE1hdGVyaWFsKTtcbiAgICAgICAgaWYgKHRoaXMuZHJhd2FibGUpIHtcbiAgICAgICAgICAgIHZhciBjb21wb3NlciA9IHRoaXMuc2NlbmUuc2hhZGVyRmFjdG9yeS5jcmVhdGVDb21wb3NlckZyb21NYXRlcmlhbENvbmZpZ3VyYXRpb24odGhpcy5fYWN0dWFsTWF0ZXJpYWwpO1xuICAgICAgICAgICAgdGhpcy5kcmF3YWJsZS5zZXRTaGFkZXJDb21wb3Nlcihjb21wb3Nlcik7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5cbi8vIEV4cG9ydFxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJPYmplY3Q7XG5cbiIsInZhciBSZW5kZXJOb2RlID0gcmVxdWlyZShcIi4vcmVuZGVybm9kZS5qc1wiKTtcbnZhciBDb25zdGFudHMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG52YXIgRnJ1c3R1bSA9IHJlcXVpcmUoXCIuLi90b29scy9mcnVzdHVtLmpzXCIpLkZydXN0dW07XG52YXIgdmVjMyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjMztcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xuXG52YXIgTk9ERV9UWVBFID0gQ29uc3RhbnRzLk5PREVfVFlQRTtcbnZhciBFVkVOVF9UWVBFID0gQ29uc3RhbnRzLkVWRU5UX1RZUEU7XG5cbiAgICAvKiogQGNvbnN0ICovXG4gICAgdmFyIFZJRVdfVE9fV09STERfTUFUUklYX09GRlNFVCA9IDA7XG4gICAgLyoqIEBjb25zdCAqL1xuICAgIHZhciBXT1JMRF9UT19WSUVXX01BVFJJWF9PRkZTRVQgPSAxNjtcbiAgICAvKiogQGNvbnN0ICovXG4gICAgdmFyIFBST0pFQ1RJT05fTUFUUklYX09GRlNFVCA9IDMyO1xuICAgIC8qKiBAY29uc3QgKi9cbiAgICB2YXIgRU5UUllfU0laRSA9IFBST0pFQ1RJT05fTUFUUklYX09GRlNFVCArIDE2O1xuXG4gICAgLyoqIEBjb25zdCAqL1xuICAgIHZhciBDTElQUExBTkVfTkVBUl9NSU4gPSAwLjAxO1xuXG4gICAgLyoqIEBjb25zdCAqL1xuICAgIHZhciBERUZBVUxUX0ZJRUxET0ZWSUVXID0gNDUgLyAxODAgKiBNYXRoLlBJO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAZXh0ZW5kcyB7UmVuZGVyTm9kZX1cbiAgICAgKi9cbiAgICB2YXIgUmVuZGVyVmlldyA9IGZ1bmN0aW9uKHNjZW5lLCBwYWdlRW50cnksIG9wdCkge1xuICAgICAgICBSZW5kZXJOb2RlLmNhbGwodGhpcywgTk9ERV9UWVBFLlZJRVcsIHNjZW5lLCBwYWdlRW50cnksIG9wdCk7XG4gICAgICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG9wdC5wb3NpdGlvbiB8fCB2ZWMzLmNyZWF0ZSgpO1xuICAgICAgICB0aGlzLm9yaWVudGF0aW9uID0gb3B0Lm9yaWVudGF0aW9uIHx8IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHRoaXMuZmllbGRPZlZpZXcgPSBvcHQuZmllbGRPZlZpZXcgIT09IHVuZGVmaW5lZCA/IG9wdC5maWVsZE9mVmlldyA6IERFRkFVTFRfRklFTERPRlZJRVc7XG4gICAgICAgIHRoaXMud29ybGRTcGFjZVBvc2l0aW9uID0gdmVjMy5jcmVhdGUoKTtcbiAgICAgICAgdGhpcy5wcm9qZWN0aW9uT3ZlcnJpZGUgPSBvcHQucHJvamVjdGlvbk92ZXJyaWRlO1xuICAgICAgICB0aGlzLnZpZXdEaXJ0eSA9IHRydWU7XG4gICAgICAgIHRoaXMucHJvamVjdGlvbkRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5mcnVzdHVtID0gbmV3IEZydXN0dW0oMSwgMTAwMDAwLCAwLCB0aGlzLmZpZWxkT2ZWaWV3LCAxKTtcbiAgICAgICAgdGhpcy5sYXN0QXNwZWN0UmF0aW8gPSAxO1xuICAgIH07XG4gICAgUmVuZGVyVmlldy5FTlRSWV9TSVpFID0gRU5UUllfU0laRTtcblxuICAgIFhNTDNELmNyZWF0ZUNsYXNzKFJlbmRlclZpZXcsIFJlbmRlck5vZGUpO1xuXG4gICAgWE1MM0QuZXh0ZW5kKFJlbmRlclZpZXcucHJvdG90eXBlLCB7XG4gICAgICAgIGdldEZydXN0dW06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJ1c3R1bTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVWaWV3TWF0cml4OiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdG1wX21hdDQgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgdmFyIHRtcF9wYXJlbnQgPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG1hdDQuaWRlbnRpdHkodG1wX21hdDQpO1xuICAgICAgICAgICAgICAgIHRtcF9tYXQ0WzEyXSA9IHRoaXMucG9zaXRpb25bMF07XG4gICAgICAgICAgICAgICAgdG1wX21hdDRbMTNdID0gdGhpcy5wb3NpdGlvblsxXTtcbiAgICAgICAgICAgICAgICB0bXBfbWF0NFsxNF0gPSB0aGlzLnBvc2l0aW9uWzJdO1xuICAgICAgICAgICAgICAgIC8vIHRtcCA9IFQgKiBPXG4gICAgICAgICAgICAgICAgbWF0NC5tdWx0aXBseSh0bXBfbWF0NCwgdG1wX21hdDQsIHRoaXMub3JpZW50YXRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50LmdldFdvcmxkTWF0cml4KHRtcF9wYXJlbnQpO1xuICAgICAgICAgICAgICAgIG1hdDQubXVsdGlwbHkodG1wX21hdDQsIHRtcF9wYXJlbnQsIHRtcF9tYXQ0KTtcbiAgICAgICAgICAgICAgICB2ZWMzLnNldCh0aGlzLndvcmxkU3BhY2VQb3NpdGlvbiwgdG1wX21hdDRbMTJdLCB0bXBfbWF0NFsxM10sIHRtcF9tYXQ0WzE0XSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWaWV3VG9Xb3JsZE1hdHJpeCh0bXBfbWF0NCk7XG4gICAgICAgICAgICAgICAgbWF0NC5pbnZlcnQodG1wX21hdDQsIHRtcF9tYXQ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFdvcmxkVG9WaWV3TWF0cml4KHRtcF9tYXQ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpLFxuXG4gICAgICAgIHVwZGF0ZVByb2plY3Rpb25NYXRyaXg6IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0bXAgPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oYXNwZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucHJvamVjdGlvbk92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJvamVjdGlvbk1hdHJpeCh0aGlzLnByb2plY3Rpb25PdmVycmlkZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENvcnJlY3RseSBjb21wdXRlIGZydXN0cnVtIGZyb20gcHJvamVjdGlvbiBtYXRyaXggKGlmIHBvc3NpYmxlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZydXN0dW0uc2V0RnJ1c3R1bSgxLCAxMDAwMDAsIDAsIHRoaXMuZmllbGRPZlZpZXcsIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGNsaXBQbGFuZSA9IHRoaXMuZ2V0Q2xpcHBpbmdQbGFuZXMoKSxcbiAgICAgICAgICAgICAgICAgICAgbmVhciA9IGNsaXBQbGFuZS5uZWFyLFxuICAgICAgICAgICAgICAgICAgICBmYXIgPSBjbGlwUGxhbmUuZmFyLFxuICAgICAgICAgICAgICAgICAgICBmb3Z5ID0gdGhpcy5maWVsZE9mVmlldztcblxuICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uTWF0cml4XG4gICAgICAgICAgICAgICAgbWF0NC5wZXJzcGVjdGl2ZSh0bXAsIGZvdnksIGFzcGVjdCwgbmVhciwgZmFyKTtcbiAgICAgICAgICAgICAgICAvLyBTZXQgcHJvamVjdGlvbk1hdHJpeFxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJvamVjdGlvbk1hdHJpeCh0bXApO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBGcnVzdHVtXG4gICAgICAgICAgICAgICAgdGhpcy5mcnVzdHVtLnNldEZydXN0dW0obmVhciwgZmFyLCAwLCBmb3Z5LCBhc3BlY3QpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0QXNwZWN0UmF0aW8gPSBhc3BlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCksXG5cbiAgICAgICAgZ2V0Q2xpcHBpbmdQbGFuZXM6IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB0X21hdCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgICAgICB2YXIgYmIgPSBuZXcgWE1MM0QuQm94KCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLmdldEJvdW5kaW5nQm94KGJiKTtcbiAgICAgICAgICAgICAgICBpZiAoYmIuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5lYXI6IDEsIGZhcjogMTAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRXb3JsZFRvVmlld01hdHJpeCh0X21hdCk7XG4gICAgICAgICAgICAgICAgYmIudHJhbnNmb3JtQXhpc0FsaWduZWQodF9tYXQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIG5lYXIgPSAtYmIubWF4LnosXG4gICAgICAgICAgICAgICAgICAgIGZhciA9IC1iYi5taW4ueixcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kID0gTWF0aC5tYXgoKGZhciAtIG5lYXIpICogMC4wMDUsIDAuMDUpO1xuXG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIHRoZSB2aWV3IGZydXN0dW0gYSBiaXQgdG8gZW5zdXJlIDJEIG9iamVjdHMgcGFyYWxsZWwgdG8gdGhlIGNhbWVyYSBhcmUgcmVuZGVyZWRcbiAgICAgICAgICAgICAgICBmYXIgKz0gZXhwYW5kO1xuICAgICAgICAgICAgICAgIG5lYXIgLT0gZXhwYW5kO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtuZWFyOiBNYXRoLm1heChuZWFyLCBleHBhbmQsIENMSVBQTEFORV9ORUFSX01JTiksIGZhcjogZmFyfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSxcblxuICAgICAgICBzZXRXb3JsZFRvVmlld01hdHJpeDogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1hdDRJblBhZ2Uoc291cmNlLCBXT1JMRF9UT19WSUVXX01BVFJJWF9PRkZTRVQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNldFZpZXdUb1dvcmxkTWF0cml4OiBmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TWF0NEluUGFnZShzb3VyY2UsIFZJRVdfVE9fV09STERfTUFUUklYX09GRlNFVCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0UHJvamVjdGlvbk1hdHJpeDogZnVuY3Rpb24oc291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLnNldE1hdDRJblBhZ2Uoc291cmNlLCBQUk9KRUNUSU9OX01BVFJJWF9PRkZTRVQpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGlydHkgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRQcm9qZWN0aW9uT3ZlcnJpZGU6IGZ1bmN0aW9uKHByb2pBZGFwdGVyKSB7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25PdmVycmlkZSA9IHByb2pBZGFwdGVyO1xuICAgICAgICAgICAgdGhpcy5zZXRQcm9qZWN0aW9uRGlydHkoKTtcbiAgICAgICAgICAgIHRoaXMuc2NlbmUucmVxdWVzdFJlZHJhdyhcIlByb2plY3Rpb24gY2hhbmdlZFwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRUcmFuc2Zvcm1EaXJ0eTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnZpZXdEaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnNldFByb2plY3Rpb25EaXJ0eSgpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS5yZXF1ZXN0UmVkcmF3KFwiVHJhbnNmb3JtYXRpb24gY2hhbmdlZFwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRQcm9qZWN0aW9uRGlydHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbihuZXdQb3MpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtRGlydHkoKTtcbiAgICAgICAgICAgIHZlYzMuY29weSh0aGlzLnBvc2l0aW9uLCBuZXdQb3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZU9yaWVudGF0aW9uOiBmdW5jdGlvbihuZXdPcmllbnRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1EaXJ0eSgpO1xuICAgICAgICAgICAgbWF0NC5jb3B5KHRoaXMub3JpZW50YXRpb24sIG5ld09yaWVudGF0aW9uKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVGaWVsZE9mVmlldzogZnVuY3Rpb24obmV3Rm92KSB7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybURpcnR5KCk7XG4gICAgICAgICAgICB0aGlzLmZpZWxkT2ZWaWV3ID0gbmV3Rm92O1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFZpZXdUb1dvcmxkTWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlld0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3TWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdldE1hdDRGcm9tUGFnZShkZXN0LCBWSUVXX1RPX1dPUkxEX01BVFJJWF9PRkZTRVQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFdvcmxkVG9WaWV3TWF0cml4OiBmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlld0RpcnR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3TWF0cml4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdldE1hdDRGcm9tUGFnZShkZXN0LCBXT1JMRF9UT19WSUVXX01BVFJJWF9PRkZTRVQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKGRlc3QsIGFzcGVjdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvamVjdGlvbkRpcnR5IHx8IGFzcGVjdCAhPSB0aGlzLmxhc3RBc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeChhc3BlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nZXRNYXQ0RnJvbVBhZ2UoZGVzdCwgUFJPSkVDVElPTl9NQVRSSVhfT0ZGU0VUKTtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXRXb3JsZFNwYWNlUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud29ybGRTcGFjZVBvc2l0aW9uO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFdvcmxkU3BhY2VCb3VuZGluZ0JveDogZnVuY3Rpb24oYmJveCkge1xuICAgICAgICAgICAgYmJveC5zZXRFbXB0eSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBFeHBvcnRcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJlbmRlclZpZXc7XG5cbiIsInZhciBQYWdlciA9IHJlcXVpcmUoXCIuL3BhZ2VyLmpzXCIpO1xudmFyIFJlbmRlck9iamVjdCA9IHJlcXVpcmUoXCIuL3JlbmRlcm9iamVjdC5qc1wiKTtcbnZhciBSZW5kZXJWaWV3ID0gcmVxdWlyZShcIi4vcmVuZGVydmlldy5qc1wiKTtcbnZhciBSZW5kZXJHcm91cCA9IHJlcXVpcmUoXCIuL3JlbmRlcmdyb3VwLmpzXCIpO1xudmFyIFJlbmRlckxpZ2h0ID0gcmVxdWlyZShcIi4vcmVuZGVybGlnaHQuanNcIik7XG52YXIgTWF0ZXJpYWxDb25maWd1cmF0aW9uID0gcmVxdWlyZShcIi4vbWF0ZXJpYWwtY29uZmlndXJhdGlvbi5qc1wiKTtcbnZhciBMaWdodE1hbmFnZXIgPSByZXF1aXJlKFwiLi4vbGlnaHRzL2xpZ2h0LW1hbmFnZXIuanNcIik7XG52YXIgQyA9IHJlcXVpcmUoXCIuL2NvbnN0YW50cy5qc1wiKTtcbnZhciBJbnB1dE5vZGUgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2dyYXBoLmpzXCIpLklucHV0Tm9kZTtcbnZhciBEYXRhTm9kZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZ3JhcGguanNcIikuRGF0YU5vZGU7XG52YXIgQnVmZmVyRW50cnkgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2RhdGEuanNcIikuQnVmZmVyRW50cnk7XG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcbnZhciBVUkkgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvdXJpLmpzXCIpLlVSSTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgbWF0NCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0NDtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7RXZlbnRFbWl0dGVyfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTY2VuZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmJvdW5kaW5nQm94ID0gbmV3IFhNTDNELkJveCgpO1xuICAgIHRoaXMubGlnaHRzID0gbmV3IExpZ2h0TWFuYWdlcigpO1xuICAgIHRoaXMucGFnZXIgPSBuZXcgUGFnZXIoKTtcblxuICAgIC8qKiBAdHlwZSBSZW5kZXJWaWV3ICovXG4gICAgdGhpcy5hY3RpdmVWaWV3ID0gbnVsbDtcblxuICAgIC8qKiBAdHlwZSBNYXRlcmlhbENvbmZpZ3VyYXRpb24gKi9cbiAgICB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgdGhpcy5yb290Tm9kZSA9IHRoaXMuY3JlYXRlUm9vdE5vZGUoKTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKFNjZW5lLCBFdmVudEVtaXR0ZXIsIHtcbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyVmlld31cbiAgICAgKi9cbiAgICBnZXRBY3RpdmVWaWV3OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXc7XG4gICAgfSwgLyoqXG4gICAgICogQHBhcmFtIHtSZW5kZXJWaWV3fSB2aWV3XG4gICAgICovXG4gICAgc2V0QWN0aXZlVmlldzogZnVuY3Rpb24gKHZpZXcpIHtcbiAgICAgICAgaWYgKHZpZXcgIT0gdGhpcy5hY3RpdmVWaWV3KSB7XG4gICAgICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQWN0aXZlIHZpZXcgbXVzdCBub3QgYmUgbnVsbFwiKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmVtaXQoQy5FVkVOVF9UWVBFLlZJRVdfQ0hBTkdFRCwgdGhpcy5hY3RpdmVWaWV3KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3Q/fSBvcHRcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyT2JqZWN0fVxuICAgICAqL1xuICAgIGNyZWF0ZVJlbmRlck9iamVjdDogZnVuY3Rpb24gKG9wdCkge1xuICAgICAgICB2YXIgcGFnZUVudHJ5ID0gdGhpcy5wYWdlci5nZXRQYWdlRW50cnkoUmVuZGVyT2JqZWN0LkVOVFJZX1NJWkUpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbmRlck9iamVjdCh0aGlzLCBwYWdlRW50cnksIG9wdCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVJlbmRlckdyb3VwOiBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgIHZhciBwYWdlRW50cnkgPSB0aGlzLnBhZ2VyLmdldFBhZ2VFbnRyeShSZW5kZXJHcm91cC5FTlRSWV9TSVpFKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJHcm91cCh0aGlzLCBwYWdlRW50cnksIG9wdCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVJlbmRlclZpZXc6IGZ1bmN0aW9uIChvcHQpIHtcbiAgICAgICAgdmFyIHBhZ2VFbnRyeSA9IHRoaXMucGFnZXIuZ2V0UGFnZUVudHJ5KFJlbmRlclZpZXcuRU5UUllfU0laRSk7XG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVyVmlldyh0aGlzLCBwYWdlRW50cnksIG9wdCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVJlbmRlckxpZ2h0OiBmdW5jdGlvbiAob3B0KSB7XG4gICAgICAgIHZhciBwYWdlRW50cnkgPSB0aGlzLnBhZ2VyLmdldFBhZ2VFbnRyeShSZW5kZXJMaWdodC5FTlRSWV9TSVpFKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZW5kZXJMaWdodCh0aGlzLCBwYWdlRW50cnksIG9wdCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZU1hdGVyaWFsQ29uZmlndXJhdGlvbjogZnVuY3Rpb24obW9kZWwsIGRhdGEsIG9wdCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hdGVyaWFsQ29uZmlndXJhdGlvbihtb2RlbCwgZGF0YSwgb3B0KTtcbiAgICB9LFxuXG4gICAgY3JlYXRlUm9vdE5vZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhZ2VFbnRyeSA9IHRoaXMucGFnZXIuZ2V0UGFnZUVudHJ5KFJlbmRlckdyb3VwLkVOVFJZX1NJWkUpO1xuICAgICAgICB2YXIgcm9vdCA9IG5ldyBSZW5kZXJHcm91cCh0aGlzLCBwYWdlRW50cnksIHtcbiAgICAgICAgICAgIG1hdGVyaWFsOiB0aGlzLmdldERlZmF1bHRNYXRlcmlhbCgpLCBuYW1lOiBcIkBzY2VuZVwiXG4gICAgICAgIH0pO1xuICAgICAgICByb290LnNldFdvcmxkTWF0cml4KG1hdDQuY3JlYXRlKCkpO1xuICAgICAgICByb290LnNldExvY2FsTWF0cml4KG1hdDQuY3JlYXRlKCkpO1xuICAgICAgICByb290LnRyYW5zZm9ybURpcnR5ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH0sXG5cbiAgICB1cGRhdGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5yb290Tm9kZS5ib3VuZGluZ0JveERpcnR5KSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBUaGVyZSBzaG91bGQgYWx3YXlzIGJlIGFuIGFjdGl2ZSB2aWV3XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVZpZXcgJiYgdGhpcy5hY3RpdmVWaWV3LnNldFByb2plY3Rpb25EaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucm9vdE5vZGUuZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KHRoaXMuYm91bmRpbmdCb3gpO1xuICAgIH0sXG5cbiAgICBnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24gKGJiKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQm91bmRpbmdCb3goKTtcbiAgICAgICAgYmIuY29weSh0aGlzLmJvdW5kaW5nQm94KTtcbiAgICB9LFxuXG4gICAgY3JlYXRlRHJhd2FibGU6IGZ1bmN0aW9uICgvKm9iaiovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjZW5lOjpjcmVhdGVEcmF3YWJsZSBub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfSxcblxuICAgIHJlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uICgvKnJlYXNvbiovKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjZW5lOjpyZXF1ZXN0UmVkcmF3IG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICB9LFxuXG4gICAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnJvb3ROb2RlLnRyYXZlcnNlKGNhbGxiYWNrKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbGwgb2JqZWN0cyBpbnRlcnNlY3RlZCBieSB0aGUgZ2l2ZW4gcmF5LCBiYXNlZCBvbiB0aGVpciBib3VuZGluZyBib3hlc1xuICAgICAqIEBwYXJhbSByYXlcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIFJlbmRlck9iamVjdHMgdGhhdCB3ZXJlIGhpdCBieSB0aGlzIHJheVxuICAgICAqL1xuICAgIGZpbmRSYXlJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbiAocmF5KSB7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgICAgIHRoaXMucm9vdE5vZGUuZmluZFJheUludGVyc2VjdGlvbnMocmF5LCBpbnRlcnNlY3Rpb25zKTtcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gICAgfSxcblxuICAgIGdldERlZmF1bHRNYXRlcmlhbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmKCF0aGlzLl9kZWZhdWx0TWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dE5vZGUgPSBuZXcgSW5wdXROb2RlKCk7XG4gICAgICAgICAgICBpbnB1dE5vZGUuZGF0YSA9IG5ldyBCdWZmZXJFbnRyeShYQy5EQVRBX1RZUEUuRkxPQVQzLCBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwXSkpO1xuICAgICAgICAgICAgaW5wdXROb2RlLm5hbWUgPSBcImRpZmZ1c2VDb2xvclwiO1xuXG4gICAgICAgICAgICB2YXIgZGF0YSA9IG5ldyBEYXRhTm9kZShmYWxzZSk7XG4gICAgICAgICAgICBkYXRhLmFwcGVuZENoaWxkKGlucHV0Tm9kZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IHRoaXMuY3JlYXRlTWF0ZXJpYWxDb25maWd1cmF0aW9uKFxuICAgICAgICAgICAgICAgIHtcInR5cGVcIjogXCJ1cm5cIiwgXCJ1cm5cIjogbmV3IFVSSShcInVybjp4bWwzZDptYXRlcmlhbDptYXR0ZVwiKX0sXG4gICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB7bmFtZTogXCJkZWZhdWx0XCJ9XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZhdWx0TWF0ZXJpYWw7XG4gICAgfVxuXG5cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2NlbmU7XG4iLCJ2YXIgRGF0YUNoYW5nZU5vdGlmaWVyID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9kYXRhLmpzXCIpLkRhdGFDaGFuZ2VOb3RpZmllcjtcblxuLyoqXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgRGF0YUNoYW5nZU5vdGlmaWVyLmFkZExpc3RlbmVyKHRoaXMuZGF0YUVudHJ5Q2hhbmdlZCk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1hmbG93LkRhdGFFbnRyeX0gZW50cnlcbiAqIEBwYXJhbSB7WGZsb3cuREFUQV9FTlRSWV9TVEFURX0gbm90aWZpY2F0aW9uXG4gKi9cbkRhdGFDaGFuZ2VMaXN0ZW5lci5wcm90b3R5cGUuZGF0YUVudHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIChlbnRyeSwgbm90aWZpY2F0aW9uKSB7XG4gICAgaWYgKGVudHJ5LnVzZXJEYXRhLndlYmdsRGF0YSkge1xuICAgICAgICBmb3IgKHZhciBpIGluIGVudHJ5LnVzZXJEYXRhLndlYmdsRGF0YSkge1xuICAgICAgICAgICAgdmFyIG9sZENoYW5nZWQgPSBlbnRyeS51c2VyRGF0YS53ZWJnbERhdGFbaV0uY2hhbmdlZDtcbiAgICAgICAgICAgIGVudHJ5LnVzZXJEYXRhLndlYmdsRGF0YVtpXS5jaGFuZ2VkID0gTWF0aC5tYXgob2xkQ2hhbmdlZCwgbm90aWZpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YUNoYW5nZUxpc3RlbmVyO1xuIiwidmFyIHZlYzMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzM7XG52YXIgdG1wMSA9IHZlYzMuY3JlYXRlKCk7XG52YXIgdG1wMiA9IHZlYzMuY3JlYXRlKCk7XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXJQbGFuZVxuICogQHBhcmFtIHtudW1iZXJ9IGZhclBsYW5lXG4gKiBAcGFyYW0ge251bWJlcn0gZm92eFxuICogQHBhcmFtIHtudW1iZXJ9IGZvdnlcbiAqIEBwYXJhbSB7bnVtYmVyfSBhc3BlY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3J0aG9ncmFwaGljXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZydXN0dW0gPSBmdW5jdGlvbiAobmVhclBsYW5lLCBmYXJQbGFuZSwgZm92eCwgZm92eSwgYXNwZWN0LCBvcnRob2dyYXBoaWMpIHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGlmICh0eXBlb2Yob3J0aG9ncmFwaGljKSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgdGhpcy5vcnRob2dyYXBoaWMgPSBmYWxzZTsgZWxzZVxuICAgICAgICB0aGlzLm9ydGhvZ3JhcGhpYyA9IG9ydGhvZ3JhcGhpYztcbiAgICB0aGlzLnNldEZydXN0dW0obmVhclBsYW5lLCBmYXJQbGFuZSwgZm92eCwgZm92eSwgYXNwZWN0LCB0aGlzLm9ydGhvZ3JhcGhpYyk7XG59O1xuXG5YTUwzRC5leHRlbmQoRnJ1c3R1bS5wcm90b3R5cGUsIHtcbiAgICBzZXRGcnVzdHVtOiBmdW5jdGlvbiAobmVhclBsYW5lLCBmYXJQbGFuZSwgZm92eCwgZm92eSwgYXNwZWN0LCBvcnRob2dyYXBoaWMpIHtcbiAgICAgICAgaWYgKGZvdnggJiYgZm92eSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZvdnggYW5kIGZvdnkgY2Fubm90IGJvdGggYmUgbm9uLXplcm8uXCIpO1xuXG4gICAgICAgIGlmIChmb3Z4KSB7XG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbmVhclBsYW5lICogTWF0aC50YW4oZm92eCAvIDIpO1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gLXRoaXMucmlnaHQ7XG4gICAgICAgICAgICB0aGlzLnRvcCA9ICgodGhpcy5yaWdodCAtIHRoaXMubGVmdCkgLyBhc3BlY3QpIC8gMjtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gLXRoaXMudG9wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50b3AgPSBuZWFyUGxhbmUgKiBNYXRoLnRhbigwLjUgKiBmb3Z5KTtcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gLXRoaXMudG9wO1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9ICh0aGlzLnRvcCAtIHRoaXMuYm90dG9tKSAqIGFzcGVjdCAvIDI7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSAtdGhpcy5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5lYXJQbGFuZSA9IG5lYXJQbGFuZTtcbiAgICAgICAgdGhpcy5mYXJQbGFuZSA9IGZhclBsYW5lO1xuXG4gICAgICAgIGlmICh0eXBlb2Yob3J0aG9ncmFwaGljKSA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHRoaXMub3J0aG9ncmFwaGljID0gZmFsc2U7IGVsc2VcbiAgICAgICAgICAgIHRoaXMub3J0aG9ncmFwaGljID0gb3J0aG9ncmFwaGljO1xuXG4gICAgfSxcblxuICAgIGdldFByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgdmFyIGxpbWl0TWF4ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICAgICAgdmFyIHJpZ2h0UGx1c0xlZnQgPSB0aGlzLnJpZ2h0ICsgdGhpcy5sZWZ0O1xuICAgICAgICB2YXIgcmlnaHRNaW51c0xlZnQgPSB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xuXG4gICAgICAgIHZhciB0b3BQbHVzQm90dG9tID0gdGhpcy50b3AgKyB0aGlzLmJvdHRvbTtcbiAgICAgICAgdmFyIHRvcE1pbnVzQm90dG9tID0gdGhpcy50b3AgLSB0aGlzLmJvdHRvbTtcblxuICAgICAgICB2YXIgZmFyUGx1c05lYXIgPSB0aGlzLmZhclBsYW5lICsgdGhpcy5uZWFyUGxhbmU7XG4gICAgICAgIHZhciBmYXJNaW51c05lYXIgPSB0aGlzLmZhclBsYW5lIC0gdGhpcy5uZWFyUGxhbmU7XG5cbiAgICAgICAgaWYgKChNYXRoLmFicyhyaWdodE1pbnVzTGVmdCkgPCAxICYmIE1hdGguYWJzKHJpZ2h0UGx1c0xlZnQpID4gbGltaXRNYXggKiBNYXRoLmFicyhyaWdodE1pbnVzTGVmdCkpIHx8IChNYXRoLmFicyh0b3BNaW51c0JvdHRvbSkgPCAxICYmIE1hdGguYWJzKHRvcFBsdXNCb3R0b20pID4gbGltaXRNYXggKiBNYXRoLmFicyh0b3BNaW51c0JvdHRvbSkpIHx8IChNYXRoLmFicyhmYXJNaW51c05lYXIpIDwgMSAmJiBNYXRoLmFicyhmYXJQbHVzTmVhcikgPiBsaW1pdE1heCAqIE1hdGguYWJzKGZhck1pbnVzTmVhcikpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgdmlld2luZyBmcnVzdHVtOiBwcm9qZWN0aW9uIG1hdHJpeCBjYW5ub3QgYmUgY29tcHV0ZWQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIEEsIEIsIEMsIEQsIEUsIEY7XG4gICAgICAgIHZhciBtID0gbWF0cml4LmRhdGEgPyBtYXRyaXguZGF0YSA6IG1hdHJpeDtcblxuICAgICAgICBpZiAodGhpcy5vcnRob2dyYXBoaWMpIHtcbiAgICAgICAgICAgIHZhciB0eCA9IC1yaWdodFBsdXNMZWZ0IC8gcmlnaHRNaW51c0xlZnQ7XG4gICAgICAgICAgICB2YXIgdHkgPSAtdG9wUGx1c0JvdHRvbSAvIHRvcE1pbnVzQm90dG9tO1xuICAgICAgICAgICAgdmFyIHR6ID0gLWZhclBsdXNOZWFyIC8gZmFyTWludXNOZWFyO1xuXG4gICAgICAgICAgICBpZiAoKE1hdGguYWJzKHJpZ2h0TWludXNMZWZ0KSA8IDEgJiYgMiA+IGxpbWl0TWF4ICogTWF0aC5hYnMocmlnaHRNaW51c0xlZnQpKSB8fCAoTWF0aC5hYnModG9wTWludXNCb3R0b20pIDwgMSAmJiAyID4gbGltaXRNYXggKiBNYXRoLmFicyh0b3BNaW51c0JvdHRvbSkpIHx8IChNYXRoLmFicyhmYXJNaW51c05lYXIpIDwgMSAmJiAyID4gbGltaXRNYXggKiBNYXRoLmFicyhmYXJNaW51c05lYXIpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCB2aWV3aW5nIGZydXN0dW06ICBwcm9qZWN0aW9uIG1hdHJpeCBjYW5ub3QgYmUgY29tcHV0ZWQuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBID0gMiAvIHJpZ2h0TWludXNMZWZ0O1xuICAgICAgICAgICAgQiA9IDIgLyB0b3BNaW51c0JvdHRvbTtcbiAgICAgICAgICAgIEMgPSAtMiAvIGZhck1pbnVzTmVhcjtcblxuICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0LmlkZW50aXR5KG0pO1xuICAgICAgICAgICAgbVswXSA9IEE7XG4gICAgICAgICAgICBtWzVdID0gQjtcbiAgICAgICAgICAgIG1bMTBdID0gQztcbiAgICAgICAgICAgIG1bMTJdID0gdHg7XG4gICAgICAgICAgICBtWzEzXSA9IHR5O1xuICAgICAgICAgICAgbVsxNF0gPSB0ejtcbiAgICAgICAgICAgIG1bMTVdID0gMS4wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgQSA9IHJpZ2h0UGx1c0xlZnQgLyByaWdodE1pbnVzTGVmdDtcbiAgICAgICAgICAgIEIgPSB0b3BQbHVzQm90dG9tIC8gdG9wTWludXNCb3R0b207XG4gICAgICAgICAgICBDID0gLWZhclBsdXNOZWFyIC8gZmFyTWludXNOZWFyO1xuXG4gICAgICAgICAgICB2YXIgZmFyVGltZXNOZWFyID0gLTIgKiB0aGlzLmZhclBsYW5lICogdGhpcy5uZWFyUGxhbmU7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoZmFyTWludXNOZWFyKSA8IDEgJiYgTWF0aC5hYnMoZmFyVGltZXNOZWFyKSA+IGxpbWl0TWF4ICogTWF0aC5hYnMoZmFyTWludXNOZWFyKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhZCB2aWV3aW5nIGZydXN0dW06IHByb2plY3Rpb24gbWF0cml4IGNhbm5vdCBiZSBjb21wdXRlZC5cIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIEQgPSBmYXJUaW1lc05lYXIgLyBmYXJNaW51c05lYXI7XG5cbiAgICAgICAgICAgIHZhciB0d29UaW1lc05lYXIgPSAyICogdGhpcy5uZWFyUGxhbmU7XG5cbiAgICAgICAgICAgIGlmICgoTWF0aC5hYnMocmlnaHRNaW51c0xlZnQpIDwgMSAmJiBNYXRoLmFicyh0d29UaW1lc05lYXIpID4gbGltaXRNYXggKiBNYXRoLmFicyhyaWdodE1pbnVzTGVmdCkpIHx8IChNYXRoLmFicyh0b3BNaW51c0JvdHRvbSkgPCAxICYmIE1hdGguYWJzKHR3b1RpbWVzTmVhcikgPiBsaW1pdE1heCAqIE1hdGguYWJzKHRvcE1pbnVzQm90dG9tKSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWQgdmlld2luZyBmcnVzdHVtOiBwcm9qZWN0aW9uIG1hdHJpeCBjYW5ub3QgYmUgY29tcHV0ZWQuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBFID0gdHdvVGltZXNOZWFyIC8gcmlnaHRNaW51c0xlZnQ7XG4gICAgICAgICAgICBGID0gdHdvVGltZXNOZWFyIC8gdG9wTWludXNCb3R0b207XG5cbiAgICAgICAgICAgIFhNTDNELm1hdGgubWF0NC5pZGVudGl0eShtKTtcbiAgICAgICAgICAgIG1bMF0gPSBFO1xuICAgICAgICAgICAgbVs1XSA9IEY7XG4gICAgICAgICAgICBtWzhdID0gQTtcbiAgICAgICAgICAgIG1bOV0gPSBCO1xuICAgICAgICAgICAgbVsxMF0gPSBDO1xuICAgICAgICAgICAgbVsxMV0gPSAtMTtcbiAgICAgICAgICAgIG1bMTRdID0gRDtcbiAgICAgICAgICAgIG1bMTVdID0gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQbGFuZXM6IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGNfYSA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX2IgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgICAgICB2YXIgY19jID0gdmVjMy5jcmVhdGUoKTtcbiAgICAgICAgdmFyIGNfZCA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICAgICAgdmFyIGNfZSA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX2YgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgICAgICB2YXIgY19nID0gdmVjMy5jcmVhdGUoKTtcbiAgICAgICAgdmFyIGNfbyA9IHZlYzMuY3JlYXRlKCk7XG5cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHBsYW5lcywgTSkge1xuICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfYSwgW3RoaXMubGVmdCwgdGhpcy5ib3R0b20sIC10aGlzLm5lYXJQbGFuZV0sIE0pO1xuICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfYiwgW3RoaXMubGVmdCwgdGhpcy50b3AsIC10aGlzLm5lYXJQbGFuZV0sIE0pO1xuICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfYywgW3RoaXMucmlnaHQsIHRoaXMudG9wLCAtdGhpcy5uZWFyUGxhbmVdLCBNKTtcbiAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChjX2QsIFt0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSwgLXRoaXMubmVhclBsYW5lXSwgTSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3J0aG9ncmFwaGljKSB7XG4gICAgICAgICAgICAgICAgdmFyIHMgPSB0aGlzLmZhclBsYW5lIC8gdGhpcy5uZWFyUGxhbmU7XG4gICAgICAgICAgICAgICAgdmFyIGZhckxlZnQgPSBzICogdGhpcy5sZWZ0O1xuICAgICAgICAgICAgICAgIHZhciBmYXJSaWdodCA9IHMgKiB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgICAgIHZhciBmYXJUb3AgPSBzICogdGhpcy50b3A7XG4gICAgICAgICAgICAgICAgdmFyIGZhckJvdHRvbSA9IHMgKiB0aGlzLmJvdHRvbTtcbiAgICAgICAgICAgICAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoY19lLCBbZmFyTGVmdCwgZmFyQm90dG9tLCAtdGhpcy5mYXJQbGFuZV0sIE0pO1xuICAgICAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChjX2YsIFtmYXJMZWZ0LCBmYXJUb3AsIC10aGlzLmZhclBsYW5lXSwgTSk7XG4gICAgICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfZywgW2ZhclJpZ2h0LCBmYXJUb3AsIC10aGlzLmZhclBsYW5lXSwgTSk7XG4gICAgICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfbywgWzAsIDAsIDBdLCBNKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbMF0uc2V0RnJvbVBvaW50cyhjX28sIGNfYywgY19iKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbMV0uc2V0RnJvbVBvaW50cyhjX28sIGNfZCwgY19jKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbMl0uc2V0RnJvbVBvaW50cyhjX28sIGNfYSwgY19kKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbM10uc2V0RnJvbVBvaW50cyhjX28sIGNfYiwgY19hKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbNF0uc2V0RnJvbVBvaW50cyhjX2EsIGNfZCwgY19jKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbNV0uc2V0RnJvbVBvaW50cyhjX2UsIGNfZiwgY19nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfZSwgW3RoaXMubGVmdCwgdGhpcy5ib3R0b20sIC10aGlzLmZhclBsYW5lXSwgTSk7XG4gICAgICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfZiwgW3RoaXMubGVmdCwgdGhpcy50b3AsIC10aGlzLmZhclBsYW5lXSwgTSk7XG4gICAgICAgICAgICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGNfZywgW3RoaXMucmlnaHQsIHRoaXMudG9wLCAtdGhpcy5mYXJQbGFuZV0sIE0pO1xuICAgICAgICAgICAgICAgIHZlYzMudHJhbnNmb3JtTWF0NChjX28sIFt0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSwgLXRoaXMuZmFyUGxhbmVdLCBNKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbMF0uc2V0RnJvbVBvaW50cyhjX2MsIGNfZywgY19mKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbMV0uc2V0RnJvbVBvaW50cyhjX2QsIGNfbywgY19nKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbMl0uc2V0RnJvbVBvaW50cyhjX2EsIGNfZSwgY19vKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbM10uc2V0RnJvbVBvaW50cyhjX2IsIGNfZiwgY19lKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbNF0uc2V0RnJvbVBvaW50cyhjX2EsIGNfZCwgY19jKTtcbiAgICAgICAgICAgICAgICBwbGFuZXNbNV0uc2V0RnJvbVBvaW50cyhjX2UsIGNfZiwgY19nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KCkpXG5cblxufSk7XG5cblxudmFyIFBsYW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlzdGFuY2UgPSAwO1xuICAgIHRoaXMubm9ybWFsID0gdmVjMy5jcmVhdGUoKTtcbn07XG5cblhNTDNELmV4dGVuZChQbGFuZS5wcm90b3R5cGUsIHtcbiAgICBzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAocG9pbnQxLCBwb2ludDIsIHBvaW50Mykge1xuICAgICAgICB2ZWMzLmNyb3NzKHRoaXMubm9ybWFsLCB2ZWMzLnN1Yih0bXAyLCBwb2ludDMsIHBvaW50MSksIHZlYzMuc3ViKHRtcDEsIHBvaW50MiwgcG9pbnQxKSk7XG4gICAgICAgIHZlYzMubm9ybWFsaXplKHRoaXMubm9ybWFsLCB0aGlzLm5vcm1hbCk7XG4gICAgICAgIHRoaXMuZGlzdGFuY2UgPSAtdmVjMy5kb3QodGhpcy5ub3JtYWwsIHBvaW50MSk7XG4gICAgfSxcblxuICAgIHNldDogZnVuY3Rpb24gKHgsIHksIHosIGRpc3RhbmNlKSB7XG4gICAgICAgIHZlYzMuc2V0KHRoaXMubm9ybWFsLCB4LCB5LCB6KTtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodGhpcy5ub3JtYWwsIHRoaXMubm9ybWFsKTtcbiAgICAgICAgdGhpcy5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIH1cbn0pO1xuXG52YXIgRnJ1c3R1bVRlc3QgPSBmdW5jdGlvbiAoZnJ1c3R1bSwgY2FtZXJhTWF0cml4KSB7XG4gICAgdGhpcy5mcnVzdHVtUGxhbmVzID0gW25ldyBQbGFuZSgpLCBuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCksIG5ldyBQbGFuZSgpLCBuZXcgUGxhbmUoKSwgbmV3IFBsYW5lKCldO1xuICAgIGlmIChmcnVzdHVtICYmIGNhbWVyYU1hdHJpeCkge1xuICAgICAgICB0aGlzLnNldChmcnVzdHVtLCBjYW1lcmFNYXRyaXgpO1xuICAgIH1cbn07XG5cblxuWE1MM0QuZXh0ZW5kKEZydXN0dW1UZXN0LnByb3RvdHlwZSwge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGcnVzdHVtfSBmcnVzdHVtXG4gICAgICogQHBhcmFtIHttYXQ0fSBtYXRyaXhcbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uIChmcnVzdHVtLCBtYXRyaXgpIHtcbiAgICAgICAgZnJ1c3R1bS5nZXRQbGFuZXModGhpcy5mcnVzdHVtUGxhbmVzLCBtYXRyaXgpO1xuXG4gICAgfSwgLyoqXG4gICAgICogQHBhcmFtIGJib3hcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0JveFZpc2libGU6IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiYm94KSB7XG4gICAgICAgICAgICBpZiAoYmJveC5pc0VtcHR5KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mcnVzdHVtUGxhbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBsYW5lID0gdGhpcy5mcnVzdHVtUGxhbmVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWwgPSBwbGFuZS5ub3JtYWw7XG4gICAgICAgICAgICAgICAgdmFyIGJieCA9IG5vcm1hbC54ID49IDAuMCA/IGJib3gubWF4LnggOiBiYm94Lm1pbi54O1xuICAgICAgICAgICAgICAgIHZhciBiYnkgPSBub3JtYWwueSA+PSAwLjAgPyBiYm94Lm1heC55IDogYmJveC5taW4ueTtcbiAgICAgICAgICAgICAgICB2YXIgYmJ6ID0gbm9ybWFsLnogPj0gMC4wID8gYmJveC5tYXgueiA6IGJib3gubWluLno7XG5cbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBkaXN0YW5jZVxuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IGJieCAqIG5vcm1hbC54ICsgYmJ5ICogbm9ybWFsLnkgKyBiYnogKiBub3JtYWwueiArIHBsYW5lLmRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgLy8gaWYgaGlnaGVzdCBwb2ludCBpcyBiZWxvdyBwbGFuZSB0aGVuIGFsbCBiZWxvdy5cbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCAwLjApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSgpKVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUGxhbmU6IFBsYW5lLFxuICAgIEZydXN0dW06IEZydXN0dW0sXG4gICAgRnJ1c3R1bVRlc3Q6IEZydXN0dW1UZXN0XG59O1xuIiwidmFyIHZlYzMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzM7XG5cbi8qKlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgT2JqZWN0U29ydGVyID0gZnVuY3Rpb24gKCkge1xuXG59O1xuXG52YXIgY19iYm94ID0gbmV3IFhNTDNELkJveCgpO1xudmFyIGNfY2VudGVyID0gdmVjMy5jcmVhdGUoKTtcblxuWE1MM0QuZXh0ZW5kKE9iamVjdFNvcnRlci5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0dMU2NlbmV9IHNjZW5lXG4gICAgICogQHBhcmFtIHtYTUwzRC5NYXQ0P30gdmlld01hdHJpeCBNYXRyaXggdG8gYXBwbHkgdG8gb2JqZWN0cyB3b3JsZCBzcGFjZSBleHRlbmQgYmVmb3JlIHNvcnRpbmdcbiAgICAgKi9cbiAgICBzb3J0U2NlbmU6IGZ1bmN0aW9uIChzY2VuZSwgdmlld01hdHJpeCkge1xuICAgICAgICB2YXIgc291cmNlT2JqZWN0QXJyYXkgPSBzY2VuZS5yZWFkeSwgb3BhcXVlID0ge30sIHRyYW5zcGFyZW50ID0gW107XG5cbiAgICAgICAgdmFyIHRyYW5zcGFyZW50QXJyYXkgPSBbXSwgb2JqO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHNvdXJjZU9iamVjdEFycmF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgb2JqID0gc291cmNlT2JqZWN0QXJyYXlbaV07XG4gICAgICAgICAgICBpZiAob2JqLmluRnJ1c3R1bSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmouaGFzVHJhbnNwYXJlbmN5KCkpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVudEFycmF5LnB1c2gob2JqKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyYW0gPSBvYmouZ2V0UHJvZ3JhbSgpO1xuICAgICAgICAgICAgICAgIG9wYXF1ZVtwcm9ncmFtLmlkXSA9IG9wYXF1ZVtwcm9ncmFtLmlkXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBvcGFxdWVbcHJvZ3JhbS5pZF0ucHVzaChvYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29ydCBvcGFxdWUgb2JqZWN0cyBmcm9tIGZyb250IHRvIGJhY2sgaW4gb3JkZXJcbiAgICAgICAgLy8gdG8gaGF2ZSBlYXJsaWVyIHotZmFpbHNcbiAgICAgICAgZm9yICh2YXIgcHJvZ0lkIGluIG9wYXF1ZSkge1xuICAgICAgICAgICAgdmFyIHdpdGhpblNoYWRlciA9IG9wYXF1ZVtwcm9nSWRdO1xuICAgICAgICAgICAgdmFyIHNvcnRlZEFycmF5ID0gbmV3IEFycmF5KHdpdGhpblNoYWRlci5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHdpdGhpblNoYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG9iaiA9IHdpdGhpblNoYWRlcltpXTtcbiAgICAgICAgICAgICAgICBvYmouZ2V0V29ybGRTcGFjZUJvdW5kaW5nQm94KGNfYmJveCk7XG4gICAgICAgICAgICAgICAgY19iYm94LmNlbnRlcihjX2NlbnRlcik7XG4gICAgICAgICAgICAgICAgdmlld01hdHJpeCAmJiB2ZWMzLnRyYW5zZm9ybU1hdDQoY19jZW50ZXIsIGNfY2VudGVyLCB2aWV3TWF0cml4KTtcbiAgICAgICAgICAgICAgICBzb3J0ZWRBcnJheVtpXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgb2JqOiBvYmosIGRlcHRoOiBjX2NlbnRlci56XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvcnRlZEFycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5kZXB0aCAtIGEuZGVwdGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9wYXF1ZVtwcm9nSWRdID0gc29ydGVkQXJyYXkubWFwKGZ1bmN0aW9uKGUpIHsgcmV0dXJuIGUub2JqOyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vU29ydCB0cmFuc3BhcmVudCBvYmplY3RzIGZyb20gYmFjayB0byBmcm9udFxuICAgICAgICB2YXIgdGxlbmd0aCA9IHRyYW5zcGFyZW50QXJyYXkubGVuZ3RoO1xuICAgICAgICBpZiAodGxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvYmogPSB0cmFuc3BhcmVudEFycmF5W2ldO1xuICAgICAgICAgICAgICAgIG9iai5nZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goY19iYm94KTtcbiAgICAgICAgICAgICAgICBjX2Jib3guY2VudGVyKGNfY2VudGVyKTtcbiAgICAgICAgICAgICAgICB2aWV3TWF0cml4ICYmIHZlYzMudHJhbnNmb3JtTWF0NChjX2NlbnRlciwgY19jZW50ZXIsIHZpZXdNYXRyaXgpO1xuICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50QXJyYXlbaV0gPSBbb2JqLCBjX2NlbnRlci56XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJhbnNwYXJlbnRBcnJheS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFbMV0gLSBiWzFdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0bGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BhcmVudFtpXSA9IHRyYW5zcGFyZW50QXJyYXlbaV1bMF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB0cmFuc3BhcmVudFswXSA9IHRyYW5zcGFyZW50QXJyYXlbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG9wYXF1ZTogb3BhcXVlLCB0cmFuc3BhcmVudDogdHJhbnNwYXJlbnRcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3RTb3J0ZXI7XG5cblxuIiwiLyoqIENhbGN1bGF0ZSB0aGUgb2Zmc2V0IG9mIHRoZSBnaXZlbiBlbGVtZW50IGFuZCByZXR1cm4gaXQuXG4gKlxuICogIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50XG4gKiAgQHJldHVybiB7e3RvcDpudW1iZXIsIGxlZnQ6bnVtYmVyfX0gdGhlIG9mZnNldFxuICpcbiAqICBUaGlzIGNvZGUgaXMgdGFrZW4gZnJvbSBodHRwOi8vamF2YXNjcmlwdC5pbmZvL3R1dG9yaWFsL2Nvb3JkaW5hdGVzIC5cbiAqICBXZSBkb24ndCB3YW50IHRvIGRvIGl0IHdpdGggdGhlIG9mZnNldFBhcmVudCB3YXksIGJlY2F1c2UgdGhlIHhtbDNkXG4gKiAgZWxlbWVudCBpcyBhY3R1YWxseSBpbnZpc2libGUgYW5kIHRodXMgb2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIG51bGxcbiAqICBhdCBsZWFzdCBpbiBXZWJLaXQuIEFsc28gaXQncyBzbG93LiBTbyB3ZSB1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuXG4gKiAgSG93ZXZlciBpdCByZXR1cm5zIHRoZSBib3ggcmVsYXRpdmUgdG8gdGhlIHdpbmRvdywgbm90IHRoZSBkb2N1bWVudC5cbiAqICBUaHVzLCB3ZSBuZWVkIHRvIGluY29ycG9yYXRlIHRoZSBzY3JvbGwgZmFjdG9yLiBBbmQgYmVjYXVzZSBJRSBpcyBzb1xuICogIGF3ZXNvbWUgc29tZSB3b3JrYXJvdW5kcyBoYXZlIHRvIGJlIGRvbmUgYW5kIHRoZSBjb2RlIGdldHMgY29tcGxpY2F0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChlbGVtZW50KSB7XG4gICAgdmFyIGJveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICAgIHZhciBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgLy8gZ2V0IHNjcm9sbCBmYWN0b3IgKGV2ZXJ5IGJyb3dzZXIgZXhjZXB0IElFIHN1cHBvcnRzIHBhZ2Ugb2Zmc2V0cylcbiAgICB2YXIgc2Nyb2xsVG9wID0gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wO1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY0VsZW0uc2Nyb2xsTGVmdCB8fCBib2R5LnNjcm9sbExlZnQ7XG5cbiAgICAvLyB0aGUgZG9jdW1lbnQgKGBodG1sYCBvciBgYm9keWApIGNhbiBiZSBzaGlmdGVkIGZyb20gbGVmdC11cHBlciBjb3JuZXIgaW4gSUUuIEdldCB0aGUgc2hpZnQuXG4gICAgdmFyIGNsaWVudFRvcCA9IGRvY0VsZW0uY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gICAgdmFyIGNsaWVudExlZnQgPSBkb2NFbGVtLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XG5cbiAgICB2YXIgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcbiAgICB2YXIgbGVmdCA9IGJveC5sZWZ0ICsgc2Nyb2xsTGVmdCAtIGNsaWVudExlZnQ7XG5cbiAgICAvLyBmb3IgRmlyZWZveCBhbiBhZGRpdGlvbmFsIHJvdW5kaW5nIGlzIHNvbWV0aW1lcyByZXF1aXJlZFxuICAgIHJldHVybiB7dG9wOiBNYXRoLnJvdW5kKHRvcCksIGxlZnQ6IE1hdGgucm91bmQobGVmdCl9O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gICAgLyoqIENvbnZlcnQgYSBnaXZlbiBtb3VzZSBwYWdlIHBvc2l0aW9uIHRvIGJlIHJlbGF0aXZlIHRvIHRoZSBnaXZlbiB0YXJnZXQgZWxlbWVudC5cbiAgICAgKiAgTW9zdCBwcm9iYWJseSB0aGUgcGFnZSBwb3NpdGlvbiBhcmUgdGhlIE1vdXNlRXZlbnQncyBwYWdlWCBhbmQgcGFnZVkgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqICBAcGFyYW0geyFPYmplY3R9IHhtbDNkRWwgdGhlIHhtbDNkIGVsZW1lbnQgdG8gd2hpY2ggdGhlIGNvb3JkcyBuZWVkIHRvIGJlIHRyYW5zbGF0ZWRcbiAgICAgKiAgQHBhcmFtIHshbnVtYmVyfSBwYWdlWCB0aGUgeC1jb29yZGluYXRlIHJlbGF0aXZlIHRvIHRoZSBwYWdlXG4gICAgICogIEBwYXJhbSB7IW51bWJlcn0gcGFnZVkgdGhlIHktY29vcmRpbmF0ZSByZWxhdGl2ZSB0byB0aGUgcGFnZVxuICAgICAqICBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSB0aGUgY29udmVydGVkIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgY29udmVydFBhZ2VDb29yZHM6IGZ1bmN0aW9uICh4bWwzZEVsLCBwYWdlWCwgcGFnZVkpIHtcbiAgICAgICAgdmFyIG9mZiA9IGNhbGN1bGF0ZU9mZnNldCh4bWwzZEVsKTtcblxuICAgICAgICByZXR1cm4ge3g6IHBhZ2VYIC0gb2ZmLmxlZnQsIHk6IHBhZ2VZIC0gb2ZmLnRvcH07XG4gICAgfVxufTtcbiIsInZhciBUZXh0dXJlTWFuYWdlciA9IHJlcXVpcmUoXCJ0ZXh0dXJlLW1hbmFnZXJcIikuU2ltcGxlVGV4dHVyZU1hbmFnZXI7XG52YXIgR0xUZXh0dXJlID0gcmVxdWlyZShcIi4vdGV4dHVyZS5qc1wiKS5HTFRleHR1cmU7XG52YXIgR0xDdWJlTWFwID0gcmVxdWlyZShcIi4vdGV4dHVyZS5qc1wiKS5HTEN1YmVNYXA7XG52YXIgR0xDYW52YXNUYXJnZXQgPSByZXF1aXJlKFwiLi9yZW5kZXJ0YXJnZXQuanNcIikuR0xDYW52YXNUYXJnZXQ7XG52YXIgUHJvZ3JhbUZhY3RvcnkgPSByZXF1aXJlKFwiLi8uLi9zaGFkZXIvcHJvZ3JhbWZhY3RvcnkuanNcIik7XG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcblxudmFyIENPTlRFWFRfT1BUSU9OUyA9IHtcbiAgICBhbHBoYTogdHJ1ZSwgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSwgYW50aWFsaWFzOiB0cnVlLCBzdGVuY2lsOiB0cnVlLCBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWVcbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudCF9IGNhbnZhc1xuICovXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yQ2FudmFzKGNhbnZhcykge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJywgQ09OVEVYVF9PUFRJT05TKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb250ZXh0IHRoYXQgaW5jbHVkZXMgYWxsIEdMIHJlbGF0ZWQgcmVzb3VyY2VzIC8gaGFuZGxlcnNcbiAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnQhfSBjYW52YXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpZFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBHTENvbnRleHQgPSBmdW5jdGlvbiAoY2FudmFzLCBpZCkge1xuICAgIHRoaXMuZ2wgPSBnZXRDb250ZXh0Rm9yQ2FudmFzKGNhbnZhcyk7XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2FudmFzVGFyZ2V0ID0gbmV3IEdMQ2FudmFzVGFyZ2V0KHRoaXMsIGNhbnZhcy5jbGllbnRXaWR0aCwgY2FudmFzLmNsaWVudEhlaWdodCk7XG4gICAgdGhpcy5wcm9ncmFtRmFjdG9yeSA9IG5ldyBQcm9ncmFtRmFjdG9yeSh0aGlzKTtcbiAgICB0aGlzLnRleHR1cmVNYW5hZ2VyID0gbmV3IFRleHR1cmVNYW5hZ2VyKHsgdW5pdHM6IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyApfSk7XG4gICAgdGhpcy5zdGF0cyA9IHtcbiAgICAgICAgbWF0ZXJpYWxzOiAwLCBtZXNoZXM6IDBcbiAgICB9O1xuICAgIHRoaXMuZXh0ZW5zaW9ucyA9IHBvcHVsYXRlRXh0ZW5zaW9ucyh0aGlzLmdsKTtcblxufTtcblxudmFyIEVYVEVOU0lPTlMgPSBHTENvbnRleHQuRVhURU5TSU9OUyA9IHt9O1xuRVhURU5TSU9OUy5TVEFOREFSRF9ERVJJVkFURVMgPSAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJztcbkVYVEVOU0lPTlMuTVVMVElQTEVfUkVOREVSX1RBUkdFVFMgPSAnV0VCR0xfZHJhd19idWZmZXJzJztcbkVYVEVOU0lPTlMuREVQVEhfVEVYVFVSRSA9ICdXRUJHTF9kZXB0aF90ZXh0dXJlJztcbkVYVEVOU0lPTlMuRkxPQVRfQ09MT1JfQlVGRkVSID0gJ1dFQkdMX2NvbG9yX2J1ZmZlcl9mbG9hdCc7XG5FWFRFTlNJT05TLkZMT0FUX1RFWFRVUkVTID0gJ09FU190ZXh0dXJlX2Zsb2F0JztcbkVYVEVOU0lPTlMuVUlOVDMyX0lORElDRVMgPSAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCc7IC8vQWxzbyBkZWZpbmVkIGluIHhmbG93L3V0aWxzL3V0aWxzLmpzXG5cblhNTDNELmV4dGVuZChHTENvbnRleHQucHJvdG90eXBlLCB7XG4gICAgZ2V0WGZsb3dFbnRyeVdlYkdsRGF0YTogZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgICAgIHJldHVybiBnZXRYZmxvd0VudHJ5V2ViR2xEYXRhKGVudHJ5LCB0aGlzLmlkKTtcbiAgICB9LFxuXG4gICAgcmVxdWVzdFJlZHJhdzogZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAvL2hhbmRsZXIucmVkcmF3KHJlYXNvbiwgZm9yY2VQaWNraW5nKTtcbiAgICB9LFxuXG4gICAgaGFuZGxlUmVzaXplRXZlbnQ6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2FudmFzVGFyZ2V0ID0gbmV3IEdMQ2FudmFzVGFyZ2V0KHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBnZXRTdGF0aXN0aWNzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRzO1xuICAgIH0sXG5cbiAgICBnZXRFeHRlbnNpb25CeU5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnNbbmFtZV07XG4gICAgfSAsXG5cbiAgICBjcmVhdGVUZXh0dXJlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBHTFRleHR1cmUodGhpcyk7XG4gICAgfSAsXG4gICAgY3JlYXRlQ3ViZU1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgR0xDdWJlTWFwKHRoaXMpO1xuICAgIH1cbn0pO1xuXG5cbmZ1bmN0aW9uIGdldFhmbG93RW50cnlXZWJHbERhdGEoZW50cnksIGNhbnZhc0lkKXtcbiAgICBpZighZW50cnkpIHJldHVybiBudWxsO1xuICAgIGlmKCFlbnRyeS51c2VyRGF0YS53ZWJnbERhdGEpXG4gICAgICAgIGVudHJ5LnVzZXJEYXRhLndlYmdsRGF0YSA9IHt9O1xuICAgIGlmKCFlbnRyeS51c2VyRGF0YS53ZWJnbERhdGFbY2FudmFzSWRdKVxuICAgICAgICBlbnRyeS51c2VyRGF0YS53ZWJnbERhdGFbY2FudmFzSWRdID0ge1xuICAgICAgICAgICAgY2hhbmdlZCA6IFhDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9ORVdcbiAgICAgICAgfTtcbiAgICByZXR1cm4gZW50cnkudXNlckRhdGEud2ViZ2xEYXRhW2NhbnZhc0lkXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAqIEByZXR1cm5zIHt7fX1cbiAqL1xuZnVuY3Rpb24gcG9wdWxhdGVFeHRlbnNpb25zKGdsKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gRVhURU5TSU9OUykge1xuICAgICAgICB2YXIgZXh0ZW5zaW9uTmFtZSA9IEVYVEVOU0lPTlNbbmFtZV07XG4gICAgICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oZXh0ZW5zaW9uTmFtZSk7XG4gICAgICAgIGlmICghZXh0KSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dJbmZvKGV4dGVuc2lvbk5hbWUsIFwiaXMgbm90IHN1cHBvcnRlZCBvbiB5b3VyIGdyYXBoaWNzIGNhcmRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRbZXh0ZW5zaW9uTmFtZV0gPSBleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHTENvbnRleHQ7XG5cblxuIiwidmFyIEZ1bGxzY3JlZW5RdWFkID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB0aGlzLmdsID0gY29udGV4dC5nbDtcbiAgICB0aGlzLmNyZWF0ZUdMQXNzZXRzKCk7XG59O1xuXG5YTUwzRC5leHRlbmQoRnVsbHNjcmVlblF1YWQucHJvdG90eXBlLCB7XG5cbiAgICBjcmVhdGVHTEFzc2V0czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB0aGlzLnBvc0J1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5wb3NCdWZmZXIpO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMSwgMSwgMCwgLTEsIDEsIDAsIDEsIC0xLCAwLCAtMSwgLTEsIDBdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICB2YXIgcG9zQXR0ciA9IHByb2dyYW0uYXR0cmlidXRlc1tcInBvc2l0aW9uXCJdO1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NBdHRyLmxvY2F0aW9uKTtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMucG9zQnVmZmVyKTtcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NBdHRyLmxvY2F0aW9uLCAzLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVfU1RSSVAsIDAsIDQpO1xuXG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NBdHRyLmxvY2F0aW9uKTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bGxzY3JlZW5RdWFkO1xuXG4iLCJcblxuLyoqXG4gKlxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSB0eXBlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEdMTWVzaCA9IGZ1bmN0aW9uIChjb250ZXh0LCB0eXBlKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLmdsVHlwZSA9IGdldEdMVHlwZUZyb21TdHJpbmcodHlwZSk7XG4gICAgdGhpcy5idWZmZXJzID0ge307XG4gICAgdGhpcy51bmlmb3JtT3ZlcnJpZGUgPSB7fTtcbiAgICB0aGlzLm1pbkluZGV4ID0gMDtcbiAgICB0aGlzLm1heEluZGV4ID0gMDtcbiAgICB0aGlzLmlzSW5kZXhlZCA9IGZhbHNlO1xuICAgIHRoaXMudmVydGV4Q291bnQgPSBudWxsO1xuICAgIHRoaXMubWluQXR0cmlidXRlQ291bnQgPSAtMTtcbiAgICB0aGlzLmNvbnRleHQuZ2V0U3RhdGlzdGljcygpLm1lc2hlcysrO1xuICAgIHRoaXMubXVsdGlEcmF3ID0gKHRoaXMuZ2xUeXBlID09IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5MSU5FX1NUUklQIHx8IHRoaXMuZ2xUeXBlID09IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRV9TVFJJUCk7XG59O1xuXG5YTUwzRC5leHRlbmQoR0xNZXNoLnByb3RvdHlwZSwge1xuICAgIHNldEluZGV4UmFuZ2U6IGZ1bmN0aW9uIChtaW5JbmRleCwgbWF4SW5kZXgpIHtcbiAgICAgICAgdGhpcy5taW5JbmRleCA9IG1pbkluZGV4O1xuICAgICAgICB0aGlzLm1heEluZGV4ID0gbWF4SW5kZXg7XG4gICAgfSxcblxuICAgIGNoZWNrQnVmZmVyQ29tcGF0aWJsZTogZnVuY3Rpb24gKG5hbWUsIHhmbG93RGF0YUJ1ZmZlcikge1xuICAgICAgICB2YXIgY250ID0geGZsb3dEYXRhQnVmZmVyLmdldEl0ZXJhdGVDb3VudCgpO1xuICAgICAgICB0aGlzLm1pbkF0dHJpYnV0ZUNvdW50ID0gKHRoaXMubWluQXR0cmlidXRlQ291bnQgPT0gLTEgPyBjbnQgOiBNYXRoLm1pbih0aGlzLm1pbkF0dHJpYnV0ZUNvdW50LCBjbnQpKTtcblxuICAgICAgICBpZiAodGhpcy5pc0luZGV4ZWQpIHtcbiAgICAgICAgICAgIGlmIChjbnQgPD0gdGhpcy5tYXhJbmRleCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluZGV4IHJhbmdlIG9mIFtcIiArIHRoaXMubWluSW5kZXggKyBcIiwgXCIgKyB0aGlzLm1heEluZGV4ICsgXCJdIFwiICsgXCIgZ29lcyBiZXlvbmQgZWxlbWVudCBjb3VudCBcIiArIGNudCArIFwiIG9mIGF0dHJpYnV0ZSAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudmVydGV4Q291bnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjbnQgPCB0aGlzLnZlcnRleENvdW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnRleENvdW50IFwiICsgdGhpcy52ZXJ0ZXhDb3VudCArIFwiIGlzIGxhcmdlciB0aGFuIGVsZW1lbnQgY291bnQgXCIgKyBjbnQgKyBcIiBvZiBhdHRyaWJ1dGUgJ1wiICsgbmFtZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVCdWZmZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmJ1ZmZlcnNbbmFtZV07XG4gICAgfSxcblxuICAgIHNldEJ1ZmZlcjogZnVuY3Rpb24gKG5hbWUsIGJ1ZmZlcikge1xuICAgICAgICB0aGlzLmJ1ZmZlcnNbbmFtZV0gPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaXNJbmRleGVkID0gdGhpcy5pc0luZGV4ZWQgfHwgbmFtZSA9PSBcImluZGV4XCI7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IHt9O1xuICAgICAgICB0aGlzLnVuaWZvcm1PdmVycmlkZSA9IHt9O1xuICAgICAgICB0aGlzLm1pbkluZGV4ID0gdGhpcy5tYXhJbmRleCA9IDA7XG4gICAgICAgIHRoaXMuaXNJbmRleGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWluQXR0cmlidXRlQ291bnQgPSAtMTtcbiAgICB9LFxuXG4gICAgc2V0VW5pZm9ybU92ZXJyaWRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBkZWxldGUgdGhpcy51bmlmb3JtT3ZlcnJpZGVbbmFtZV07XG4gICAgICAgIHRoaXMudW5pZm9ybU92ZXJyaWRlW25hbWVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIHNldFZlcnRleENvdW50OiBmdW5jdGlvbiAodmVydGV4Q291bnQpIHtcbiAgICAgICAgdGhpcy52ZXJ0ZXhDb3VudCA9IHZlcnRleENvdW50O1xuICAgIH0sXG5cbiAgICBpc1JlYWR5VG9SZW5kZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluQXR0cmlidXRlQ291bnQgPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldEVsZW1lbnRDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVycy5pbmRleC5sZW5ndGg7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgY2FsY3VsYXRlIGVsZW1lbnQgY291bnQuXCIsIGUpO1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LCAvKipcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldFZlcnRleENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMudmVydGV4Q291bnQgIT0gbnVsbCA/IHRoaXMudmVydGV4Q291bnQgOiB0aGlzLm1pbkF0dHJpYnV0ZUNvdW50ICk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vWE1MM0QuZGVidWcubG9nRXJyb3IoXCJDb3VsZCBub3QgY2FsY3VsYXRlIHZlcnRleCBjb3VudC5cIiwgZSk7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0U2hhZGVyQ2xvc3VyZX0gcHJvZ3JhbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2JpbmRWZXJ0ZXhCdWZmZXJzOiBmdW5jdGlvbihwcm9ncmFtKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbCwgc0F0dHJpYnV0ZXMgPSBwcm9ncmFtLmF0dHJpYnV0ZXMsIGJ1ZmZlcnMgPSB0aGlzLmJ1ZmZlcnMsIGksIG5hbWU7XG5cbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzQXR0cmlidXRlcyk7XG4gICAgICAgIHZhciBrZXlMZW5ndGggPSBrZXlzLmxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5hbWUgPSBrZXlzW2ldO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbbmFtZV07XG4gICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzQXR0cmlidXRlc1tuYW1lXS5sb2NhdGlvbjtcblxuICAgICAgICAgICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NhdGlvbiwgYnVmZmVyLnR1cGxlU2l6ZSwgYnVmZmVyLmdsVHlwZSwgZmFsc2UsIDAsIDApO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF91bmJpbmRWZXJ0ZXhCdWZmZXJzOiBmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2wsIHNBdHRyaWJ1dGVzID0gcHJvZ3JhbS5hdHRyaWJ1dGVzO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHNBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB2YXIgc2hhZGVyQXR0cmlidXRlID0gc0F0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgICAgICBnbC5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoc2hhZGVyQXR0cmlidXRlLmxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0Fic3RyYWN0U2hhZGVyQ2xvc3VyZX0gcHJvZ3JhbVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZHJhdzogZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsLCBzQXR0cmlidXRlcyA9IHByb2dyYW0uYXR0cmlidXRlcywgYnVmZmVycyA9IHRoaXMuYnVmZmVycywgdHJpQ291bnQgPSAwLCBvZmZzZXQsIGo7XG5cbiAgICAgICAgLy9CaW5kIHZlcnRleCBidWZmZXJzXG4gICAgICAgIHRoaXMuX2JpbmRWZXJ0ZXhCdWZmZXJzKHByb2dyYW0pO1xuXG4gICAgICAgIC8vRHJhdyB0aGUgb2JqZWN0XG4gICAgICAgIGlmICh0aGlzLmlzSW5kZXhlZCkge1xuICAgICAgICAgICAgdmFyIGluZGV4QnVmZmVyID0gYnVmZmVycy5pbmRleDtcbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsaW5kZXhCdWZmZXIpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5tdWx0aURyYXcgJiYgdGhpcy52ZXJ0ZXhDb3VudCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMudmVydGV4Q291bnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gdGhpcy52ZXJ0ZXhDb3VudFtqXTtcbiAgICAgICAgICAgICAgICAgICAgZ2wuZHJhd0VsZW1lbnRzKHRoaXMuZ2xUeXBlLCBjb3VudCwgaW5kZXhCdWZmZXIuZ2xUeXBlLCBvZmZzZXQgKiBpbmRleEJ1ZmZlci5ieXRlc1BlckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5kcmF3RWxlbWVudHModGhpcy5nbFR5cGUsIHRoaXMuZ2V0RWxlbWVudENvdW50KCksIGluZGV4QnVmZmVyLmdsVHlwZSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlDb3VudCA9IHRoaXMuZ2V0RWxlbWVudENvdW50KCkgLyAzO1xuICAgICAgICB9IGVsc2UgeyAvLyBub3QgaW5kZXhlZFxuICAgICAgICAgICAgaWYgKHRoaXMubXVsdGlEcmF3ICYmIHRoaXMudmVydGV4Q291bnQpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnZlcnRleENvdW50Lmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IHRoaXMudmVydGV4Q291bnRbal07XG4gICAgICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXModGhpcy5nbFR5cGUsIG9mZnNldCwgY291bnQpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgKz0gY291bnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC5kcmF3QXJyYXlzKHRoaXMuZ2xUeXBlLCAwLCB0aGlzLmdldFZlcnRleENvdW50KCkpO1xuICAgICAgICAgICAgICAgIHRyaUNvdW50ID0gdGhpcy5nZXRWZXJ0ZXhDb3VudCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy9VbmJpbmQgdmVydGV4IGJ1ZmZlcnNcbiAgICAgICAgdGhpcy5fdW5iaW5kVmVydGV4QnVmZmVycyhwcm9ncmFtKTtcblxuXG4gICAgICAgIGlmIChwcm9ncmFtLnVuZG9Vbmlmb3JtVmFyaWFibGVPdmVycmlkZSlcbiAgICAgICAgICAgIHByb2dyYW0udW5kb1VuaWZvcm1WYXJpYWJsZU92ZXJyaWRlKHRoaXMudW5pZm9ybU92ZXJyaWRlKTtcblxuICAgICAgICByZXR1cm4gdHJpQ291bnQ7XG4gICAgfVxuXG5cbn0pO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlTmFtZVxuICovXG52YXIgZ2V0R0xUeXBlRnJvbVN0cmluZyA9IGZ1bmN0aW9uICh0eXBlTmFtZSkge1xuICAgIHZhciBHTCA9IHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG4gICAgaWYgKHR5cGVOYW1lICYmIHR5cGVOYW1lLnRvTG93ZUdMYXNlKVxuICAgICAgICB0eXBlTmFtZSA9IHR5cGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgc3dpdGNoICh0eXBlTmFtZSkge1xuICAgICAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICAgICAgICByZXR1cm4gR0wuVFJJQU5HTEVTO1xuICAgICAgICBjYXNlIFwidHJpc3RyaXBzXCI6XG4gICAgICAgICAgICByZXR1cm4gR0wuVFJJQU5HTEVfU1RSSVA7XG4gICAgICAgIGNhc2UgXCJwb2ludHNcIjpcbiAgICAgICAgICAgIHJldHVybiBHTC5QT0lOVFM7XG4gICAgICAgIGNhc2UgXCJsaW5lc1wiOlxuICAgICAgICAgICAgcmV0dXJuIEdMLkxJTkVTO1xuICAgICAgICBjYXNlIFwibGluZXN0cmlwc1wiOlxuICAgICAgICAgICAgcmV0dXJuIEdMLkxJTkVfU1RSSVA7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHByaW1pdGl2ZSB0eXBlOiBcIiArIHR5cGVOYW1lKTtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdMTWVzaDtcbiIsIlxudmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHMuanNcIik7XG52YXIgU3lzdGVtTm90aWZpZXIgPSByZXF1aXJlKFwiLi4vc3lzdGVtL3N5c3RlbS1ub3RpZmllci5qc1wiKTtcblxuLy9ub2luc3BlY3Rpb24gSlNWYWxpZGF0ZUpTRG9jXG4vKipcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzaGFkZXJTb3VyY2VcbiAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfVxuICovXG52YXIgY3JlYXRlV2ViR0xTaGFkZXJGcm9tU291cmNlID0gZnVuY3Rpb24gKGdsLCB0eXBlLCBzaGFkZXJTb3VyY2UpIHtcbiAgICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xuICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNoYWRlclNvdXJjZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DT01QSUxFX1NUQVRVUykgPT0gMCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgICAgdmFyIGVycm9yU3RyaW5nID0gXCJcIjtcbiAgICAgICAgaWYgKHR5cGUgPT0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LlZFUlRFWF9TSEFERVIpXG4gICAgICAgICAgICBlcnJvclN0cmluZyA9IFwiVmVydGV4IHNoYWRlciBmYWlsZWQgdG8gY29tcGlsZTogXFxuXCI7IGVsc2VcbiAgICAgICAgICAgIGVycm9yU3RyaW5nID0gXCJGcmFnbWVudCBzaGFkZXIgZmFpbGVkIHRvIGNvbXBpbGU6IFxcblwiO1xuXG4gICAgICAgIGVycm9yU3RyaW5nICs9IG1lc3NhZ2UgKyBcIlxcbi0tLS0tLS0tXFxuXCI7XG4gICAgICAgIGVycm9yU3RyaW5nICs9IFwiU2hhZGVyIFNvdXJjZTpcXG4tLS0tLS0tLVxcblwiO1xuICAgICAgICBlcnJvclN0cmluZyArPSBYTUwzRC5kZWJ1Zy5mb3JtYXRTb3VyY2VDb2RlKHNoYWRlclNvdXJjZSk7XG4gICAgICAgIGdsLmdldEVycm9yKCk7XG4gICAgICAgIFN5c3RlbU5vdGlmaWVyLnNlbmRFdmVudCgnZ2xzbCcsIHtcbiAgICAgICAgICAgICAgICBnbHNsVHlwZTogXCJjb21waWxlX2Vycm9yXCIsXG4gICAgICAgICAgICAgICAgc2hhZGVyVHlwZTogdHlwZSA9PSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuVkVSVEVYX1NIQURFUiA/IFwidmVydGV4XCIgOiBcImZyYWdtZW50XCIsXG4gICAgICAgICAgICAgICAgY29kZTogc2hhZGVyU291cmNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvclN0cmluZylcbiAgICB9XG4gICAgcmV0dXJuIHNoYWRlcjtcbn07XG5cbi8vbm9pbnNwZWN0aW9uIEpTVmFsaWRhdGVKU0RvY1xuLyoqXG4gKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAqIEBwYXJhbSB2ZXJ0ZXhTb3VyY2VzXG4gKiBAcGFyYW0gZnJhZ21lbnRTb3VyY2VzXG4gKiBAcmV0dXJucyB7V2ViR0xQcm9ncmFtfVxuICovXG52YXIgY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzID0gZnVuY3Rpb24gKGdsLCB2ZXJ0ZXhTb3VyY2VzLCBmcmFnbWVudFNvdXJjZXMpIHtcbiAgICB2YXIgc2hkLCBzLCBzcmM7XG4gICAgdmFyIHNoYWRlcnMgPSBbXTtcbiAgICBmb3IgKHMgaW4gdmVydGV4U291cmNlcykge1xuICAgICAgICBzcmMgPSB2ZXJ0ZXhTb3VyY2VzW3NdO1xuICAgICAgICBzaGQgPSBjcmVhdGVXZWJHTFNoYWRlckZyb21Tb3VyY2UoZ2wsIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5WRVJURVhfU0hBREVSLCBzcmMpO1xuICAgICAgICBzaGFkZXJzLnB1c2goc2hkKTtcbiAgICB9XG4gICAgZm9yIChzIGluIGZyYWdtZW50U291cmNlcykge1xuICAgICAgICBzcmMgPSBmcmFnbWVudFNvdXJjZXNbc107XG4gICAgICAgIHNoZCA9IGNyZWF0ZVdlYkdMU2hhZGVyRnJvbVNvdXJjZShnbCwgV2ViR0xSZW5kZXJpbmdDb250ZXh0LkZSQUdNRU5UX1NIQURFUiwgc3JjKTtcbiAgICAgICAgc2hhZGVycy5wdXNoKHNoZCk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQcm9ncmFtRnJvbVNoYWRlcnMoZ2wsIHNoYWRlcnMpO1xufTtcblxuLy9ub2luc3BlY3Rpb24gSlNWYWxpZGF0ZUpTRG9jXG4vKipcbiAqIEBwYXJhbSB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fSBnbFxuICogQHBhcmFtIHtPYmplY3R9IHNoYWRlcnNcbiAqIEByZXR1cm4ge1dlYkdMUHJvZ3JhbX1cbiAqL1xudmFyIGNyZWF0ZVByb2dyYW1Gcm9tU2hhZGVycyA9IGZ1bmN0aW9uIChnbCwgc2hhZGVycykge1xuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIGZvciAodmFyIHMgaW4gc2hhZGVycykge1xuICAgICAgICB2YXIgc2hhZGVyID0gc2hhZGVyc1tzXTtcbiAgICAgICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcik7XG4gICAgfVxuICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgIGlmIChnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIFdlYkdMUmVuZGVyaW5nQ29udGV4dC5MSU5LX1NUQVRVUykgPT0gMCkge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgICAgICB2YXIgZXJyb3JTdHJpbmcgPSBcIlNoYWRlciBsaW5raW5nIGZhaWxlZDogXFxuXCI7XG4gICAgICAgIGVycm9yU3RyaW5nICs9IG1lc3NhZ2U7XG4gICAgICAgIGVycm9yU3RyaW5nICs9IFwiXFxuLS0tLS0tLS1cXG5cIjtcbiAgICAgICAgZ2wuZ2V0RXJyb3IoKTtcbiAgICAgICAgU3lzdGVtTm90aWZpZXIuc2VuZEV2ZW50KCdnbHNsJywge2dsc2xUeXBlOiBcImxpbmtfZXJyb3JcIiwgbWVzc2FnZTogbWVzc2FnZX0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JTdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZ3JhbTtcbn07XG5cbnZhciB0YWxseSA9IGZ1bmN0aW9uIChnbCwgaGFuZGxlLCBwcm9ncmFtT2JqZWN0KSB7XG4gICAgdmFyIGk7XG4gICAgLy8gVGFsbHkgc2hhZGVyIGF0dHJpYnV0ZXNcbiAgICB2YXIgbnVtQXR0cmlidXRlcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoaGFuZGxlLCBnbC5BQ1RJVkVfQVRUUklCVVRFUyk7XG4gICAgZm9yIChpID0gMDsgaSA8IG51bUF0dHJpYnV0ZXM7IGkrKykge1xuICAgICAgICB2YXIgYXR0ID0gZ2wuZ2V0QWN0aXZlQXR0cmliKGhhbmRsZSwgaSk7XG4gICAgICAgIGlmICghYXR0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciBhdHRJbmZvID0ge307XG4gICAgICAgIGF0dEluZm8ubmFtZSA9IGF0dC5uYW1lO1xuICAgICAgICBhdHRJbmZvLnNpemUgPSBhdHQuc2l6ZTtcbiAgICAgICAgYXR0SW5mby5nbFR5cGUgPSBhdHQudHlwZTtcbiAgICAgICAgYXR0SW5mby5sb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKGhhbmRsZSwgYXR0Lm5hbWUpO1xuICAgICAgICBwcm9ncmFtT2JqZWN0LmF0dHJpYnV0ZXNbYXR0Lm5hbWVdID0gYXR0SW5mbztcbiAgICB9XG5cblxuICAgIC8vIFRhbGx5IHNoYWRlciB1bmlmb3JtcyBhbmQgc2FtcGxlcnNcbiAgICB2YXIgbnVtVW5pZm9ybXMgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKGhhbmRsZSwgZ2wuQUNUSVZFX1VOSUZPUk1TKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtVW5pZm9ybXM7IGkrKykge1xuICAgICAgICB2YXIgdW5pID0gZ2wuZ2V0QWN0aXZlVW5pZm9ybShoYW5kbGUsIGkpO1xuICAgICAgICBpZiAoIXVuaSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB2YXIgdW5pSW5mbyA9IHt9O1xuICAgICAgICB1bmlJbmZvLm5hbWUgPSB1bmkubmFtZTtcbiAgICAgICAgdW5pSW5mby5zaXplID0gdW5pLnNpemU7XG4gICAgICAgIHVuaUluZm8uZ2xUeXBlID0gdW5pLnR5cGU7XG4gICAgICAgIHVuaUluZm8ubG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oaGFuZGxlLCB1bmkubmFtZSk7XG5cbiAgICAgICAgdmFyIG5hbWUgPSB1bmlJbmZvLm5hbWU7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGFycmF5IGlkZW50aWZpZXIgZnJvbSBuYW1lLCB0aGlzIGlzIGhhbmRsZWQgYnkgc2l6ZVxuICAgICAgICBpZiAobmFtZS5zdWJzdHJpbmcobmFtZS5sZW5ndGggLSAzKSA9PSBcIlswXVwiKSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAzKTsgLy8gUmVtb3ZlIFswXVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuaS50eXBlID09IGdsLlNBTVBMRVJfMkQgfHwgdW5pLnR5cGUgPT0gZ2wuU0FNUExFUl9DVUJFKSB7XG4gICAgICAgICAgICAvLyBTZXQgYWxsIHRleHR1cmUgdW5pdHMgdG8gMCwgbmVlZHMgdG8gYmUgSW50MzJBcnJheVxuICAgICAgICAgICAgdW5pSW5mby5jYWNoZWRVbml0cyA9IG5ldyBJbnQzMkFycmF5KHVuaUluZm8uc2l6ZSk7XG4gICAgICAgICAgICB1bmlJbmZvLnRleHR1cmVzID0gW107XG4gICAgICAgICAgICAvLyBDYWNoZXMgdGhpcyBpbmZvcm1hdGlvblxuICAgICAgICAgICAgdXRpbHMuc2V0VW5pZm9ybShnbCwgdW5pSW5mbywgdW5pSW5mby5jYWNoZWRVbml0cyk7XG5cbiAgICAgICAgICAgIHByb2dyYW1PYmplY3Quc2FtcGxlcnNbbmFtZV0gPSB1bmlJbmZvO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHByb2dyYW1PYmplY3QudW5pZm9ybXNbbmFtZV0gPSB1bmlJbmZvO1xuICAgIH1cblxufTtcblxudmFyIHVuaXF1ZU9iamVjdElkID0gdXRpbHMuZ2V0VW5pcXVlQ291bnRlcigpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gKiBAcGFyYW0ge3sgZnJhZ21lbnQ6IHN0cmluZywgdmVydGV4OiBzdHJpbmcgfX0gc291cmNlc1xuICovXG52YXIgUHJvZ3JhbU9iamVjdCA9IGZ1bmN0aW9uIChnbCwgc291cmNlcykge1xuICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuXG4gICAgdGhpcy5pZCA9IHVuaXF1ZU9iamVjdElkKCk7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy51bmlmb3JtcyA9IHt9O1xuICAgIHRoaXMuc2FtcGxlcnMgPSB7fTtcbiAgICB0aGlzLmhhbmRsZSA9IG51bGw7XG5cbiAgICB0aGlzLmNyZWF0ZSgpO1xufTtcblxuWE1MM0QuZXh0ZW5kKFByb2dyYW1PYmplY3QucHJvdG90eXBlLCB7XG4gICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiQ3JlYXRlIHNoYWRlciBwcm9ncmFtOiBcIiwgdGhpcy5pZCk7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gY3JlYXRlUHJvZ3JhbUZyb21Tb3VyY2VzKHRoaXMuZ2wsIFt0aGlzLnNvdXJjZXMudmVydGV4XSwgW3RoaXMuc291cmNlcy5mcmFnbWVudF0pO1xuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBTeXN0ZW1Ob3RpZmllci5zZW5kRXZlbnQoJ2dsc2wnLCB7Z2xzbFR5cGU6IFwic3VjY2Vzc1wifSk7XG4gICAgICAgIHRoaXMuYmluZCgpO1xuICAgICAgICB0YWxseSh0aGlzLmdsLCB0aGlzLmhhbmRsZSwgdGhpcyk7XG4gICAgfSxcblxuICAgIGJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZSkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJUcnlpbmcgdG8gYmluZCBpbnZhbGlkIEdMUHJvZ3JhbS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHRoaXMuaGFuZGxlKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU29tZSBvZiB0aGUgZGVwZW5kZW50IHRleHR1cmVzIG1heSBoYXZlIGNoYW5nZWQgdGhlaXIgdGV4dHVyZSB1bml0c1xuICAgICAgICAgKi9cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLnNhbXBsZXJzKSB7XG4gICAgICAgICAgICB2YXIgc2FtcGxlciA9IHRoaXMuc2FtcGxlcnNbbmFtZV07XG4gICAgICAgICAgICBpZihzYW1wbGVyLnRleHR1cmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2FtcGxlckZyb21UZXh0dXJlcyhzYW1wbGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICB9LCBpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuaGFuZGxlO1xuICAgIH0sIHNldFVuaWZvcm1WYXJpYWJsZXM6IGZ1bmN0aW9uIChlbnZOYW1lcywgc3lzTmFtZXMsIGlucHV0Q29sbGVjdGlvbikge1xuICAgICAgICB2YXIgaSwgYmFzZSwgb3ZlcnJpZGUsIG5hbWU7XG4gICAgICAgIGlmIChlbnZOYW1lcyAmJiBpbnB1dENvbGxlY3Rpb24uZW52QmFzZSkge1xuICAgICAgICAgICAgaSA9IGVudk5hbWVzLmxlbmd0aDtcbiAgICAgICAgICAgIGJhc2UgPSBpbnB1dENvbGxlY3Rpb24uZW52QmFzZTtcbiAgICAgICAgICAgIG92ZXJyaWRlID0gaW5wdXRDb2xsZWN0aW9uLmVudk92ZXJyaWRlO1xuICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBlbnZOYW1lc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFVuaWZvcm1WYXJpYWJsZShuYW1lLCBvdmVycmlkZSAmJiBvdmVycmlkZVtuYW1lXSAhPT0gdW5kZWZpbmVkID8gb3ZlcnJpZGVbbmFtZV0gOiBiYXNlW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc3lzTmFtZXMgJiYgaW5wdXRDb2xsZWN0aW9uLnN5c0Jhc2UpIHtcbiAgICAgICAgICAgIGkgPSBzeXNOYW1lcy5sZW5ndGg7XG4gICAgICAgICAgICBiYXNlID0gaW5wdXRDb2xsZWN0aW9uLnN5c0Jhc2U7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgICAgICAgICAgbmFtZSA9IHN5c05hbWVzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybVZhcmlhYmxlKG5hbWUsIGJhc2VbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgc2V0VW5pZm9ybVZhcmlhYmxlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMudW5pZm9ybXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHV0aWxzLnNldFVuaWZvcm0odGhpcy5nbCwgdGhpcy51bmlmb3Jtc1tuYW1lXSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2FtcGxlcnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0VW5pZm9ybVNhbXBsZXIodGhpcy5zYW1wbGVyc1tuYW1lXSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRleHR1cmUgdW5pdHMgZnJvbSB0aGUgdGV4dHVyZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzYW1wbGVyXG4gICAgICogQHBhcmFtIHNhbXBsZXJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBzZXRTYW1wbGVyRnJvbVRleHR1cmVzOiBmdW5jdGlvbiAoc2FtcGxlcikge1xuICAgICAgICB2YXIgdGV4dHVyZXMgPSBzYW1wbGVyLnRleHR1cmVzO1xuICAgICAgICB2YXIgY2FjaGVkVW5pdHMgPSBzYW1wbGVyLmNhY2hlZFVuaXRzO1xuICAgICAgICB2YXIgdGV4dHVyZVVuaXRzQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHRleHR1cmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB1bml0ID0gdGV4dHVyZXNbaV0udW5pdDtcblxuICAgICAgICAgICAgLy8gSWYgdGV4dHVyZSBpcyBub3QgYm91bmQgdG8gYSB0ZXh0dXJlIHVuaXQgKC0xKSwgYmluZCBpdCBub3dcbiAgICAgICAgICAgIGlmICh1bml0ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgdW5pdCA9IHRleHR1cmVzW2ldLl9iaW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pdCAhPSBjYWNoZWRVbml0c1tpXSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZFVuaXRzW2ldID0gdW5pdDtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlVW5pdHNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJTZXR0aW5nIG5ldyB0ZXh0dXJlIHVuaXRzOlwiLCBzYW1wbGVyLm5hbWUsIGNhY2hlZFVuaXRzKTtcbiAgICAgICAgICAgIHV0aWxzLnNldFVuaWZvcm0odGhpcy5nbCwgc2FtcGxlciwgY2FjaGVkVW5pdHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldFNhbXBsZXJGcm9tQXJyYXk6IGZ1bmN0aW9uKHNhbXBsZXIsIGFycikge1xuICAgICAgICB2YXIgY2FjaGVkVW5pdHMgPSBzYW1wbGVyLmNhY2hlZFVuaXRzO1xuICAgICAgICB2YXIgdGV4dHVyZVVuaXRzQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB1bml0ID0gYXJyW2ldO1xuICAgICAgICAgICAgaWYgKHVuaXQgIT0gY2FjaGVkVW5pdHNbaV0pIHtcbiAgICAgICAgICAgICAgICBjYWNoZWRVbml0c1tpXSA9IHVuaXQ7XG4gICAgICAgICAgICAgICAgdGV4dHVyZVVuaXRzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgIHV0aWxzLnNldFVuaWZvcm0odGhpcy5nbCwgc2FtcGxlciwgY2FjaGVkVW5pdHMpO1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJTZXR0aW5nIGdsb2JhbCB0ZXh0dXJlIHVuaXRzOlwiLCBzYW1wbGVyLm5hbWUsIGNhY2hlZFVuaXRzLCB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzYW1wbGVyXG4gICAgICogQHBhcmFtIHtBcnJheS48R0xUZXh0dXJlPnxJbnQzMkFycmF5fSB2YWx1ZVxuICAgICAqL1xuICAgIHNldFVuaWZvcm1TYW1wbGVyOiBmdW5jdGlvbiAoc2FtcGxlciwgdmFsdWUpIHtcbiAgICAgICAgWE1MM0QuZGVidWcuYXNzZXJ0KHZhbHVlICYmIHNhbXBsZXIpO1xuICAgICAgICAvLyBUZXh0dXJlcyBhcmUgYWx3YXlzIGFuIGFycmF5IHZhbHVlXG4gICAgICAgIFhNTDNELmRlYnVnLmFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSwgXCJQcm9ncmFtOjpzZXRVbmlmb3JtU2FtcGxlcjogVW5leHBlY3RlZCB2YWx1ZS5cIik7XG4gICAgICAgIC8vIFdlIGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5XG4gICAgICAgIFhNTDNELmRlYnVnLmFzc2VydCh2YWx1ZS5sZW5ndGgsIFwiUHJvZ3JhbTo6c2V0VW5pZm9ybVNhbXBsZXI6IE5vIGVudHJ5IGluIHZhbHVlLlwiKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVmFsdWUgY2FuIGVpdGhlciBiZSBhbiBhcnJheSBvZiBHTFRleHR1cmVzIHRoYXQga25vdyB0aGVpciBjdXJyZW50IHRleHR1cmUgdW5pdCxcbiAgICAgICAgICogb3RoZXJ3aXNlIGEgdHlwZWQgYXJyYXkgY29udGFpbmluZyB0aGUgdGV4dHVyZSB1bml0cyB3ZSBoYXZlIHRvIGJpbmQuXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGhhc1RleHR1cmVzID0gdmFsdWVbMF0udW5pdCAhPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYoaGFzVGV4dHVyZXMpIHtcbiAgICAgICAgICAgIHNhbXBsZXIudGV4dHVyZXMgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuc2V0U2FtcGxlckZyb21UZXh0dXJlcyhzYW1wbGVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2FtcGxlckZyb21BcnJheShzYW1wbGVyLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9ncmFtT2JqZWN0O1xuXG4iLCIvKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xudmFyIElSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XG59O1xuSVJlbmRlclRhcmdldC5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uICgpIHtcbn07XG5JUmVuZGVyVGFyZ2V0LnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbiAoKSB7XG59O1xuSVJlbmRlclRhcmdldC5wcm90b3R5cGUuZ2V0V2lkdGggPSBmdW5jdGlvbiAoKSB7XG59O1xuSVJlbmRlclRhcmdldC5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xufTtcbklSZW5kZXJUYXJnZXQucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xufTtcbklSZW5kZXJUYXJnZXQucHJvdG90eXBlLnJlc2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG59O1xuXG4vKipcbiAqIFdyYXBwZXIgdG8gaGFuZGxlIHNjcmVlbiBjb250ZXh0IGFzIHJlbmRlciB0YXJnZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxuICogQGltcGxlbWVudHMgSVJlbmRlclRhcmdldFxuICovXG52YXIgR0xDYW52YXNUYXJnZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xufTtcblxudmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkge1xufTtcblxuWE1MM0QuZXh0ZW5kKEdMQ2FudmFzVGFyZ2V0LnByb3RvdHlwZSwge1xuICAgIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgIH0sIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfSwgZ2V0U2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSwgYmluZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgfSwgdW5iaW5kOiBlbXB0eSwgcmVzaXplOiBlbXB0eVxufSk7XG5cbi8qKlxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSBvcHRcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMgSVJlbmRlclRhcmdldFxuICovXG52YXIgR0xSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoY29udGV4dCwgb3B0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLndpZHRoID0gb3B0LndpZHRoIHx8IDgwMDtcbiAgICB0aGlzLmhlaWdodCA9IG9wdC5oZWlnaHQgfHwgNjAwO1xuICAgIHRoaXMuc2NhbGUgPSBvcHQuc2NhbGUgfHwgMTtcbiAgICB0aGlzLm9wdCA9IHRoaXMuZmlsbE9wdGlvbnMob3B0KTtcbiAgICB0aGlzLmhhbmRsZSA9IG51bGw7XG4gICAgdGhpcy5jb2xvclRhcmdldCA9IHtoYW5kbGU6IG51bGwsIGlzVGV4dHVyZTogZmFsc2V9O1xuICAgIHRoaXMuZGVwdGhUYXJnZXQgPSB7aGFuZGxlOiBudWxsLCBpc1RleHR1cmU6IGZhbHNlfTtcbiAgICB0aGlzLnN0ZW5jaWxUYXJnZXQgPSB7aGFuZGxlOiBudWxsLCBpc1RleHR1cmU6IGZhbHNlfTtcbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG59O1xuXG5YTUwzRC5leHRlbmQoR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfSwgZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9LCBnZXRTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZTtcbiAgICB9LCBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5oYW5kbGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJhbWVCdWZmZXIodGhpcy5vcHQuY29sb3JGb3JtYXQsIHRoaXMub3B0LmRlcHRoRm9ybWF0LCB0aGlzLm9wdC5zdGVuY2lsRm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmhhbmRsZSk7XG4gICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9LCB1bmJpbmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgIH0sIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuYmluZCgpO1xuICAgIH0sIGNyZWF0ZUZyYW1lQnVmZmVyOiBmdW5jdGlvbiAoY29sb3JGb3JtYXQsIGRlcHRoRm9ybWF0LCBzdGVuY2lsRm9ybWF0KSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblxuICAgICAgICB0aGlzLmhhbmRsZSA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5oYW5kbGUpO1xuICAgICAgICBjb2xvckZvcm1hdCAmJiB0aGlzLmNyZWF0ZUNvbG9yVGFyZ2V0KGNvbG9yRm9ybWF0KTtcbiAgICAgICAgZGVwdGhGb3JtYXQgJiYgdGhpcy5jcmVhdGVEZXB0aFRhcmdldChkZXB0aEZvcm1hdCk7XG4gICAgICAgIHN0ZW5jaWxGb3JtYXQgJiYgdGhpcy5jcmVhdGVTdGVuY2lsVGFyZ2V0KHN0ZW5jaWxGb3JtYXQpO1xuICAgICAgICB0aGlzLmNoZWNrU3RhdHVzKCk7XG4gICAgfSwgY3JlYXRlQ29sb3JUYXJnZXQ6IGZ1bmN0aW9uIChjb2xvckZvcm1hdCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICAgIGlmICh0aGlzLm9wdC5jb2xvckFzUmVuZGVyYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgY3QgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBjdCk7XG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgY29sb3JGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcblxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5SRU5ERVJCVUZGRVIsIGN0KTtcblxuICAgICAgICAgICAgdGhpcy5jb2xvclRhcmdldCA9IHtcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGN0LCBpc1RleHR1cmU6IGZhbHNlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy9vcHQuZ2VuZXJhdGVNaXBtYXAgPSBvcHQuZ2VuZXJhdGVDb2xvcnNNaXBtYXA7XG4gICAgICAgICAgICB2YXIgY3RleCA9IHRoaXMuY29udGV4dC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBjdGV4LmNyZWF0ZVRleDJERnJvbURhdGEoY29sb3JGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5SR0JBLCB0aGlzLm9wdC5jb2xvclR5cGUgfHwgZ2wuVU5TSUdORURfQllURSwgdGhpcy5vcHQpO1xuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBjdGV4LmhhbmRsZSwgMCk7XG4gICAgICAgICAgICB0aGlzLmNvbG9yVGFyZ2V0ID0ge1xuICAgICAgICAgICAgICAgIGhhbmRsZTogY3RleCwgaXNUZXh0dXJlOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgY3JlYXRlRGVwdGhUYXJnZXQ6IGZ1bmN0aW9uIChkZXB0aEZvcm1hdCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICAgIHRoaXMub3B0LmlzRGVwdGggPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5vcHQuZGVwdGhBc1JlbmRlcmJ1ZmZlcikge1xuICAgICAgICAgICAgdmFyIGR0ID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgZHQpO1xuICAgICAgICAgICAgZ2wucmVuZGVyYnVmZmVyU3RvcmFnZShnbC5SRU5ERVJCVUZGRVIsIGRlcHRoRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG5cbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIGR0KTtcblxuICAgICAgICAgICAgdGhpcy5kZXB0aFRhcmdldCA9IHtcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGR0LCBpc1RleHR1cmU6IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvL29wdC5nZW5lcmF0ZU1pcG1hcCA9IG9wdC5nZW5lcmF0ZURlcHRoTWlwbWFwO1xuICAgICAgICAgICAgdmFyIGR0ZXggPSB0aGlzLmNvbnRleHQuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZHRleC5jcmVhdGVUZXgyREZyb21EYXRhKGRlcHRoRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuREVQVEhfQ09NUE9ORU5ULCBnbC5GTE9BVCwgdGhpcy5vcHQpO1xuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkRFUFRIX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIGR0ZXguaGFuZGxlLCAwKTtcblxuICAgICAgICAgICAgdGhpcy5kZXB0aFRhcmdldCA9IHtcbiAgICAgICAgICAgICAgICBoYW5kbGU6IGR0ZXgsIGlzVGV4dHVyZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgY3JlYXRlU3RlbmNpbFRhcmdldDogZnVuY3Rpb24gKHN0ZW5jaWxGb3JtYXQpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgICBpZiAodGhpcy5vcHQuc3RlbmNpbEFzUmVuZGVyYnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgc3QgPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBzdCk7XG4gICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgc3RlbmNpbEZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgICAgICAgZ2wuYmluZFJlbmRlcmJ1ZmZlcihnbC5SRU5ERVJCVUZGRVIsIG51bGwpO1xuXG4gICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuU1RFTkNJTF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHN0KTtcblxuICAgICAgICAgICAgdGhpcy5zdGVuY2lsVGFyZ2V0ID0ge1xuICAgICAgICAgICAgICAgIGhhbmRsZTogc3QsIGlzVGV4dHVyZTogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vb3B0LmdlbmVyYXRlTWlwbWFwID0gb3B0LmdlbmVyYXRlU3RlbmNpbE1pcG1hcDtcbiAgICAgICAgICAgIHZhciBzdGV4ID0gdGhpcy5jb250ZXh0LmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgICAgIHN0ZXguY3JlYXRlVGV4MkRGcm9tRGF0YShzdGVuY2lsRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuU1RFTkNJTF9DT01QT05FTlQsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMub3B0KTtcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5TVEVOQ0lMX0FUVEFDSE1FTlQsIGdsLlRFWFRVUkVfMkQsIHN0ZXguaGFuZGxlLCAwKTtcblxuICAgICAgICAgICAgdGhpcy5zdGVuY2lsVGFyZ2V0ID0ge1xuICAgICAgICAgICAgICAgIGhhbmRsZTogc3RleCwgaXNUZXh0dXJlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBjaGVja1N0YXR1czogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCB0aGlzLmhhbmRsZSk7XG4gICAgICAgIC8vRmluYWxpemUgZnJhbWVidWZmZXIgY3JlYXRpb25cbiAgICAgICAgdmFyIGZiU3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG5cbiAgICAgICAgc3dpdGNoIChmYlN0YXR1cykge1xuICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURTpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UOlxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfTUlTU0lOR19BVFRBQ0hNRU5UXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlM6XG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0RJTUVOU0lPTlNcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX1VOU1VQUE9SVEVEOlxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfVU5TVVBQT1JURURcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogXCIgKyBmYlN0YXR1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG4gICAgICAgIHRoaXMudmFsaWQgPSAoZmJTdGF0dXMgPT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpO1xuICAgICAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgICB9LCBmaWxsT3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgICB2YXIgb3B0ID0ge1xuICAgICAgICAgICAgd3JhcFM6IGdsLkNMQU1QX1RPX0VER0UsXG4gICAgICAgICAgICB3cmFwVDogZ2wuQ0xBTVBfVE9fRURHRSxcbiAgICAgICAgICAgIG1pbkZpbHRlcjogZ2wuTkVBUkVTVCxcbiAgICAgICAgICAgIG1hZ0ZpbHRlcjogZ2wuTkVBUkVTVCxcbiAgICAgICAgICAgIGRlcHRoTW9kZTogZ2wuTFVNSU5BTkNFLFxuICAgICAgICAgICAgZGVwdGhDb21wYXJlTW9kZTogZ2wuQ09NUEFSRV9SX1RPX1RFWFRVUkUsXG4gICAgICAgICAgICBkZXB0aENvbXBhcmVGdW5jOiBnbC5MRVFVQUwsXG4gICAgICAgICAgICBjb2xvcnNBc1JlbmRlcmJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICBkZXB0aEFzUmVuZGVyYnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIHN0ZW5jaWxBc1JlbmRlcmJ1ZmZlcjogZmFsc2UsXG4gICAgICAgICAgICBpc0RlcHRoOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGl0ZW0gaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0W2l0ZW1dID0gb3B0aW9uc1tpdGVtXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0O1xuICAgIH0sIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhbmRsZSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKHRoaXMuaGFuZGxlKTtcblxuICAgICAgICBpZiAodGhpcy5jb2xvclRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3JUYXJnZXQuaXNUZXh0dXJlKVxuICAgICAgICAgICAgICAgIHRoaXMuY29sb3JUYXJnZXQuaGFuZGxlLmRpc3Bvc2UoKTsgZWxzZVxuICAgICAgICAgICAgICAgIGdsLmRlbGV0ZVJlbmRlckJ1ZmZlcih0aGlzLmNvbG9yVGFyZ2V0LmhhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVwdGhUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlcHRoVGFyZ2V0LmlzVGV4dHVyZSlcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoVGFyZ2V0LmhhbmRsZS5kaXNwb3NlKCk7IGVsc2VcbiAgICAgICAgICAgICAgICBnbC5kZWxldGVSZW5kZXJCdWZmZXIodGhpcy5kZXB0aFRhcmdldC5oYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0ZW5jaWxUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0ZW5jaWxUYXJnZXQuaXNUZXh0dXJlKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RlbmNpbFRhcmdldC5oYW5kbGUuZGlzcG9zZSgpOyBlbHNlXG4gICAgICAgICAgICAgICAgZ2wuZGVsZXRlUmVuZGVyQnVmZmVyKHRoaXMuc3RlbmNpbFRhcmdldC5oYW5kbGUpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbnZhciBHTFNjYWxlZFJlbmRlclRhcmdldCA9IGZ1bmN0aW9uIChjb250ZXh0LCBtYXhEaW1lbnNpb24sIG9wdCkge1xuICAgIEdMUmVuZGVyVGFyZ2V0LmNhbGwodGhpcywgY29udGV4dCwgb3B0KTtcbiAgICB0aGlzLnNjYWxlVG9NYXhEaW1lbnNpb24obWF4RGltZW5zaW9uKTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKEdMU2NhbGVkUmVuZGVyVGFyZ2V0LCBHTFJlbmRlclRhcmdldCk7XG5YTUwzRC5leHRlbmQoR0xTY2FsZWRSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XG4gICAgc2NhbGVUb01heERpbWVuc2lvbjogZnVuY3Rpb24gKG1heERpbWVuc2lvbikge1xuICAgICAgICB2YXIgaERpZmYgPSB0aGlzLmhlaWdodCAtIG1heERpbWVuc2lvbjtcbiAgICAgICAgdmFyIHdEaWZmID0gdGhpcy53aWR0aCAtIG1heERpbWVuc2lvbjtcblxuICAgICAgICBpZiAoaERpZmYgPiAwIHx8IHdEaWZmID4gMCkge1xuICAgICAgICAgICAgdmFyIHNjYWxlO1xuICAgICAgICAgICAgaWYgKGhEaWZmID4gd0RpZmYpIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG1heERpbWVuc2lvbiAvIHRoaXMuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzY2FsZSA9IG1heERpbWVuc2lvbiAvIHRoaXMud2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5mbG9vcih0aGlzLndpZHRoICogc2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmZsb29yKHRoaXMuaGVpZ2h0ICogc2NhbGUpO1xuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb250ZXh0XG4gICAgICogQHBhcmFtIG9wdFxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBpbXBsZW1lbnRzIElSZW5kZXJUYXJnZXRcbiAgICAgKi9cbiAgICB2YXIgR0xDdWJlTWFwUmVuZGVyVGFyZ2V0ID0gZnVuY3Rpb24gKGNvbnRleHQsIG9wdCkge1xuICAgICAgICB2YXIgZ2wgPSBjb250ZXh0LmdsO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLndpZHRoID0gb3B0LndpZHRoIHx8IDgwMDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLndpZHRoO1xuICAgICAgICB0aGlzLnNjYWxlID0gb3B0LnNjYWxlIHx8IDE7XG4gICAgICAgIHRoaXMub3B0ID0gdGhpcy5maWxsT3B0aW9ucyhvcHQpO1xuICAgICAgICB0aGlzLmhhbmRsZSA9IG51bGw7XG4gICAgICAgIHRoaXMuY3RleCA9IG51bGw7XG4gICAgICAgIHRoaXMuZHRleCA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RleCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29sb3JUYXJnZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmRlcHRoVGFyZ2V0ID0gIG51bGw7XG4gICAgICAgIHRoaXMuc3RlbmNpbFRhcmdldCA9IG51bGw7XG4gICAgICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5nbFNpZGVzID0gW2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9YLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9ZLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1ksXG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl07XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXJzID0gW107XG4gICAgfTtcblxuICAgIFhNTDNELmV4dGVuZChHTEN1YmVNYXBSZW5kZXJUYXJnZXQucHJvdG90eXBlLCB7XG4gICAgICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9LFxuICAgICAgICBnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9LFxuICAgICAgICBnZXRTY2FsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2FsZTtcbiAgICAgICAgfSxcbiAgICAgICAgYmluZDogZnVuY3Rpb24gKHNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZyYW1lYnVmZmVycy5sZW5ndGggPD0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlRnJhbWVCdWZmZXJzKHRoaXMub3B0LmNvbG9yRm9ybWF0LCB0aGlzLm9wdC5kZXB0aEZvcm1hdCwgdGhpcy5vcHQuc3RlbmNpbEZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy52YWxpZCkge1xuICAgICAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIHRoaXMuZnJhbWVidWZmZXJzW3NpZGVdKTtcbiAgICAgICAgICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5iaW5kKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUZyYW1lQnVmZmVyczogZnVuY3Rpb24gKGNvbG9yRm9ybWF0LCBkZXB0aEZvcm1hdCwgc3RlbmNpbEZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICAgICAgICBpZihjb2xvckZvcm1hdCkgeyAvL1RPRE8gY2hlY2sgaWYgcmVuZGVyYnVmZmVycyBpbnN0ZWFkIG9mIHRleHR1cmVzLi4uXG4gICAgICAgICAgICAgICAgdGhpcy5jdGV4ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUN1YmVNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN0ZXguY3JlYXRlVGV4MkRGcm9tRGF0YShjb2xvckZvcm1hdCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIGdsLlJHQkEsIHRoaXMub3B0LmNvbG9yVHlwZSB8fCBnbC5VTlNJR05FRF9CWVRFLCB0aGlzLm9wdCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xvclRhcmdldCA9IHsgaGFuZGxlOiB0aGlzLmN0ZXgsICBpc1RleHR1cmU6IHRydWV9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZGVwdGhGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdC5pc0RlcHRoID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdC5kZXB0aEFzUmVuZGVyYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kdGV4ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUN1YmVNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kdGV4LmNyZWF0ZVRleDJERnJvbURhdGEoZGVwdGhGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBnbC5ERVBUSF9DT01QT05FTlQsIGdsLkZMT0FULCB0aGlzLm9wdCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhUYXJnZXQgPSB7IGhhbmRsZTogdGhpcy5kdGV4LCAgaXNUZXh0dXJlOiB0cnVlfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihzdGVuY2lsRm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGV4ID0gdGhpcy5jb250ZXh0LmNyZWF0ZUN1YmVNYXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXguY3JlYXRlVGV4MkRGcm9tRGF0YShzdGVuY2lsRm9ybWF0LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgZ2wuU1RFTkNJTF9DT01QT05FTlQsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMub3B0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZW5jaWxUYXJnZXQgPSB7IGhhbmRsZTogdGhpcy5zdGV4LCBpc1RleHR1cmU6IHRydWV9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5nbFNpZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlcnNbaV0gPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcnNbaV0pO1xuICAgICAgICAgICAgICAgIGNvbG9yRm9ybWF0ICYmIHRoaXMuY3JlYXRlQ29sb3JUYXJnZXQoY29sb3JGb3JtYXQsIGkpO1xuICAgICAgICAgICAgICAgIGRlcHRoRm9ybWF0ICYmIHRoaXMuY3JlYXRlRGVwdGhUYXJnZXQoZGVwdGhGb3JtYXQsIGkpO1xuICAgICAgICAgICAgICAgIHN0ZW5jaWxGb3JtYXQgJiYgdGhpcy5jcmVhdGVTdGVuY2lsVGFyZ2V0KHN0ZW5jaWxGb3JtYXQsIGkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tTdGF0dXMoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNyZWF0ZUNvbG9yVGFyZ2V0OiBmdW5jdGlvbiAoY29sb3JGb3JtYXQsIHNpZGUpIHtcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5nbFNpZGVzW3NpZGVdLCB0aGlzLmN0ZXguaGFuZGxlLCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlRGVwdGhUYXJnZXQ6IGZ1bmN0aW9uIChkZXB0aEZvcm1hdCwgc2lkZSkge1xuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHQuZGVwdGhBc1JlbmRlcmJ1ZmZlcikge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kdGV4KSB0aGlzLmR0ZXggPSBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLmR0ZXhbc2lkZV0gPSBnbC5jcmVhdGVSZW5kZXJidWZmZXIoKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgdGhpcy5kdGV4W3NpZGVdKTtcbiAgICAgICAgICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZGVwdGhGb3JtYXQsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kUmVuZGVyYnVmZmVyKGdsLlJFTkRFUkJVRkZFUiwgbnVsbCk7XG5cbiAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZ2wuREVQVEhfQVRUQUNITUVOVCwgZ2wuUkVOREVSQlVGRkVSLCB0aGlzLmR0ZXhbc2lkZV0pO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5kZXB0aFRhcmdldCkgdGhpcy5kZXB0aFRhcmdldCA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVwdGhUYXJnZXRbc2lkZV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZTogdGhpcy5kdGV4W3NpZGVdLFxuICAgICAgICAgICAgICAgICAgICBpc1RleHR1cmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5UMCwgdGhpcy5nbFNpZGVzW3NpZGVdLCB0aGlzLmR0ZXguaGFuZGxlLCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU3RlbmNpbFRhcmdldDogZnVuY3Rpb24gKHN0ZW5jaWxGb3JtYXQsIHNpZGUpIHtcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblxuICAgICAgICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLlNURU5DSUxfQVRUQUNITUVOVCwgdGhpcy5nbFNpZGVzW3NpZGVdLCB0aGlzLnN0ZXguaGFuZGxlLCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2tTdGF0dXM6IGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cbiAgICAgICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgdGhpcy5mcmFtZWJ1ZmZlcnNbc2lkZV0pO1xuICAgICAgICAgICAgLy9GaW5hbGl6ZSBmcmFtZWJ1ZmZlciBjcmVhdGlvblxuICAgICAgICAgICAgdmFyIGZiU3RhdHVzID0gZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyhnbC5GUkFNRUJVRkZFUik7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZmJTdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9JTkNPTVBMRVRFX0FUVEFDSE1FTlRcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQ6XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiSW5jb21wbGV0ZSBmcmFtZWJ1ZmZlcjogRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlRcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgZ2wuRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TOlxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkluY29tcGxldGUgZnJhbWVidWZmZXI6IEZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OU1wiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBGUkFNRUJVRkZFUl9VTlNVUFBPUlRFRFwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbmNvbXBsZXRlIGZyYW1lYnVmZmVyOiBcIiArIGZiU3RhdHVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsKTtcblxuICAgICAgICAgICAgdGhpcy52YWxpZCA9IChmYlN0YXR1cyA9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZDtcbiAgICAgICAgfSxcbiAgICAgICAgZmlsbE9wdGlvbnM6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICAgICAgICB2YXIgb3B0ID0ge1xuICAgICAgICAgICAgICAgIHdyYXBTOiBnbC5DTEFNUF9UT19FREdFLFxuICAgICAgICAgICAgICAgIHdyYXBUOiBnbC5DTEFNUF9UT19FREdFLFxuICAgICAgICAgICAgICAgIG1pbkZpbHRlcjogZ2wuTkVBUkVTVCxcbiAgICAgICAgICAgICAgICBtYWdGaWx0ZXI6IGdsLk5FQVJFU1QsXG4gICAgICAgICAgICAgICAgZGVwdGhNb2RlOiBnbC5MVU1JTkFOQ0UsXG4gICAgICAgICAgICAgICAgZGVwdGhDb21wYXJlTW9kZTogZ2wuQ09NUEFSRV9SX1RPX1RFWFRVUkUsXG4gICAgICAgICAgICAgICAgZGVwdGhDb21wYXJlRnVuYzogZ2wuTEVRVUFMLFxuICAgICAgICAgICAgICAgIGNvbG9yc0FzUmVuZGVyYnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZXB0aEFzUmVuZGVyYnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzdGVuY2lsQXNSZW5kZXJidWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzRGVwdGg6IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpdGVtIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHRbaXRlbV0gPSBvcHRpb25zW2l0ZW1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3B0O1xuICAgICAgICB9LFxuICAgICAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mcmFtZWJ1ZmZlcnMubGVuZ3RoIDw9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICAgICAgICBmb3IodmFyIHNpZGUgaW4gdGhpcy5mcmFtZWJ1ZmZlcnMpXG4gICAgICAgICAgICAgICAgZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcnNbc2lkZV0pO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvclRhcmdldC5oYW5kbGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2xvclRhcmdldC5oYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZGVwdGhUYXJnZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcHRoVGFyZ2V0LmhhbmRsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGVuY2lsVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RlbmNpbFRhcmdldC5oYW5kbGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmZyYW1lYnVmZmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgfSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEdMQ2FudmFzVGFyZ2V0OiBHTENhbnZhc1RhcmdldCxcbiAgICBHTFJlbmRlclRhcmdldDogR0xSZW5kZXJUYXJnZXQsXG4gICAgR0xTY2FsZWRSZW5kZXJUYXJnZXQ6IEdMU2NhbGVkUmVuZGVyVGFyZ2V0LFxuICAgIEdMQ3ViZU1hcFJlbmRlclRhcmdldDogR0xDdWJlTWFwUmVuZGVyVGFyZ2V0XG59O1xuXG5cbiIsInZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzLmpzXCIpO1xudmFyIFN0YXRlTWFjaGluZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jb250cmliL3N0YXRlLW1hY2hpbmUuanNcIik7XG52YXIgU2FtcGxlckNvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvZGF0YS5qc1wiKS5TYW1wbGVyQ29uZmlnO1xudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG52YXIgdW5pcXVlT2JqZWN0SWQgPSB1dGlscy5nZXRVbmlxdWVDb3VudGVyKCk7XG5cbi8vbm9pbnNwZWN0aW9uIEpTVmFsaWRhdGVKU0RvY1xuLyoqXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBHTFRleHR1cmUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIFNhbXBsZXJDb25maWcuY2FsbCh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtHTENvbnRleHR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5pZCA9IHVuaXF1ZU9iamVjdElkKCk7XG5cbiAgICAvKipcbiAgICAgKiBVbml0IHRoZSB0ZXh0dXJlIGlzIGN1cnJlbnRseSBib3VuZCB0byAob3IgLTEgaWYgYm91bmQgdG8gbm8gdW5pdClcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudW5pdCA9IC0xO1xuXG4gICAgdGhpcy5zZXREZWZhdWx0cygpO1xuXG4gICAgdGhpcy53aWR0aCA9IDA7XG4gICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuaGFuZGxlID0gbnVsbDtcblxuICAgIHRoaXMudGV4dHVyZVR5cGUgPSBjb250ZXh0LmdsLlRFWFRVUkVfMkQ7XG5cbiAgICB0aGlzLnRleHR1cmVVbml0Q2FsbGJhY2sgPSB0aGlzLmxvc3RUZXh0dXJlVW5pdC5iaW5kKHRoaXMpO1xufTtcblxuWE1MM0QuY3JlYXRlQ2xhc3MoR0xUZXh0dXJlLCBTYW1wbGVyQ29uZmlnKTtcblxuR0xUZXh0dXJlLlN0YXRlID0ge1xuICAgIE5PTkU6IFwibm9uZVwiLCBMT0FESU5HOiBcImxvYWRpbmdcIiwgUkVBRFk6IFwicmVhZHlcIiwgRVJST1I6IFwiZXJyb3JcIlxufTtcblxuXG52YXIgZ2V0T3JDcmVhdGVGYWxsYmFja1RleHR1cmUgPSAoZnVuY3Rpb24gKCkge1xuXG4gICAgdmFyIGNfZmFsbGJhY2tUZXh0dXJlID0gbnVsbDtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICBpZiAoIWNfZmFsbGJhY2tUZXh0dXJlKSB7XG4gICAgICAgICAgICBjX2ZhbGxiYWNrVGV4dHVyZSA9IG5ldyBHTFRleHR1cmUoY29udGV4dCk7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IDE2O1xuICAgICAgICAgICAgdmFyIHRleGVscyA9IG5ldyBVaW50OEFycmF5KHNpemUgKiBzaXplICogMyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHRleGVsc1tpXSA9IDEyODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNfZmFsbGJhY2tUZXh0dXJlLmNyZWF0ZVRleDJERnJvbURhdGEoV2ViR0xSZW5kZXJpbmdDb250ZXh0LlJHQiwgc2l6ZSwgc2l6ZSwgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlJHQiwgV2ViR0xSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0JZVEUsIHtcbiAgICAgICAgICAgICAgICB0ZXhlbHM6IHRleGVscywgd3JhcFM6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5SRVBFQVQsIHdyYXBUOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuUkVQRUFULCBtaW5GaWx0ZXI6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5MSU5FQVIsIG1hZ0ZpbHRlcjogV2ViR0xSZW5kZXJpbmdDb250ZXh0LkxJTkVBUlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNfZmFsbGJhY2tUZXh0dXJlO1xuICAgIH1cbn0oKSk7XG5cbnZhciBpc1Bvd2VyT2ZUd28gPSBmdW5jdGlvbiAoZGltZW5zaW9uKSB7XG4gICAgcmV0dXJuIChkaW1lbnNpb24gJiAoZGltZW5zaW9uIC0gMSkpID09IDA7XG59O1xudmFyIG5leHRIaWdoZXN0UG93ZXJPZlR3byA9IGZ1bmN0aW9uICh4KSB7XG4gICAgLS14O1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgMzI7IGkgPDw9IDEpIHtcbiAgICAgICAgeCA9IHggfCB4ID4+IGk7XG4gICAgfVxuICAgIHJldHVybiB4ICsgMTtcbn07XG5cbi8qKlxuICogU2NhbGUgdXAgdGhlIHRleHR1cmUgdG8gdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiB0d28gZGltZW5zaW9ucy5cbiAqIEByZXR1cm5zIHtIVE1MQ2FudmFzRWxlbWVudH1cbiAqL1xudmFyIHNjYWxlSW1hZ2UgPSBmdW5jdGlvbiAoaW1hZ2UsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SFRNTENhbnZhc0VsZW1lbnR9XG4gICAgICovXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gbmV4dEhpZ2hlc3RQb3dlck9mVHdvKHdpZHRoKTtcbiAgICBjYW52YXMuaGVpZ2h0ID0gbmV4dEhpZ2hlc3RQb3dlck9mVHdvKGhlaWdodCk7XG5cbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgaWYgKGltYWdlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIHRtcENhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0bXBDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB2YXIgdG1wQ29udGV4dCA9IHRtcENhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIHZhciBpbWFnZURhdGEgPSB0bXBDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgaW1hZ2VEYXRhLmRhdGEuc2V0KGltYWdlLmRhdGEpO1xuICAgICAgICB0bXBDb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuXG4gICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRtcENhbnZhcywgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2FudmFzO1xufTtcblxudmFyIGdsVGV4dHVyZUZvcm1hdEZyb21YZmxvdyA9IGZ1bmN0aW9uIChmb3JtYXQsIGdsKSB7XG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX0ZPUk1BVC5BTFBIQTpcbiAgICAgICAgICAgIHJldHVybiBnbC5BTFBIQTtcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX0ZPUk1BVC5SR0I6XG4gICAgICAgICAgICByZXR1cm4gZ2wuUkdCO1xuICAgICAgICBjYXNlIFhDLlRFWFRVUkVfRk9STUFULlJHQkE6XG4gICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX0ZPUk1BVC5MVU1JTkFOQ0U6XG4gICAgICAgICAgICByZXR1cm4gZ2wuTFVNSU5BTkNFO1xuICAgICAgICBjYXNlIFhDLlRFWFRVUkVfRk9STUFULkxVTUlOQU5DRV9BTFBIQTpcbiAgICAgICAgICAgIHJldHVybiBnbC5MVU1JTkFOQ0VfQUxQSEE7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBUZXh0dXJlIEZvcm1hdCFcIik7XG4gICAgfVxufTtcblxudmFyIGdsVGV4dHVyZVR5cGVGcm9tWGZsb3cgPSBmdW5jdGlvbiAodHlwZSwgZ2wpIHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBYQy5URVhUVVJFX1RZUEUuRkxPQVQ6XG4gICAgICAgICAgICByZXR1cm4gZ2wuRkxPQVQ7XG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9UWVBFLlVCWVRFOlxuICAgICAgICAgICAgcmV0dXJuIGdsLlVOU0lHTkVEX0JZVEU7XG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9UWVBFLlVTSE9SVF80XzRfNF80OlxuICAgICAgICAgICAgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzRfNF80XzQ7XG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9UWVBFLlVTSE9SVF81XzVfNV8xOlxuICAgICAgICAgICAgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XG4gICAgICAgIGNhc2UgWEMuVEVYVFVSRV9UWVBFLlVTSE9SVF81XzZfNTpcbiAgICAgICAgICAgIHJldHVybiBnbC5HTF9VTlNJR05FRF9TSE9SVF81XzZfNTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIFRleHR1cmUgVHlwZSFcIik7XG4gICAgfVxufTtcblxuWE1MM0QuZXh0ZW5kKEdMVGV4dHVyZS5wcm90b3R5cGUsIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1hmbG93LlRleHR1cmVFbnRyeX0gdGV4dHVyZUVudHJ5XG4gICAgICovXG4gICAgdXBkYXRlRnJvbVRleHR1cmVFbnRyeTogZnVuY3Rpb24gKHRleHR1cmVFbnRyeSkge1xuICAgICAgICBpZiAoIXRleHR1cmVFbnRyeS5pc0xvYWRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQodGV4dHVyZUVudHJ5LmdldFNhbXBsZXJDb25maWcoKSk7XG4gICAgICAgICAgICB2YXIgaW1nID0gdGV4dHVyZUVudHJ5LmFzR0xUZXh0dXJlVmFsdWUoKTtcbiAgICAgICAgICAgIGlmICghaW1nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZhaWxlZCgpO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVPclVwZGF0ZVRleHR1cmUoaW1nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9hZHMoKTtcbiAgICAgICAgfVxuICAgIH0sIC8qKlxuICAgICAqIFdlIG5lZWQgdG8gc2NhbGUgdGV4dHVyZSB3aGVuIG9uZSBvZiB0aGUgd3JhcCBtb2RlcyBpcyBub3QgQ0xBTVBfVE9fRURHRSBhbmRcbiAgICAgKiBvbmUgb2YgdGhlIHRleHR1cmUgZGltZW5zaW9ucyBpcyBub3QgcG93ZXIgb2YgdHdvLlxuICAgICAqIE90aGVyd2lzZSByZW5kZXJlZCB0ZXh0dXJlIHdpbGwgYmUganVzdCBibGFjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgbmVlZHNTY2FsZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmdlbmVyYXRlTWlwTWFwIHx8IHRoaXMud3JhcFMgIT0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LkNMQU1QX1RPX0VER0UgfHwgdGhpcy53cmFwVCAhPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQuQ0xBTVBfVE9fRURHRSkgJiYgKCFpc1Bvd2VyT2ZUd28od2lkdGgpIHx8ICFpc1Bvd2VyT2ZUd28oaGVpZ2h0KSlcbiAgICB9LFxuXG5cbiAgICBfYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG4gICAgICAgIHZhciB0ZXh0dXJlTWFuYWdlciA9IHRoaXMuY29udGV4dC50ZXh0dXJlTWFuYWdlcjtcbiAgICAgICAgdmFyIHVuaXQgPSB0aGlzLnVuaXQgPSB0ZXh0dXJlTWFuYWdlci5iaW5kKHRoaXMuaWQsIHsgZGlzcG9zZTogdGhpcy50ZXh0dXJlVW5pdENhbGxiYWNrIH0pO1xuICAgICAgICBpZiAodW5pdCA9PSAtMikge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJBbGwgYXZhaWxhYmxlIHRleHR1cmUgdW5pdHMgYXJlIGZ1bGwuXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShXZWJHTFJlbmRlcmluZ0NvbnRleHQuVEVYVFVSRTAgKyB1bml0KTtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKHRoaXMudGV4dHVyZVR5cGUsIHRoaXMuaGFuZGxlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5pdDtcbiAgICB9LFxuXG4gICAgdW5iaW5kOiBmdW5jdGlvbiAodW5pdCkge1xuICAgICAgICAvLyBEbyBub3RoaW5nLCB0ZXh0dXJlIG1hbmFnZXIgd2lsbCBoYW5kbGUgdGhpc1xuICAgIH0sXG5cbiAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgICAgdmFyIHRleHR1cmVNYW5hZ2VyID0gdGhpcy5jb250ZXh0LnRleHR1cmVNYW5hZ2VyO1xuICAgICAgICB0ZXh0dXJlTWFuYWdlci5kaXNwb3NlKHRoaXMuaWQpO1xuICAgICAgICBnbC5kZWxldGVUZXh0dXJlKHRoaXMuaGFuZGxlKTtcbiAgICB9LFxuXG4gICAgY2FuQmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09IEdMVGV4dHVyZS5TdGF0ZS5SRUFEWTtcbiAgICB9LFxuXG4gICAgY3JlYXRlT3JVcGRhdGVUZXh0dXJlOiBmdW5jdGlvbiAodGV4ZWxTb3VyY2UpIHtcblxuICAgICAgICBpZiAoIXRoaXMuaGFuZGxlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZSA9IHRoaXMuY29udGV4dC5nbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmVGcm9tRGF0YSh0ZXhlbFNvdXJjZSk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVRleHR1cmVGcm9tRGF0YTogZnVuY3Rpb24gKHRleGVsU291cmNlKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcbiAgICAgICAgdGhpcy5fYmluZCgpO1xuXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMud3JhcFMpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLndyYXBUKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01JTl9GSUxURVIsIHRoaXMubWluRmlsdGVyKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMubWFnRmlsdGVyKTtcblxuICAgICAgICB2YXIgdHlwZSA9IGdsVGV4dHVyZVR5cGVGcm9tWGZsb3codGV4ZWxTb3VyY2UudGV4ZWxUeXBlLCBnbCk7XG4gICAgICAgIHZhciBmb3JtYXQgPSBnbFRleHR1cmVGb3JtYXRGcm9tWGZsb3codGV4ZWxTb3VyY2UudGV4ZWxGb3JtYXQsIGdsKTtcblxuICAgICAgICB2YXIgd2lkdGggPSB0ZXhlbFNvdXJjZS53aWR0aDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gdGV4ZWxTb3VyY2UuaGVpZ2h0O1xuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICBpZiAodGhpcy5nZW5lcmF0ZU1pcE1hcCAmJiB0aGlzLm5lZWRzU2NhbGUod2lkdGgsIGhlaWdodCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBnbC5GTE9BVClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaG91bGQgZ2VuZXJhdGUgTWlwTWFwcyBidXQgdGV4dHVyZSBkYXRhIGlzIGZsb2F0IGFuZCBub3QgcG93ZXIgb2YgdHdvIGluIHNpemUhXCIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRleGVsU291cmNlID0gc2NhbGVJbWFnZSh0ZXhlbFNvdXJjZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4ZWxTb3VyY2UgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIGZvcm1hdCwgdHlwZSwgdGV4ZWxTb3VyY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRleGVsU291cmNlLmRhdGEgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheSkge1xuICAgICAgICAgICAgICAgIC8vIFdlYkdMIGRvZXMgbm90IHN1cHBvcnQgVWludDhDbGFtcGVkQXJyYXksIHdoaWNoIGlzIChjb3JyZWN0bHkpIHVzZWQgYnkgYXN5bmMuIFhmbG93LiBXZSBqdXN0IGJ1aWxkIGEgbmV3IHZpZXdcbiAgICAgICAgICAgICAgICAvLyBvbiB0b3Agb2YgdGhlIHVuZGVybHlpbmcgYXJyYXkgYnVmZmVyIHdoaWNoIHNob3VsZCBiZSByZWxhdGl2ZWx5IGZhc3RcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBuZXcgVWludDhBcnJheSh0ZXhlbFNvdXJjZS5kYXRhLmJ1ZmZlcikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCB0ZXhlbFNvdXJjZS5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdlbmVyYXRlTWlwTWFwKVxuICAgICAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy50ZXh0dXJlVHlwZSk7XG5cbiAgICAgICAgdGhpcy5jcmVhdGVkKCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVRleDJERnJvbURhdGE6IGZ1bmN0aW9uIChpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBvcHQpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuXG4gICAgICAgIHZhciBvcHQgPSBvcHQgfHwge307XG4gICAgICAgIHZhciB0ZXhlbHMgPSBvcHQudGV4ZWxzO1xuXG4gICAgICAgIGlmICghdGV4ZWxzKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlVHlwZSA9PSBnbC5GTE9BVCkge1xuICAgICAgICAgICAgICAgIHRleGVscyA9IG5ldyBGbG9hdDMyQXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGV4ZWxzID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLmhhbmRsZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgdGhpcy5fYmluZCgpO1xuXG4gICAgICAgIC8vIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfV1JBUF9TLCBvcHQud3JhcFMpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfV1JBUF9ULCBvcHQud3JhcFQpO1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKHRoaXMudGV4dHVyZVR5cGUsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgb3B0Lm1pbkZpbHRlcik7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBvcHQubWFnRmlsdGVyKTtcblxuICAgICAgICBpZiAoIW9wdC5pc0RlcHRoKSB7XG4gICAgICAgICAgICBpZiAodGV4ZWxzIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBzb3VyY2VGb3JtYXQsIHNvdXJjZVR5cGUsIG5ldyBVaW50OEFycmF5KHRleGVscy5idWZmZXIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCB0ZXhlbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQuZ2VuZXJhdGVNaXBtYXApIHtcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRoaXMudGV4dHVyZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlZCgpO1xuICAgIH0sXG5cbiAgICBsb3N0VGV4dHVyZVVuaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVuaXQgPSAtMTtcbiAgICB9XG5cbn0pO1xuXG5TdGF0ZU1hY2hpbmUuY3JlYXRlKHtcbiAgICB0YXJnZXQ6IEdMVGV4dHVyZS5wcm90b3R5cGUsXG4gICAgaW5pdGlhbDogR0xUZXh0dXJlLlN0YXRlLk5PTkUsXG4gICAgZXZlbnRzOiBbe25hbWU6ICdjcmVhdGVkJywgZnJvbTogJyonLCB0bzogR0xUZXh0dXJlLlN0YXRlLlJFQURZfSwge1xuICAgICAgICBuYW1lOiAnZmFpbGVkJywgZnJvbTogJyonLCB0bzogR0xUZXh0dXJlLlN0YXRlLkVSUk9SXG4gICAgfSwge25hbWU6ICdsb2FkcycsIGZyb206ICcqJywgdG86IEdMVGV4dHVyZS5TdGF0ZS5MT0FESU5HfV1cbn0pO1xuXG4vL25vaW5zcGVjdGlvbiBKU1ZhbGlkYXRlSlNEb2Ncbi8qKlxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgR0xDdWJlTWFwID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBHTFRleHR1cmUuY2FsbCh0aGlzLCBjb250ZXh0LCBjb250ZXh0LmdsLlRFWFRVUkVfQ1VCRV9NQVApO1xuICAgIHZhciBnbCA9IGNvbnRleHQuZ2w7XG4gICAgdGhpcy50ZXh0dXJlVHlwZSA9IGNvbnRleHQuZ2wuVEVYVFVSRV9DVUJFX01BUDtcbiAgICB0aGlzLmdsU2lkZXMgPSBbZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YLCBnbC5URVhUVVJFX0NVQkVfTUFQX05FR0FUSVZFX1gsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWSwgZ2wuVEVYVFVSRV9DVUJFX01BUF9ORUdBVElWRV9ZLCBnbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1osIGdsLlRFWFRVUkVfQ1VCRV9NQVBfTkVHQVRJVkVfWl07XG5cbn07XG5YTUwzRC5jcmVhdGVDbGFzcyhHTEN1YmVNYXAsIEdMVGV4dHVyZSwge1xuICAgIHVwZGF0ZVRleHR1cmVGcm9tRGF0YTogZnVuY3Rpb24gKHRleGVsU291cmNlKSB7XG4gICAgICAgIGRlYnVnLmxvZyhcInVwZGF0ZVRleHR1cmVGcm9tRGF0YSBub3QgaW1wbGVtZW50ZWQgZm9yIEN1YmVNYXBwaW5nIVwiKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlVGV4MkRGcm9tRGF0YTogZnVuY3Rpb24gKGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCBzb3VyY2VGb3JtYXQsIHNvdXJjZVR5cGUsIG9wdCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cbiAgICAgICAgdmFyIG9wdCA9IG9wdCB8fCB7fTtcbiAgICAgICAgdmFyIHRleGVscyA9IG9wdC50ZXhlbHM7XG5cbiAgICAgICAgaWYgKCF0ZXhlbHMpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VUeXBlID09IGdsLkZMT0FUKSB7XG4gICAgICAgICAgICAgICAgdGV4ZWxzID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuaGFuZGxlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICB0aGlzLl9iaW5kKCk7XG5cbiAgICAgICAgLy8gZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1MsIG9wdC53cmFwUyk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9XUkFQX1QsIG9wdC53cmFwVCk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkodGhpcy50ZXh0dXJlVHlwZSwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBvcHQubWluRmlsdGVyKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaSh0aGlzLnRleHR1cmVUeXBlLCBnbC5URVhUVVJFX01BR19GSUxURVIsIG9wdC5tYWdGaWx0ZXIpO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmdsU2lkZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGlmICghb3B0LmlzRGVwdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4ZWxzIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudGV4SW1hZ2UyRCh0aGlzLmdsU2lkZXNbaV0sIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBzb3VyY2VGb3JtYXQsIHNvdXJjZVR5cGUsIG5ldyBVaW50OEFycmF5KHRleGVscy5idWZmZXIpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKHRoaXMuZ2xTaWRlc1tpXSwgMCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIHNvdXJjZUZvcm1hdCwgc291cmNlVHlwZSwgdGV4ZWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQodGhpcy5nbFNpZGVzW2ldLCAwLCBpbnRlcm5hbEZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgc291cmNlRm9ybWF0LCBzb3VyY2VUeXBlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHQuZ2VuZXJhdGVNaXBtYXApIHtcbiAgICAgICAgICAgIGdsLmdlbmVyYXRlTWlwbWFwKHRoaXMudGV4dHVyZVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlZCgpO1xuICAgIH1cbn0pO1xuXG5HTEN1YmVNYXAuU3RhdGUgPSB7XG4gICAgTk9ORTogXCJub25lXCIsIExPQURJTkc6IFwibG9hZGluZ1wiLCBSRUFEWTogXCJyZWFkeVwiLCBFUlJPUjogXCJlcnJvclwiXG59O1xuXG5TdGF0ZU1hY2hpbmUuY3JlYXRlKHtcbiAgICB0YXJnZXQ6IEdMQ3ViZU1hcC5wcm90b3R5cGUsXG4gICAgaW5pdGlhbDogR0xDdWJlTWFwLlN0YXRlLk5PTkUsXG4gICAgZXZlbnRzOiBbe25hbWU6ICdjcmVhdGVkJywgZnJvbTogJyonLCB0bzogR0xDdWJlTWFwLlN0YXRlLlJFQURZfSwge1xuICAgICAgICBuYW1lOiAnZmFpbGVkJywgZnJvbTogJyonLCB0bzogR0xDdWJlTWFwLlN0YXRlLkVSUk9SXG4gICAgfSwge25hbWU6ICdsb2FkcycsIGZyb206ICcqJywgdG86IEdMQ3ViZU1hcC5TdGF0ZS5MT0FESU5HfV1cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEdMVGV4dHVyZTogR0xUZXh0dXJlLFxuICAgIEdMQ3ViZU1hcDogR0xDdWJlTWFwXG59O1xuXG5cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICAgIC8qKlxuICAgICAqIFNldCB1bmlmb3JtcyBmb3IgYWN0aXZlIHByb2dyYW1cbiAgICAgKiBAcGFyYW0ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH0gZ2xcbiAgICAgKiBAcGFyYW0gdVxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHRyYW5zcG9zZWRcbiAgICAgKi9cbiAgICBzZXRVbmlmb3JtOiBmdW5jdGlvbiAoZ2wsIHUsIHZhbHVlLCB0cmFuc3Bvc2VkKSB7XG5cbiAgICAgICAgLy9ub2luc3BlY3Rpb24gRmFsbHRocm91Z2hJblN3aXRjaFN0YXRlbWVudEpTXG4gICAgICAgIHN3aXRjaCAodS5nbFR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgMzU2NzA6IC8vZ2wuQk9PTFxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmFuc2Zvcm0gYSBVbml0OEFycmF5IGludG8gYSBKUyBBcnJheVxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWl2KHUubG9jYXRpb24sIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCh2YWx1ZSwgZnVuY3Rpb24odikgeyByZXR1cm4gdjsgfSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaSh1LmxvY2F0aW9uLCB2YWx1ZSB8fCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDUxMjQ6ICAvL2dsLklOVFxuICAgICAgICAgICAgY2FzZSAzNTY3ODogLy9nbC5TQU1QTEVSXzJEXG4gICAgICAgICAgICBjYXNlIDM1NjgwOiAvL2dsLlNBTVBMRVJfQ1VCRVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWl2KHUubG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWkodS5sb2NhdGlvbiwgdmFsdWUgfHwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIDM1NjcxOiAvLyBnbC5CT09MX1ZFQzJcbiAgICAgICAgICAgIGNhc2UgMzU2Njc6XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJpdih1LmxvY2F0aW9uLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIGdsLklOVF9WRUMyXG5cbiAgICAgICAgICAgIGNhc2UgMzU2NzI6IC8vIGdsLkJPT0xfVkVDM1xuICAgICAgICAgICAgY2FzZSAzNTY2ODpcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2l2KHUubG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZ2wuSU5UX1ZFQzNcblxuICAgICAgICAgICAgY2FzZSAzNTY3MzogLy8gZ2wuQk9PTF9WRUM0XG4gICAgICAgICAgICBjYXNlIDM1NjY5OlxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm00aXYodS5sb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBnbC5JTlRfVkVDNFxuXG4gICAgICAgICAgICBjYXNlIDUxMjY6XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWZ2KHUubG9jYXRpb24sIHZhbHVlKTsgZWxzZVxuICAgICAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodS5sb2NhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBnbC5GTE9BVFxuICAgICAgICAgICAgY2FzZSAzNTY2NDpcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMmZ2KHUubG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZ2wuRkxPQVRfVkVDMlxuICAgICAgICAgICAgY2FzZSAzNTY2NTpcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtM2Z2KHUubG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZ2wuRkxPQVRfVkVDM1xuICAgICAgICAgICAgY2FzZSAzNTY2NjpcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtNGZ2KHUubG9jYXRpb24sIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gZ2wuRkxPQVRfVkVDNFxuXG4gICAgICAgICAgICBjYXNlIDM1Njc0OlxuICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgyZnYodS5sb2NhdGlvbiwgdHJhbnNwb3NlZCB8fCBmYWxzZSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrOy8vIGdsLkZMT0FUX01BVDJcbiAgICAgICAgICAgIGNhc2UgMzU2NzU6XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1LmxvY2F0aW9uLCB0cmFuc3Bvc2VkIHx8IGZhbHNlLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7Ly8gZ2wuRkxPQVRfTUFUM1xuICAgICAgICAgICAgY2FzZSAzNTY3NjpcbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtTWF0cml4NGZ2KHUubG9jYXRpb24sIHRyYW5zcG9zZWQgfHwgZmFsc2UsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhazsvLyBnbC5GTE9BVF9NQVQ0XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJVbmtub3duIHVuaWZvcm0gdHlwZSBcIiArIHUuZ2xUeXBlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRVbmlxdWVDb3VudGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjX2NvdW50ZXIgPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNfY291bnRlcisrO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGNoZWNrRXJyb3I6IGZ1bmN0aW9uIChnbCwgdGV4dCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBnbC5nZXRFcnJvcigpO1xuICAgICAgICBpZiAoZXJyb3IgIT09IGdsLk5PX0VSUk9SKSB7XG4gICAgICAgICAgICB2YXIgdGV4dEVyciA9IFwiXCIgKyBlcnJvcjtcbiAgICAgICAgICAgIHN3aXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDEyODA6XG4gICAgICAgICAgICAgICAgICAgIHRleHRFcnIgPSBcIjEyODAgKCBHTF9JTlZBTElEX0VOVU0gKVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyODE6XG4gICAgICAgICAgICAgICAgICAgIHRleHRFcnIgPSBcIjEyODEgKCBHTF9JTlZBTElEX1ZBTFVFIClcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxMjgyOlxuICAgICAgICAgICAgICAgICAgICB0ZXh0RXJyID0gXCIxMjgyICggR0xfSU5WQUxJRF9PUEVSQVRJT04gKVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDEyODM6XG4gICAgICAgICAgICAgICAgICAgIHRleHRFcnIgPSBcIjEyODMgKCBHTF9TVEFDS19PVkVSRkxPVyApXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI4NDpcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVyciA9IFwiMTI4NCAoIEdMX1NUQUNLX1VOREVSRkxPVyApXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMTI4NTpcbiAgICAgICAgICAgICAgICAgICAgdGV4dEVyciA9IFwiMTI4NSAoIEdMX09VVF9PRl9NRU1PUlkgKVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtc2cgPSBcIkdMIGVycm9yIFwiICsgdGV4dEVyciArIFwiIG9jY3VyZWQuXCI7XG4gICAgICAgICAgICBpZiAodGV4dCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIG1zZyArPSBcIiBcIiArIHRleHQ7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy50cmFjZShtc2cpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHN1cHBvcnRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhISh3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0ICYmIChjYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG59O1xuXG4iLCJ2YXIgQWJzdHJhY3RDYW52YXNIYW5kbGVyID0gcmVxdWlyZShcIi4uL3JlbmRlcmVyL2NhbnZhcy1oYW5kbGVyLmpzXCIpO1xudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcbnZhciB4bWwzZEZvcm1hdEhhbmRsZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9mb3JtYXRoYW5kbGVyLmpzXCIpLnhtbDNkRm9ybWF0SGFuZGxlcjtcblxudmFyIE1BWEZQUyA9IDMwO1xuXG52YXIgT1BUSU9OX0NPTlRJTlVPVVMgPSBcInJlbmRlcmVyLWNvbnRpbnVvdXNcIjtcbk9wdGlvbnMucmVnaXN0ZXIoT1BUSU9OX0NPTlRJTlVPVVMsIGZhbHNlKTtcblxuLyoqXG4gKiBHTENhbnZhc0hhbmRsZXIgY2xhc3MuXG4gKiBSZWdpc3RlcnMgYW5kIGhhbmRsZXMgdGhlIGV2ZW50cyB0aGF0IGhhcHBlbiBvbiB0aGUgY2FudmFzIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHhtbDNkRWxlbVxuICogICAgICAgICAgICB0aGUgcm9vdCB4bWwzZCBub2RlLCBjb250YWluaW5nIHRoZSBYTUwzRCBzY2VuZSBzdHJ1Y3R1cmVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgQWJzdHJhY3RDYW52YXNIYW5kbGVyXG4gKi9cbmZ1bmN0aW9uIEdMQ2FudmFzSGFuZGxlcih4bWwzZEVsZW0sIGNhbnZhcykge1xuICAgIEFic3RyYWN0Q2FudmFzSGFuZGxlci5jYWxsKHRoaXMsIHhtbDNkRWxlbSwgY2FudmFzKTtcbiAgICB0aGlzLnJlbmRlckludGVyZmFjZSA9IHt9O1xuXG4gICAgdGhpcy5sYXN0UGlja09iaiA9IG51bGw7XG5cbiAgICB0aGlzLmxhc3RLbm93bkRpbWVuc2lvbnMgPSB7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0fTtcbiAgICB0aGlzLmluaXRpYWxpemUoKTtcbn1cblxuWE1MM0QuY3JlYXRlQ2xhc3MoR0xDYW52YXNIYW5kbGVyLCBBYnN0cmFjdENhbnZhc0hhbmRsZXIpO1xuXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLnNldFJlbmRlcmVyID0gZnVuY3Rpb24gKHJlbmRlcmVyKSB7XG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xufTtcblxuR0xDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgICB0aGlzLmNvbmZpZ3VyZUNhbnZhcygpO1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgYXQgcmVndWxhciBpbnRlcnZhbHMgYnkgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHRvXG4gICAgLy8gZGV0ZXJtaW5lIGlmIGEgcmVkcmF3XG4gICAgLy8gaXMgbmVlZGVkXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoaXMudGljayA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICBpZighdGhhdC5yZW5kZXJlcilcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBYTUwzRC51cGRhdGVYZmxvd09ic2VydmVyKCk7XG4gICAgICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuXG4gICAgICAgIGlmICh0aGF0LmNhbnZhc1NpemVDaGFuZ2VkKCkgfHwgdGhhdC5yZW5kZXJlci5uZWVkc1JlZHJhdygpIHx8IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX0NPTlRJTlVPVVMpKSB7XG4gICAgICAgICAgICB0aGF0LmRpc3BhdGNoVXBkYXRlRXZlbnQoKTtcbiAgICAgICAgICAgIHRoYXQuZHJhdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGF0LnRpY2ssIE1BWEZQUyk7XG4gICAgfTtcblxuICAgICAgLy8gQmxvY2sgdGhlIHJpZ2h0LWNsaWNrIGNvbnRleHQgbWVudSBvbiB0aGUgY2FudmFzIHVubGVzcyBpdCdzIGV4cGxpY2l0bHkgdG9nZ2xlZFxuICAgIHZhciBjbSA9IHRoaXMuX3htbDNkRWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJjb250ZXh0bWVudVwiKTtcbiAgICBpZiAoIWNtIHx8IGNtID09IFwiZmFsc2VcIikge1xuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0ICYmIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uICYmIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG59O1xuXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmNvbmZpZ3VyZUNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgeG1sM2RFbGVtZW50ID0gdGhpcy5feG1sM2RFbGVtZW50O1xuICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cbiAgICB2YXIgcGFyZW50ID0geG1sM2RFbGVtZW50LnBhcmVudE5vZGU7XG4gICAgLy8gUGxhY2UgeG1sM2RFbGVtZW50IGluc2lkZSBhbiBpbnZpc2JsZSBkaXZcbiAgICB2YXIgaGlkZURpdiA9IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIC8vaGlkZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShoaWRlRGl2LCB4bWwzZEVsZW1lbnQpO1xuICAgIGhpZGVEaXYuYXBwZW5kQ2hpbGQoeG1sM2RFbGVtZW50KTtcblxuICAgIC8vIENyZWF0ZSBjYW52YXMgYW5kIGFwcGVuZCBpdCB3aGVyZSB0aGUgeG1sM2QgZWxlbWVudCB3YXMgYmVmb3JlXG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShjYW52YXMsIGhpZGVEaXYpO1xuXG4gICAgdmFyIHN0eWxlID0gY2FudmFzLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh4bWwzZEVsZW1lbnQpO1xuICAgIGlmICghY2FudmFzLnN0eWxlLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICB2YXIgYmdjb2xvciA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoXCJiYWNrZ3JvdW5kLWNvbG9yXCIpO1xuICAgICAgICBpZiAoYmdjb2xvciAmJiBiZ2NvbG9yICE9IFwidHJhbnNwYXJlbnRcIilcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiZ2NvbG9yO1xuICAgIH1cbiAgICAvLyBOZWVkIHRvIGJlIHNldCBmb3IgY29ycmVjdCBjYW52YXMgc2l6ZVxuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcblxuICAgIHJldHVybiBjYW52YXM7XG59O1xuXG4vKipcbiAqIEJpbmRzIHRoZSBwaWNraW5nIGJ1ZmZlciBhbmQgcGFzc2VzIHRoZSByZXF1ZXN0IGZvciBhIHBpY2tpbmcgcGFzcyB0byB0aGVcbiAqIHJlbmRlcmVyXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc1hcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNZXG4gKiBAcmV0dXJuIHtEcmF3YWJsZXxudWxsfSBuZXdseSBwaWNrZWQgb2JqZWN0XG4gKi9cbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuZ2V0UGlja09iamVjdEJ5UG9pbnQgPSBmdW5jdGlvbiAoY2FudmFzWCwgY2FudmFzWSkge1xuICAgIC8vIFRPRE9cbiAgICAvL2lmICghdGhpcy5yZW5kZXJPcHRpb25zLnBpY2tpbmdFbmFibGVkKVxuICAgIC8vICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFJlbmRlck9iamVjdEZyb21QaWNraW5nQnVmZmVyKGNhbnZhc1gsIGNhbnZhc1kpO1xufTtcblxuLyoqXG4gKlxuICogQHJldHVybnMge0hUTUxFbGVtZW50fVxuICovXG5HTENhbnZhc0hhbmRsZXIucHJvdG90eXBlLmdldFBpY2tlZE9iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLnBpY2tlZE9iamVjdCA/IHRoaXMucmVuZGVyZXIucGlja2VkT2JqZWN0Lm5vZGUgOiBudWxsO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzWFxuICogQHBhcmFtIHtudW1iZXJ9IGNhbnZhc1lcbiAqIEByZXR1cm4ge3ZlYzN8bnVsbH0gVGhlIHdvcmxkIHNwYWNlIG5vcm1hbCBvbiB0aGUgb2JqZWN0J3Mgc3VyZmFjZSBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXNcbiAqL1xuR0xDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5nZXRXb3JsZFNwYWNlTm9ybWFsQnlQb2ludCA9IGZ1bmN0aW9uIChjYW52YXNYLCBjYW52YXNZKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0V29ybGRTcGFjZU5vcm1hbEJ5UG9pbnQoY2FudmFzWCwgY2FudmFzWSk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNYXG4gKiBAcGFyYW0ge251bWJlcn0gY2FudmFzWVxuICogQHJldHVybiB7dmVjM3xudWxsfSBUaGUgd29ybGQgc3BhY2UgcG9zaXRpb24gb24gdGhlIG9iamVjdCdzIHN1cmZhY2UgYXQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzXG4gKi9cbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlQb2ludCA9IGZ1bmN0aW9uIChjYW52YXNYLCBjYW52YXNZKSB7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlQb2ludChjYW52YXNYLCBjYW52YXNZKTtcbn07XG5cbkdMQ2FudmFzSGFuZGxlci5wcm90b3R5cGUuY2FudmFzU2l6ZUNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcbiAgICBpZiAoY2FudmFzLmNsaWVudFdpZHRoICE9PSB0aGlzLmxhc3RLbm93bkRpbWVuc2lvbnMud2lkdGggfHwgY2FudmFzLmNsaWVudEhlaWdodCAhPT0gdGhpcy5sYXN0S25vd25EaW1lbnNpb25zLmhlaWdodCkge1xuXG4gICAgICAgIHRoaXMubGFzdEtub3duRGltZW5zaW9ucy53aWR0aCA9IGNhbnZhcy53aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgdGhpcy5sYXN0S25vd25EaW1lbnNpb25zLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0O1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmhhbmRsZVJlc2l6ZUV2ZW50KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hSZXNpemVFdmVudCh7d2lkdGg6IGNhbnZhcy53aWR0aCwgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgY190aW1lciA9IHdpbmRvdy5wZXJmb3JtYW5jZSB8fCBEYXRlO1xuXG4vKipcbiAqIENhbGxlZCBieSB0aWNrKCkgdG8gcmVkcmF3IHRoZSBzY2VuZSBpZiBuZWVkZWRcbiAqL1xuR0xDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xuICAgIFhNTDNELmZsdXNoRE9NQ2hhbmdlcygpO1xuICAgIHRyeSB7XG4gICAgICAgIHZhciBzdGFydCA9IGNfdGltZXIubm93KCk7XG4gICAgICAgIHZhciBzdGF0cyA9IHRoaXMucmVuZGVyZXIucmVuZGVyVG9DYW52YXMoKTtcbiAgICAgICAgdmFyIGVuZCA9IGNfdGltZXIubm93KCk7XG5cblxuICAgICAgICB2YXIgZmFjdG9yeSA9IHhtbDNkRm9ybWF0SGFuZGxlci5nZXRGYWN0b3J5KFwid2ViZ2xcIiwgdGhpcy5pZCk7XG4gICAgICAgIHZhciB4bWwzZEFkYXB0ZXIgPSBmYWN0b3J5LmdldEFkYXB0ZXIodGhpcy5feG1sM2RFbGVtZW50KTtcbiAgICAgICAgeG1sM2RBZGFwdGVyLm9uRnJhbWVEcmF3bigpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRnJhbWVEcmF3bkV2ZW50KHN0YXJ0LCBlbmQsIHN0YXRzKTtcblxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRXhjZXB0aW9uKGUpO1xuICAgIH1cblxufTtcblxuR0xDYW52YXNIYW5kbGVyLnByb3RvdHlwZS5nZXRNb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24gKGV2dCkge1xuICAgIHZhciByY3QgPSB0aGlzLl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogKGV2dC5jbGllbnRYIC0gcmN0LmxlZnQpLCB5OiAoZXZ0LmNsaWVudFkgLSByY3QudG9wKVxuICAgIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9ICBHTENhbnZhc0hhbmRsZXI7XG5cbiIsInZhciBHTFByb2dyYW1PYmplY3QgPSByZXF1aXJlKFwiLi4vYmFzZS9wcm9ncmFtLmpzXCIpO1xudmFyIFhmbG93VXRpbHM9IHJlcXVpcmUoXCIuLi94Zmxvdy91dGlscy5qc1wiKTtcblxuLyoqXG4gKiBBIFNoYWRlckNsb3N1cmUgY29ubmVjdHMgYSBtZXNoLXNwZWNpZmljIEdMUHJvZ3JhbSB3aXRoIGl0J3MgWGZsb3cgZGF0YVxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQWJzdHJhY3RTaGFkZXJDbG9zdXJlID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtHTFByb2dyYW1PYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgLyoqXG4gICAgICogQSBmbGFnIHVzZWQgYnkgc2hhZGVyY29tcG9zZXIgdG8gc29ydCBvdXQgb2Jzb2xldGUgc2hhZGVyY2xvc3VyZXNcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLm9ic29sZXRlID0gZmFsc2U7XG4gICAgdGhpcy5pZCA9IFwiXCI7XG5cbiAgICB0aGlzLnVuaWZvcm1Db2xsZWN0aW9uID0ge1xuICAgICAgICBlbnZCYXNlOiB7fSwgZW52T3ZlcnJpZGU6IG51bGwsIHN5c0Jhc2U6IG51bGxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcmVzLCBpZiB0aGUgdW5kZXJseWluZyBzaGFkZXIgaGFzIHNlbWktdHJhbnNwYXJlbmNpZXNcbiAgICAgKiBhbmQgdGh1cyBuZWVkcyB0byBjb25zaWRlcmVkIGZvciBhbHBoYS1ibGVuZGluZ1xuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNvdXJjZSBvZiBhIHNoYWRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge3t2ZXJ0ZXg6IHN0cmluZywgZnJhZ21lbnQ6IHN0cmluZ319XG4gICAgICovXG4gICAgdGhpcy5zb3VyY2UgPSB7XG4gICAgICAgIHZlcnRleDogXCJcIiwgZnJhZ21lbnQ6IFwiXCJcbiAgICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBYnN0cmFjdFNoYWRlckNsb3N1cmUucHJvdG90eXBlLCB7XG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2dyYW0gPyB0aGlzLnByb2dyYW0uYXR0cmlidXRlcyA6IHt9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHVuaWZvcm1zOiB7XG4gICAgICAgICAgICB3cml0ZWFibGU6IGZhbHNlLCBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9ncmFtID8gdGhpcy5wcm9ncmFtLnVuaWZvcm1zIDoge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgc2FtcGxlcnM6IHtcbiAgICAgICAgICAgIHdyaXRlYWJsZTogZmFsc2UsIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb2dyYW0gPyB0aGlzLnByb2dyYW0uc2FtcGxlcnMgOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5YTUwzRC5jcmVhdGVDbGFzcyhBYnN0cmFjdFNoYWRlckNsb3N1cmUsIG51bGwsIHtcblxuICAgIGVxdWFsczogZnVuY3Rpb24gKHRoYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnZlcnRleCA9PT0gdGhhdC5zb3VyY2UudmVydGV4ICYmIHRoaXMuc291cmNlLmZyYWdtZW50ID09PSB0aGF0LnNvdXJjZS5mcmFnbWVudDtcbiAgICB9LFxuXG4gICAgaGFzVHJhbnNwYXJlbmN5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVHJhbnNwYXJlbnQ7XG4gICAgfSxcblxuICAgIGNvbXBpbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNvdXJjZS5mcmFnbWVudCB8fCAhdGhpcy5zb3VyY2UudmVydGV4KSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIk5vIHNvdXJjZSBmb3VuZCBmb3IgbWF0ZXJpYWxcIiwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJvZ3JhbU9iamVjdCA9IG5ldyBHTFByb2dyYW1PYmplY3QodGhpcy5jb250ZXh0LmdsLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW1PYmplY3Q7XG4gICAgICAgIHRoaXMuaWQgPSBwcm9ncmFtT2JqZWN0LmlkO1xuICAgIH0sXG5cbiAgICBiaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbS5iaW5kKCk7XG4gICAgfSxcblxuICAgIHVuYmluZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByb2dyYW0udW5iaW5kKCk7XG4gICAgfSxcblxuICAgIGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbS5pc1ZhbGlkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WGZsb3cuQ29tcHV0ZVJlc3VsdH0geGZsb3dSZXN1bHRcbiAgICAgKi9cbiAgICB1cGRhdGVVbmlmb3Jtc0Zyb21Db21wdXRlUmVzdWx0OiBmdW5jdGlvbiAoeGZsb3dSZXN1bHQpIHtcbiAgICAgICAgdmFyIG1hcCA9IHhmbG93UmVzdWx0LmdldE91dHB1dE1hcCgpO1xuXG4gICAgICAgIHZhciBlbnZCYXNlID0gdGhpcy51bmlmb3JtQ29sbGVjdGlvbi5lbnZCYXNlID0ge307XG4gICAgICAgIHRoaXMuc2V0RGVmYXVsdFVuaWZvcm1zKHRoaXMudW5pZm9ybUNvbGxlY3Rpb24uZW52QmFzZSk7XG5cbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBtYXApIHtcbiAgICAgICAgICAgIGVudkJhc2VbbmFtZV0gPSBYZmxvd1V0aWxzLmdldEdMVW5pZm9ybVZhbHVlRnJvbVhmbG93RGF0YUVudHJ5KG1hcFtuYW1lXSwgdGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmFtZXMgPSBPYmplY3Qua2V5cyhlbnZCYXNlKTtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtVmFyaWFibGVzKG5hbWVzLCBudWxsLCB0aGlzLnVuaWZvcm1Db2xsZWN0aW9uKTtcblxuICAgICAgICB0aGlzLmlzVHJhbnNwYXJlbnQgPSB0aGlzLmdldFRyYW5zcGFyZW5jeUZyb21JbnB1dERhdGEobWFwKTtcbiAgICB9LFxuXG4gICAgc2V0VW5pZm9ybVZhcmlhYmxlczogZnVuY3Rpb24gKGVudk5hbWVzLCBzeXNOYW1lcywgdW5pZm9ybUNvbGxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtLnNldFVuaWZvcm1WYXJpYWJsZXMoZW52TmFtZXMsIHN5c05hbWVzLCB1bmlmb3JtQ29sbGVjdGlvbik7XG4gICAgfSxcblxuICAgIHNldFN5c3RlbVVuaWZvcm1WYXJpYWJsZXM6IGZ1bmN0aW9uIChzeXNOYW1lcywgc3lzVmFsdWVzKSB7XG4gICAgICAgIHRoaXMudW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZSA9IHN5c1ZhbHVlcztcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtVmFyaWFibGVzKG51bGwsIHN5c05hbWVzLCB0aGlzLnVuaWZvcm1Db2xsZWN0aW9uKTtcbiAgICB9LFxuXG4gICAgY2hhbmdlVW5pZm9ybVZhcmlhYmxlT3ZlcnJpZGU6IGZ1bmN0aW9uIChwcmV2T3ZlcnJpZGUsIG5ld092ZXJyaWRlKSB7XG4gICAgICAgIHZhciBvdmVycmlkZU5hbWVzID0gcHJldk92ZXJyaWRlID8gT2JqZWN0LmtleXMocHJldk92ZXJyaWRlKSA6IFtdO1xuICAgICAgICBpZiAobmV3T3ZlcnJpZGUpIG92ZXJyaWRlTmFtZXMucHVzaC5hcHBseShvdmVycmlkZU5hbWVzLCBPYmplY3Qua2V5cyhuZXdPdmVycmlkZSkpO1xuICAgICAgICB0aGlzLnVuaWZvcm1Db2xsZWN0aW9uLmVudk92ZXJyaWRlID0gbmV3T3ZlcnJpZGU7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybVZhcmlhYmxlcyhvdmVycmlkZU5hbWVzLCBudWxsLCB0aGlzLnVuaWZvcm1Db2xsZWN0aW9uKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFNoYWRlckNsb3N1cmU7XG5cbiIsInZhciBHTFNjZW5lID0gcmVxdWlyZShcIi4uL3NjZW5lL2dsc2NlbmUuanNcIik7XG52YXIgR0xMaWdodHMgPSByZXF1aXJlKFwiLi4vc2NlbmUvZ2xsaWdodHMuanNcIik7XG52YXIgTWF0ZXJpYWxFdmVudHMgPSByZXF1aXJlKFwiLi4vbWF0ZXJpYWxzL2V2ZW50cy5qc1wiKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlcjtcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcbnZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xudmFyIElTaGFkZXJDb21wb3NlciA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbi8qKlxuICogQGVudW1cbiAqL1xuSVNoYWRlckNvbXBvc2VyLlVwZGF0ZVN0YXRlID0ge1xuICAgIFNIQURFUl9VUERBVEVEOiAxLCBTSEFERVJfQ09NUElMRUQ6IDIsIFNIQURFUl9VTkNIQU5HRUQ6IDNcbn07XG5cbklTaGFkZXJDb21wb3Nlci5TdGF0ZSA9IHtcbiAgICBPSzogMSwgTk9fU0NSSVBUOiAyLCBOT19QUk9HUkFNOiAzXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c2NlbmV9IHNjZW5lXG4gKiBAcGFyYW0ge3t9PX0gb3B0XG4gKi9cbklTaGFkZXJDb21wb3Nlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKHNjZW5lLCBvcHQpIHtcbn07XG5cbi8qKlxuICpcbiAqIEByZXR1cm5zIEFic3RyYWN0U2hhZGVyQ2xvc3VyZXxudWxsXG4gKi9cbklTaGFkZXJDb21wb3Nlci5wcm90b3R5cGUuZ2V0U2hhZGVyQ2xvc3VyZSA9IGZ1bmN0aW9uIChzY2VuZSkge1xuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XG4gKi9cbklTaGFkZXJDb21wb3Nlci5wcm90b3R5cGUuZ2V0UmVxdWVzdEZpZWxkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW107XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHt7fX1cbiAqL1xuSVNoYWRlckNvbXBvc2VyLnByb3RvdHlwZS5nZXRTaGFkZXJBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7fTtcbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbiAqL1xudmFyIEFic3RyYWN0U2hhZGVyQ29tcG9zZXIgPSBmdW5jdGlvbiAoY29udGV4dCwgc2hhZGVySW5mbykge1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5zaGFkZXJDbG9zdXJlcyA9IFtdO1xuICAgIHRoaXMuZGF0YUNoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZUxpZ2h0VmFsdWVzID0gZmFsc2U7XG4gICAgdGhpcy5yZXF1ZXN0ID0gbnVsbDtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygwKTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKEFic3RyYWN0U2hhZGVyQ29tcG9zZXIsIEV2ZW50RW1pdHRlciwge1xuXG4gICAgLy8gSW1wbGVtZW50ZWQgYnkgc3ViY2xhc3NcbiAgICBzZXRTaGFkZXJJbmZvOiBudWxsLFxuXG5cbiAgICB1cGRhdGVSZXF1ZXN0OiBmdW5jdGlvbiAoeGZsb3dEYXRhTm9kZSkge1xuICAgICAgICBpZiAodGhpcy5yZXF1ZXN0KSB0aGlzLnJlcXVlc3QuY2xlYXIoKTtcblxuICAgICAgICB0aGlzLnJlcXVlc3QgPSBuZXcgQ29tcHV0ZVJlcXVlc3QoeGZsb3dEYXRhTm9kZSwgdGhpcy5nZXRSZXF1ZXN0RmllbGRzKCksIHRoaXMub25TaGFkZXJSZXF1ZXN0Q2hhbmdlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNldFNoYWRlclJlY29tcGlsZSgpO1xuICAgIH0sXG5cbiAgICBvblNoYWRlckluZm9DaGFuZ2VkOiBmdW5jdGlvbiAoc2hhZGVySW5mbykge1xuICAgICAgICB0aGlzLnNldFNoYWRlckluZm8oc2hhZGVySW5mbyk7XG4gICAgICAgIHRoaXMuc2V0U2hhZGVyUmVjb21waWxlKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KFwiU2hhZGVyIHNjcmlwdCBjaGFuZ2VkXCIpO1xuICAgIH0sXG5cbiAgICBvblNoYWRlclJlcXVlc3RDaGFuZ2U6IGZ1bmN0aW9uIChyZXF1ZXN0LCBjaGFuZ2VUeXBlKSB7XG4gICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSB0cnVlO1xuICAgICAgICBpZiAoY2hhbmdlVHlwZSA9PSBYQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpXG4gICAgICAgICAgICB0aGlzLnNldFNoYWRlclJlY29tcGlsZSgpO1xuICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIlNoYWRlciBkYXRhIGNoYW5nZWRcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gICAgICogQHBhcmFtIHt7fT19IG9wdFxuICAgICAqL1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHNjZW5lLCBvcHQpIHtcbiAgICAgICAgb3B0ID0gb3B0IHx8IHt9O1xuICAgICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgLy8gQ2xlYW4gdXAgc2hhZGVyQ2xvc3VyZXMgdGhhdCBhcmUgbm90IHVzZWQhXG4gICAgICAgIHZhciBpID0gdGhpcy5zaGFkZXJDbG9zdXJlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNoYWRlckNsb3N1cmVzW2ldLm9ic29sZXRlKSB0aGlzLnNoYWRlckNsb3N1cmVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5zaGFkZXJDbG9zdXJlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldFNoYWRlckRhdGFSZXN1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZXMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhhdC51cGRhdGVDbG9zdXJlRnJvbUNvbXB1dGVSZXN1bHQoc2hhZGVyLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy51cGRhdGVMaWdodFZhbHVlcykge1xuICAgICAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFkZXIpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnVwZGF0ZUNsb3N1cmVGcm9tTGlnaHRQYXJhbWV0ZXJzKHNoYWRlciwgc2NlbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtBYnN0cmFjdFNoYWRlckNsb3N1cmV9IHNoYWRlckNsb3N1cmVcbiAgICAgKiBAcGFyYW0ge1hmbG93LkNvbXB1dGVSZXN1bHR9IHJlc3VsdFxuICAgICAqL1xuICAgIHVwZGF0ZUNsb3N1cmVGcm9tQ29tcHV0ZVJlc3VsdDogZnVuY3Rpb24gKHNoYWRlckNsb3N1cmUsIHJlc3VsdCkge1xuICAgICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LmdldE91dHB1dE1hcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNoYWRlckNsb3N1cmUuYmluZCgpO1xuICAgICAgICBzaGFkZXJDbG9zdXJlLnVwZGF0ZVVuaWZvcm1zRnJvbUNvbXB1dGVSZXN1bHQocmVzdWx0KTtcbiAgICB9LFxuXG4gICAgdXBkYXRlQ2xvc3VyZUZyb21MaWdodFBhcmFtZXRlcnM6IGZ1bmN0aW9uIChzaGFkZXJDbG9zdXJlLCBzY2VuZSkge1xuICAgICAgICBzaGFkZXJDbG9zdXJlLmJpbmQoKTtcbiAgICAgICAgc2hhZGVyQ2xvc3VyZS5zZXRTeXN0ZW1Vbmlmb3JtVmFyaWFibGVzKEdMTGlnaHRzLkFMTF9QQVJBTUVURVJTLCBzY2VuZS5zeXN0ZW1Vbmlmb3Jtcyk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVN5c3RlbVVuaWZvcm1zOiBmdW5jdGlvbiAobmFtZXMsIHNjZW5lKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZXMuZm9yRWFjaChmdW5jdGlvbiAoc2hhZGVyKSB7XG4gICAgICAgICAgICBzaGFkZXIuYmluZCgpO1xuICAgICAgICAgICAgc2hhZGVyLnNldFN5c3RlbVVuaWZvcm1WYXJpYWJsZXMobmFtZXMsIHNjZW5lLnN5c3RlbVVuaWZvcm1zKTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuXG4gICAgY3JlYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdENvbXBvc2VyOjpjcmVhdGVTaGFkZXJDbG9zdXJlIG5lZWRzIHRvIGJlIG92ZXJyaWRkZW5cIik7XG4gICAgfSxcblxuICAgIGNyZWF0ZU9iamVjdERhdGFSZXF1ZXN0OiBmdW5jdGlvbiAob2JqZWN0RGF0YU5vZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFic3RyYWN0Q29tcG9zZXI6OmNyZWF0ZU9iamVjdERhdGFSZXF1ZXN0IG5lZWRzIHRvIGJlIG92ZXJyaWRkZW5cIik7XG4gICAgfSxcblxuICAgIGRpc3RyaWJ1dGVPYmplY3RTaGFkZXJEYXRhOiBmdW5jdGlvbiAob2JqZWN0UmVxdWVzdCwgYXR0cmlidXRlQ2FsbGJhY2ssIHVuaWZvcm1DYWxsYmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBYnN0cmFjdENvbXBvc2VyOjpkaXN0cmlidXRlT2JqZWN0U2hhZGVyRGF0YSBuZWVkcyB0byBiZSBvdmVycmlkZGVuXCIpO1xuICAgIH0sXG5cbiAgICBnZXRTaGFkZXJDbG9zdXJlOiBmdW5jdGlvbiAoc2NlbmUsIHZzUmVxdWVzdCkge1xuICAgICAgICB2YXIgc2hhZGVyID0gdGhpcy5jcmVhdGVTaGFkZXJDbG9zdXJlKCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNoYWRlci5jcmVhdGVTb3VyY2VzKHNjZW5lLCB0aGlzLmdldFNoYWRlckRhdGFSZXN1bHQoKSwgdnNSZXF1ZXN0KVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaGFkZXI6IFwiICsgZS5tZXNzYWdlKVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoYWRlckNsb3N1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaGFkZXJDbG9zdXJlc1tpXS5lcXVhbHMoc2hhZGVyKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZXNbaV0ub2Jzb2xldGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXJDbG9zdXJlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVNoYWRlckNsb3N1cmUoc2hhZGVyLCBzY2VuZSk7XG4gICAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfSxcblxuICAgIGluaXRpYWxpemVTaGFkZXJDbG9zdXJlOiBmdW5jdGlvbiAoc2hhZGVyQ2xvc3VyZSwgc2NlbmUpIHtcbiAgICAgICAgc2hhZGVyQ2xvc3VyZS5jb21waWxlKCk7XG5cbiAgICAgICAgc2NlbmUuZW1pdChNYXRlcmlhbEV2ZW50cy5NQVRFUklBTF9JTklUSUFMSVpFRCk7XG4gICAgICAgIHRoaXMudXBkYXRlQ2xvc3VyZUZyb21Db21wdXRlUmVzdWx0KHNoYWRlckNsb3N1cmUsIHRoaXMuZ2V0U2hhZGVyRGF0YVJlc3VsdCgpKTtcbiAgICAgICAgdGhpcy51cGRhdGVDbG9zdXJlRnJvbUxpZ2h0UGFyYW1ldGVycyhzaGFkZXJDbG9zdXJlLCBzY2VuZSk7XG4gICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZXMucHVzaChzaGFkZXJDbG9zdXJlKTtcbiAgICB9LFxuXG4gICAgc2V0U2hhZGVyUmVjb21waWxlOiBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNoYWRlckNsb3N1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmVzW2ldLm9ic29sZXRlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoTWF0ZXJpYWxFdmVudHMuTUFURVJJQUxfU1RSVUNUVVJFX0NIQU5HRUQpO1xuICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy51cGRhdGVMaWdodFZhbHVlcyA9IHRydWU7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQHJldHVybnMge1hmbG93LkNvbXB1dGVSZXN1bHR8bnVsbH1cbiAgICAgKi9cbiAgICBnZXRTaGFkZXJEYXRhUmVzdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QgPyB0aGlzLnJlcXVlc3QuZ2V0UmVzdWx0KCkgOiBudWxsO1xuICAgIH1cblxuXG59KTtcblxuXG4vKipcbiAqIEBpbXBsZW1lbnRzIElTaGFkZXJDb21wb3NlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEZWZhdWx0Q29tcG9zZXIgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoRGVmYXVsdENvbXBvc2VyLCBBYnN0cmFjdFNoYWRlckNvbXBvc2VyLCB7XG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgfSxcblxuICAgIGdldFNoYWRlckNsb3N1cmU6IGZ1bmN0aW9uIChzY2VuZSwgdnNSZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQucHJvZ3JhbUZhY3RvcnkuZ2V0RmFsbGJhY2tQcm9ncmFtKCk7XG4gICAgfSxcblxuICAgIGdldFNoYWRlckF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtjb2xvcjogbnVsbCwgbm9ybWFsOiBudWxsIC8qIGZvciBwaWNraW5nICovfTtcbiAgICB9LFxuXG4gICAgZ2V0UmVxdWVzdEZpZWxkczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW1wiZGlmZnVzZUNvbG9yXCIsIFwidXNlVmVydGV4Q29sb3JcIl07XG4gICAgfSxcblxuICAgIGNyZWF0ZU9iamVjdERhdGFSZXF1ZXN0OiBmdW5jdGlvbiAob2JqZWN0RGF0YU5vZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29tcHV0ZVJlcXVlc3Qob2JqZWN0RGF0YU5vZGUsIFtcInBvc2l0aW9uXCIsIFwiY29sb3JcIiwgXCJub3JtYWxcIiwgXCJkaWZmdXNlQ29sb3JcIiwgXCJ1c2VWZXJ0ZXhDb2xvclwiXSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBkaXN0cmlidXRlT2JqZWN0U2hhZGVyRGF0YTogZnVuY3Rpb24gKG9iamVjdFJlcXVlc3QsIGF0dHJpYnV0ZUNhbGxiYWNrLCB1bmlmb3JtQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9iamVjdFJlcXVlc3QuZ2V0UmVzdWx0KCk7XG5cbiAgICAgICAgdmFyIGRhdGFNYXAgPSByZXN1bHQuZ2V0T3V0cHV0TWFwKCksIHJlcXVlc3RGaWVsZHMgPSB0aGlzLmdldFJlcXVlc3RGaWVsZHMoKTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkYXRhTWFwKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdEZpZWxkcy5pbmRleE9mKG5hbWUpICE9IC0xKVxuICAgICAgICAgICAgICAgIHVuaWZvcm1DYWxsYmFjayhuYW1lLCBkYXRhTWFwW25hbWVdKTsgZWxzZVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUNhbGxiYWNrKG5hbWUsIGRhdGFNYXBbbmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQWJzdHJhY3RTaGFkZXJDb21wb3NlcjogQWJzdHJhY3RTaGFkZXJDb21wb3NlcixcbiAgICBEZWZhdWx0Q29tcG9zZXI6IERlZmF1bHRDb21wb3NlclxufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBNQVRFUklBTF9TVFJVQ1RVUkVfQ0hBTkdFRDogXCJtYXRlcmlhbF9zdHJ1Y3R1cmVfY2hhbmdlZFwiLFxuICAgIE1BVEVSSUFMX0lOSVRJQUxJWkVEOiBcIm1hdGVyaWFsX2luaXRpYWxpemVkXCJcbn07XG4iLCJ2YXIgQWJzdHJhY3RTaGFkZXJDbG9zdXJlID0gcmVxdWlyZShcIi4vLi4vYWJzdHJhY3RzaGFkZXJjbG9zdXJlLmpzXCIpO1xudmFyIEpTU2hhZGVyQ29tcG9zZXIgPSByZXF1aXJlKFwiLi9qc3NoYWRlcmNvbXBvc2VyLmpzXCIpO1xudmFyIFN5c3RlbU5vdGlmaWVyID0gcmVxdWlyZShcIi4uLy4uL3N5c3RlbS9zeXN0ZW0tbm90aWZpZXIuanNcIik7XG52YXIgZ2V0SlNTeXN0ZW1Db25maWd1cmF0aW9uID0gcmVxdWlyZShcIi4vanNzeXN0ZW1jb25maWd1cmF0aW9uLmpzXCIpO1xudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi91dGlscy9vcHRpb25zLmpzXCIpO1xuXG5cbnZhciBjX2pzU2hhZGVyQ2FjaGUgPSB7fTtcblxuXG5mdW5jdGlvbiBjb252ZXJ0RW52TmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIChcIl9lbnZfXCIgKyBuYW1lKS5yZXBsYWNlKC9fKy9nLCBcIl9cIik7XG59XG5cbmZ1bmN0aW9uIGFkZERlZmF1bHRDaGFubmVsaW5nKHZzQ29uZmlnLCBpbnB1dE5hbWUpIHtcbiAgICB2YXIgb3V0cHV0TmFtZSA9IGNvbnZlcnRFbnZOYW1lKGlucHV0TmFtZSk7XG4gICAgdnNDb25maWcuY2hhbm5lbEF0dHJpYnV0ZShpbnB1dE5hbWUsIG91dHB1dE5hbWUsIG51bGwpO1xufVxuXG5cbmZ1bmN0aW9uIGNoYW5uZWxWc0F0dHJpYnV0ZSh2c0NvbmZpZywgaW5wdXROYW1lLCBzcGFjZUluZm8pIHtcbiAgICBpZiAoIXNwYWNlSW5mbyB8fCAhc3BhY2VJbmZvW2lucHV0TmFtZV0pIHtcbiAgICAgICAgYWRkRGVmYXVsdENoYW5uZWxpbmcodnNDb25maWcsIGlucHV0TmFtZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaSA9IHNwYWNlSW5mb1tpbnB1dE5hbWVdLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHNwYWNlSW5mb1tpbnB1dE5hbWVdW2ldO1xuICAgICAgICB2YXIgb3V0cHV0TmFtZSA9IGNvbnZlcnRFbnZOYW1lKGVudHJ5Lm5hbWUpLCBjb2RlID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChlbnRyeS5zcGFjZSkge1xuICAgICAgICAgICAgY2FzZSBTaGFkZS5TUEFDRV9WRUNUT1JfVFlQRVMuT0JKRUNUOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTaGFkZS5TUEFDRV9WRUNUT1JfVFlQRVMuVklFV19QT0lOVDpcbiAgICAgICAgICAgICAgICB2c0NvbmZpZy5hZGRJbnB1dFBhcmFtZXRlcihYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsIFwibW9kZWxWaWV3TWF0cml4XCIsIHRydWUpO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBvdXRwdXROYW1lICsgXCIgPSAoIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoI0l7XCIgKyBpbnB1dE5hbWUgKyBcIn0sIDEuMCkgKS54eXo7XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNoYWRlLlNQQUNFX1ZFQ1RPUl9UWVBFUy5WSUVXX05PUk1BTDpcbiAgICAgICAgICAgICAgICB2c0NvbmZpZy5hZGRJbnB1dFBhcmFtZXRlcihYQy5EQVRBX1RZUEUuRkxPQVQzWDMsIFwibW9kZWxWaWV3TWF0cml4TlwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb2RlID0gb3V0cHV0TmFtZSArIFwiID0gbm9ybWFsaXplKCBtb2RlbFZpZXdNYXRyaXhOICogI0l7XCIgKyBpbnB1dE5hbWUgKyBcIn0gKTtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgU2hhZGUuU1BBQ0VfVkVDVE9SX1RZUEVTLldPUkxEX1BPSU5UOlxuICAgICAgICAgICAgICAgIHZzQ29uZmlnLmFkZElucHV0UGFyYW1ldGVyKFhDLkRBVEFfVFlQRS5GTE9BVDRYNCwgXCJtb2RlbE1hdHJpeFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb2RlID0gb3V0cHV0TmFtZSArIFwiID0gKCBtb2RlbE1hdHJpeCAqIHZlYzQoI0l7XCIgKyBpbnB1dE5hbWUgKyBcIn0sIDEuMCkgKS54eXo7XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFNoYWRlLlNQQUNFX1ZFQ1RPUl9UWVBFUy5XT1JMRF9OT1JNQUw6XG4gICAgICAgICAgICAgICAgdnNDb25maWcuYWRkSW5wdXRQYXJhbWV0ZXIoWEMuREFUQV9UWVBFLkZMT0FUM1gzLCBcIm1vZGVsTWF0cml4TlwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBjb2RlID0gb3V0cHV0TmFtZSArIFwiID0gbm9ybWFsaXplKCBtb2RlbE1hdHJpeE4gKiAjSXtcIiArIGlucHV0TmFtZSArIFwifSApO1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBoYW5kbGUgU3BhY2UgVHlwZTogXCIgKyBlbnRyeS5zcGFjZSk7XG4gICAgICAgIH1cbiAgICAgICAgdnNDb25maWcuY2hhbm5lbEF0dHJpYnV0ZShpbnB1dE5hbWUsIG91dHB1dE5hbWUsIGNvZGUpO1xuICAgIH1cbn1cblxuXG4vKipcbiAqIEBwYXJhbSB7WEMuREFUQV9UWVBFfSB4Zmxvd1R5cGVcbiAqL1xudmFyIGNvbnZlcnRYZmxvdzJTaGFkZVR5cGUgPSBmdW5jdGlvbiAoeGZsb3dUeXBlLCBzb3VyY2UpIHtcbiAgICB2YXIgcmVzdWx0ID0ge31cbiAgICBzd2l0Y2ggKHhmbG93VHlwZSkge1xuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5CT09MOlxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5CT09MRUFOO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLklOVDpcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gU2hhZGUuVFlQRVMuSU5UO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkZMT0FUOlxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5OVU1CRVI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQyOlxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5PQkpFQ1Q7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IFNoYWRlLk9CSkVDVF9LSU5EUy5GTE9BVDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQzOlxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5PQkpFQ1Q7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IFNoYWRlLk9CSkVDVF9LSU5EUy5GTE9BVDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ0OlxuICAgICAgICAgICAgcmVzdWx0LnR5cGUgPSBTaGFkZS5UWVBFUy5PQkpFQ1Q7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IFNoYWRlLk9CSkVDVF9LSU5EUy5GTE9BVDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQzWDM6XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IFNoYWRlLlRZUEVTLk9CSkVDVDtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0gU2hhZGUuT0JKRUNUX0tJTkRTLk1BVFJJWDM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ0WDQ6XG4gICAgICAgICAgICByZXN1bHQudHlwZSA9IFNoYWRlLlRZUEVTLk9CSkVDVDtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0gU2hhZGUuT0JKRUNUX0tJTkRTLk1BVFJJWDQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuVEVYVFVSRTpcbiAgICAgICAgICAgIHJlc3VsdC50eXBlID0gU2hhZGUuVFlQRVMuT0JKRUNUO1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBTaGFkZS5PQkpFQ1RfS0lORFMuVEVYVFVSRTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5VTktOT1dOOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBYZmxvdyBEYXRhVHlwZTogXCIgKyB4Zmxvd1R5cGUpO1xuICAgIH1cbiAgICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIGNvbnRleHRcbiAqIEBwYXJhbSBzb3VyY2VUZW1wbGF0ZVxuICogQHBhcmFtIGRhdGFDYWxsYmFja1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBKU1NoYWRlckNsb3N1cmUgPSBmdW5jdGlvbiAoY29udGV4dCwgc291cmNlVGVtcGxhdGUsIGV4dHJhY3RlZFBhcmFtcykge1xuICAgIEFic3RyYWN0U2hhZGVyQ2xvc3VyZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIHRoaXMuc291cmNlVGVtcGxhdGUgPSBzb3VyY2VUZW1wbGF0ZTtcbiAgICB0aGlzLmV4dHJhY3RlZFBhcmFtcyA9IGV4dHJhY3RlZFBhcmFtcztcbiAgICB0aGlzLnVuaWZvcm1TZXR0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICB0aGlzLnVuaWZvcm1Db252ZXJ0ZXIgPSBbXTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKEpTU2hhZGVyQ2xvc3VyZSwgQWJzdHJhY3RTaGFkZXJDbG9zdXJlLCB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0dMU2NlbmV9IHNjZW5lXG4gICAgICogQHBhcmFtIHtYZmxvdy5Db21wdXRlUmVzdWx0fSBzaGFkZXJSZXN1bHRcbiAgICAgKiBAcGFyYW0gb2JqZWN0RGF0YVxuICAgICAqL1xuICAgIGNyZWF0ZVNvdXJjZXM6IGZ1bmN0aW9uIChzY2VuZSwgc2hhZGVyUmVzdWx0LCB2c1JlcXVlc3QpIHtcblxuICAgICAgICB2YXIgdnNEYXRhUmVzdWx0ID0gdnNSZXF1ZXN0LmdldFJlc3VsdCgpO1xuXG4gICAgICAgIHZhciBzeXN0ZW1QYXJhbWV0ZXJzID0gZ2V0U3lzdGVtUGFyYW1ldGVycyh0aGlzLmNvbnRleHQsIHNjZW5lLnN5c3RlbVVuaWZvcm1zKTtcbiAgICAgICAgdmFyIGVudmlyb25tZW50UGFyYW1ldGVycyA9IHt9O1xuXG5cblxuICAgICAgICB2YXIgc2hhZGVyRW50cmllcyA9IHNoYWRlclJlc3VsdCAmJiBzaGFkZXJSZXN1bHQuZ2V0T3V0cHV0TWFwKCksIHZzU2hhZGVyT3V0cHV0ID0gdnNEYXRhUmVzdWx0ICYmIHZzRGF0YVJlc3VsdC5vdXRwdXROYW1lcztcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXh0cmFjdGVkUGFyYW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1OYW1lID0gdGhpcy5leHRyYWN0ZWRQYXJhbXNbaV07XG4gICAgICAgICAgICBpZiAodnNTaGFkZXJPdXRwdXQgJiYgdnNTaGFkZXJPdXRwdXQuaW5kZXhPZihwYXJhbU5hbWUpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgZW52aXJvbm1lbnRQYXJhbWV0ZXJzW3BhcmFtTmFtZV0gPSBjb252ZXJ0WGZsb3cyU2hhZGVUeXBlKHZzRGF0YVJlc3VsdC5nZXRPdXRwdXRUeXBlKHBhcmFtTmFtZSksIHZzRGF0YVJlc3VsdC5pc091dHB1dFVuaWZvcm0ocGFyYW1OYW1lKSA/IFNoYWRlLlNPVVJDRVMuVU5JRk9STSA6IFNoYWRlLlNPVVJDRVMuVkVSVEVYKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhZGVyRW50cmllcyAmJiBzaGFkZXJFbnRyaWVzW3BhcmFtTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudFBhcmFtZXRlcnNbcGFyYW1OYW1lXSA9IGNvbnZlcnRYZmxvdzJTaGFkZVR5cGUoc2hhZGVyRW50cmllc1twYXJhbU5hbWVdLnR5cGUsIFNoYWRlLlNPVVJDRVMuVU5JRk9STSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dERhdGEgPSB7XG4gICAgICAgICAgICBcInRoaXNcIjogeyBcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiYW55XCIsIFwiaW5mb1wiOiBzeXN0ZW1QYXJhbWV0ZXJzIH0sXG4gICAgICAgICAgICBcImdsb2JhbC5zaGFkZVwiOiBbe1wiZXh0cmFcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJhbnlcIiwgXCJnbG9iYWxcIjogdHJ1ZSwgXCJpbmZvXCI6IGVudmlyb25tZW50UGFyYW1ldGVycyB9fV1cbiAgICAgICAgfTtcblxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIkNPTlRFWFQ6XCIsIGNvbnRleHREYXRhKTtcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnN0YW50czogdHJ1ZSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB0cnVlLFxuICAgICAgICAgICAgc2FuaXRpemU6IHRydWUsXG4gICAgICAgICAgICB0cmFuc2Zvcm1TcGFjZXM6IE9wdGlvbnMuZ2V0VmFsdWUoXCJzaGFkZWpzLXRyYW5zZm9ybVNwYWNlc1wiKSxcbiAgICAgICAgICAgIGV4dHJhY3RVbmlmb3JtRXhwcmVzc2lvbnM6IE9wdGlvbnMuZ2V0VmFsdWUoXCJzaGFkZWpzLWV4dHJhY3RVbmlmb3JtRXhwcmVzc2lvbnNcIilcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbXBpbGVPcHRpb25zID0ge1xuICAgICAgICAgICAgdXNlU3RhdGljOiB0cnVlLCB1bmlmb3JtRXhwcmVzc2lvbnM6IG9wdGlvbnMudW5pZm9ybUV4cHJlc3Npb25zXG4gICAgICAgIH07XG4gICAgICAgIHZhciBpbXBsZW1lbnRhdGlvbiA9IHNjZW5lLmRlZmVycmVkID8gXCJ4bWwzZC1nbHNsLWRlZmVycmVkXCIgOiBcInhtbDNkLWdsc2wtZm9yd2FyZFwiO1xuXG4gICAgICAgIHZhciBqc1NoYWRlcktleSA9IGltcGxlbWVudGF0aW9uICsgXCI7XCIgKyBKU09OLnN0cmluZ2lmeShvcHRpb25zKSArIFwiO1wiICsgSlNPTi5zdHJpbmdpZnkoZW52aXJvbm1lbnRQYXJhbWV0ZXJzKSArIFwiO1wiICsgdGhpcy5zb3VyY2VUZW1wbGF0ZTtcblxuICAgICAgICB2YXIgY2FjaGVFbnRyeTtcbiAgICAgICAgaWYgKCEoY2FjaGVFbnRyeSA9IGNfanNTaGFkZXJDYWNoZVtqc1NoYWRlcktleV0pKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciB3b3JrU2V0ID0gbmV3IFNoYWRlLldvcmtpbmdTZXQoKTtcbiAgICAgICAgICAgICAgICB3b3JrU2V0LnBhcnNlKHRoaXMuc291cmNlVGVtcGxhdGUsIHtsb2M6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB3b3JrU2V0LmFuYWx5emUoY29udGV4dERhdGEsIGltcGxlbWVudGF0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgc3BhY2VJbmZvID0gd29ya1NldC5nZXRQcm9jZXNzaW5nRGF0YSgnc3BhY2VJbmZvJyk7XG4gICAgICAgICAgICAgICAgdmFyIGdsc2xTaGFkZXIgPSB3b3JrU2V0LmNvbXBpbGVGcmFnbWVudFNoYWRlcihjb21waWxlT3B0aW9ucyk7XG5cbiAgICAgICAgICAgICAgICBjYWNoZUVudHJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGdsc2xTaGFkZXIuc291cmNlLCB1bmlmb3JtU2V0dGVyOiBnbHNsU2hhZGVyLnVuaWZvcm1TZXR0ZXIsIHNwYWNlSW5mbzogc3BhY2VJbmZvXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjYWNoZUVudHJ5Lmhhc1RyYW5zcGFyZW50U2hhZGVyQ2xvc3VyZSA9IHdvcmtTZXQuZ2V0UHJvY2Vzc2luZ0RhdGEoXCJpc1RyYW5zcGFyZW50XCIpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3JtU2V0dGVyID0gZ2xzbFNoYWRlci51bmlmb3JtU2V0dGVyO1xuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlID0ge1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudDogZ2xzbFNoYWRlci5zb3VyY2UsIHZlcnRleDogdGhpcy5jcmVhdGVWZXJ0ZXhTaGFkZXIodnNSZXF1ZXN0LCB2c0RhdGFSZXN1bHQsIHNwYWNlSW5mbylcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2NlbmUuZGVmZXJyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVFbnRyeS5zaWduYXR1cmVzID0gd29ya1NldC5nZXRQcm9jZXNzaW5nRGF0YShcImNvbG9yQ2xvc3VyZVNpZ25hdHVyZXNcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChPcHRpb25zLmdldFZhbHVlKFwic2hhZGVqcy1jYWNoZVwiKSlcbiAgICAgICAgICAgICAgICAgICAgY19qc1NoYWRlckNhY2hlW2pzU2hhZGVyS2V5XSA9IGNhY2hlRW50cnk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgU3lzdGVtTm90aWZpZXIuc2VuZEV2ZW50KCdzaGFkZWpzJywge1xuICAgICAgICAgICAgICAgICAgICBzaGFkZWpzVHlwZTogXCJlcnJvclwiLCBldmVudDogZSwgY29kZTogdGhpcy5zb3VyY2VUZW1wbGF0ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiU2hhZGUuanMgQ29tcGlsZSBFcnJvcjpcXG5cIiArIGUubWVzc2FnZSArIFwiXFxuLS0tLS0tLS0tLS0tXFxuXCIgKyBcIlNoYWRlciBTb3VyY2U6XCIgKyBcIlxcbi0tLS0tLS0tLS0tLVxcblwiICsgWE1MM0QuZGVidWcuZm9ybWF0U291cmNlQ29kZSh0aGlzLnNvdXJjZVRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvdXJjZSA9IHtcbiAgICAgICAgICAgIGZyYWdtZW50OiBjYWNoZUVudHJ5LnNvdXJjZSwgdmVydGV4OiB0aGlzLmNyZWF0ZVZlcnRleFNoYWRlcih2c1JlcXVlc3QsIHZzRGF0YVJlc3VsdCwgY2FjaGVFbnRyeS5zcGFjZUluZm8pXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFzVHJhbnNwYXJlbnRTaGFkZXJDbG9zdXJlID0gY2FjaGVFbnRyeS5oYXNUcmFuc3BhcmVudFNoYWRlckNsb3N1cmU7XG5cbiAgICAgICAgdGhpcy51bmlmb3JtU2V0dGVyID0gY2FjaGVFbnRyeS51bmlmb3JtU2V0dGVyO1xuICAgICAgICBpZiAoc2NlbmUuZGVmZXJyZWQpIHtcbiAgICAgICAgICAgIHNjZW5lLmNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMucHVzaC5hcHBseShzY2VuZS5jb2xvckNsb3N1cmVTaWduYXR1cmVzLCBjYWNoZUVudHJ5LnNpZ25hdHVyZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIGVycm9ycy5cbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcodGhpcy5zb3VyY2UudmVydGV4KTtcbiAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcodGhpcy5zb3VyY2UuZnJhZ21lbnQpO1xuXG4gICAgICAgIFN5c3RlbU5vdGlmaWVyLnNlbmRFdmVudCgnc2hhZGVqcycsIHtcbiAgICAgICAgICAgIHNoYWRlanNUeXBlOiBcInN1Y2Nlc3NcIiwgdmVydGV4U2hhZGVyOiB0aGlzLnNvdXJjZS52ZXJ0ZXgsIGZyYWdtZW50U2hhZGVyOiB0aGlzLnNvdXJjZS5mcmFnbWVudFxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gICAgY3JlYXRlVmVydGV4U2hhZGVyOiBmdW5jdGlvbiAodnNSZXF1ZXN0LCB2c0RhdGFSZXN1bHQsIHNwYWNlSW5mbykge1xuICAgICAgICB2YXIgdnNDb25maWcgPSB2c1JlcXVlc3QuZ2V0Q29uZmlnKCk7XG4gICAgICAgIHZhciBuYW1lcyA9IHZzRGF0YVJlc3VsdC5vdXRwdXROYW1lcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY2hhbm5lbFZzQXR0cmlidXRlKHZzQ29uZmlnLCBuYW1lc1tpXSwgc3BhY2VJbmZvKTtcbiAgICAgICAgfVxuICAgICAgICB2c0NvbmZpZy5hZGRJbnB1dFBhcmFtZXRlcihYQy5EQVRBX1RZUEUuRkxPQVQ0WDQsIFwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiLCB0cnVlKTtcbiAgICAgICAgdnNDb25maWcuYWRkQ29kZUZyYWdtZW50KFwiZ2xfUG9zaXRpb24gPSBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICogdmVjNCgjSXtwb3NpdGlvbn0sIDEuMCk7XCIpO1xuICAgICAgICByZXR1cm4gdnNSZXF1ZXN0LmdldFZlcnRleFNoYWRlcigpLmdldEdMU0xDb2RlKCk7XG4gICAgfSxcblxuICAgIHNldFVuaWZvcm1WYXJpYWJsZXM6IGZ1bmN0aW9uIChlbnZOYW1lcywgc3lzTmFtZXMsIGlucHV0Q29sbGVjdGlvbikge1xuICAgICAgICB0aGlzLnVuaWZvcm1TZXR0ZXIoZW52TmFtZXMsIHN5c05hbWVzLCBpbnB1dENvbGxlY3Rpb24sIHRoaXMucHJvZ3JhbS5zZXRVbmlmb3JtVmFyaWFibGUuYmluZCh0aGlzLnByb2dyYW0pKTtcbiAgICB9LFxuXG4gICAgZ2V0VHJhbnNwYXJlbmN5RnJvbUlucHV0RGF0YTogZnVuY3Rpb24gKGRhdGFNYXApIHtcbiAgICAgICAgLy8gVE9ETzogQ29tcHV0ZSBUcmFuc3BhcmVuY3lcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzVHJhbnNwYXJlbnRTaGFkZXJDbG9zdXJlO1xuICAgIH0sXG5cbiAgICAvKiBEZWZhdWx0IHZhbHVlcyBhcmUgY29tcGlsZWQgaW50byBzaGFkZS5qcyAqL1xuICAgIHNldERlZmF1bHRVbmlmb3JtczogZnVuY3Rpb24gKCkge1xuICAgIH1cblxufSk7XG5cbi8qKlxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSB7e319IGdsb2JhbHNcbiAqIEByZXR1cm5zIHt7fX1cbiAqL1xuZnVuY3Rpb24gZ2V0U3lzdGVtUGFyYW1ldGVycyhjb250ZXh0LCBnbG9iYWxzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGdldEpTU3lzdGVtQ29uZmlndXJhdGlvbihjb250ZXh0KTtcblxuICAgIC8vIFVwZGF0ZSBsaWdodCBwYXJhbWV0ZXJzIHdoaWNoIHZhcnkgaW4gdGhlaXIgc2l6ZSBkZXBlbmRpbmcgb24gbnVtYmVyIG9mIGxpZ2h0cyBkZWZpbmVkXG4gICAgW1wicG9pbnRcIiwgXCJkaXJlY3Rpb25hbFwiLCBcInNwb3RcIl0uZm9yRWFjaChmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICB2YXIgb24gPSBtb2RlbCArIFwiTGlnaHRPblwiO1xuICAgICAgICByZXN1bHRbXCJNQVhfXCIgKyBtb2RlbC50b1VwcGVyQ2FzZSgpICsgXCJMSUdIVFNcIl0uc3RhdGljVmFsdWUgPSBnbG9iYWxzW29uXSAmJiBnbG9iYWxzW29uXS5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBnbG9iYWwgaW4gZ2xvYmFscykge1xuICAgICAgICB2YXIgZW50cnkgPSByZXN1bHRbZ2xvYmFsXTtcbiAgICAgICAgaWYoZW50cnkgJiYgZW50cnkuc3RhdGljU2l6ZSkge1xuICAgICAgICAgICAgdmFyIGFMZW5ndGggPSBnbG9iYWxzW2dsb2JhbF0ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGFMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHVwbGVTaXplID0gZ2V0VHVwbGVTaXplKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBlbnRyeS5zdGF0aWNTaXplID0gYUxlbmd0aCAvIHR1cGxlU2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRG8gbm90IGFsbG93IGEgYXJyYXkgb2Ygc2l6ZSAwLCByZW1vdmUgZW50cnkgaW5zdGVhZFxuICAgICAgICAgICAgICAgIC8vIFRPRE8oa3NvbnMpOiBSZW1vdmUgb25jZSB3ZSBjYW4gY2hlY2sgYXJyYXkgc2l6ZSBpbiBzaGFkZS5qc1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbZ2xvYmFsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHt7fX0gZGVzYyBPYmplY3QgdHlwZSBkZXNjcmlwdG9yXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBnZXRUdXBsZVNpemUoZGVzYykge1xuICAgIGlmKGRlc2MudHlwZSA9PSBcImFycmF5XCIpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRzID0gZGVzYy5lbGVtZW50cztcbiAgICAgICAgaWYgKGVsZW1lbnRzLnR5cGUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgc3dpdGNoKGVsZW1lbnRzLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dHVyZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmbG9hdFwiOiByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmxvYXQyXCI6IHJldHVybiAyO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmbG9hdDNcIjogcmV0dXJuIDM7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZsb2F0NFwiOiByZXR1cm4gNDtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWF0cml4NFwiOiByZXR1cm4gMTY7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgKFwiVW5rbm93biBhcnJheSBlbGVtZW50IGtpbmQ6XCIgKyBlbGVtZW50cy5raW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBKU1NoYWRlckNsb3N1cmU7XG5cbiIsInZhciBBYnN0cmFjdFNoYWRlckNvbXBvc2VyID0gcmVxdWlyZShcIi4vLi4vYWJzdHJhY3RzaGFkZXJjb21wb3Nlci5qc1wiKS5BYnN0cmFjdFNoYWRlckNvbXBvc2VyO1xudmFyIEpTU2hhZGVyQ2xvc3VyZSA9IHJlcXVpcmUoXCIuL2pzc2hhZGVyY2xvc3VyZS5qc1wiKTtcbnZhciBWU0NvbmZpZyA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi94Zmxvdy9wcm9jZXNzaW5nL3ZzLWNvbm5lY3QuanNcIikuVlNDb25maWc7XG52YXIgVmVydGV4U2hhZGVyUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5WZXJ0ZXhTaGFkZXJSZXF1ZXN0O1xudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XG4gKiBAcGFyYW0ge01hdGVyaWFsQ29uZmlndXJhdGlvbn0gY29uZmlnXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFNoYWRlckNvbXBvc2VyXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpTU2hhZGVyQ29tcG9zZXIgPSBmdW5jdGlvbiAoY29udGV4dCwgY29uZmlnKSB7XG4gICAgQWJzdHJhY3RTaGFkZXJDb21wb3Nlci5jYWxsKHRoaXMsIGNvbnRleHQsIGNvbmZpZyk7XG5cbiAgICBpZiAoIXdpbmRvdy5TaGFkZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2hhZGUuanMgbGlicmFyeSBub3QgZm91bmRcIik7XG5cbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuXG4gICAgLyoqIEB0eXBlIHN0cmluZyovXG4gICAgdGhpcy5zb3VyY2VUZW1wbGF0ZSA9IGNvbmZpZy5tb2RlbC5zY3JpcHQ7XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmV4dHJhY3RlZFBhcmFtcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7WGZsb3cuQ29tcHV0ZVJlcXVlc3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3QgPSBudWxsO1xuXG4gICAgdGhpcy5zZXRTaGFkZXJJbmZvKGNvbmZpZyk7XG59O1xuXG5KU1NoYWRlckNvbXBvc2VyLmNvbnZlcnRTeXNOYW1lID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKEpTU2hhZGVyQ29tcG9zZXIsIEFic3RyYWN0U2hhZGVyQ29tcG9zZXIsIHtcbiAgICBzZXRTaGFkZXJJbmZvOiBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYXN0ID0gU2hhZGUucGFyc2UodGhpcy5zb3VyY2VUZW1wbGF0ZSwge2xvYzogdHJ1ZX0pO1xuICAgICAgICAgICAgdGhpcy5leHRyYWN0ZWRQYXJhbXMgPSBTaGFkZS5leHRyYWN0UGFyYW1ldGVycyhhc3QsIHtpbXBsZW1lbnRhdGlvbjogXCJ4bWwzZC1nbHNsLWZvcndhcmRcIn0pLnNoYWRlclBhcmFtZXRlcnM7XG4gICAgICAgICAgICAvLyBGSVhNRTogU2hhZGVyLmpzIHNob3VsZCBhbHdheXMgcmVxdWVzdCBwb3NpdGlvbiAoaW4gY2FzZVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBXZSBpZ25vcmUgZXJyb3JzIGhlcmUuIFRoZXkgd2lsbCByZW9jY3VyIHdoZW4gdXBkYXRpbmcgY29ubmVjdGVkIG1lc2ggY2xvc3VyZXNcbiAgICAgICAgICAgIHRoaXMuZXh0cmFjdGVkUGFyYW1zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXh0cmFjdGVkUGFyYW1zLmluZGV4T2YoXCJwb3NpdGlvblwiKSA9PSAtMSkgdGhpcy5leHRyYWN0ZWRQYXJhbXMucHVzaChcInBvc2l0aW9uXCIpO1xuXG4gICAgICAgIC8vIFRoZSBjb21wb3NlciBpcyBpbnRlcmVzdGVkIGluIGNoYW5nZXMgb2YgYWxsIHBvc3NpYmxlIHNoYWRlciBwYXJhbWV0ZXJzIChleHRyYWN0ZWQpXG4gICAgICAgIC8vIHRoZSBpbnN0YW5jZXMgKGNsb3N1cmVzKSB3aWxsIG9ubHkgc2V0IHRob3NlLCB0aGF0IG9jY3VyIGluIHRoZSBpbnN0YW5jZVxuICAgICAgICBpZiAodGhpcy5leHRyYWN0ZWRQYXJhbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJlcXVlc3QoY29uZmlnLmRhdGFOb2RlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRSZXF1ZXN0RmllbGRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RlZFBhcmFtcztcbiAgICB9LFxuXG4gICAgZ2V0U2hhZGVyQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge2NvbG9yOiBudWxsLCBub3JtYWw6IG51bGwsIHRleGNvb3JkOiBudWxsfTtcbiAgICB9LFxuXG4gICAgY3JlYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IEpTU2hhZGVyQ2xvc3VyZSh0aGlzLmNvbnRleHQsIHRoaXMuc291cmNlVGVtcGxhdGUsIHRoaXMuZXh0cmFjdGVkUGFyYW1zKTtcbiAgICB9LFxuXG4gICAgY3JlYXRlT2JqZWN0RGF0YVJlcXVlc3Q6IGZ1bmN0aW9uIChvYmplY3REYXRhTm9kZSwgY2FsbGJhY2spIHtcblxuICAgICAgICB2YXIgdnNDb25maWcgPSBuZXcgVlNDb25maWcoKTtcbiAgICAgICAgdmFyIG5hbWVzID0gdGhpcy5leHRyYWN0ZWRQYXJhbXMuc2xpY2UoKTtcbiAgICAgICAgLy9pZihuYW1lcy5pbmRleE9mKFwicG9zaXRpb25cIikgPT0gLTEpIG5hbWVzLnB1c2goXCJwb3NpdGlvblwiKTtcbiAgICAgICAgdnNDb25maWcuYWRkQXR0cmlidXRlKFhDLkRBVEFfVFlQRS5GTE9BVDMsIFwicG9zaXRpb25cIiwgdHJ1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcInBvc2l0aW9uXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIHhmbG93SW5mbyA9IG9iamVjdERhdGFOb2RlLmdldE91dHB1dENoYW5uZWxJbmZvKG5hbWUpO1xuICAgICAgICAgICAgaWYgKHhmbG93SW5mbykge1xuICAgICAgICAgICAgICAgIHZzQ29uZmlnLmFkZEF0dHJpYnV0ZSh4Zmxvd0luZm8udHlwZSwgbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBWZXJ0ZXhTaGFkZXJSZXF1ZXN0KG9iamVjdERhdGFOb2RlLCB2c0NvbmZpZywgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBkaXN0cmlidXRlT2JqZWN0U2hhZGVyRGF0YTogZnVuY3Rpb24gKG9iamVjdFJlcXVlc3QsIGF0dHJpYnV0ZUNhbGxiYWNrLCB1bmlmb3JtQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IG9iamVjdFJlcXVlc3QuZ2V0VmVydGV4U2hhZGVyKCk7XG4gICAgICAgIHZhciBpbnB1dE5hbWVzID0gdmVydGV4U2hhZGVyLmlucHV0TmFtZXM7XG4gICAgICAgIHZhciBpLCBuYW1lLCBlbnRyeTtcblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmFtZSA9IGlucHV0TmFtZXNbaV07XG4gICAgICAgICAgICBlbnRyeSA9IHZlcnRleFNoYWRlci5nZXRJbnB1dERhdGEobmFtZSk7XG4gICAgICAgICAgICBpZiAodmVydGV4U2hhZGVyLmlzSW5wdXRVbmlmb3JtKG5hbWUpKVxuICAgICAgICAgICAgICAgIHVuaWZvcm1DYWxsYmFjayhuYW1lLCBlbnRyeSk7IGVsc2VcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVDYWxsYmFjayhuYW1lLCBlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dE5hbWVzID0gdmVydGV4U2hhZGVyLm91dHB1dE5hbWVzO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb3V0cHV0TmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG5hbWUgPSBvdXRwdXROYW1lc1tpXTtcbiAgICAgICAgICAgIGlmICh2ZXJ0ZXhTaGFkZXIuaXNPdXRwdXRGcmFnbWVudFVuaWZvcm0obmFtZSkpIHtcbiAgICAgICAgICAgICAgICB1bmlmb3JtQ2FsbGJhY2sodmVydGV4U2hhZGVyLmdldE91dHB1dFNvdXJjZU5hbWUobmFtZSksIHZlcnRleFNoYWRlci5nZXRVbmlmb3JtT3V0cHV0RGF0YShuYW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSlNTaGFkZXJDb21wb3NlcjtcblxuXG4iLCJ2YXIgR0xDb250ZXh0ID0gcmVxdWlyZShcIi4uLy4uL2Jhc2UvY29udGV4dC5qc1wiKTtcbnZhciBzaW5nbGV0b24gPSBudWxsO1xuXG52YXIgU1lTVEVNX0NPTlRFWFRfVEVNUExBVEUgPSAge1xuICAgICAgICBcImNvb3Jkc1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXG4gICAgICAgIFwiY2FtZXJhUG9zaXRpb25cIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxuICAgICAgICBcInZpZXdNYXRyaXhcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCIsIFwic291cmNlXCI6IFwidW5pZm9ybVwifSxcbiAgICAgICAgXCJ2aWV3SW52ZXJzZU1hdHJpeFwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDRcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxuICAgICAgICBcIm1vZGVsTWF0cml4XCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4NFwiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXG4gICAgICAgIFwibW9kZWxWaWV3TWF0cml4XCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4NFwiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXG4gICAgICAgIFwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDRcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxuICAgICAgICBcIm1vZGVsTWF0cml4TlwiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDNcIiwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxuICAgICAgICBcIm1vZGVsVmlld01hdHJpeE5cIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXgzXCIsIFwic291cmNlXCI6IFwidW5pZm9ybVwifSxcblxuICAgICAgICBcIk1BWF9QT0lOVExJR0hUU1wiOiB7XCJ0eXBlXCI6IFwiaW50XCIsIFwic291cmNlXCI6IFwiY29uc3RhbnRcIiwgXCJzdGF0aWNWYWx1ZVwiOiA1fSxcbiAgICAgICAgXCJwb2ludExpZ2h0T25cIjoge1widHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcImJvb2xlYW5cIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXG4gICAgICAgIFwicG9pbnRMaWdodEF0dGVudWF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxuICAgICAgICB9LFxuICAgICAgICBcInBvaW50TGlnaHRJbnRlbnNpdHlcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicG9pbnRMaWdodFBvc2l0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxuICAgICAgICB9LFxuICAgICAgICBcInBvaW50TGlnaHRDYXN0U2hhZG93XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcImJvb2xlYW5cIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxuICAgICAgICB9LFxuICAgICAgICBcInBvaW50TGlnaHRTaGFkb3dCaWFzXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm51bWJlclwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicG9pbnRMaWdodFNoYWRvd01hcFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwidGV4dHVyZVwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicG9pbnRMaWdodE1hdHJpeFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgICAgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcIm1hdHJpeDRcIn0sXG4gICAgICAgICAgICBcInN0YXRpY1NpemVcIjogNSxcbiAgICAgICAgICAgIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwicG9pbnRMaWdodFByb2plY3Rpb25cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJtYXRyaXg0XCJ9LFxuICAgICAgICAgICAgXCJzdGF0aWNTaXplXCI6IDUsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxuICAgICAgICB9LFxuICAgICAgICBcInBvaW50TGlnaHROZWFyRmFyXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiZmxvYXQyXCJ9LFxuICAgICAgICAgICAgXCJzdGF0aWNTaXplXCI6IDUsXG4gICAgICAgICAgICBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxuICAgICAgICB9LFxuXG4gICAgICAgIFwiTUFYX0RJUkVDVElPTkFMTElHSFRTXCI6IHtcInR5cGVcIjogXCJpbnRcIiwgXCJzb3VyY2VcIjogXCJjb25zdGFudFwiLCBcInN0YXRpY1ZhbHVlXCI6IDV9LFxuICAgICAgICBcImRpcmVjdGlvbmFsTGlnaHRPblwiOiB7XCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwiYm9vbGVhblwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwifSxcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxuICAgICAgICB9LFxuICAgICAgICBcImRpcmVjdGlvbmFsTGlnaHREaXJlY3Rpb25cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodENhc3RTaGFkb3dcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwiYm9vbGVhblwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwiZGlyZWN0aW9uYWxMaWdodFNoYWRvd0JpYXNcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwibnVtYmVyXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0U2hhZG93TWFwXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJ0ZXh0dXJlXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJkaXJlY3Rpb25hbExpZ2h0TWF0cml4XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4NFwifSxcbiAgICAgICAgICAgIFwic3RhdGljU2l6ZVwiOiA1LFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcbiAgICAgICAgfSxcblxuICAgICAgICBcIk1BWF9TUE9UTElHSFRTXCI6IHtcInR5cGVcIjogXCJpbnRcIiwgXCJzb3VyY2VcIjogXCJjb25zdGFudFwiLCBcInN0YXRpY1ZhbHVlXCI6IDV9LFxuICAgICAgICBcInNwb3RMaWdodE9uXCI6IHtcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJib29sZWFuXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJ9LFxuICAgICAgICBcInNwb3RMaWdodEF0dGVudWF0aW9uXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJmbG9hdDNcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxuICAgICAgICB9LFxuICAgICAgICBcInNwb3RMaWdodEludGVuc2l0eVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiZmxvYXQzXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzcG90TGlnaHRQb3NpdGlvblwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwiZmxvYXQzXCJ9LCBcInN0YXRpY1NpemVcIjogNSwgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzcG90TGlnaHREaXJlY3Rpb25cIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwib2JqZWN0XCIsIFwia2luZFwiOiBcImZsb2F0M1wifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlXCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsIFwiZWxlbWVudHNcIjoge1widHlwZVwiOiBcIm51bWJlclwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0Q29zU29mdEZhbGxvZmZBbmdsZVwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxuICAgICAgICB9LFxuICAgICAgICBcInNwb3RMaWdodENhc3RTaGFkb3dcIjoge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIiwgXCJlbGVtZW50c1wiOiB7XCJ0eXBlXCI6IFwiYm9vbGVhblwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0U2hhZG93Qmlhc1wiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJudW1iZXJcIn0sIFwic3RhdGljU2l6ZVwiOiA1LCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIlxuICAgICAgICB9LFxuICAgICAgICBcInNwb3RMaWdodFNoYWRvd01hcFwiOiB7XG4gICAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLCBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwidGV4dHVyZVwifSwgXCJzdGF0aWNTaXplXCI6IDUsIFwic291cmNlXCI6IFwidW5pZm9ybVwiXG4gICAgICAgIH0sXG4gICAgICAgIFwic3BvdExpZ2h0TWF0cml4XCI6IHtcbiAgICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgICBcImVsZW1lbnRzXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwibWF0cml4NFwifSxcbiAgICAgICAgICAgIFwic3RhdGljU2l6ZVwiOiA1LFxuICAgICAgICAgICAgXCJzb3VyY2VcIjogXCJ1bmlmb3JtXCJcbiAgICAgICAgfSxcbiAgICAgICAgXCJzc2FvTWFwXCI6IHtcInR5cGVcIjogXCJvYmplY3RcIiwgXCJraW5kXCI6IFwidGV4dHVyZVwiLCBcInNvdXJjZVwiOiBcInVuaWZvcm1cIn0sXG4gICAgICAgIFwiZW52aXJvbm1lbnRcIjoge1widHlwZVwiOiBcIm9iamVjdFwiLCBcImtpbmRcIjogXCJ0ZXh0dXJlXCIsIFwic291cmNlXCI6IFwidW5pZm9ybVwifVxufTtcblxuZnVuY3Rpb24gY3JlYXRlU3lzdGVtQ29uZmlndXJhdGlvbihjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFNZU1RFTV9DT05URVhUX1RFTVBMQVRFO1xuICAgIHZhciBleHQgPSBjb250ZXh0LmdldEV4dGVuc2lvbkJ5TmFtZShHTENvbnRleHQuRVhURU5TSU9OUy5TVEFOREFSRF9ERVJJVkFURVMpO1xuICAgIGlmIChleHQpIHtcbiAgICAgICAgcmVzdWx0LmZ3aWR0aCA9IHt0eXBlOiBTaGFkZS5UWVBFUy5GVU5DVElPTn07XG4gICAgICAgIHJlc3VsdC5keCA9IHt0eXBlOiBTaGFkZS5UWVBFUy5GVU5DVElPTn07XG4gICAgICAgIHJlc3VsdC5keSA9IHt0eXBlOiBTaGFkZS5UWVBFUy5GVU5DVElPTn07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIGlmICghc2luZ2xldG9uKSB7XG4gICAgICAgIHNpbmdsZXRvbiA9IGNyZWF0ZVN5c3RlbUNvbmZpZ3VyYXRpb24oY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBzaW5nbGV0b247XG59O1xuXG5cblxuIiwidmFyIEpTU2hhZGVyQ29tcG9zZXIgPSByZXF1aXJlKFwiLi9qcy9qc3NoYWRlcmNvbXBvc2VyLmpzXCIpO1xudmFyIFVSTlNoYWRlckNvbXBvc2VyID0gcmVxdWlyZShcIi4vdXJuL3VybnNoYWRlcmNvbXBvc2VyLmpzXCIpO1xudmFyIERlZmF1bHRDb21wb3NlciA9IHJlcXVpcmUoXCIuL2Fic3RyYWN0c2hhZGVyY29tcG9zZXIuanNcIikuRGVmYXVsdENvbXBvc2VyO1xuXG4vKipcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNoYWRlckNvbXBvc2VyRmFjdG9yeSA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAvKiogQHR5cGUge09iamVjdC48bnVtYmVyLCBJU2hhZGVyQ29tcG9zZXI+fSAqL1xuICAgIHRoaXMuY29tcG9zZXJzID0ge307XG4gICAgdGhpcy5kZWZhdWx0Q29tcG9zZXIgPSBuZXcgRGVmYXVsdENvbXBvc2VyKGNvbnRleHQpO1xuICAgIHRoaXMubGlnaHRWYWx1ZXNEaXJ0eSA9IHRydWU7XG59O1xuXG5cblhNTDNELmV4dGVuZChTaGFkZXJDb21wb3NlckZhY3RvcnkucHJvdG90eXBlLCB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01hdGVyaWFsQ29uZmlndXJhdGlvbn0gbWF0ZXJpYWxDb25maWd1cmF0aW9uXG4gICAgICogQHJldHVybnMge0lTaGFkZXJDb21wb3Nlcn1cbiAgICAgKi9cbiAgICBjcmVhdGVDb21wb3NlckZyb21NYXRlcmlhbENvbmZpZ3VyYXRpb246IGZ1bmN0aW9uIChtYXRlcmlhbENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgaWYgKCFtYXRlcmlhbENvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRDb21wb3NlcjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb21wb3NlcnNbbWF0ZXJpYWxDb25maWd1cmF0aW9uLmlkXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsVHlwZSA9IG1hdGVyaWFsQ29uZmlndXJhdGlvbi5tb2RlbC50eXBlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobW9kZWxUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ1cm5cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBVUk5TaGFkZXJDb21wb3Nlcih0aGlzLmNvbnRleHQsIG1hdGVyaWFsQ29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInRleHQvamF2YXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC9zaGFkZS1qYXZhc2NyaXB0XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgSlNTaGFkZXJDb21wb3Nlcih0aGlzLmNvbnRleHQsIG1hdGVyaWFsQ29uZmlndXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiQ2FuIG5vdCBjcmVhdGUgc2hhZGVyIG9mIHR5cGU6XCIsIG1vZGVsVHlwZSwgbWF0ZXJpYWxDb25maWd1cmF0aW9uLm1vZGVsKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiTm8gc2hhZGVyIGNvdWxkIGJlIGNyZWF0ZWQgZm9yICdcIiArIG1hdGVyaWFsQ29uZmlndXJhdGlvbi5uYW1lICsgXCInOlwiLCBlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuZGVmYXVsdENvbXBvc2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcG9zZXJzW21hdGVyaWFsQ29uZmlndXJhdGlvbi5pZF0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LmdldFN0YXRpc3RpY3MoKS5tYXRlcmlhbHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQgfHwgdGhpcy5kZWZhdWx0Q29tcG9zZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0VGVtcGxhdGVCeUlkOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zZXJzW2lkXTtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiB0aGlzLmNvbXBvc2Vycykge1xuICAgICAgICAgICAgdGhpcy5jb21wb3NlcnNbaV0udXBkYXRlKHNjZW5lLCB7dXBkYXRlTGlnaHRWYWx1ZXM6IHRoaXMubGlnaHRWYWx1ZXNEaXJ0eX0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGlnaHRWYWx1ZXNEaXJ0eSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBzZXRMaWdodFN0cnVjdHVyZURpcnR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2V0U2hhZGVyUmVjb21waWxlKCk7XG4gICAgfSxcblxuICAgIHNldFNoYWRlclJlY29tcGlsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuY29tcG9zZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2Vyc1tpXS5zZXRTaGFkZXJSZWNvbXBpbGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVTeXN0ZW1Vbmlmb3JtczogZnVuY3Rpb24gKG5hbWVzLCBzY2VuZSkge1xuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMuY29tcG9zZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvc2Vyc1tpXS51cGRhdGVTeXN0ZW1Vbmlmb3JtcyhuYW1lcywgc2NlbmUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldExpZ2h0VmFsdWVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5jb21wb3NlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9zZXJzW2ldLnVwZGF0ZUxpZ2h0VmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyQ29tcG9zZXJGYWN0b3J5O1xuXG5cbiIsInZhciBFVkVOVF9UWVBFID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3NjZW5lL2NvbnN0YW50cy5qc1wiKS5FVkVOVF9UWVBFO1xudmFyIFRhcmdldHMgPSByZXF1aXJlKFwiLi4vYmFzZS9yZW5kZXJ0YXJnZXRcIik7XG5cbnZhciBMaWdodFBhc3MgPSByZXF1aXJlKFwiLi4vcmVuZGVyLXBhc3Nlcy9saWdodC1wYXNzXCIpO1xudmFyIFBvaW50TGlnaHRQYXNzID0gcmVxdWlyZShcIi4uL3JlbmRlci1wYXNzZXMvcG9pbnRsaWdodC1wYXNzXCIpO1xuXG4vKipcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XG4gKiBAcGFyYW0ge0dMU2NlbmV9IHNjZW5lXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNoYWRvd01hcFNlcnZpY2UgPSBmdW5jdGlvbiAoY29udGV4dCwgc2NlbmUpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHNjZW5lLm9uKEVWRU5UX1RZUEUuTElHSFRfU1RSVUNUVVJFX0NIQU5HRUQsIHRoaXMub25MaWdodFN0cnVjdHVyZUNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgc2NlbmUub24oRVZFTlRfVFlQRS5MSUdIVF9WQUxVRV9DSEFOR0VELCB0aGlzLm9uTGlnaHRWYWx1ZUNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgc2NlbmUub24oRVZFTlRfVFlQRS5TQ0VORV9TSEFQRV9DSEFOR0VELCB0aGlzLm9uU2NlbmVTaGFwZUNoYW5nZWQuYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLnNoYWRvd01hcEluZm9zID0gW107XG4gICAgdGhpcy5kaXJ0eSA9IHRydWU7XG59O1xuXG5YTUwzRC5leHRlbmQoU2hhZG93TWFwU2VydmljZS5wcm90b3R5cGUsIHtcbiAgICBvbkxpZ2h0U3RydWN0dXJlQ2hhbmdlZDogZnVuY3Rpb24gKGxpZ2h0LCByZW1vdmVkKSB7XG4gICAgICAgIHZhciBzaGFkb3dNYXBJbmZvcyA9IHRoaXMuc2hhZG93TWFwSW5mb3M7XG4gICAgICAgIGlmIChyZW1vdmVkKSB7XG4gICAgICAgICAgICByZW1vdmVMaWdodChzaGFkb3dNYXBJbmZvcywgbGlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxpZ2h0TmVlZHNTaGFkb3dNYXAobGlnaHQpKSB7XG4gICAgICAgICAgICAgICAgYWRkTGlnaHQoc2hhZG93TWFwSW5mb3MsIGxpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcXVlc3RSZW5kZXJpbmcoXCJsaWdodCBhZGRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkxpZ2h0VmFsdWVDaGFuZ2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcmluZyhcImxpZ2h0IHZhbHVlIGNoYW5nZWRcIik7XG4gICAgfSxcblxuICAgIG9uU2NlbmVTaGFwZUNoYW5nZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UmVuZGVyaW5nKFwic2NlbmUgc2hhcGUgY2hhbmdlZFwiKTtcbiAgICB9LFxuXG4gICAgcmVxdWVzdFJlbmRlcmluZzogZnVuY3Rpb24oLypyZWFzb24qLykge1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgdXBkYXRlRm9yUmVuZGVyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdmFyIHNoYWRvd01hcHMgPSB0aGlzLnNoYWRvd01hcEluZm9zO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaGFkb3dNYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2hhZG93TWFwc1tpXS5wYXNzLnJlbmRlclNjZW5lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmlsbEdsb2JhbFBhcmFtZXRlcnM6IGZ1bmN0aW9uKGdsb2JhbHMpIHtcbiAgICAgICAgdmFyIHNoYWRvd1VuaXRzID0gbWVyZ2VTaGFkb3dQYXJhbWV0ZXJzKHRoaXMuc2hhZG93TWFwSW5mb3MpO1xuICAgICAgICBYTUwzRC5leHRlbmQoZ2xvYmFscywgc2hhZG93VW5pdHMpO1xuICAgIH1cblxufSk7XG5cbmZ1bmN0aW9uIGxpZ2h0TmVlZHNTaGFkb3dNYXAobGlnaHQpIHtcbiAgICByZXR1cm4gISFsaWdodC5tb2RlbC5nZXRQYXJhbWV0ZXIoXCJjYXN0U2hhZG93XCIpWzBdO1xufVxuXG5mdW5jdGlvbiBhZGRMaWdodChzaGFkb3dNYXBJbmZvcywgbGlnaHQpIHtcbiAgICB2YXIgY29udGV4dCA9IGxpZ2h0LnNjZW5lLmNvbnRleHQ7XG4gICAgdmFyIHBhc3NJbmZvID0gY3JlYXRlUGFzc0luZm8obGlnaHQsIGNvbnRleHQpO1xuICAgIHNoYWRvd01hcEluZm9zLnB1c2gocGFzc0luZm8pO1xufVxuXG5cbmZ1bmN0aW9uIHJlbW92ZUxpZ2h0KHNoYWRvd01hcEluZm9zLCBsaWdodCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhZG93TWFwSW5mb3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHNoYWRvd01hcEluZm9zW2ldLmxpZ2h0ID09PSBsaWdodCkge1xuICAgICAgICAgICAgc2hhZG93TWFwSW5mb3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIC8vIFRPRE86IEZyZWUgcGFzcyBhbmQgb3RoZXIgcmVzb3VyY2VzLCBmcmVlIHRleHR1cmUgc2xvdFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXNzSW5mbyhsaWdodCwgY29udGV4dCkge1xuICAgIHZhciBzaXplID0gTWF0aC5tYXgoY29udGV4dC5jYW52YXNUYXJnZXQud2lkdGgsIGNvbnRleHQuY2FudmFzVGFyZ2V0LmhlaWdodCkgKiAyO1xuICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgIGNvbG9yRm9ybWF0OiBjb250ZXh0LmdsLlJHQkEsXG4gICAgICAgIGRlcHRoRm9ybWF0OiBjb250ZXh0LmdsLkRFUFRIX0NPTVBPTkVOVDE2LFxuICAgICAgICBzdGVuY2lsRm9ybWF0OiBudWxsLFxuICAgICAgICBkZXB0aEFzUmVuZGVyYnVmZmVyOiB0cnVlXG4gICAgfTtcblxuICAgIHZhciBwYXNzID0gbGlnaHQubW9kZWwuaWQgPT0gXCJwb2ludFwiID8gY3JlYXRlUG9pbnRMaWdodFBhc3MobGlnaHQsIGNvbnRleHQsIHBhcmFtcykgOiBjcmVhdGVMaWdodFBhc3MobGlnaHQsIGNvbnRleHQsIHBhcmFtcyk7XG4gICAgcGFzcy5pbml0KGNvbnRleHQpO1xuXG4gICAgLy8gQmluZCB0YXJnZXQgaW4gb3JkZXIgdG8gY3JlYXRlIHRleHR1cmUgbWFwXG4gICAgcGFzcy5vdXRwdXQuYmluZCgpO1xuXG4gICAgLy8gVE9ETzogQmV0dGVyIHdheSB0byBmaXggdGhlIHRleHR1cmUgdW5pdD9cbiAgICB2YXIgdW5pdEVudHJ5ID0gY29udGV4dC50ZXh0dXJlTWFuYWdlci5nZXRFbnRyeShwYXNzLm91dHB1dC5jb2xvclRhcmdldC5oYW5kbGUuaWQpO1xuICAgIHVuaXRFbnRyeS5maXhlZCA9IHRydWU7XG5cbiAgICBwYXNzLm91dHB1dC51bmJpbmQoKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpZ2h0OiBsaWdodCwgcGFzczogcGFzcywgc2xvdDogdW5pdEVudHJ5LnNsb3RcbiAgICB9O1xufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUxpZ2h0UGFzcyhsaWdodCwgY29udGV4dCwgcGFyYW1zKSB7XG4gICAgdmFyIGxpZ2h0RnJhbWVidWZmZXIgPSBuZXcgVGFyZ2V0cy5HTFJlbmRlclRhcmdldChjb250ZXh0LCBwYXJhbXMpO1xuICAgIHJldHVybiBuZXcgTGlnaHRQYXNzKHtjb250ZXh0OiBjb250ZXh0fSwgbGlnaHRGcmFtZWJ1ZmZlciwgbGlnaHQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQb2ludExpZ2h0UGFzcyhsaWdodCwgY29udGV4dCwgcGFyYW1zKSB7XG4gICAgdmFyIGxpZ2h0RnJhbWVidWZmZXIgPSBuZXcgVGFyZ2V0cy5HTEN1YmVNYXBSZW5kZXJUYXJnZXQoY29udGV4dCwgcGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFBvaW50TGlnaHRQYXNzKHtjb250ZXh0OiBjb250ZXh0fSwgbGlnaHRGcmFtZWJ1ZmZlciwgbGlnaHQpO1xufVxuXG5mdW5jdGlvbiBtZXJnZVNoYWRvd1BhcmFtZXRlcnMoc2hhZG93TWFwSW5mb3MpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgW1wic3BvdFwiLCBcInBvaW50XCIsIFwiZGlyZWN0aW9uYWxcIl0uZm9yRWFjaChmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICB2YXIgc2FtZU1vZGVsID0gc2hhZG93TWFwSW5mb3MuZmlsdGVyKGZ1bmN0aW9uKGluZm8pIHsgcmV0dXJuIGluZm8ubGlnaHQubW9kZWwuaWQgPT0gbW9kZWw7IH0pO1xuICAgICAgICByZXN1bHRbbW9kZWwgKyBcIkxpZ2h0U2hhZG93TWFwXCJdID0gc2FtZU1vZGVsLm1hcChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIGluZm8uc2xvdDtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBTaGFkb3dNYXBTZXJ2aWNlO1xuIiwiXG5cblhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcImRlZmF1bHRcIiwge1xuXG5cdHZlcnRleDogXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMyBub3JtYWw7XFxuYXR0cmlidXRlIHZlYzMgdGFuZ2VudDtcXG5hdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDtcXG5hdHRyaWJ1dGUgdmVjMyBjb2xvcjtcXG5cXG52YXJ5aW5nIHZlYzMgZnJhZ1dvcmxkUG9zaXRpb247XFxudmFyeWluZyB2ZWMzIGZyYWdQb3NpdGlvbjtcXG52YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcXG52YXJ5aW5nIHZlYzMgZnJhZ1RhbmdlbnQ7XFxudmFyeWluZyB2ZWMzIGZyYWdCaXRhbmdlbnQ7XFxudmFyeWluZyB2ZWMzIGZyYWdDb2xvcjtcXG52YXJ5aW5nIHZlYzIgZnJhZ1RleGNvb3JkO1xcblxcbnVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcXG51bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcXG51bmlmb3JtIG1hdDMgbW9kZWxWaWV3TWF0cml4TjtcXG51bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAgIHZlYzMgTjtcXG4gICAgdmVjMyBUO1xcbiAgICB2ZWMzIEI7XFxuICAgICNpZiBIQVNfTk9STUFMXFxuICAgICAgICBmcmFnTm9ybWFsID0gbW9kZWxWaWV3TWF0cml4TiAqIG5vcm1hbDtcXG4gICAgI2VuZGlmXFxuICAgICNpZiBIQVNfVEFOR0VOVFxcbiAgICAgICAgZnJhZ1RhbmdlbnQgPSBtb2RlbFZpZXdNYXRyaXhOICogdGFuZ2VudDtcXG4gICAgICAgIGZyYWdCaXRhbmdlbnQgPSBtb2RlbFZpZXdNYXRyaXhOICogbm9ybWFsaXplKGNyb3NzKG5vcm1hbCwgdGFuZ2VudCkpO1xcbiAgICAjZW5kaWZcXG5cXG4gICAgZnJhZ1dvcmxkUG9zaXRpb24gPSAobW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XFxuICAgIGZyYWdQb3NpdGlvbiA9ICh2aWV3TWF0cml4ICogdmVjNChmcmFnV29ybGRQb3NpdGlvbiwgMS4wKSkueHl6O1xcbiAgICBmcmFnVGV4Y29vcmQgPSB0ZXhjb29yZDtcXG4gICAgZnJhZ0NvbG9yID0gY29sb3I7XFxuXFxuICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZlYzQoZnJhZ1Bvc2l0aW9uLCAxLjApO1xcbn1cIixcblx0ZnJhZ21lbnQ6IFwidmFyeWluZyB2ZWMzIGZyYWdXb3JsZFBvc2l0aW9uO1xcbnZhcnlpbmcgdmVjMyBmcmFnUG9zaXRpb247XFxudmFyeWluZyB2ZWMzIGZyYWdOb3JtYWw7XFxudmFyeWluZyB2ZWMzIGZyYWdUYW5nZW50O1xcbnZhcnlpbmcgdmVjMyBmcmFnQml0YW5nZW50O1xcbnZhcnlpbmcgdmVjMyBmcmFnQ29sb3I7XFxudmFyeWluZyB2ZWMyIGZyYWdUZXhjb29yZDtcXG5cXG51bmlmb3JtIHZlYzMgY29vcmRzO1xcbnVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNzYW9NYXA7XFxuXFxuI2lmIE1BWF9QT0lOVF9MSUdIVFNcXG5cXHR1bmlmb3JtIHZlYzMgcG9pbnRMaWdodFBvc2l0aW9uW01BWF9QT0lOVF9MSUdIVFNdO1xcblxcdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0SW50ZW5zaXR5W01BWF9QT0lOVF9MSUdIVFNdO1xcblxcdHVuaWZvcm0gdmVjMyBwb2ludExpZ2h0QXR0ZW51YXRpb25bTUFYX1BPSU5UX0xJR0hUU107XFxuXFx0dW5pZm9ybSBib29sIHBvaW50TGlnaHRPbltNQVhfUE9JTlRfTElHSFRTXTtcXG5cXHR1bmlmb3JtIGJvb2wgcG9pbnRMaWdodENhc3RTaGFkb3dbTUFYX1BPSU5UX0xJR0hUU107XFxuI2VuZGlmXFxuXFxuI2lmIE1BWF9TUE9UX0xJR0hUU1xcblxcdHVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvbltNQVhfU1BPVF9MSUdIVFNdO1xcblxcdHVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bTUFYX1NQT1RfTElHSFRTXTtcXG5cXHR1bmlmb3JtIHZlYzMgc3BvdExpZ2h0SW50ZW5zaXR5W01BWF9TUE9UX0xJR0hUU107XFxuXFx0dW5pZm9ybSB2ZWMzIHNwb3RMaWdodEF0dGVudWF0aW9uW01BWF9TUE9UX0xJR0hUU107XFxuXFx0dW5pZm9ybSBmbG9hdCBzcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVbTUFYX1NQT1RfTElHSFRTXTtcXG5cXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVbTUFYX1NQT1RfTElHSFRTXTtcXG5cXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodFNvZnRuZXNzW01BWF9TUE9UX0xJR0hUU107XFxuXFx0dW5pZm9ybSBib29sIHNwb3RMaWdodE9uW01BWF9TUE9UX0xJR0hUU107XFxuXFx0dW5pZm9ybSBib29sIHNwb3RMaWdodENhc3RTaGFkb3dbTUFYX1NQT1RfTElHSFRTXTtcXG5cXHQjaWYgSEFTX1NQT1RfTElHSFRfU0hBRE9XTUFQU1xcblxcdFxcdHVuaWZvcm0gbWF0NCBzcG90TGlnaHRNYXRyaXhbTUFYX1NQT1RfTElHSFRTXTtcXG5cXHRcXHR1bmlmb3JtIHNhbXBsZXIyRCBzcG90TGlnaHRTaGFkb3dNYXBbTUFYX1NQT1RfTElHSFRTXTtcXG5cXHRcXHR1bmlmb3JtIGZsb2F0IHNwb3RMaWdodFNoYWRvd0JpYXNbTUFYX1NQT1RfTElHSFRTXTtcXG5cXHQjZW5kaWZcXG4jZW5kaWZcXG5cXG4jaWYgTUFYX0RJUkVDVElPTkFMX0xJR0hUU1xcblxcdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW01BWF9ESVJFQ1RJT05BTF9MSUdIVFNdO1xcblxcdHVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5W01BWF9ESVJFQ1RJT05BTF9MSUdIVFNdO1xcblxcdHVuaWZvcm0gYm9vbCBkaXJlY3Rpb25hbExpZ2h0T25bTUFYX0RJUkVDVElPTkFMX0xJR0hUU107XFxuXFx0dW5pZm9ybSBib29sIGRpcmVjdGlvbmFsTGlnaHRDYXN0U2hhZG93W01BWF9ESVJFQ1RJT05BTF9MSUdIVFNdO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gdmVjMyBiYXNlQ29sb3I7XFxudW5pZm9ybSBmbG9hdCBzdWJzdXJmYWNlO1xcbnVuaWZvcm0gZmxvYXQgbWV0YWxsaWM7XFxudW5pZm9ybSBmbG9hdCBzcGVjdWxhcjtcXG51bmlmb3JtIGZsb2F0IHNwZWN1bGFyVGludDtcXG51bmlmb3JtIGZsb2F0IHJvdWdobmVzcztcXG51bmlmb3JtIGZsb2F0IGFuaXNvdHJvcGljO1xcbnVuaWZvcm0gZmxvYXQgc2hlZW47XFxudW5pZm9ybSBmbG9hdCBzaGVlblRpbnQ7XFxudW5pZm9ybSBmbG9hdCBjbGVhckNvYXQ7XFxudW5pZm9ybSBmbG9hdCBjbGVhckNvYXRHbG9zcztcXG51bmlmb3JtIGZsb2F0IGNsZWFyQ29hdFRoaWNrbmVzcztcXG51bmlmb3JtIGZsb2F0IGFtYmllbnRJbnRlbnNpdHk7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnVuaWZvcm0gc2FtcGxlcjJEIGJhc2VDb2xvclRleHR1cmU7XFxudW5pZm9ybSBzYW1wbGVyMkQgc3Vic3VyZmFjZVRleHR1cmU7XFxudW5pZm9ybSBzYW1wbGVyMkQgbWV0YWxsaWNUZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNwZWN1bGFyVGV4dHVyZTtcXG51bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhclRpbnRUZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHJvdWdobmVzc1RleHR1cmU7XFxudW5pZm9ybSBzYW1wbGVyMkQgYW5pc290cm9waWNUZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIHNoZWVuVGV4dHVyZTtcXG51bmlmb3JtIHNhbXBsZXIyRCBzaGVlblRpbnRUZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyQ29hdFRleHR1cmU7XFxudW5pZm9ybSBzYW1wbGVyMkQgY2xlYXJDb2F0R2xvc3NUZXh0dXJlO1xcbnVuaWZvcm0gc2FtcGxlcjJEIGNsZWFyQ29hdFRoaWNrbmVzc1RleHR1cmU7XFxudW5pZm9ybSBzYW1wbGVyMkQgb3BhY2l0eVRleHR1cmU7XFxuXFxudW5pZm9ybSBzYW1wbGVyMkQgbm9ybWFsTWFwO1xcblxcbnN0cnVjdCBUYW5nZW50U3BhY2Uge1xcblxcdHZlYzMgTjtcXG5cXHR2ZWMzIFQ7XFxuXFx0dmVjMyBCO1xcbn07XFxuXFxuVGFuZ2VudFNwYWNlIGdldFRhbmdlbnRTcGFjZSgpIHtcXG5cXHRUYW5nZW50U3BhY2UgcztcXG5cXHQjaWYgSEFTX05PUk1BTFxcblxcdFxcdHMuTiA9IG5vcm1hbGl6ZShmcmFnTm9ybWFsKTtcXG5cXHQjZWxzZVxcblxcdFxcdCNpZiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXG5cXHRcXHRcXHR2ZWMzIFggPSBkRmR4KGZyYWdQb3NpdGlvbik7XFxuXFx0XFx0XFx0dmVjMyBZID0gZEZkeShmcmFnUG9zaXRpb24pO1xcblxcdFxcdFxcdHMuTiA9IG5vcm1hbGl6ZShjcm9zcyhYLCBZKSk7XFxuXFx0XFx0I2Vsc2VcXG5cXHRcXHRcXHQjZXJyb3IgU29ycnksIHNoYWRlciBjYW5ub3QgYmUgY29tcGlsZWQgYmVjYXVzZSB0aGUgM0QgbW9kZWxzIGRvZXMgbm90IGhhdmUgbm9ybWFscyBhbmQgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIGV4dGVuc2lvbiBpcyBub3QgYXZhaWxhYmxlIG9uIHRoZSBkZXZpY2UuXFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmIEhBU19UQU5HRU5UXFxuXFx0XFx0cy5UID0gbm9ybWFsaXplKGZyYWdUYW5nZW50KTtcXG5cXHRcXHRzLkIgPSBub3JtYWxpemUoZnJhZ0JpdGFuZ2VudCk7XFxuXFx0I2Vsc2VcXG5cXHRcXHRzLlQgPSBub3JtYWxpemUoY3Jvc3Mocy5OLCB2ZWMzKDAuMCwgMC45OTk5OTksIDAuMDAwMDAxKSkpO1xcblxcdFxcdHMuQiA9IG5vcm1hbGl6ZShjcm9zcyhzLk4sIHMuVCkpO1xcblxcdCNlbmRpZlxcblxcblxcdHJldHVybiBzO1xcbn1cXG5cXG5UYW5nZW50U3BhY2Ugbm9ybWFsTWFwcGluZyhUYW5nZW50U3BhY2Ugb3JpZ2luYWwpIHtcXG5cXHQjaWYgSEFTX05PUk1BTF9NQVAgJiYgSEFTX1RFWENPT1JEXFxuXFx0XFx0VGFuZ2VudFNwYWNlIHBlcnR1cmJlZDtcXG5cXHRcXHR2ZWMzIHNhbXBsZSA9IHRleHR1cmUyRChub3JtYWxNYXAsIGZyYWdUZXhjb29yZCkucmdiO1xcblxcdFxcdHZlYzMgbk4gPSBub3JtYWxpemUoKHNhbXBsZSAtIDAuNSkgKiAyLjApO1xcblxcdFxcdHBlcnR1cmJlZC5OID0gbm9ybWFsaXplKG9yaWdpbmFsLk4gKiBuTi56ICsgb3JpZ2luYWwuVCAqIG5OLnkgKyBvcmlnaW5hbC5CICogbk4ueCk7XFxuXFx0XFx0cGVydHVyYmVkLlQgPSBub3JtYWxpemUob3JpZ2luYWwuVCAtIHBlcnR1cmJlZC5OICogZG90KHBlcnR1cmJlZC5OLCBvcmlnaW5hbC5UKSk7XFxuXFx0XFx0cGVydHVyYmVkLkIgPSBub3JtYWxpemUoY3Jvc3MocGVydHVyYmVkLk4sIHBlcnR1cmJlZC5UKSk7XFxuXFx0XFx0cmV0dXJuIHBlcnR1cmJlZDtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiBvcmlnaW5hbDtcXG5cXHQjZW5kaWZcXG59XFxuXFxudmVjMyBsaW5lYXJpemUoY29uc3QgdmVjMyBjb2xvcikge1xcblxcdHJldHVybiBwb3coY29sb3IsIHZlYzMoMi4yKSk7XFxufVxcblxcbnZlYzMgZ2V0QmFzZUNvbG9yKCkge1xcblxcdHZlYzMgY29sb3I7XFxuXFx0I2lmIEhBU19CQVNFX0NPTE9SX1RFWFRVUkUgJiYgSEFTX1RFWENPT1JEXFxuXFx0XFx0Y29sb3IgPSBsaW5lYXJpemUodGV4dHVyZTJEKGJhc2VDb2xvclRleHR1cmUsIGZyYWdUZXhjb29yZCkucmdiKTtcXG5cXHQjZWxzZVxcblxcdFxcdCNpZiBIQVNfQ09MT1JcXG5cXHRcXHRcXHQvLyBXZSBhc3N1bWUgdGhhdCB2ZXJ0ZXggY29sb3JzIGFyZSBhbHJlYWR5IGxpbmVhcml6ZWRcXG5cXHRcXHRcXHRjb2xvciA9IGZyYWdDb2xvcjtcXG5cXHRcXHQjZWxzZVxcblxcdFxcdFxcdGNvbG9yID0gbGluZWFyaXplKGJhc2VDb2xvcik7XFxuXFx0XFx0I2VuZGlmXFxuXFx0I2VuZGlmXFxuXFxuXFx0cmV0dXJuIGNvbG9yO1xcbn1cXG5cXG5mbG9hdCBnZXRTdWJzdXJmYWNlKCkge1xcblxcdCNpZiBIQVNfU1VCU1VSRkFDRV9URVhUVVJFICYmIEhBU19URVhDT09SRFxcblxcdFxcdHJldHVybiB0ZXh0dXJlMkQoc3Vic3VyZmFjZVRleHR1cmUsIGZyYWdUZXhjb29yZCkucjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiBzdWJzdXJmYWNlO1xcblxcdCNlbmRpZlxcbn1cXG5cXG5mbG9hdCBnZXRNZXRhbGxpYygpIHtcXG5cXHQjaWYgSEFTX01FVEFMTElDX1RFWFRVUkUgJiYgSEFTX1RFWENPT1JEXFxuXFx0XFx0cmV0dXJuIHRleHR1cmUyRChtZXRhbGxpY1RleHR1cmUsIGZyYWdUZXhjb29yZCkucjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiBtZXRhbGxpYztcXG5cXHQjZW5kaWZcXG59XFxuXFxuZmxvYXQgZ2V0U3BlY3VsYXIoKSB7XFxuXFx0I2lmIEhBU19TUEVDVUxBUl9URVhUVVJFICYmIEhBU19URVhDT09SRFxcblxcdFxcdHJldHVybiB0ZXh0dXJlMkQoc3BlY3VsYXJUZXh0dXJlLCBmcmFnVGV4Y29vcmQpLnI7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZXR1cm4gc3BlY3VsYXI7XFxuXFx0I2VuZGlmXFxufVxcblxcbmZsb2F0IGdldFNwZWN1bGFyVGludCgpIHtcXG5cXHQjaWYgSEFTX1NQRUNVTEFSVElOVF9URVhUVVJFICYmIEhBU19URVhDT09SRFxcblxcdFxcdHJldHVybiB0ZXh0dXJlMkQoc3BlY3VsYXJUaW50VGV4dHVyZSwgZnJhZ1RleGNvb3JkKS5yO1xcblxcdCNlbHNlXFxuXFx0XFx0cmV0dXJuIHNwZWN1bGFyVGludDtcXG5cXHQjZW5kaWZcXG59XFxuXFxuZmxvYXQgZ2V0Um91Z2huZXNzKCkge1xcblxcdCNpZiBIQVNfUk9VR0hORVNTX1RFWFRVUkUgJiYgSEFTX1RFWENPT1JEXFxuXFx0XFx0cmV0dXJuIHRleHR1cmUyRChyb3VnaG5lc3NUZXh0dXJlLCBmcmFnVGV4Y29vcmQpLnI7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZXR1cm4gcm91Z2huZXNzO1xcblxcdCNlbmRpZlxcbn1cXG5cXG5mbG9hdCBnZXRBbmlzb3Ryb3BpYygpIHtcXG5cXHQjaWYgSEFTX0FOSVNPVFJPUElDX1RFWFRVUkUgJiYgSEFTX1RFWENPT1JEXFxuXFx0XFx0cmV0dXJuIHRleHR1cmUyRChhbmlzb3Ryb3BpY1RleHR1cmUsIGZyYWdUZXhjb29yZCkucjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiBhbmlzb3Ryb3BpYztcXG5cXHQjZW5kaWZcXG59XFxuXFxuZmxvYXQgZ2V0U2hlZW4oKSB7XFxuXFx0I2lmIEhBU19TSEVFTl9URVhUVVJFICYmIEhBU19URVhDT09SRFxcblxcdFxcdHJldHVybiB0ZXh0dXJlMkQoc2hlZW5UZXh0dXJlLCBmcmFnVGV4Y29vcmQpLnI7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZXR1cm4gc2hlZW47XFxuXFx0I2VuZGlmXFxufVxcblxcbmZsb2F0IGdldFNoZWVuVGludCgpIHtcXG5cXHQjaWYgSEFTX1NIRUVOVElOVF9URVhUVVJFICYmIEhBU19URVhDT09SRFxcblxcdFxcdHJldHVybiB0ZXh0dXJlMkQoc2hlZW5UaW50VGV4dHVyZSwgZnJhZ1RleGNvb3JkKS5yO1xcblxcdCNlbHNlXFxuXFx0XFx0cmV0dXJuIHNoZWVuVGludDtcXG5cXHQjZW5kaWZcXG59XFxuXFxuZmxvYXQgZ2V0Q2xlYXJDb2F0KCkge1xcblxcdCNpZiBIQVNfQ0xFQVJDT0FUX1RFWFRVUkUgJiYgSEFTX1RFWENPT1JEXFxuXFx0XFx0cmV0dXJuIHRleHR1cmUyRChjbGVhckNvYXRUZXh0dXJlLCBmcmFnVGV4Y29vcmQpLnI7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZXR1cm4gY2xlYXJDb2F0O1xcblxcdCNlbmRpZlxcbn1cXG5cXG5mbG9hdCBnZXRDbGVhckNvYXRHbG9zcygpIHtcXG5cXHQjaWYgSEFTX0NMRUFSQ09BVEdMT1NTX1RFWFRVUkUgJiYgSEFTX1RFWENPT1JEXFxuXFx0XFx0cmV0dXJuIHRleHR1cmUyRChjbGVhckNvYXRHbG9zc1RleHR1cmUsIGZyYWdUZXhjb29yZCkucjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiBjbGVhckNvYXRHbG9zcztcXG5cXHQjZW5kaWZcXG59XFxuXFxuZmxvYXQgZ2V0Q2xlYXJDb2F0VGhpY2tuZXNzKCkge1xcblxcdCNpZiBIQVNfQ0xFQVJDT0FUVEhJQ0tORVNTX1RFWFRVUkUgJiYgSEFTX1RFWENPT1JEXFxuXFx0XFx0cmV0dXJuIHRleHR1cmUyRChjbGVhckNvYXRUaGlja25lc3NUZXh0dXJlLCBmcmFnVGV4Y29vcmQpLnI7XFxuXFx0I2Vsc2VcXG5cXHRcXHRyZXR1cm4gY2xlYXJDb2F0VGhpY2tuZXNzO1xcblxcdCNlbmRpZlxcbn1cXG5cXG5mbG9hdCBnZXRPcGFjaXR5KCkge1xcblxcdCNpZiBIQVNfT1BBQ0lUWV9URVhUVVJFICYmIEhBU19URVhDT09SRFxcblxcdFxcdHJldHVybiB0ZXh0dXJlMkQob3BhY2l0eVRleHR1cmUsIGZyYWdUZXhjb29yZCkucjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiBvcGFjaXR5O1xcblxcdCNlbmRpZlxcbn1cXG5cXG5mbG9hdCBnZXRTU09BKCkge1xcblxcdCNpZiBIQVNfU1NBT19NQVBcXG5cXHRcXHRyZXR1cm4gMS4wIC0gdGV4dHVyZTJEKHNzYW9NYXAsIGdsX0ZyYWdDb29yZC54eSAvIGNvb3Jkcy54eSkucjtcXG5cXHQjZWxzZVxcblxcdFxcdHJldHVybiAxLjA7XFxuXFx0I2VuZGlmXFxufVxcblxcbnN0cnVjdCBTdXJmYWNlUGFyYW1ldGVycyB7XFxuXFx0ZmxvYXQgc3Vic3VyZmFjZTtcXG5cXHRmbG9hdCBtZXRhbGxpYztcXG5cXHRmbG9hdCBzcGVjdWxhcjtcXG5cXHRmbG9hdCBzcGVjdWxhclRpbnQ7XFxuXFx0ZmxvYXQgcm91Z2huZXNzO1xcblxcdGZsb2F0IGFuaXNvdHJvcGljO1xcblxcdGZsb2F0IHNoZWVuO1xcblxcdGZsb2F0IHNoZWVuVGludDtcXG5cXHRmbG9hdCBjbGVhckNvYXQ7XFxuXFx0ZmxvYXQgY2xlYXJDb2F0R2xvc3M7XFxuXFx0ZmxvYXQgY2xlYXJDb2F0VGhpY2tuZXNzO1xcblxcdGZsb2F0IG9wYWNpdHk7XFxuXFx0ZmxvYXQgc3NhbztcXG59O1xcblxcblN1cmZhY2VQYXJhbWV0ZXJzIGdldFN1cmZhY2VQYXJhbWV0ZXJzKCkge1xcblxcdHJldHVybiBTdXJmYWNlUGFyYW1ldGVycyhcXG5cXHRcXHRnZXRTdWJzdXJmYWNlKCksXFxuXFx0XFx0Z2V0TWV0YWxsaWMoKSxcXG5cXHRcXHRnZXRTcGVjdWxhcigpLFxcblxcdFxcdGdldFNwZWN1bGFyVGludCgpLFxcblxcdFxcdGdldFJvdWdobmVzcygpLFxcblxcdFxcdGdldEFuaXNvdHJvcGljKCksXFxuXFx0XFx0Z2V0U2hlZW4oKSxcXG5cXHRcXHRnZXRTaGVlblRpbnQoKSxcXG5cXHRcXHRnZXRDbGVhckNvYXQoKSxcXG5cXHRcXHRnZXRDbGVhckNvYXRHbG9zcygpLFxcblxcdFxcdGdldENsZWFyQ29hdFRoaWNrbmVzcygpLFxcblxcdFxcdGdldE9wYWNpdHkoKSxcXG5cXHRcXHRnZXRTU09BKClcXG5cXHQpO1xcbn1cXG5cXG5mbG9hdCBsdW1pbmFuY2UoY29uc3QgdmVjMyBjb2xvcikge1xcblxcdHJldHVybiBkb3QodmVjMygwLjMsIDAuNiwgMC4xKSwgY29sb3IpO1xcbn1cXG5cXG5zdHJ1Y3QgU3VyZmFjZUNvbG9ycyB7XFxuXFx0dmVjMyBiYXNlO1xcblxcdHZlYzMgc3BlY3VsYXI7XFxuXFx0dmVjMyBzaGVlbjtcXG59O1xcblxcblN1cmZhY2VDb2xvcnMgZ2V0U3VyZmFjZUNvbG9ycyhTdXJmYWNlUGFyYW1ldGVycyBwYXJhbWV0ZXJzKSB7XFxuXFx0dmVjMyBsaW5lYXJCYXNlQ29sb3IgPSBnZXRCYXNlQ29sb3IoKTtcXG5cXHRmbG9hdCBsdW1pbmFuY2UgPSBsdW1pbmFuY2UobGluZWFyQmFzZUNvbG9yKTtcXG5cXHR2ZWMzIHRpbnQgPSBsdW1pbmFuY2UgPiAwLjAgPyBsaW5lYXJCYXNlQ29sb3IgLyBsdW1pbmFuY2UgOiB2ZWMzKDEuMCk7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yID0gbWl4KHBhcmFtZXRlcnMuc3BlY3VsYXIgKiAwLjggKiBtaXgodmVjMygxLjApLCB0aW50LCBwYXJhbWV0ZXJzLnNwZWN1bGFyVGludCksIGxpbmVhckJhc2VDb2xvciwgcGFyYW1ldGVycy5tZXRhbGxpYyk7XFxuXFx0dmVjMyBzaGVlbkNvbG9yID0gbWl4KHZlYzMoMS4wKSwgdGludCwgcGFyYW1ldGVycy5zaGVlblRpbnQpO1xcblxcdHJldHVybiBTdXJmYWNlQ29sb3JzKGxpbmVhckJhc2VDb2xvciwgc3BlY3VsYXJDb2xvciwgc2hlZW5Db2xvcik7XFxufVxcblxcbmZsb2F0IHNxdWFyZShjb25zdCBmbG9hdCB4KSB7XFxuXFx0cmV0dXJuIHggKiB4O1xcbn1cXG5cXG5mbG9hdCBzbWl0aChjb25zdCBmbG9hdCBOZG90ViwgY29uc3QgZmxvYXQgc3FyTmRvdFYsIGNvbnN0IGZsb2F0IHNxclJvdWdobmVzcykge1xcblxcdHJldHVybiAxLjAgLyAoTmRvdFYgKyBzcXJ0KHNxck5kb3RWICsgc3FyUm91Z2huZXNzIC0gc3FyTmRvdFYgKiBzcXJSb3VnaG5lc3MpKTtcXG59XFxuXFxudmVjMyBsaWdodENvbnRyaWJ1dGlvbihUYW5nZW50U3BhY2Ugb3JpZ2luYWwsIFRhbmdlbnRTcGFjZSBwZXJ0dXJiZWQsIHZlYzMgTCwgdmVjMyBWLCBTdXJmYWNlQ29sb3JzIGNvbG9ycywgU3VyZmFjZVBhcmFtZXRlcnMgcGFyYW1ldGVycykge1xcblxcdGZsb2F0IE5kb3RMID0gZG90KHBlcnR1cmJlZC5OLCBMKTtcXG5cXHRmbG9hdCBOZG90ViA9IGRvdChwZXJ0dXJiZWQuTiwgVik7XFxuXFxuXFx0aWYgKE5kb3RMIDwgMC4wKVxcblxcdFxcdHJldHVybiB2ZWMzKDAuMCk7XFxuXFxuXFx0dmVjMyBIID0gbm9ybWFsaXplKEwgKyBWKTtcXG5cXHRmbG9hdCBIZG90VCA9IGRvdChILCBwZXJ0dXJiZWQuVCk7XFxuXFx0ZmxvYXQgSGRvdEIgPSBkb3QoSCwgcGVydHVyYmVkLkIpO1xcblxcdGZsb2F0IE5kb3RIID0gZG90KHBlcnR1cmJlZC5OLCBIKTtcXG5cXHRmbG9hdCBMZG90SCA9IGRvdChMLCBIKTtcXG5cXG5cXHRmbG9hdCBzcXJOZG90TCA9IHNxdWFyZShOZG90TCk7XFxuXFx0ZmxvYXQgc3FyTmRvdFYgPSBzcXVhcmUoTmRvdFYpO1xcblxcdGZsb2F0IHNxclJvdWdobmVzcyA9IHNxdWFyZShwYXJhbWV0ZXJzLnJvdWdobmVzcyk7XFxuXFx0ZmxvYXQgc3FyTmRvdEggPSBzcXVhcmUoTmRvdEgpO1xcblxcblxcdGZsb2F0IE5kb3RMc2NobGljayA9IHBvdyhjbGFtcCgxLjAgLSBOZG90TCwgMC4wLCAxLjApLCA1LjApO1xcblxcdGZsb2F0IE5kb3RWc2NobGljayA9IHBvdyhjbGFtcCgxLjAgLSBOZG90ViwgMC4wLCAxLjApLCA1LjApO1xcblxcdGZsb2F0IExkb3RIc2NobGljayA9IHBvdyhjbGFtcCgxLjAgLSBMZG90SCwgMC4wLCAxLjApLCA1LjApO1xcblxcblxcdC8vIGRpZmZ1c2VcXG5cXHRmbG9hdCBmZDkwID0gMC41ICsgMi4wICogTGRvdEggKiBMZG90SCAqIHBhcmFtZXRlcnMucm91Z2huZXNzO1xcblxcdGZsb2F0IGRpZmZ1c2VDb250cmlidXRpb24gPSBtaXgoMS4wLCBmZDkwLCBOZG90THNjaGxpY2spICogbWl4KDEuMCwgZmQ5MCwgTmRvdFZzY2hsaWNrKSAqIHBhcmFtZXRlcnMuc3NhbztcXG5cXHQvLyBzdWJzdXJmYWNlXFxuXFx0ZmxvYXQgZnNzOTAgPSBwYXJhbWV0ZXJzLnJvdWdobmVzcyAqIExkb3RIICogTGRvdEg7XFxuXFx0ZmxvYXQgZnNzID0gbWl4KDEuMCwgZnNzOTAsIE5kb3RMc2NobGljaykgKiBtaXgoMS4wLCBmc3M5MCwgTmRvdFZzY2hsaWNrKTtcXG5cXHRmbG9hdCBzdWJzdXJmYWNlQ29udHJpYnV0aW9uID0gMS4yNSAqIChmc3MgKiAoMS4wIC8gKE5kb3RMICsgTmRvdFYpIC0gMC41KSArIDAuNSk7XFxuXFx0dmVjMyBkaWZmdXNlQ29sb3IgPSAxLjAgLyBQSSAqIG1peChkaWZmdXNlQ29udHJpYnV0aW9uLCBzdWJzdXJmYWNlQ29udHJpYnV0aW9uLCBwYXJhbWV0ZXJzLnN1YnN1cmZhY2UpICogY29sb3JzLmJhc2UgKyBMZG90SHNjaGxpY2sgKiBwYXJhbWV0ZXJzLnNoZWVuICogY29sb3JzLnNoZWVuO1xcblxcblxcdC8vIHNwZWN1bGFyXFxuXFx0ZmxvYXQgYXNwZWN0ID0gc3FydCgxLjAgLSBwYXJhbWV0ZXJzLmFuaXNvdHJvcGljICogMC45KTtcXG5cXHRmbG9hdCBheCA9IG1heCgwLjAwMSwgc3FyUm91Z2huZXNzIC8gYXNwZWN0KTtcXG5cXHRmbG9hdCBheSA9IG1heCgwLjAwMSwgc3FyUm91Z2huZXNzICogYXNwZWN0KTtcXG5cXHRmbG9hdCBzcXJSb3VnaG5lc3NHZW9tZXRyaWMgPSBzcXVhcmUocGFyYW1ldGVycy5yb3VnaG5lc3MgKiAwLjUgKyAwLjUpO1xcblxcdGZsb2F0IERzcGVjdWxhciA9IDEuMCAvIChQSSAqIGF4ICogYXkgKiBzcXVhcmUoc3F1YXJlKEhkb3RUIC8gYXgpICsgc3F1YXJlKEhkb3RCIC8gYXkpICsgc3FyTmRvdEgpKTtcXG5cXHRmbG9hdCBHc3BlY3VsYXIgPSBzbWl0aChOZG90TCwgc3FyTmRvdEwsIHNxclJvdWdobmVzc0dlb21ldHJpYykgKiBzbWl0aChOZG90Viwgc3FyTmRvdFYsIHNxclJvdWdobmVzc0dlb21ldHJpYyk7XFxuXFx0dmVjMyBzcGVjdWxhckNvbG9yID0gRHNwZWN1bGFyICogR3NwZWN1bGFyICogbWl4KGNvbG9ycy5zcGVjdWxhciwgdmVjMygxKSwgTGRvdEhzY2hsaWNrKTtcXG5cXG5cXHR2ZWMzIHN1cmZhY2VSZWZsZWN0aW9uQ29sb3IgPSAoZGlmZnVzZUNvbG9yICogKDEuMCAtIHBhcmFtZXRlcnMubWV0YWxsaWMpICsgc3BlY3VsYXJDb2xvcikgKiBOZG90TDtcXG5cXG5cXHQvLyBjbGVhciBjb2F0XFxuXFx0dmVjMyBjbGVhckNvYXROID0gbm9ybWFsaXplKG1peChwZXJ0dXJiZWQuTiwgb3JpZ2luYWwuTiwgcGFyYW1ldGVycy5jbGVhckNvYXRUaGlja25lc3MpKTtcXG5cXHRmbG9hdCBjbGVhckNvYXROZG90ViA9IGRvdChjbGVhckNvYXROLCBWKTtcXG5cXHRmbG9hdCBjbGVhckNvYXROZG90TCA9IGRvdChjbGVhckNvYXROLCBMKTtcXG5cXHRmbG9hdCBjbGVhckNvYXROZG90SCA9IGRvdChjbGVhckNvYXROLCBIKTtcXG5cXG5cXHRmbG9hdCBjbGVhckNvYXRTcXJOZG90ViA9IHNxdWFyZShjbGVhckNvYXROZG90Vik7XFxuXFx0ZmxvYXQgY2xlYXJDb2F0U3FyTmRvdEwgPSBzcXVhcmUoY2xlYXJDb2F0TmRvdEwpO1xcblxcdGZsb2F0IGNsZWFyQ29hdFNxck5kb3RIID0gc3F1YXJlKGNsZWFyQ29hdE5kb3RIKTtcXG5cXG5cXHRmbG9hdCBjbGVhckNvYXRSb3VnaG5lc3MgPSBtaXgoMC4xLCAwLjAwMSwgcGFyYW1ldGVycy5jbGVhckNvYXRHbG9zcyk7XFxuXFx0ZmxvYXQgY2xlYXJDb2F0U3FyUm91Z2huZXNzID0gc3F1YXJlKGNsZWFyQ29hdFJvdWdobmVzcyk7XFxuXFx0ZmxvYXQgRGNsZWFyQ29hdCA9IGNsZWFyQ29hdFJvdWdobmVzcyA+PSAxLjAgPyAxLjAgLyBQSSA6IChjbGVhckNvYXRTcXJSb3VnaG5lc3MgLSAxLjApIC8gKFBJICogbG9nKGNsZWFyQ29hdFNxclJvdWdobmVzcykgKiAoMS4wICsgKGNsZWFyQ29hdFNxclJvdWdobmVzcyAtIDEuMCkgKiBjbGVhckNvYXRTcXJOZG90SCkpO1xcblxcdGZsb2F0IEZjbGVhckNvYXQgPSBtaXgoMC4wNCwgMS4wLCBMZG90SHNjaGxpY2spO1xcblxcdGZsb2F0IEdjbGVhckNvYXQgPSBzbWl0aChjbGVhckNvYXROZG90TCwgY2xlYXJDb2F0U3FyTmRvdEwsIDAuMjUpICogc21pdGgoY2xlYXJDb2F0TmRvdFYsIGNsZWFyQ29hdFNxck5kb3RWLCAwLjI1KTtcXG5cXHRmbG9hdCBjbGVhckNvYXRSZWZsZWN0aW9uID0gMC4yNSAqIHBhcmFtZXRlcnMuY2xlYXJDb2F0ICogR2NsZWFyQ29hdCAqIEZjbGVhckNvYXQgKiBEY2xlYXJDb2F0ICogY2xlYXJDb2F0TmRvdEw7XFxuXFxuXFx0cmV0dXJuIG1heCh2ZWMzKDAuMCksIChzdXJmYWNlUmVmbGVjdGlvbkNvbG9yICsgY2xlYXJDb2F0UmVmbGVjdGlvbikpO1xcbn1cXG5cXG5mbG9hdCBhdHRlbnVhdGlvbihjb25zdCB2ZWMzIEwsIGNvbnN0IHZlYzMgYXR0ZW51YXRpb24pIHtcXG5cXHRmbG9hdCBkaXN0ID0gbGVuZ3RoKEwpO1xcblxcdHJldHVybiAxLjAgLyAoYXR0ZW51YXRpb24ueCArIGF0dGVudWF0aW9uLnkgKiBkaXN0ICsgYXR0ZW51YXRpb24ueiAqIGRpc3QgKiBkaXN0KTtcXG59XFxuXFxuZmxvYXQgdW5wYWNrRGVwdGgoY29uc3QgdmVjNCByZ2JhRGVwdGgpIHtcXG5cXHRjb25zdCB2ZWM0IGJpdFNoaWZ0ID0gdmVjNCgxLjAgLyAoMjU2LjAgKiAyNTYuMCAqIDI1Ni4wKSwgMS4wIC8gKDI1Ni4wICogMjU2LjApLCAxLjAgLyAyNTYuMCwgMS4wKTtcXG5cXHRmbG9hdCBkZXB0aCA9IGRvdChyZ2JhRGVwdGgsIGJpdFNoaWZ0KTtcXG5cXHRyZXR1cm4gZGVwdGg7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG5cXHRUYW5nZW50U3BhY2Ugb3JpZ2luYWxUYW5nZW50U3BhY2UgPSBnZXRUYW5nZW50U3BhY2UoKTtcXG5cXHRUYW5nZW50U3BhY2UgcGVydHVyYmVkVGFuZ2VudFNwYWNlID0gbm9ybWFsTWFwcGluZyhvcmlnaW5hbFRhbmdlbnRTcGFjZSk7XFxuXFx0U3VyZmFjZVBhcmFtZXRlcnMgcGFyYW1ldGVycyA9IGdldFN1cmZhY2VQYXJhbWV0ZXJzKCk7XFxuXFx0U3VyZmFjZUNvbG9ycyBjb2xvcnMgPSBnZXRTdXJmYWNlQ29sb3JzKHBhcmFtZXRlcnMpO1xcblxcdHZlYzMgViA9IC1ub3JtYWxpemUoZnJhZ1Bvc2l0aW9uKTtcXG5cXG5cXHR2ZWMzIGZpbmFsQ29sb3I7XFxuXFx0I2lmIE1BWF9QT0lOVF9MSUdIVFMgPiAwXFxuXFx0XFx0Zm9yIChpbnQgaWR4ID0gMDsgaWR4IDwgTUFYX1BPSU5UX0xJR0hUUzsgKytpZHgpIHtcXG5cXHRcXHRcXHRpZiAocG9pbnRMaWdodE9uW2lkeF0pIHtcXG5cXHRcXHRcXHRcXHR2ZWM0IGxpZ2h0UG9zaXRpb24gPSB2aWV3TWF0cml4ICogdmVjNChwb2ludExpZ2h0UG9zaXRpb25baWR4XSwgMS4wKTtcXG5cXHRcXHRcXHRcXHR2ZWMzIEwgPSBsaWdodFBvc2l0aW9uLnh5eiAtIGZyYWdQb3NpdGlvbjtcXG5cXHRcXHRcXHRcXHRmbG9hdCBhdHRlbnVhdGlvbiA9IGF0dGVudWF0aW9uKEwsIHBvaW50TGlnaHRBdHRlbnVhdGlvbltpZHhdKTtcXG5cXHRcXHRcXHRcXHRMID0gbm9ybWFsaXplKEwpO1xcblxcdFxcdFxcdFxcdGZpbmFsQ29sb3IgKz0gbGlnaHRDb250cmlidXRpb24ob3JpZ2luYWxUYW5nZW50U3BhY2UsIHBlcnR1cmJlZFRhbmdlbnRTcGFjZSwgTCwgViwgY29sb3JzLCBwYXJhbWV0ZXJzKSAqIHBvaW50TGlnaHRJbnRlbnNpdHlbaWR4XSAqIGF0dGVudWF0aW9uO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0I2VuZGlmXFxuXFxuXFx0I2lmIE1BWF9TUE9UX0xJR0hUUyA+IDBcXG5cXHRcXHRmb3IgKGludCBpZHggPSAwOyBpZHggPCBNQVhfU1BPVF9MSUdIVFM7ICsraWR4KSB7XFxuXFx0XFx0XFx0aWYgKHNwb3RMaWdodE9uW2lkeF0pIHtcXG5cXHRcXHRcXHRcXHRmbG9hdCBzaGFkb3dJbmZsdWVuY2UgPSAxLjA7XFxuXFx0XFx0XFx0XFx0I2lmIEhBU19TUE9UX0xJR0hUX1NIQURPV01BUFNcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3dJbmZsdWVuY2UgPSAwLjA7XFxuXFx0XFx0XFx0XFx0XFx0dmVjNCBsc3BvcyA9IHNwb3RMaWdodE1hdHJpeFtpZHhdICogdmVjNChmcmFnV29ybGRQb3NpdGlvbiwgMS4wKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWMzIHBlcnNwZWN0aXZlRGl2UG9zID0gbHNwb3MueHl6IC8gbHNwb3MudyAqIDAuNSArIDAuNTtcXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBsc0RlcHRoID0gcGVyc3BlY3RpdmVEaXZQb3MuejtcXG5cXHRcXHRcXHRcXHRcXHR2ZWMyIGxpZ2h0dXYgPSBwZXJzcGVjdGl2ZURpdlBvcy54eTtcXG5cXHRcXHRcXHRcXHRcXHRmbG9hdCBkZXB0aCA9IHVucGFja0RlcHRoKHRleHR1cmUyRChzcG90TGlnaHRTaGFkb3dNYXBbaWR4XSwgbGlnaHR1dikpICsgc3BvdExpZ2h0U2hhZG93Qmlhc1tpZHhdO1xcblxcdFxcdFxcdFxcdFxcdGlmKGxzRGVwdGggPCBkZXB0aClcXG5cXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dJbmZsdWVuY2UgPSAxLjA7XFxuXFx0XFx0XFx0XFx0I2VuZGlmXFxuXFx0XFx0XFx0XFx0aWYgKHNoYWRvd0luZmx1ZW5jZSA+IDAuMCkge1xcblxcdFxcdFxcdFxcdFxcdHZlYzQgbGlnaHRQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KHNwb3RMaWdodFBvc2l0aW9uW2lkeF0sIDEuMCk7XFxuXFx0XFx0XFx0XFx0XFx0dmVjMyBMID0gbGlnaHRQb3NpdGlvbi54eXogLSBmcmFnUG9zaXRpb247XFxuXFx0XFx0XFx0XFx0XFx0ZmxvYXQgYXR0ZW51YXRpb24gPSBhdHRlbnVhdGlvbihMLCBzcG90TGlnaHRBdHRlbnVhdGlvbltpZHhdKTtcXG5cXHRcXHRcXHRcXHRcXHRMID0gbm9ybWFsaXplKEwpO1xcblxcdFxcdFxcdFxcdFxcdHZlYzMgRCA9IG5vcm1hbGl6ZSgodmlld01hdHJpeCAqIHZlYzQoLXNwb3RMaWdodERpcmVjdGlvbltpZHhdLCAwLjApKS54eXopO1xcblxcdFxcdFxcdFxcdFxcdGZsb2F0IGFuZ2xlID0gZG90KEwsIEQpO1xcblxcdFxcdFxcdFxcdFxcdGlmIChhbmdsZSA+IHNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVtpZHhdKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmxvYXQgc29mdG5lc3MgPSAxLjA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGFuZ2xlIDwgc3BvdExpZ2h0Q29zU29mdEZhbGxvZmZBbmdsZVtpZHhdKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNvZnRuZXNzID0gKGFuZ2xlIC0gc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlW2lkeF0pIC8gKHNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVbaWR4XSAtIHNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVtpZHhdKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmaW5hbENvbG9yICs9IGxpZ2h0Q29udHJpYnV0aW9uKG9yaWdpbmFsVGFuZ2VudFNwYWNlLCBwZXJ0dXJiZWRUYW5nZW50U3BhY2UsIEwsIFYsIGNvbG9ycywgcGFyYW1ldGVycykgKiBzcG90TGlnaHRJbnRlbnNpdHlbaWR4XSAqIGF0dGVudWF0aW9uICogc29mdG5lc3MgKiBzaGFkb3dJbmZsdWVuY2U7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcblxcblxcdCNpZiBNQVhfRElSRUNUSU9OQUxfTElHSFRTID4gMFxcblxcdFxcdGZvciAoaW50IGlkeCA9IDA7IGlkeCA8IE1BWF9ESVJFQ1RJT05BTF9MSUdIVFM7ICsraWR4KSB7XFxuXFx0XFx0XFx0aWYgKGRpcmVjdGlvbmFsTGlnaHRPbltpZHhdKSB7XFxuXFx0XFx0XFx0XFx0dmVjMyBMID0gbm9ybWFsaXplKCh2aWV3TWF0cml4ICogdmVjNCgtZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbltpZHhdLCAwLjApKS54eXopO1xcblxcdFxcdFxcdFxcdGZpbmFsQ29sb3IgKz0gbGlnaHRDb250cmlidXRpb24ob3JpZ2luYWxUYW5nZW50U3BhY2UsIHBlcnR1cmJlZFRhbmdlbnRTcGFjZSwgTCwgViwgY29sb3JzLCBwYXJhbWV0ZXJzKSAqIGRpcmVjdGlvbmFsTGlnaHRJbnRlbnNpdHlbaWR4XTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdCNlbmRpZlxcblxcblxcdGZpbmFsQ29sb3IgKz0gY29sb3JzLmJhc2UgKiBhbWJpZW50SW50ZW5zaXR5ICogcGFyYW1ldGVycy5zc2FvO1xcblxcblxcdGdsX0ZyYWdDb2xvciA9IHZlYzQocG93KGZpbmFsQ29sb3IsIHZlYzMoMS4wIC8gMi4yKSksIHBhcmFtZXRlcnMub3BhY2l0eSk7XFxufVxcblwiLFxuXG5cdGFkZERpcmVjdGl2ZXM6IGZ1bmN0aW9uKGRpcmVjdGl2ZXMsIGxpZ2h0cywgcGFyYW1zKSB7XG5cdFx0ZGlyZWN0aXZlcy5wdXNoKFwiI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcIik7XG5cdFx0ZGlyZWN0aXZlcy5wdXNoKFwiUEkgXCIgKyBNYXRoLlBJKTtcblxuXHRcdGRpcmVjdGl2ZXMucHVzaChcIkhBU19OT1JNQUwgXCIgKyAoXCJub3JtYWxcIiBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XG5cdFx0ZGlyZWN0aXZlcy5wdXNoKFwiSEFTX1RBTkdFTlQgXCIgKyAoXCJ0YW5nZW50XCIgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xuXHRcdGRpcmVjdGl2ZXMucHVzaChcIkhBU19URVhDT09SRCBcIiArIChcInRleGNvb3JkXCIgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xuXHRcdGRpcmVjdGl2ZXMucHVzaChcIkhBU19DT0xPUiBcIiArIChcImNvbG9yXCIgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xuXG5cdFx0W1wicG9pbnRcIiwgXCJkaXJlY3Rpb25hbFwiLCBcInNwb3RcIl0uZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuXHRcdFx0dmFyIG51bUxpZ2h0cyA9IGxpZ2h0cy5nZXRNb2RlbENvdW50KHR5cGUpO1xuXHRcdFx0dmFyIGNhc3RTaGFkb3dzID0gZmFsc2U7XG5cdFx0XHRpZihudW1MaWdodHMpIHtcblx0XHRcdFx0Y2FzdFNoYWRvd3MgPSBBcnJheS5wcm90b3R5cGUuc29tZS5jYWxsKGxpZ2h0cy5nZXRNb2RlbEVudHJ5KHR5cGUpLnBhcmFtZXRlcnNbXCJjYXN0U2hhZG93XCJdLCBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0ZGlyZWN0aXZlcy5wdXNoKFwiTUFYX1wiICsgdHlwZS50b1VwcGVyQ2FzZSgpICsgXCJfTElHSFRTIFwiICsgbnVtTGlnaHRzKTtcblx0XHRcdGRpcmVjdGl2ZXMucHVzaChcIkhBU19cIiArIHR5cGUudG9VcHBlckNhc2UoKSArIFwiX0xJR0hUX1NIQURPV01BUFMgXCIgKyAoY2FzdFNoYWRvd3MgPyAxIDogMCkpO1xuXHRcdH0pO1xuXG5cdFx0ZGlyZWN0aXZlcy5wdXNoKFwiSEFTX1NTQU9fTUFQIFwiICsgKFhNTDNELm9wdGlvbnMuZ2V0VmFsdWUoXCJyZW5kZXJlci1zc2FvXCIpID8gXCIxXCIgOiBcIjBcIikpO1xuXG5cdFx0ZGlyZWN0aXZlcy5wdXNoKFwiSEFTX0JBU0VfQ09MT1JfVEVYVFVSRSBcIiArIChcImJhc2VDb2xvclRleHR1cmVcIiBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XG5cdFx0ZGlyZWN0aXZlcy5wdXNoKFwiSEFTX1NVQlNVUkZBQ0VfVEVYVFVSRSBcIiArIChcInN1YnN1cmZhY2VUZXh0dXJlXCIgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xuXHRcdGRpcmVjdGl2ZXMucHVzaChcIkhBU19NRVRBTExJQ19URVhUVVJFIFwiICsgKFwibWV0YWxsaWNUZXh0dXJlXCIgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xuXHRcdGRpcmVjdGl2ZXMucHVzaChcIkhBU19TUEVDVUxBUl9URVhUVVJFIFwiICsgKFwic3BlY3VsYXJUZXh0dXJlXCIgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xuXHRcdGRpcmVjdGl2ZXMucHVzaChcIkhBU19TUEVDVUxBUlRJTlRfVEVYVFVSRSBcIiArIChcInNwZWN1bGFyVGludFRleHR1cmVcIiBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XG5cdFx0ZGlyZWN0aXZlcy5wdXNoKFwiSEFTX1JPVUdITkVTU19URVhUVVJFIFwiICsgKFwicm91Z2huZXNzVGV4dHVyZVwiIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcblx0XHRkaXJlY3RpdmVzLnB1c2goXCJIQVNfQU5JU09UUk9QSUNfVEVYVFVSRSBcIiArIChcImFuaXNvdHJvcGljVGV4dHVyZVwiIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcblx0XHRkaXJlY3RpdmVzLnB1c2goXCJIQVNfU0hFRU5fVEVYVFVSRSBcIiArIChcInNoZWVuVGV4dHVyZVwiIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcblx0XHRkaXJlY3RpdmVzLnB1c2goXCJIQVNfU0hFRU5USU5UX1RFWFRVUkUgXCIgKyAoXCJzaGVlblRpbnRUZXh0dXJlXCIgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xuXHRcdGRpcmVjdGl2ZXMucHVzaChcIkhBU19DTEVBUkNPQVRfVEVYVFVSRSBcIiArIChcImNsZWFyQ29hdFRleHR1cmVcIiBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XG5cdFx0ZGlyZWN0aXZlcy5wdXNoKFwiSEFTX0NMRUFSQ09BVEdMT1NTX1RFWFRVUkUgXCIgKyAoXCJjbGVhckNvYXRHbG9zc1RleHR1cmVcIiBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XG5cdFx0ZGlyZWN0aXZlcy5wdXNoKFwiSEFTX0NMRUFSQ09BVFRISUNLTkVTU19URVhUVVJFIFwiICsgKFwiY2xlYXJDb2F0VGhpY2tuZXNzVGV4dHVyZVwiIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcblx0XHRkaXJlY3RpdmVzLnB1c2goXCJIQVNfT1BBQ0lUWV9URVhUVVJFIFwiICsgKFwib3BhY2l0eVRleHR1cmVcIiBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XG5cblx0XHRkaXJlY3RpdmVzLnB1c2goXCJIQVNfTk9STUFMX01BUCBcIiArIChcIm5vcm1hbE1hcFwiIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcblx0fSxcblxuXHRoYXNUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdHJldHVybiAocGFyYW1zLm9wYWNpdHkgJiYgcGFyYW1zLm9wYWNpdHkuZ2V0VmFsdWUoKVswXSA8IDEpIHx8IChcIm9wYWNpdHlUZXh0dXJlXCIgaW4gcGFyYW1zKTtcblx0fSxcblxuXHR1bmlmb3Jtczoge1xuXHRcdGJhc2VDb2xvcjogWzEuMCwgMS4wLCAxLjBdLFxuXHRcdHN1YnN1cmZhY2U6IDAsXG5cdFx0bWV0YWxsaWM6IDAsXG5cdFx0c3BlY3VsYXI6IDAuNSxcblx0XHRzcGVjdWxhclRpbnQ6IDAsXG5cdFx0cm91Z2huZXNzOiAwLjUsXG5cdFx0YW5pc290cm9waWM6IDAuMCxcblx0XHRzaGVlbjogMCxcblx0XHRzaGVlblRpbnQ6IDAuNSxcblx0XHRjbGVhckNvYXQ6IDAsXG5cdFx0Y2xlYXJDb2F0R2xvc3M6IDEsXG5cdFx0Y2xlYXJDb2F0VGhpY2tuZXNzOiAxLFxuXHRcdG9wYWNpdHk6IDEuMCxcblx0XHRhbWJpZW50SW50ZW5zaXR5OiAwLjBcblx0fSxcblx0c2FtcGxlcnM6IHtcblx0XHRiYXNlQ29sb3JUZXh0dXJlOiBudWxsLFxuXHRcdHN1YnN1cmZhY2VUZXh0dXJlOiBudWxsLFxuXHRcdG1ldGFsbGljVGV4dHVyZTogbnVsbCxcblx0XHRzcGVjdWxhclRleHR1cmU6IG51bGwsXG5cdFx0c3BlY3VsYXJUaW50VGV4dHVyZTogbnVsbCxcblx0XHRyb3VnaG5lc3NUZXh0dXJlOiBudWxsLFxuXHRcdGFuaXNvdHJvcGljVGV4dHVyZTogbnVsbCxcblx0XHRzaGVlblRleHR1cmU6IG51bGwsXG5cdFx0c2hlZW5UaW50VGV4dHVyZTogbnVsbCxcblx0XHRjbGVhckNvYXRUZXh0dXJlOiBudWxsLFxuXHRcdGNsZWFyQ29hdEdsb3NzVGV4dHVyZTogbnVsbCxcblx0XHRjbGVhckNvYXRUaGlja25lc3NUZXh0dXJlOiBudWxsLFxuXHRcdG9wYWNpdHlUZXh0dXJlOiBudWxsLFxuXHRcdG5vcm1hbE1hcDogbnVsbFxuXHR9LFxuXHRhdHRyaWJ1dGVzOiB7XG5cdFx0bm9ybWFsOiBudWxsLFxuXHRcdHRhbmdlbnQ6IG51bGwsXG5cdFx0dGV4Y29vcmQ6IG51bGwsXG5cdFx0Y29sb3I6IG51bGxcblx0fVxufSk7XG4iLCJYTUwzRC5tYXRlcmlhbHMucmVnaXN0ZXIoXCJkaWZmdXNlXCIsIHtcblxuICAgIHZlcnRleCA6IFtcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBub3JtYWw7XCIsXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgY29sb3I7XCIsXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdGV4Y29vcmQ7XCIsXG5cbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnRXllVmVjdG9yO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdWZXJ0ZXhDb2xvcjtcIixcblxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXG4gICAgICAgIFwidW5pZm9ybSBtYXQzIG1vZGVsVmlld01hdHJpeE47XCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGV5ZVBvc2l0aW9uO1wiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgXCIgICAgdmVjMyBwb3MgPSBwb3NpdGlvbjtcIixcbiAgICAgICAgXCIgICAgdmVjMyBub3JtID0gbm9ybWFsO1wiLFxuXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zLCAxLjApO1wiLFxuICAgICAgICBcIiAgICBmcmFnTm9ybWFsID0gbm9ybWFsaXplKG1vZGVsVmlld01hdHJpeE4gKiBub3JtKTtcIixcbiAgICAgICAgXCIgICAgZnJhZ1ZlcnRleFBvc2l0aW9uID0gKG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zLCAxLjApKS54eXo7XCIsXG4gICAgICAgIFwiICAgIGZyYWdFeWVWZWN0b3IgPSBub3JtYWxpemUoZnJhZ1ZlcnRleFBvc2l0aW9uKTtcIixcbiAgICAgICAgXCIgICAgZnJhZ1RleENvb3JkID0gdGV4Y29vcmQ7XCIsXG4gICAgICAgIFwiICAgIGZyYWdWZXJ0ZXhDb2xvciA9IGNvbG9yO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50IDogW1xuICAgICAgICBcInVuaWZvcm0gZmxvYXQgYW1iaWVudEludGVuc2l0eTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZUNvbG9yO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZUNvbG9yO1wiLFxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgdHJhbnNwYXJlbmN5O1wiLFxuICAgICAgICBcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLFxuICAgICAgICBcInVuaWZvcm0gYm9vbCB1c2VWZXJ0ZXhDb2xvcjtcIixcblxuICAgICAgICBcIiNpZiBIQVNfRU1JU1NJVkVURVhUVVJFXCIsXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgZW1pc3NpdmVUZXh0dXJlO1wiLFxuICAgICAgICBcIiNlbmRpZlwiLFxuICAgICAgICBcIiNpZiBIQVNfRElGRlVTRVRFWFRVUkVcIixcbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBkaWZmdXNlVGV4dHVyZTtcIixcbiAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdFeWVWZWN0b3I7XCIsXG4gICAgICAgIFwidmFyeWluZyB2ZWMyIGZyYWdUZXhDb29yZDtcIixcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxuXG4gICAgICAgIFwiI2lmIE1BWF9QT0lOVExJR0hUUyA+IDBcIixcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodEF0dGVudWF0aW9uW01BWF9QT0lOVExJR0hUU107XCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRQb3NpdGlvbltNQVhfUE9JTlRMSUdIVFNdO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0SW50ZW5zaXR5W01BWF9QT0lOVExJR0hUU107XCIsXG4gICAgICAgIFwidW5pZm9ybSBib29sIHBvaW50TGlnaHRPbltNQVhfUE9JTlRMSUdIVFNdO1wiLFxuICAgICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgIFwiI2lmIE1BWF9ESVJFQ1RJT05BTExJR0hUUyA+IDBcIixcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbltNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5W01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXG4gICAgICAgIFwidW5pZm9ybSBib29sIGRpcmVjdGlvbmFsTGlnaHRPbltNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxuICAgICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgIFwiI2lmIE1BWF9TUE9UTElHSFRTID4gMFwiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRBdHRlbnVhdGlvbltNQVhfU1BPVExJR0hUU107XCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodFBvc2l0aW9uW01BWF9TUE9UTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0SW50ZW5zaXR5W01BWF9TUE9UTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgc3BvdExpZ2h0T25bTUFYX1NQT1RMSUdIVFNdO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcG90TGlnaHREaXJlY3Rpb25bTUFYX1NQT1RMSUdIVFNdO1wiLFxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlW01BWF9TUE9UTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVbTUFYX1NQT1RMSUdIVFNdO1wiLFxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0U29mdG5lc3NbTUFYX1NQT1RMSUdIVFNdO1wiLFxuICAgICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgXCIgIGZsb2F0IGFscGhhID0gIG1heCgwLjAsIDEuMCAtIHRyYW5zcGFyZW5jeSk7XCIsXG4gICAgICAgIFwiICB2ZWMzIG9iakRpZmZ1c2UgPSBkaWZmdXNlQ29sb3I7XCIsXG4gICAgICAgIFwiICBpZih1c2VWZXJ0ZXhDb2xvcilcIixcbiAgICAgICAgXCIgICAgb2JqRGlmZnVzZSAqPSBmcmFnVmVydGV4Q29sb3I7XCIsXG4gICAgICAgIFwiICAjaWYgSEFTX0RJRkZVU0VURVhUVVJFXCIsXG4gICAgICAgIFwiICAgIHZlYzQgdGV4RGlmZnVzZSA9IHRleHR1cmUyRChkaWZmdXNlVGV4dHVyZSwgZnJhZ1RleENvb3JkKTtcIixcbiAgICAgICAgXCIgICAgYWxwaGEgKj0gdGV4RGlmZnVzZS5hO1wiLFxuICAgICAgICBcIiAgICBvYmpEaWZmdXNlICo9IHRleERpZmZ1c2UucmdiO1wiLFxuICAgICAgICBcIiAgI2VuZGlmXCIsXG4gICAgICAgIFwiICBpZiAoYWxwaGEgPCAwLjA1KSBkaXNjYXJkO1wiLFxuXG4gICAgICAgIFwiICAjaWYgSEFTX0VNSVNTSVZFVEVYVFVSRVwiLFxuICAgICAgICBcIiAgICB2ZWMzIGNvbG9yID0gZW1pc3NpdmVDb2xvciAqIHRleHR1cmUyRChlbWlzc2l2ZVRleHR1cmUsIGZyYWdUZXhDb29yZCkucmdiICsgKGFtYmllbnRJbnRlbnNpdHkgKiBvYmpEaWZmdXNlKTtcIixcbiAgICAgICAgXCIgICNlbHNlXCIsXG4gICAgICAgIFwiICAgIHZlYzMgY29sb3IgPSBlbWlzc2l2ZUNvbG9yICsgKGFtYmllbnRJbnRlbnNpdHkgKiBvYmpEaWZmdXNlKTtcIixcbiAgICAgICAgXCIgICNlbmRpZlwiLFxuXG4gICAgICAgIFwiICAjaWYgTUFYX1BPSU5UTElHSFRTID4gMFwiLFxuICAgICAgICBcIiAgICBmb3IgKGludCBpPTA7IGk8TUFYX1BPSU5UTElHSFRTOyBpKyspIHtcIixcbiAgICAgICAgXCIgICAgICBpZiAoIXBvaW50TGlnaHRPbltpXSlcIixcbiAgICAgICAgXCIgICAgICAgICBjb250aW51ZTtcIixcbiAgICAgICAgXCIgICAgICB2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XCIsXG4gICAgICAgIFwiICAgICAgdmVjMyBMID0gbFBvc2l0aW9uLnh5eiAtIGZyYWdWZXJ0ZXhQb3NpdGlvbjtcIixcbiAgICAgICAgXCIgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKEwpO1wiLFxuICAgICAgICBcIiAgICAgIEwgPSBub3JtYWxpemUoTCk7XCIsXG4gICAgICAgIFwiICAgICAgZmxvYXQgYXR0ZW4gPSAxLjAgLyAocG9pbnRMaWdodEF0dGVudWF0aW9uW2ldLnggKyBwb2ludExpZ2h0QXR0ZW51YXRpb25baV0ueSAqIGRpc3QgKyBwb2ludExpZ2h0QXR0ZW51YXRpb25baV0ueiAqIGRpc3QgKiBkaXN0KTtcIixcbiAgICAgICAgXCIgICAgICB2ZWMzIElkaWZmID0gcG9pbnRMaWdodEludGVuc2l0eVtpXSAqIG9iakRpZmZ1c2UgKiBtYXgoZG90KGZyYWdOb3JtYWwsTCksMC4wKTtcIixcbiAgICAgICAgXCIgICAgICBjb2xvciA9IGNvbG9yICsgYXR0ZW4qSWRpZmY7XCIsXG4gICAgICAgIFwiICAgIH1cIixcbiAgICAgICAgXCIgICNlbmRpZlwiLFxuXG4gICAgICAgIFwiI2lmIE1BWF9ESVJFQ1RJT05BTExJR0hUUyA+IDBcIixcbiAgICAgICAgXCIgIGZvciAoaW50IGk9MDsgaTxNQVhfRElSRUNUSU9OQUxMSUdIVFM7IGkrKykge1wiLFxuICAgICAgICBcIiAgICAgIGlmICghZGlyZWN0aW9uYWxMaWdodE9uW2ldKVwiLFxuICAgICAgICBcIiAgICAgICAgIGNvbnRpbnVlO1wiLFxuICAgICAgICBcIiAgICB2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNChkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW2ldLCAwLjApO1wiLFxuICAgICAgICBcIiAgICB2ZWMzIEwgPSAgbm9ybWFsaXplKC1sRGlyZWN0aW9uLnh5eik7XCIsXG4gICAgICAgIFwiICAgIHZlYzMgSWRpZmYgPSBkaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5W2ldICogb2JqRGlmZnVzZSAqIG1heChkb3QoZnJhZ05vcm1hbCxMKSwwLjApO1wiLFxuICAgICAgICBcIiAgICBjb2xvciA9IGNvbG9yICsgSWRpZmY7XCIsXG4gICAgICAgIFwiICB9XCIsXG4gICAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgICAgXCIjaWYgTUFYX1NQT1RMSUdIVFMgPiAwXCIsXG4gICAgICAgIFwiICBmb3IgKGludCBpPTA7IGk8TUFYX1NQT1RMSUdIVFM7IGkrKykge1wiLFxuICAgICAgICBcIiAgICAgIGlmICghc3BvdExpZ2h0T25baV0pXCIsXG4gICAgICAgIFwiICAgICAgICAgY29udGludWU7XCIsXG4gICAgICAgIFwiICAgIHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxuICAgICAgICBcIiAgICB2ZWMzIEwgPSBsUG9zaXRpb24ueHl6IC0gZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxuICAgICAgICBcIiAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKEwpO1wiLFxuICAgICAgICBcIiAgICBMID0gbm9ybWFsaXplKEwpO1wiLFxuICAgICAgICBcIiAgICBmbG9hdCBhdHRlbiA9IDEuMCAvIChzcG90TGlnaHRBdHRlbnVhdGlvbltpXS54ICsgc3BvdExpZ2h0QXR0ZW51YXRpb25baV0ueSAqIGRpc3QgKyBzcG90TGlnaHRBdHRlbnVhdGlvbltpXS56ICogZGlzdCAqIGRpc3QpO1wiLFxuICAgICAgICBcIiAgICB2ZWMzIElkaWZmID0gc3BvdExpZ2h0SW50ZW5zaXR5W2ldICogb2JqRGlmZnVzZSAqIG1heChkb3QoZnJhZ05vcm1hbCxMKSwwLjApO1wiLFxuICAgICAgICBcIiAgICB2ZWM0IGxEaXJlY3Rpb24gPSB2aWV3TWF0cml4ICogdmVjNCgtc3BvdExpZ2h0RGlyZWN0aW9uW2ldLCAwLjApO1wiLFxuICAgICAgICBcIiAgICB2ZWMzIEQgPSBub3JtYWxpemUobERpcmVjdGlvbi54eXopO1wiLFxuICAgICAgICBcIiAgICBmbG9hdCBhbmdsZSA9IGRvdChMLCBEKTtcIixcbiAgICAgICAgXCIgICAgaWYoYW5nbGUgPiBzcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVbaV0pIHtcIixcbiAgICAgICAgXCIgICAgICAgZmxvYXQgc29mdG5lc3MgPSAxLjA7XCIsXG4gICAgICAgIFwiICAgICAgIGlmIChhbmdsZSA8IHNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVbaV0pXCIsXG4gICAgICAgIFwiICAgICAgICAgICBzb2Z0bmVzcyA9IChhbmdsZSAtIHNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVtpXSkgLyAgKHNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVbaV0gLSAgc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlW2ldKTtcIixcbiAgICAgICAgXCIgICAgICAgY29sb3IgKz0gYXR0ZW4gKiBzb2Z0bmVzcyAqIElkaWZmO1wiLFxuICAgICAgICBcIiAgICB9XCIsXG4gICAgICAgIFwiICB9XCIsXG4gICAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgICAgXCIgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIGFscGhhKTtcIixcbiAgICAgICAgXCJ9XCJcbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBhZGREaXJlY3RpdmVzOiBmdW5jdGlvbihkaXJlY3RpdmVzLCBsaWdodHMsIHBhcmFtcykge1xuICAgICAgICBbXCJwb2ludFwiLCBcImRpcmVjdGlvbmFsXCIsIFwic3BvdFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgbnVtTGlnaHRzID0gbGlnaHRzLmdldE1vZGVsQ291bnQodHlwZSk7XG4gICAgICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJNQVhfXCIgKyB0eXBlLnRvVXBwZXJDYXNlKCkgKyBcIkxJR0hUUyBcIiArIG51bUxpZ2h0cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfRElGRlVTRVRFWFRVUkUgXCIgKyAoJ2RpZmZ1c2VUZXh0dXJlJyBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIkhBU19FTUlTU0lWRVRFWFRVUkUgXCIgKyAoJ2VtaXNzaXZlVGV4dHVyZScgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xuICAgIH0sXG4gICAgaGFzVHJhbnNwYXJlbmN5OiBmdW5jdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHBhcmFtcy50cmFuc3BhcmVuY3kgJiYgcGFyYW1zLnRyYW5zcGFyZW5jeS5nZXRWYWx1ZSgpWzBdID4gMC4wMDE7XG4gICAgfSxcbiAgICB1bmlmb3Jtczoge1xuICAgICAgICBkaWZmdXNlQ29sb3IgICAgOiBbMS4wLCAxLjAsIDEuMF0sXG4gICAgICAgIGVtaXNzaXZlQ29sb3IgICA6IFswLjAsIDAuMCwgMC4wXSxcbiAgICAgICAgdHJhbnNwYXJlbmN5ICAgIDogMC4wLFxuICAgICAgICBhbWJpZW50SW50ZW5zaXR5OiAwLjAsXG4gICAgICAgIHVzZVZlcnRleENvbG9yIDogZmFsc2VcbiAgICB9LFxuICAgIHNhbXBsZXJzOiB7XG4gICAgICAgIGRpZmZ1c2VUZXh0dXJlIDogbnVsbCxcbiAgICAgICAgZW1pc3NpdmVUZXh0dXJlIDogbnVsbFxuICAgIH0sXG4gICAgYXR0cmlidXRlczoge1xuICAgICAgICBub3JtYWwgOiB7XG4gICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICB0ZXhjb29yZDogbnVsbCxcbiAgICAgICAgY29sb3I6IG51bGxcbiAgICB9XG59KTtcbiIsIlhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcIm1hdHRlXCIsIHtcblxuICAgIHZlcnRleDogW1xuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIGNvbG9yO1wiLFxuXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdWZXJ0ZXhDb2xvcjtcIixcblxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgXCIgICBmcmFnVmVydGV4Q29sb3IgPSBjb2xvcjtcIixcbiAgICAgICAgXCIgICBnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50OiBbXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2VDb2xvcjtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgdXNlVmVydGV4Q29sb3I7XCIsXG5cbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgXCIgICAgdmVjMyBjb2xvciA9IGRpZmZ1c2VDb2xvcjtcIixcbiAgICAgICAgXCIgICAgaWYgKHVzZVZlcnRleENvbG9yKVwiLFxuICAgICAgICBcIiAgICAgICBjb2xvciAqPSAgZnJhZ1ZlcnRleENvbG9yO1wiLFxuICAgICAgICBcIiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KGNvbG9yLCAxLjApO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRpZmZ1c2VDb2xvciA6IFsxLjAsIDEuMCwgMS4wXSxcbiAgICAgICAgdXNlVmVydGV4Q29sb3I6IGZhbHNlXG4gICAgfSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIGNvbG9yOiBudWxsLFxuICAgICAgICBub3JtYWw6IG51bGwgLy8gRm9yIHBpY2tpbmdcbiAgICB9XG59KTtcblxuWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwiZmxhdFwiLCBYTUwzRC5tYXRlcmlhbHMuZ2V0U2NyaXB0KFwibWF0dGVcIikpO1xuIiwiWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwicGhvbmdcIiwge1xuXG4gICAgdmVydGV4IDogW1xuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIixcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBjb2xvcjtcIixcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiB0ZXhjb29yZDtcIixcblxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdFeWVWZWN0b3I7XCIsXG4gICAgICAgIFwidmFyeWluZyB2ZWMyIGZyYWdUZXhDb29yZDtcIixcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxuXG4gICAgICAgIFwiI2lmIChIQVNfUE9JTlRMSUdIVF9TSEFET1dNQVBTIHx8IEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFMgfHwgSEFTX1NQT1RMSUdIVF9TSEFET1dNQVBTKVwiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnV29ybGRQb3NpdGlvbjtcIiwgLy9uZWVkZWQgYnkgYW55IG9mIHRoZSBsaWdodCB0eXBlc1xuICAgICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1wiLFxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXG4gICAgICAgIFwidW5pZm9ybSBtYXQzIG1vZGVsVmlld01hdHJpeE47XCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGV5ZVBvc2l0aW9uO1wiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgXCIgICAgdmVjMyBwb3MgPSBwb3NpdGlvbjtcIixcbiAgICAgICAgXCIgICAgdmVjMyBub3JtID0gbm9ybWFsO1wiLFxuICAgICAgICBcIiAgICBnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvcywgMS4wKTtcIixcbiAgICAgICAgXCIgICAgZnJhZ05vcm1hbCA9IG5vcm1hbGl6ZShtb2RlbFZpZXdNYXRyaXhOICogbm9ybSk7XCIsXG4gICAgICAgIFwiICAgIGZyYWdWZXJ0ZXhQb3NpdGlvbiA9IChtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KHBvcywgMS4wKSkueHl6O1wiLFxuICAgICAgICBcIiAgICBmcmFnRXllVmVjdG9yID0gbm9ybWFsaXplKGZyYWdWZXJ0ZXhQb3NpdGlvbik7XCIsXG4gICAgICAgIFwiICAgIGZyYWdUZXhDb29yZCA9IHRleGNvb3JkO1wiLFxuICAgICAgICBcIiAgICBmcmFnVmVydGV4Q29sb3IgPSBjb2xvcjtcIixcbiAgICAgICAgXCIjaWYgKEhBU19QT0lOVExJR0hUX1NIQURPV01BUFMgfHwgSEFTX0RJUkVDVElPTkFMTElHSFRfU0hBRE9XTUFQUyB8fCBIQVNfU1BPVExJR0hUX1NIQURPV01BUFMpXCIsXG4gICAgICAgIFwiICAgIGZyYWdXb3JsZFBvc2l0aW9uID0gKG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKSkueHl6O1wiLFxuICAgICAgICBcIiNlbmRpZlwiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50IDogW1xuICAgICAgICBcInVuaWZvcm0gZmxvYXQgYW1iaWVudEludGVuc2l0eTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZUNvbG9yO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBlbWlzc2l2ZUNvbG9yO1wiLFxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgc2hpbmluZXNzO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcGVjdWxhckNvbG9yO1wiLFxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgdHJhbnNwYXJlbmN5O1wiLFxuICAgICAgICBcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLFxuICAgICAgICBcInVuaWZvcm0gYm9vbCB1c2VWZXJ0ZXhDb2xvcjtcIixcblx0XHRcInVuaWZvcm0gdmVjMyBjb29yZHM7XCIsXG5cbiAgICAgICAgXCIjaWYgSEFTX0VNSVNTSVZFVEVYVFVSRVwiLFxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlVGV4dHVyZTtcIixcbiAgICAgICAgXCIjZW5kaWZcIixcbiAgICAgICAgXCIjaWYgSEFTX0RJRkZVU0VURVhUVVJFXCIsXG4gICAgICAgIFwidW5pZm9ybSBzYW1wbGVyMkQgZGlmZnVzZVRleHR1cmU7XCIsXG4gICAgICAgIFwiI2VuZGlmXCIsXG4gICAgICAgIFwiI2lmIEhBU19TUEVDVUxBUlRFWFRVUkVcIixcbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBzcGVjdWxhclRleHR1cmU7XCIsXG4gICAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnRXllVmVjdG9yO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdWZXJ0ZXhDb2xvcjtcIixcblxuICAgICAgICBcIiNpZiAoSEFTX1BPSU5UTElHSFRfU0hBRE9XTUFQUyB8fCBIQVNfRElSRUNUSU9OQUxMSUdIVF9TSEFET1dNQVBTIHx8IEhBU19TUE9UTElHSFRfU0hBRE9XTUFQUylcIixcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1dvcmxkUG9zaXRpb247XCIsICAvL2lmIHRoZXJlIGlzIFNoYWRvdyB3ZSBuZWVkIHdvcmxkIHBvc2l0aW9uIGFuZCB1bnBhY2tpbmcgZnVuY3Rpb25cbiAgICAgICAgXCJmbG9hdCB1bnBhY2tEZXB0aCggY29uc3QgaW4gdmVjNCByZ2JhX2RlcHRoICkge1wiLFxuICAgICAgICBcIiAgY29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKiAyNTYuMCApLCAxLjAgLyAoIDI1Ni4wICogMjU2LjAgKSwgMS4wIC8gMjU2LjAsIDEuMCApO1wiLFxuICAgICAgICBcIiAgZmxvYXQgZGVwdGggPSBkb3QoIHJnYmFfZGVwdGgsIGJpdF9zaGlmdCApO1wiLFxuICAgICAgICBcIiAgcmV0dXJuIGRlcHRoO1wiLFxuICAgICAgICBcIn1cIixcbiAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICBcIiNpZiBNQVhfUE9JTlRMSUdIVFMgPiAwXCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHBvaW50TGlnaHRBdHRlbnVhdGlvbltNQVhfUE9JTlRMSUdIVFNdO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBwb2ludExpZ2h0UG9zaXRpb25bTUFYX1BPSU5UTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgcG9pbnRMaWdodEludGVuc2l0eVtNQVhfUE9JTlRMSUdIVFNdO1wiLFxuICAgICAgICBcInVuaWZvcm0gYm9vbCBwb2ludExpZ2h0T25bTUFYX1BPSU5UTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgcG9pbnRMaWdodENhc3RTaGFkb3dbTUFYX1BPSU5UTElHSFRTXTtcIixcbiAgICAgICAgICAgIFwiI2lmIEhBU19QT0lOVExJR0hUX1NIQURPV01BUFNcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBzYW1wbGVyQ3ViZSBwb2ludExpZ2h0U2hhZG93TWFwW01BWF9QT0lOVExJR0hUU107XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgcG9pbnRMaWdodFNoYWRvd0JpYXNbTUFYX1BPSU5UTElHSFRTXTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSB2ZWMyIHBvaW50TGlnaHROZWFyRmFyW01BWF9QT0lOVExJR0hUU107XCIsXG4gICAgICAgICAgICBcImZsb2F0IHZlY1RvRGVwdGgodmVjMyB2ZWMsIGZsb2F0IG4sIGZsb2F0IGYpe1wiLFxuICAgICAgICAgICAgICAgIFwidmVjMyBhYnNWZWMgPSBhYnModmVjKTtcIiArXG4gICAgICAgICAgICAgICAgXCJmbG9hdCBtYXhDb21wID0gbWF4KGFic1ZlYy54LCBtYXgoYWJzVmVjLnksIGFic1ZlYy56KSk7XCIsXG4gICAgICAgICAgICAgICAgXCJmbG9hdCByZXMgPSAoZituKS8oZi1uKS0oMi4wKmYqbikvKGYtbikvbWF4Q29tcDtcIixcbiAgICAgICAgICAgICAgICBcInJldHVybiByZXMqMC41KzAuNTtcIixcbiAgICAgICAgICAgIFwifVwiLFxuICAgICAgICAgICAgXCIjZW5kaWZcIixcbiAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICBcIiNpZiBNQVhfU1BPVExJR0hUUyA+IDBcIixcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0QXR0ZW51YXRpb25bTUFYX1NQT1RMSUdIVFNdO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBzcG90TGlnaHRQb3NpdGlvbltNQVhfU1BPVExJR0hUU107XCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIHNwb3RMaWdodEludGVuc2l0eVtNQVhfU1BPVExJR0hUU107XCIsXG4gICAgICAgIFwidW5pZm9ybSBib29sIHNwb3RMaWdodE9uW01BWF9TUE9UTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgc3BvdExpZ2h0RGlyZWN0aW9uW01BWF9TUE9UTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVtNQVhfU1BPVExJR0hUU107XCIsXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlW01BWF9TUE9UTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHNwb3RMaWdodFNvZnRuZXNzW01BWF9TUE9UTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgc3BvdExpZ2h0Q2FzdFNoYWRvd1tNQVhfU1BPVExJR0hUU107XCIsXG4gICAgICAgICAgICBcIiNpZiBIQVNfU1BPVExJR0hUX1NIQURPV01BUFNcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBtYXQ0IHNwb3RMaWdodE1hdHJpeFsgTUFYX1NQT1RMSUdIVFMgXTtcIiwvL3VzZWQgZm9yIHNoYWRvd21hcGNvb3JkIGNhbGN1bGF0aW9uXG4gICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHNwb3RMaWdodFNoYWRvd01hcFtNQVhfU1BPVExJR0hUU107XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gZmxvYXQgc3BvdExpZ2h0U2hhZG93Qmlhc1tNQVhfU1BPVExJR0hUU107XCIsXG4gICAgICAgICAgICBcIiNlbmRpZlwiLFxuICAgICAgICBcIiNlbmRpZlwiLFxuXG5cbiAgICAgICAgXCIjaWYgTUFYX0RJUkVDVElPTkFMTElHSFRTID4gMFwiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uW01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGRpcmVjdGlvbmFsTGlnaHRJbnRlbnNpdHlbTUFYX0RJUkVDVElPTkFMTElHSFRTXTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGJvb2wgZGlyZWN0aW9uYWxMaWdodE9uW01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXG4gICAgICAgIFwidW5pZm9ybSBib29sIGRpcmVjdGlvbmFsTGlnaHRDYXN0U2hhZG93W01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXG4gICAgICAgICAgICBcIiNpZiBIQVNfRElSRUNUSU9OQUxMSUdIVF9TSEFET1dNQVBTXCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gbWF0NCBkaXJlY3Rpb25hbExpZ2h0TWF0cml4W01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXG4gICAgICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXBbTUFYX0RJUkVDVElPTkFMTElHSFRTXTtcIixcbiAgICAgICAgICAgIFwidW5pZm9ybSBmbG9hdCBkaXJlY3Rpb25hbExpZ2h0U2hhZG93Qmlhc1tNQVhfRElSRUNUSU9OQUxMSUdIVFNdO1wiLFxuICAgICAgICAgICAgXCIjZW5kaWZcIixcbiAgICAgICAgXCIjZW5kaWZcIixcblxuXG5cdFx0XCJ1bmlmb3JtIHNhbXBsZXIyRCBzc2FvTWFwO1wiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgLy9jYWxjdWxhdGUgc2hhZG93bWFwIGNvb3JkcyAodmVjdG9yIGZvciBwb2ludGxpZ2h0KVxuICAgICAgICBcIiNpZiBNQVhfUE9JTlRMSUdIVFMgPiAwICYmIEhBU19QT0lOVExJR0hUX1NIQURPV01BUFNcIixcbiAgICAgICAgXCIgICAgdmVjMyBwb2ludExpZ2h0U2hhZG93TWFwRGlyZWN0aW9uW01BWF9QT0lOVExJR0hUU107XCIsXG4gICAgICAgIFwiICAgIGZvcihpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRMSUdIVFM7IGkrKykge1wiLFxuICAgICAgICBcIiAgICAgICBwb2ludExpZ2h0U2hhZG93TWFwRGlyZWN0aW9uW2ldID0gZnJhZ1dvcmxkUG9zaXRpb24gLSBwb2ludExpZ2h0UG9zaXRpb25baV07XCIsXG4gICAgICAgIFwiICAgIH1cIixcbiAgICAgICAgXCIjZW5kaWZcIixcbiAgICAgICAgXCIjaWYgTUFYX1NQT1RMSUdIVFMgPiAwICYmIEhBU19TUE9UTElHSFRfU0hBRE9XTUFQU1wiLFxuICAgICAgICBcIiAgICB2ZWM0IHNwb3RMaWdodFNoYWRvd01hcENvb3JkW01BWF9TUE9UTElHSFRTXTtcIixcbiAgICAgICAgXCIgICAgZm9yKGludCBpID0gMDsgaSA8IE1BWF9TUE9UTElHSFRTOyBpKyspIHtcIixcbiAgICAgICAgXCIgICAgICBzcG90TGlnaHRTaGFkb3dNYXBDb29yZFtpXSA9IHNwb3RMaWdodE1hdHJpeFtpXSAqIHZlYzQoZnJhZ1dvcmxkUG9zaXRpb24sIDEuMCk7XCIsXG4gICAgICAgIFwiICAgIH1cIixcbiAgICAgICAgXCIjZW5kaWZcIixcbiAgICAgICAgXCIjaWYgTUFYX0RJUkVDVElPTkFMTElHSFRTID4gMCAmJiBIQVNfRElSRUNUSU9OQUxMSUdIVF9TSEFET1dNQVBTXCIsXG4gICAgICAgIFwiICAgIHZlYzQgZGlyZWN0aW9uYWxMaWdodFNoYWRvd01hcENvb3JkW01BWF9ESVJFQ1RJT05BTExJR0hUU107XCIsXG4gICAgICAgIFwiICAgIGZvcihpbnQgaSA9IDA7IGkgPCBNQVhfRElSRUNUSU9OQUxMSUdIVFM7IGkrKykge1wiLFxuICAgICAgICBcIiAgICAgIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXBDb29yZFtpXSA9IGRpcmVjdGlvbmFsTGlnaHRNYXRyaXhbaV0gKiB2ZWM0KGZyYWdXb3JsZFBvc2l0aW9uLCAxLjApO1wiLFxuICAgICAgICBcIiAgICB9XCIsXG4gICAgICAgIFwiI2VuZGlmXCIsXG5cbiAgICAgICAgXCIgIGZsb2F0IGFscGhhID0gIG1heCgwLjAsIDEuMCAtIHRyYW5zcGFyZW5jeSk7XCIsXG4gICAgICAgIFwiICB2ZWMzIG9iakRpZmZ1c2UgPSBkaWZmdXNlQ29sb3I7XCIsXG4gICAgICAgIFwiICBpZih1c2VWZXJ0ZXhDb2xvcilcIixcbiAgICAgICAgXCIgICAgb2JqRGlmZnVzZSAqPSBmcmFnVmVydGV4Q29sb3I7XCIsXG4gICAgICAgIFwiICAjaWYgSEFTX0RJRkZVU0VURVhUVVJFXCIsXG4gICAgICAgIFwiICAgIHZlYzQgdGV4RGlmZnVzZSA9IHRleHR1cmUyRChkaWZmdXNlVGV4dHVyZSwgZnJhZ1RleENvb3JkKTtcIixcbiAgICAgICAgXCIgICAgYWxwaGEgKj0gdGV4RGlmZnVzZS5hO1wiLFxuICAgICAgICBcIiAgICBvYmpEaWZmdXNlICo9IHRleERpZmZ1c2UucmdiO1wiLFxuICAgICAgICBcIiAgI2VuZGlmXCIsXG4gICAgICAgIFwiICBpZiAoYWxwaGEgPCAwLjA1KSBkaXNjYXJkO1wiLFxuICAgICAgICBcIiAgI2lmIEhBU19FTUlTU0lWRVRFWFRVUkVcIixcbiAgICAgICAgXCIgICAgdmVjMyBjb2xvciA9IGVtaXNzaXZlQ29sb3IgKiB0ZXh0dXJlMkQoZW1pc3NpdmVUZXh0dXJlLCBmcmFnVGV4Q29vcmQpLnJnYiArIChhbWJpZW50SW50ZW5zaXR5ICogb2JqRGlmZnVzZSk7XCIsXG4gICAgICAgIFwiICAjZWxzZVwiLFxuICAgICAgICBcIiAgICB2ZWMzIGNvbG9yID0gZW1pc3NpdmVDb2xvciArIChhbWJpZW50SW50ZW5zaXR5ICogb2JqRGlmZnVzZSk7XCIsXG4gICAgICAgIFwiICAjZW5kaWZcIixcbiAgICAgICAgXCIgIHZlYzMgb2JqU3BlY3VsYXIgPSBzcGVjdWxhckNvbG9yO1wiLFxuICAgICAgICBcIiAgI2lmIEhBU19TUEVDVUxBUlRFWFRVUkVcIixcbiAgICAgICAgXCIgICAgb2JqU3BlY3VsYXIgPSBvYmpTcGVjdWxhciAqIHRleHR1cmUyRChzcGVjdWxhclRleHR1cmUsIGZyYWdUZXhDb29yZCkucmdiO1wiLFxuICAgICAgICBcIiAgI2VuZGlmXCIsXG5cdFx0XCIgICNpZiBIQVNfU1NBT01BUFwiLFxuXHRcdFwiXHQgZmxvYXQgc3NhbyA9IDEuMCAtIHRleHR1cmUyRChzc2FvTWFwLCBnbF9GcmFnQ29vcmQueHkgLyBjb29yZHMueHkpLnI7XCIsXG4gICAgICAgIFwiICAjZW5kaWZcIixcblxuICAgICAgICBcIiAgZmxvYXQgc2hhZG93SW5mbHVlbmNlID0gMC4wO1wiLCAvL3VzZWQgZm9yIHNhbXBsaW5nIHNoYWRvd1xuXG5cdFx0XCIjaWYgTUFYX1BPSU5UTElHSFRTID4gMFwiLFxuICAgICAgICBcIiAgZm9yIChpbnQgaSA9IDA7IGkgPCBNQVhfUE9JTlRMSUdIVFM7IGkrKykge1wiLFxuICAgICAgICBcIiAgICBzaGFkb3dJbmZsdWVuY2UgPSAxLjA7XCIsXG4gICAgICAgIFwiICAgIGlmKHBvaW50TGlnaHRPbltpXSl7XCIsXG4gICAgICAgIFwiICAgI2lmIEhBU19QT0lOVExJR0hUX1NIQURPV01BUFNcIixcbiAgICAgICAgXCIgICAgICAgaWYocG9pbnRMaWdodENhc3RTaGFkb3dbaV0pe1wiLFxuICAgICAgICBcIiAgICAgICAgICAgc2hhZG93SW5mbHVlbmNlID0gMC4wO1wiLFxuICAgICAgICBcIiAgICAgICAgICAgZmxvYXQgbHNEZXB0aCA9IHZlY1RvRGVwdGgocG9pbnRMaWdodFNoYWRvd01hcERpcmVjdGlvbltpXSwgcG9pbnRMaWdodE5lYXJGYXJbaV0ueCwgcG9pbnRMaWdodE5lYXJGYXJbaV0ueSApO1wiLFxuICAgICAgICBcIlx0XHQgICAgZmxvYXQgZGVwdGggPSB1bnBhY2tEZXB0aCggdGV4dHVyZUN1YmUocG9pbnRMaWdodFNoYWRvd01hcFtpXSwgcG9pbnRMaWdodFNoYWRvd01hcERpcmVjdGlvbltpXSkpICsgIHBvaW50TGlnaHRTaGFkb3dCaWFzW2ldO1wiLFxuICAgICAgICBcIiAgICAgICAgICAgaWYobHNEZXB0aCA8IGRlcHRoKVwiLFxuICAgICAgICBcIiAgICAgICAgICAgICAgIHNoYWRvd0luZmx1ZW5jZSA9IDEuMDtcIixcbiAgICAgICAgXCIgICAgICAgfVwiLFxuICAgICAgICBcIiAgICAgICBpZihzaGFkb3dJbmZsdWVuY2UgPiAwLjApe1wiLFxuICAgICAgICBcIiAgICNlbmRpZlwiLFxuICAgICAgICBcIiAgICAgICB2ZWM0IGxQb3NpdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KCBwb2ludExpZ2h0UG9zaXRpb25bIGkgXSwgMS4wICk7XCIsXG4gICAgICAgIFwiICAgICAgIHZlYzMgTCA9IGxQb3NpdGlvbi54eXogLSBmcmFnVmVydGV4UG9zaXRpb247XCIsXG4gICAgICAgIFwiICAgICAgIGZsb2F0IGRpc3QgPSBsZW5ndGgoTCk7XCIsXG4gICAgICAgIFwiICAgICAgIEwgPSBub3JtYWxpemUoTCk7XCIsXG4gICAgICAgIFwiICAgICAgIHZlYzMgUiA9IG5vcm1hbGl6ZShyZWZsZWN0KEwsZnJhZ05vcm1hbCkpO1wiLFxuICAgICAgICBcIiAgICAgICBmbG9hdCBhdHRlbiA9IDEuMCAvIChwb2ludExpZ2h0QXR0ZW51YXRpb25baV0ueCArIHBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS55ICogZGlzdCArIHBvaW50TGlnaHRBdHRlbnVhdGlvbltpXS56ICogZGlzdCAqIGRpc3QpO1wiLFxuICAgICAgICBcIiAgICAgICB2ZWMzIElkaWZmID0gcG9pbnRMaWdodEludGVuc2l0eVtpXSAqIG9iakRpZmZ1c2UgKiBtYXgoZG90KGZyYWdOb3JtYWwsTCksMC4wKTtcIixcblx0XHRcIiAgICNpZiBIQVNfU1NBT01BUFwiLFxuXHRcdFwiICAgICAgIElkaWZmICo9IHNzYW87XCIsXG5cdFx0XCIgICAjZW5kaWZcIixcbiAgICAgICAgXCIgICAgICAgdmVjMyBJc3BlYyA9IHBvaW50TGlnaHRJbnRlbnNpdHlbaV0gKiBvYmpTcGVjdWxhciAqIHBvdyhtYXgoZG90KFIsZnJhZ0V5ZVZlY3RvciksMC4wKSwgc2hpbmluZXNzKjEyOC4wKTtcIixcbiAgICAgICAgXCIgICAgICAgY29sb3IgPSBjb2xvciArIChhdHRlbipzaGFkb3dJbmZsdWVuY2UqKElkaWZmICsgSXNwZWMpKTtcIixcbiAgICAgICAgXCIgICAjaWYgSEFTX1BPSU5UTElHSFRfU0hBRE9XTUFQU1wiLFxuICAgICAgICBcIiAgICAgICB9XCIsICAvL3BvaW50bGlnaHQgdmlzaWJsZVxuICAgICAgICBcIiAgICNlbmRpZlwiLFxuICAgICAgICBcIiAgICAgfVwiLCAvL3BvaW50TGlnaHQgb25cbiAgICAgICAgXCIgIH1cIiwgLy9wb2ludExpZ2h0IGxvb3BcbiAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICBcIiNpZiBNQVhfU1BPVExJR0hUUyA+IDBcIixcbiAgICAgICAgXCIgIGZvciAoaW50IGk9MDsgaTxNQVhfU1BPVExJR0hUUzsgaSsrKSB7XCIsXG4gICAgICAgIFwiICAgIHNoYWRvd0luZmx1ZW5jZSA9IDEuMDtcIixcbiAgICAgICAgXCIgICAgaWYoc3BvdExpZ2h0T25baV0pIHtcIixcbiAgICAgICAgXCIgICNpZiBIQVNfU1BPVExJR0hUX1NIQURPV01BUFNcIixcbiAgICAgICAgXCIgICAgICAgaWYoc3BvdExpZ2h0Q2FzdFNoYWRvd1tpXSl7XCIsXG4gICAgICAgIFwiICAgICAgICAgICBzaGFkb3dJbmZsdWVuY2UgPSAwLjA7XCIsXG4gICAgICAgIFwiICAgICAgICAgICB2ZWM0IGxzcG9zID0gc3BvdExpZ2h0U2hhZG93TWFwQ29vcmRbaV07XCIsXG4gICAgICAgIFwiXHRcdFx0dmVjMyBwZXJzcGVjdGl2ZURpdlBvcyA9IGxzcG9zLnh5eiAvIGxzcG9zLncgKiAwLjUgKyAwLjU7XCIsXG4gICAgICAgIFwiXHRcdFx0ZmxvYXQgbHNEZXB0aCA9IHBlcnNwZWN0aXZlRGl2UG9zLno7XCIsXG4gICAgICAgIFwiXHRcdFx0dmVjMiBsaWdodHV2ID0gcGVyc3BlY3RpdmVEaXZQb3MueHk7XCIsXG4gICAgICAgIFwiXHRcdFx0ZmxvYXQgZGVwdGggPSB1bnBhY2tEZXB0aCh0ZXh0dXJlMkQoc3BvdExpZ2h0U2hhZG93TWFwW2ldLCBsaWdodHV2KSkgKyBzcG90TGlnaHRTaGFkb3dCaWFzW2ldO1wiLFxuICAgICAgICBcIiAgICAgICAgICAgaWYobHNEZXB0aCA8IGRlcHRoKVwiLFxuICAgICAgICBcIiAgICAgICAgICAgICAgIHNoYWRvd0luZmx1ZW5jZSA9IDEuMDtcIixcbiAgICAgICAgXCIgICAgICAgfVwiLFxuICAgICAgICBcIiAgICAgICBpZihzaGFkb3dJbmZsdWVuY2UgPiAwLjApe1wiLFxuICAgICAgICBcIiAgI2VuZGlmXCIsXG4gICAgICAgIFwiICAgICAgIHZlYzQgbFBvc2l0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoIHNwb3RMaWdodFBvc2l0aW9uWyBpIF0sIDEuMCApO1wiLFxuICAgICAgICBcIiAgICAgICB2ZWMzIEwgPSBsUG9zaXRpb24ueHl6IC0gZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxuICAgICAgICBcIiAgICAgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKEwpO1wiLFxuICAgICAgICBcIiAgICAgICBMID0gbm9ybWFsaXplKEwpO1wiLFxuICAgICAgICBcIiAgICAgICB2ZWMzIFIgPSBub3JtYWxpemUocmVmbGVjdChMLGZyYWdOb3JtYWwpKTtcIixcbiAgICAgICAgXCIgICAgICAgZmxvYXQgYXR0ZW4gPSAxLjAgLyAoc3BvdExpZ2h0QXR0ZW51YXRpb25baV0ueCArIHNwb3RMaWdodEF0dGVudWF0aW9uW2ldLnkgKiBkaXN0ICsgc3BvdExpZ2h0QXR0ZW51YXRpb25baV0ueiAqIGRpc3QgKiBkaXN0KTtcIixcbiAgICAgICAgXCIgICAgICAgdmVjMyBJZGlmZiA9IHNwb3RMaWdodEludGVuc2l0eVtpXSAqIG9iakRpZmZ1c2UgKiBtYXgoZG90KGZyYWdOb3JtYWwsTCksMC4wKTtcIixcbiAgICAgICAgXCIgICAjaWYgSEFTX1NTQU9NQVBcIixcbiAgICAgICAgXCJcdCAgICBJZGlmZiAqPSBzc2FvO1wiLFxuICAgICAgICBcIiAgICNlbmRpZlwiLFxuICAgICAgICBcIiAgICAgICB2ZWMzIElzcGVjID0gc3BvdExpZ2h0SW50ZW5zaXR5W2ldICogb2JqU3BlY3VsYXIgKiBwb3cobWF4KGRvdChSLGZyYWdFeWVWZWN0b3IpLDAuMCksIHNoaW5pbmVzcyoxMjguMCk7XCIsXG4gICAgICAgIFwiICAgICAgIHZlYzQgbERpcmVjdGlvbiA9IHZpZXdNYXRyaXggKiB2ZWM0KC1zcG90TGlnaHREaXJlY3Rpb25baV0sIDAuMCk7XCIsXG4gICAgICAgIFwiICAgICAgIHZlYzMgRCA9IG5vcm1hbGl6ZShsRGlyZWN0aW9uLnh5eik7XCIsXG4gICAgICAgIFwiICAgICAgIGZsb2F0IGFuZ2xlID0gZG90KEwsIEQpO1wiLFxuICAgICAgICBcIiAgICAgICBpZihhbmdsZSA+IHNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVtpXSkge1wiLFxuICAgICAgICBcIiAgICAgICAgICAgZmxvYXQgc29mdG5lc3MgPSAxLjA7XCIsXG4gICAgICAgIFwiICAgICAgICAgICBpZiAoYW5nbGUgPCBzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlW2ldKVwiLFxuICAgICAgICBcIiAgICAgICAgICAgICAgIHNvZnRuZXNzID0gKGFuZ2xlIC0gc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlW2ldKSAvICAoc3BvdExpZ2h0Q29zU29mdEZhbGxvZmZBbmdsZVtpXSAtICBzcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGVbaV0pO1wiLFxuICAgICAgICBcIiAgICAgICAgICAgY29sb3IgKz0gYXR0ZW4qc29mdG5lc3Mqc2hhZG93SW5mbHVlbmNlKihJZGlmZiArIElzcGVjKTtcIixcbiAgICAgICAgXCIgICAgICAgfVwiLFxuICAgICAgICBcIiAgICNpZiBIQVNfU1BPVExJR0hUX1NIQURPV01BUFNcIixcbiAgICAgICAgXCIgICAgICAgfVwiLCAvL2xpZ2h0IHZpc2libGUgaWYgc2hhZG93IGVuYWJsZWRcbiAgICAgICAgXCIgICAjZW5kaWZcIixcbiAgICAgICAgXCIgICB9IFwiLCAvLyBzcG90bGlnaHQgb25cbiAgICAgICAgXCIgIH1cIiwgLy8gbGlnaHQgbG9vcFxuICAgICAgICBcIiNlbmRpZlwiLFxuXG4gICAgICAgIFwiI2lmIE1BWF9ESVJFQ1RJT05BTExJR0hUUyA+IDBcIixcbiAgICAgICAgXCIgIGZvciAoaW50IGk9MDsgaTxNQVhfRElSRUNUSU9OQUxMSUdIVFM7IGkrKykge1wiLFxuICAgICAgICBcIiAgIHNoYWRvd0luZmx1ZW5jZSA9IDEuMDtcIixcbiAgICAgICAgXCIgICBpZihkaXJlY3Rpb25hbExpZ2h0T25baV0pe1wiLFxuICAgICAgICBcIiAgICNpZiBIQVNfRElSRUNUSU9OQUxMSUdIVF9TSEFET1dNQVBTXCIsXG4gICAgICAgIFwiICAgICAgIGlmKGRpcmVjdGlvbmFsTGlnaHRDYXN0U2hhZG93W2ldKXtcIixcbiAgICAgICAgXCIgICAgICAgICAgIHNoYWRvd0luZmx1ZW5jZSA9IDAuMDtcIixcbiAgICAgICAgXCIgICAgICAgICAgIHZlYzQgbHNwb3MgPSBkaXJlY3Rpb25hbExpZ2h0U2hhZG93TWFwQ29vcmRbaV07XCIsXG4gICAgICAgIFwiICAgICAgICAgICB2ZWMzIG9ydGhvZ29uYWxEaXZQb3MgPSBsc3Bvcy54eXogLyBsc3Bvcy53ICowLjUgKyAwLjU7XCIsXG4gICAgICAgIFwiICAgICAgICAgICBmbG9hdCBsc0RlcHRoID0gb3J0aG9nb25hbERpdlBvcy56O1wiLFxuICAgICAgICBcIiAgICAgICAgICAgdmVjMiBsaWdodHV2ID0gb3J0aG9nb25hbERpdlBvcy54eTtcIixcbiAgICAgICAgXCIgICAgICAgICAgICAgICBmbG9hdCBkZXB0aCA9IHVucGFja0RlcHRoKHRleHR1cmUyRChkaXJlY3Rpb25hbExpZ2h0U2hhZG93TWFwW2ldLCBsaWdodHV2KSkrZGlyZWN0aW9uYWxMaWdodFNoYWRvd0JpYXNbaV07XCIsXG4gICAgICAgIFwiICAgICAgICAgICAgICAgaWYobHNEZXB0aCA8IGRlcHRoKSBzaGFkb3dJbmZsdWVuY2UgPSAxLjA7XCIsXG4gICAgICAgIFwiICAgICAgIH1cIixcbiAgICAgICAgXCIgICAgICAgaWYoc2hhZG93SW5mbHVlbmNlID4gMC4wKXtcIixcbiAgICAgICAgXCIgICAjZW5kaWZcIixcbiAgICAgICAgXCIgICAgICAgdmVjNCBsRGlyZWN0aW9uID0gdmlld01hdHJpeCAqIHZlYzQoZGlyZWN0aW9uYWxMaWdodERpcmVjdGlvbltpXSwgMC4wKTtcIixcbiAgICAgICAgXCIgICAgICAgdmVjMyBMID0gIG5vcm1hbGl6ZSgtbERpcmVjdGlvbi54eXopO1wiLFxuICAgICAgICBcIiAgICAgICB2ZWMzIFIgPSBub3JtYWxpemUocmVmbGVjdChMLGZyYWdOb3JtYWwpKTtcIixcbiAgICAgICAgXCIgICAgICAgdmVjMyBJZGlmZiA9IGRpcmVjdGlvbmFsTGlnaHRJbnRlbnNpdHlbaV0gKiBvYmpEaWZmdXNlICogbWF4KGRvdChmcmFnTm9ybWFsLEwpLDAuMCk7XCIsXG5cdFx0XCIgICAjaWYgSEFTX1NTQU9NQVBcIixcblx0XHRcIiAgICAgICBJZGlmZiAqPSBzc2FvO1wiLFxuXHRcdFwiICAgI2VuZGlmXCIsXG4gICAgICAgIFwiICAgICAgIHZlYzMgSXNwZWMgPSBkaXJlY3Rpb25hbExpZ2h0SW50ZW5zaXR5W2ldICogb2JqU3BlY3VsYXIgKiBwb3cobWF4KGRvdChSLGZyYWdFeWVWZWN0b3IpLDAuMCksIHNoaW5pbmVzcyoxMjguMCk7XCIsXG4gICAgICAgIFwiICAgICAgIGNvbG9yID0gY29sb3IgKyBzaGFkb3dJbmZsdWVuY2UqKChJZGlmZiArIElzcGVjKSk7XCIsXG4gICAgICAgIFwiICAgI2lmIEhBU19ESVJFQ1RJT05BTExJR0hUX1NIQURPV01BUFNcIixcbiAgICAgICAgXCIgICAgICAgfVwiLCAvL2xpZ2h0IHZpc2libGVcbiAgICAgICAgXCIgICAjZW5kaWZcIixcbiAgICAgICAgXCIgICB9XCIsIC8vZGlyTGlnaHQgb25cbiAgICAgICAgXCIgIH1cIiwgLy8gZGlyTGlnaHQgbG9vcFxuICAgICAgICBcIiNlbmRpZlwiLFxuICAgICAgICBcIiAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgYWxwaGEpO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGFkZERpcmVjdGl2ZXM6IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBsaWdodHMsIHBhcmFtcykge1xuICAgICAgICBbXCJwb2ludFwiLCBcImRpcmVjdGlvbmFsXCIsIFwic3BvdFwiXS5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICB2YXIgbnVtTGlnaHRzID0gbGlnaHRzLmdldE1vZGVsQ291bnQodHlwZSk7XG4gICAgICAgICAgICB2YXIgY2FzdFNoYWRvd3MgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmKG51bUxpZ2h0cykge1xuICAgICAgICAgICAgICAgIGNhc3RTaGFkb3dzID0gQXJyYXkucHJvdG90eXBlLnNvbWUuY2FsbChsaWdodHMuZ2V0TW9kZWxFbnRyeSh0eXBlKS5wYXJhbWV0ZXJzW1wiY2FzdFNoYWRvd1wiXSwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIk1BWF9cIiArIHR5cGUudG9VcHBlckNhc2UoKSArIFwiTElHSFRTIFwiICsgbnVtTGlnaHRzKTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIkhBU19cIiArIHR5cGUudG9VcHBlckNhc2UoKSArIFwiTElHSFRfU0hBRE9XTUFQUyBcIiArIChjYXN0U2hhZG93cyA/IDEgOiAwKSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIkhBU19ESUZGVVNFVEVYVFVSRSBcIiArICgnZGlmZnVzZVRleHR1cmUnIGluIHBhcmFtcyA/IFwiMVwiIDogXCIwXCIpKTtcbiAgICAgICAgZGlyZWN0aXZlcy5wdXNoKFwiSEFTX1NQRUNVTEFSVEVYVFVSRSBcIiArICgnc3BlY3VsYXJUZXh0dXJlJyBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XG4gICAgICAgIGRpcmVjdGl2ZXMucHVzaChcIkhBU19FTUlTU0lWRVRFWFRVUkUgXCIgKyAoJ2VtaXNzaXZlVGV4dHVyZScgaW4gcGFyYW1zID8gXCIxXCIgOiBcIjBcIikpO1xuICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfU1NBT01BUCBcIiArIChYTUwzRC5vcHRpb25zLmdldFZhbHVlKFwicmVuZGVyZXItc3Nhb1wiKSA/IFwiMVwiIDogXCIwXCIpKTtcbiAgICB9LFxuICAgIGhhc1RyYW5zcGFyZW5jeTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBwYXJhbXMudHJhbnNwYXJlbmN5ICYmIHBhcmFtcy50cmFuc3BhcmVuY3kuZ2V0VmFsdWUoKVswXSA+IDAuMDAxO1xuICAgIH0sXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgICAgZGlmZnVzZUNvbG9yICAgIDogWzEuMCwgMS4wLCAxLjBdLFxuICAgICAgICBlbWlzc2l2ZUNvbG9yICAgOiBbMC4wLCAwLjAsIDAuMF0sXG4gICAgICAgIHNwZWN1bGFyQ29sb3IgICA6IFswLjAsIDAuMCwgMC4wXSxcbiAgICAgICAgdHJhbnNwYXJlbmN5ICAgIDogMC4wLFxuICAgICAgICBzaGluaW5lc3MgICAgICAgOiAwLjIsXG4gICAgICAgIGFtYmllbnRJbnRlbnNpdHk6IDAuMCxcbiAgICAgICAgdXNlVmVydGV4Q29sb3IgOiBmYWxzZVxuICAgIH0sXG5cbiAgICBzYW1wbGVyczoge1xuICAgICAgICBkaWZmdXNlVGV4dHVyZSA6IG51bGwsXG4gICAgICAgIGVtaXNzaXZlVGV4dHVyZSA6IG51bGwsXG4gICAgICAgIHNwZWN1bGFyVGV4dHVyZSA6IG51bGwsXG4gICAgICAgIGRpcmVjdGlvbmFsTGlnaHRTaGFkb3dNYXAgOiBudWxsLFxuICAgICAgICBzcG90TGlnaHRTaGFkb3dNYXAgOiBudWxsLFxuICAgICAgICBwb2ludExpZ2h0U2hhZG93TWFwIDogbnVsbCxcblx0XHRzc2FvTWFwOiBudWxsXG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgbm9ybWFsIDoge1xuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgdGV4Y29vcmQ6IG51bGwsXG4gICAgICAgIGNvbG9yOiBudWxsXG4gICAgfVxufSk7XG4iLCJYTUwzRC5tYXRlcmlhbHMucmVnaXN0ZXIoXCJwb2ludFwiLCB7XG5cbiAgICB2ZXJ0ZXggOiBbXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgY29sb3I7XCIsXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzIgdGV4Y29vcmQ7XCIsXG5cbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleFBvc2l0aW9uO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnRXllVmVjdG9yO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMiBmcmFnVGV4Q29vcmQ7XCIsXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdWZXJ0ZXhDb2xvcjtcIixcblxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdNYXRyaXg7XCIsXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IHByb2plY3Rpb25NYXRyaXg7XCIsXG4gICAgICAgIFwidW5pZm9ybSBtYXQzIG1vZGVsVmlld01hdHJpeE47XCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMzIGV5ZVBvc2l0aW9uO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBjb29yZHM7XCIsXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCBwb2ludFNpemU7XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxuICAgICAgICBcIiAgICB2ZWMzIHBvcyA9IHBvc2l0aW9uO1wiLFxuXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zLCAxLjApO1wiLFxuICAgICAgICBcIiAgICBmcmFnVmVydGV4UG9zaXRpb24gPSAobW9kZWxWaWV3TWF0cml4ICogdmVjNChwb3MsIDEuMCkpLnh5ejtcIixcbiAgICAgICAgXCIgICAgZnJhZ0V5ZVZlY3RvciA9IG5vcm1hbGl6ZShmcmFnVmVydGV4UG9zaXRpb24pO1wiLFxuICAgICAgICBcIiAgICBmcmFnVGV4Q29vcmQgPSB0ZXhjb29yZDtcIixcbiAgICAgICAgXCIgICAgZnJhZ1ZlcnRleENvbG9yID0gY29sb3I7XCIsXG4gICAgICAgIFwiICAgIHZlYzQgcG9zMiA9IHZlYzQoZnJhZ1ZlcnRleFBvc2l0aW9uLCAxLjApOyBwb3MyLnggKz0gcG9pbnRTaXplO1wiLFxuICAgICAgICBcIiAgICBnbF9Qb2ludFNpemUgPSBkaXN0YW5jZSggZ2xfUG9zaXRpb24ueHksIChwcm9qZWN0aW9uTWF0cml4ICogcG9zMikueHkgKSAqIGNvb3Jkcy54IC8gZ2xfUG9zaXRpb24udztcIixcbiAgICAgICAgXCJ9XCJcbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBmcmFnbWVudCA6IFtcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZUNvbG9yO1wiLFxuICAgICAgICBcInVuaWZvcm0gZmxvYXQgdHJhbnNwYXJlbmN5O1wiLFxuICAgICAgICBcInVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1wiLFxuICAgICAgICBcInVuaWZvcm0gYm9vbCB1c2VWZXJ0ZXhDb2xvcjtcIixcbiAgICAgICAgXCJ1bmlmb3JtIHZlYzIgdGV4Q29vcmRPZmZzZXQ7XCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMyIHRleENvb3JkU2l6ZTtcIixcblxuICAgICAgICBcIiNpZiBIQVNfRElGRlVTRVRFWFRVUkVcIixcbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBkaWZmdXNlVGV4dHVyZTtcIixcbiAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnVmVydGV4UG9zaXRpb247XCIsXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdFeWVWZWN0b3I7XCIsXG4gICAgICAgIFwidmFyeWluZyB2ZWMyIGZyYWdUZXhDb29yZDtcIixcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ1ZlcnRleENvbG9yO1wiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgXCIgIGZsb2F0IGFscGhhID0gIG1heCgwLjAsIDEuMCAtIHRyYW5zcGFyZW5jeSk7XCIsXG4gICAgICAgIFwiICB2ZWMzIG9iakRpZmZ1c2UgPSBkaWZmdXNlQ29sb3I7XCIsXG4gICAgICAgIFwiICBpZih1c2VWZXJ0ZXhDb2xvcilcIixcbiAgICAgICAgXCIgICAgb2JqRGlmZnVzZSAqPSBmcmFnVmVydGV4Q29sb3I7XCIsXG4gICAgICAgIFwiICAjaWYgSEFTX0RJRkZVU0VURVhUVVJFXCIsXG4gICAgICAgIFwiICAgIHZlYzIgdGV4Q29vcmQgPSBmcmFnVGV4Q29vcmQgKyB0ZXhDb29yZE9mZnNldCArIGdsX1BvaW50Q29vcmQqdGV4Q29vcmRTaXplO1wiLFxuICAgICAgICBcIiAgICB0ZXhDb29yZC55ID0gMS4wIC0gdGV4Q29vcmQueTtcIixcbiAgICAgICAgXCIgICAgdmVjNCB0ZXhEaWZmdXNlID0gdGV4dHVyZTJEKGRpZmZ1c2VUZXh0dXJlLCB0ZXhDb29yZCk7XCIsXG4gICAgICAgIFwiICAgIGFscGhhICo9IHRleERpZmZ1c2UuYTtcIixcbiAgICAgICAgXCIgICAgb2JqRGlmZnVzZSAqPSB0ZXhEaWZmdXNlLnJnYjtcIixcbiAgICAgICAgXCIgICNlbmRpZlwiLFxuICAgICAgICBcIiAgaWYgKGFscGhhIDwgMC4wNSkgZGlzY2FyZDtcIixcbiAgICAgICAgXCIgIGdsX0ZyYWdDb2xvciA9IHZlYzQob2JqRGlmZnVzZSwgYWxwaGEpO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcbiAgICBhZGREaXJlY3RpdmVzOiBmdW5jdGlvbihkaXJlY3RpdmVzLCBsaWdodHMsIHBhcmFtcykge1xuICAgICAgICBkaXJlY3RpdmVzLnB1c2goXCJIQVNfRElGRlVTRVRFWFRVUkUgXCIgKyAoJ2RpZmZ1c2VUZXh0dXJlJyBpbiBwYXJhbXMgPyBcIjFcIiA6IFwiMFwiKSk7XG4gICAgfSxcbiAgICBoYXNUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gcGFyYW1zLnRyYW5zcGFyZW5jeSAmJiBwYXJhbXMudHJhbnNwYXJlbmN5LmdldFZhbHVlKClbMF0gPiAwLjAwMTtcbiAgICB9LFxuICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGRpZmZ1c2VDb2xvcjogWzEuMCwgMS4wLCAxLjBdLFxuICAgICAgICB0ZXhDb29yZE9mZnNldDogWzAsIDBdLFxuICAgICAgICB0ZXhDb29yZFNpemU6IFsxLCAxXSxcbiAgICAgICAgdHJhbnNwYXJlbmN5OiAwLjAsXG4gICAgICAgIHVzZVZlcnRleENvbG9yOiBmYWxzZSxcbiAgICAgICAgcG9pbnRTaXplOiAxLjBcbiAgICB9LFxuICAgIHNhbXBsZXJzOiB7XG4gICAgICAgIGRpZmZ1c2VUZXh0dXJlOiBudWxsXG4gICAgfSxcbiAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHRleGNvb3JkOiBudWxsLFxuICAgICAgICBjb2xvcjogbnVsbFxuICAgIH1cbn0pO1xuIiwidmFyIGNfZ2xvYmFsU2NyaXB0cyA9IHt9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAobmFtZSwgc2NyaXB0KSB7XG4gICAgICAgIGNfZ2xvYmFsU2NyaXB0c1tuYW1lXSA9IHNjcmlwdDtcbiAgICAgICAgc2NyaXB0Lm5hbWUgPSBuYW1lO1xuICAgIH0sXG5cbiAgICBnZXRTY3JpcHQ6IGZ1bmN0aW9uIChzY3JpcHQpIHtcbiAgICAgICAgcmV0dXJuIGNfZ2xvYmFsU2NyaXB0c1tzY3JpcHRdO1xuICAgIH1cbn07XG4iLCJ2YXIgU2hhZGVyRGVzY3JpcHRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVuaWZvcm1zID0ge307XG4gICAgdGhpcy5zYW1wbGVycyA9IHt9O1xuICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xuICAgIHRoaXMubmFtZSA9IFwiXCI7XG4gICAgdGhpcy5mcmFnbWVudCA9IFwiXCI7XG4gICAgdGhpcy52ZXJ0ZXggPSBcIlwiO1xufTtcblNoYWRlckRlc2NyaXB0b3IucHJvdG90eXBlLmFkZERpcmVjdGl2ZXMgPSBmdW5jdGlvbiAoKSB7XG59O1xuU2hhZGVyRGVzY3JpcHRvci5wcm90b3R5cGUuaGFzVHJhbnNwYXJlbmN5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyRGVzY3JpcHRvcjtcbiIsInZhciBBYnN0cmFjdFNoYWRlckNsb3N1cmUgPSByZXF1aXJlKFwiLi8uLi9hYnN0cmFjdHNoYWRlcmNsb3N1cmUuanNcIik7XG52YXIgU3lzdGVtTm90aWZpZXIgPSByZXF1aXJlKFwiLi4vLi4vc3lzdGVtL3N5c3RlbS1ub3RpZmllci5qc1wiKTtcblxuLyoqXG4gKiBBIFNoYWRlckNsb3N1cmUgY29ubmVjdHMgYSBtZXNoLXNwZWNpZmljIEdMUHJvZ3JhbSB3aXRoIGl0J3MgWGZsb3cgZGF0YVxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSBkZXNjcmlwdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNoYWRlckNsb3N1cmUgPSBmdW5jdGlvbiAoY29udGV4dCwgZGVzY3JpcHRvcikge1xuICAgIEFic3RyYWN0U2hhZGVyQ2xvc3VyZS5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICAgIHRoaXMuZGVzY3JpcHRvciA9IGRlc2NyaXB0b3I7XG59O1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhTaGFkZXJDbG9zdXJlLCBBYnN0cmFjdFNoYWRlckNsb3N1cmUpO1xuXG5YTUwzRC5leHRlbmQoU2hhZGVyQ2xvc3VyZS5wcm90b3R5cGUsIHtcblxuICAgIHNldERlZmF1bHRVbmlmb3JtczogZnVuY3Rpb24gKGRlc3QpIHtcbiAgICAgICAgWE1MM0QuZXh0ZW5kKGRlc3QsIHRoaXMuZGVzY3JpcHRvci51bmlmb3Jtcyk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVNvdXJjZXM6IGZ1bmN0aW9uIChzY2VuZSwgc2hhZGVyRGF0YSwgdnNSZXF1ZXN0KSB7XG5cbiAgICAgICAgdmFyIG9iamVjdERhdGEgPSB2c1JlcXVlc3QgJiYgdnNSZXF1ZXN0LmdldFJlc3VsdCgpO1xuICAgICAgICB2YXIgZGlyZWN0aXZlcyA9IFtdO1xuXG4gICAgICAgIHZhciBpbnB1dERhdGEgPSB7fTtcbiAgICAgICAgc2hhZGVyRGF0YSAmJiBYTUwzRC5leHRlbmQoaW5wdXREYXRhLCBzaGFkZXJEYXRhLmdldE91dHB1dE1hcCgpKTtcbiAgICAgICAgb2JqZWN0RGF0YSAmJiBYTUwzRC5leHRlbmQoaW5wdXREYXRhLCBvYmplY3REYXRhLmdldE91dHB1dE1hcCgpKTtcblxuXG4gICAgICAgIGZvciAodmFyIGF0dHJOYW1lIGluIHRoaXMuZGVzY3JpcHRvci5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmRlc2NyaXB0b3IuYXR0cmlidXRlc1thdHRyTmFtZV07XG4gICAgICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkucmVxdWlyZWQgJiYgIWlucHV0RGF0YVthdHRyTmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNZXNoIGlzIG1pc3NpbmcgJ1wiICsgYXR0ck5hbWUgKyBcIicgYXR0cmlidXRlLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVzY3JpcHRvci5hZGREaXJlY3RpdmVzKGRpcmVjdGl2ZXMsIHNjZW5lLmxpZ2h0cyB8fCB7fSwgaW5wdXREYXRhKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSB7XG4gICAgICAgICAgICBmcmFnbWVudDogdGhpcy5hZGREaXJlY3RpdmVzVG9Tb3VyY2UoZGlyZWN0aXZlcywgdGhpcy5kZXNjcmlwdG9yLmZyYWdtZW50KSxcbiAgICAgICAgICAgIHZlcnRleDogdGhpcy5hZGREaXJlY3RpdmVzVG9Tb3VyY2UoZGlyZWN0aXZlcywgdGhpcy5kZXNjcmlwdG9yLnZlcnRleClcbiAgICAgICAgfTtcblxuICAgICAgICBTeXN0ZW1Ob3RpZmllci5zZW5kRXZlbnQoJ3VybnNoYWRlcicsIHtcbiAgICAgICAgICAgIHVybnNoYWRlclR5cGU6IFwiY29kZVwiLCB2ZXJ0ZXhTaGFkZXI6IHRoaXMuc291cmNlLnZlcnRleCwgZnJhZ21lbnRTaGFkZXI6IHRoaXMuc291cmNlLmZyYWdtZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBhZGREaXJlY3RpdmVzVG9Tb3VyY2U6IGZ1bmN0aW9uIChkaXJlY3RpdmVzLCBzb3VyY2UpIHtcbiAgICAgICAgdmFyIGhlYWRlciA9IFwiXCI7XG4gICAgICAgIGRpcmVjdGl2ZXMuZm9yRWFjaChmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgaWYgKHZbMF0gPT09IFwiI1wiKVxuICAgICAgICAgICAgICAgIGhlYWRlciArPSB2ICsgXCJcXG5cIjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoZWFkZXIgKz0gXCIjZGVmaW5lIFwiICsgdiArIFwiXFxuXCI7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGVhZGVyICsgXCJcXG5cIiArIHNvdXJjZTtcbiAgICB9LFxuXG4gICAgZ2V0VHJhbnNwYXJlbmN5RnJvbUlucHV0RGF0YTogZnVuY3Rpb24gKGRhdGFNYXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRvci5oYXNUcmFuc3BhcmVuY3koZGF0YU1hcCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhZGVyQ2xvc3VyZTtcblxuIiwidmFyIEFic3RyYWN0U2hhZGVyQ29tcG9zZXIgPSByZXF1aXJlKFwiLi4vYWJzdHJhY3RzaGFkZXJjb21wb3Nlci5qc1wiKS5BYnN0cmFjdFNoYWRlckNvbXBvc2VyO1xudmFyIFVSTlNoYWRlckNsb3N1cmU9IHJlcXVpcmUoXCIuL3VybnNoYWRlcmNsb3N1cmUuanNcIik7XG52YXIgU2hhZGVyRGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuL3NoYWRlci1kZXNjcmlwdG9yLmpzXCIpO1xudmFyIENvbXB1dGVSZXF1ZXN0ID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uL3hmbG93L2ludGVyZmFjZS9yZXF1ZXN0LmpzXCIpLkNvbXB1dGVSZXF1ZXN0O1xudmFyIGFkZEZyYWdtZW50U2hhZGVySGVhZGVyID0gcmVxdWlyZShcIi4uLy4uL3NoYWRlci9zaGFkZXItdXRpbHMuanNcIikuYWRkRnJhZ21lbnRTaGFkZXJIZWFkZXI7XG5yZXF1aXJlKFwiLi9kaWZmdXNlLmpzXCIpO1xucmVxdWlyZShcIi4vZGVmYXVsdC5qc1wiKTtcbnJlcXVpcmUoXCIuL3Bob25nLmpzXCIpO1xucmVxdWlyZShcIi4vbWF0dGUuanNcIik7XG5yZXF1aXJlKFwiLi9wb2ludC5qc1wiKTtcbnJlcXVpcmUoXCIuL3V0aWxpdHkuanNcIik7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHsqfVxuICovXG52YXIgZ2V0U2hhZGVyRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIHNoYWRlck5hbWUgPSBwYXRoLnN1YnN0cmluZyhwYXRoLmxhc3RJbmRleE9mKCc6JykgKyAxKTtcbiAgICByZXR1cm4gWE1MM0QubWF0ZXJpYWxzLmdldFNjcmlwdChzaGFkZXJOYW1lKTtcbn07XG5cblxuLyoqXG4gKiBAaW1wbGVtZW50cyB7SVNoYWRlckNvbXBvc2VyfVxuICogQGV4dGVuZHMgQWJzdHJhY3RTaGFkZXJDb21wb3NlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBVUk5TaGFkZXJDb21wb3NlciA9IGZ1bmN0aW9uIChjb250ZXh0LCBtYXRlcmlhbENvbmZpZ3VyYXRpb24pIHtcbiAgICBBYnN0cmFjdFNoYWRlckNvbXBvc2VyLmNhbGwodGhpcywgY29udGV4dCwgbWF0ZXJpYWxDb25maWd1cmF0aW9uKTtcbiAgICB0aGlzLmRlc2NyaXB0b3IgPSBudWxsO1xuICAgIHRoaXMuc2V0TWF0ZXJpYWxDb25maWd1cmF0aW9uKG1hdGVyaWFsQ29uZmlndXJhdGlvbik7XG59O1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhVUk5TaGFkZXJDb21wb3NlciwgQWJzdHJhY3RTaGFkZXJDb21wb3Nlciwge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtNYXRlcmlhbENvbmZpZ3VyYXRpb259IG1hdGVyaWFsQ29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIHNldE1hdGVyaWFsQ29uZmlndXJhdGlvbjogZnVuY3Rpb24gKG1hdGVyaWFsQ29uZmlndXJhdGlvbikge1xuICAgICAgICB2YXIgc2hhZGVyU2NyaXB0VVJJID0gbWF0ZXJpYWxDb25maWd1cmF0aW9uLm1vZGVsLnVybjtcbiAgICAgICAgdGhpcy5zZXRTaGFkZXJTY3JpcHQoc2hhZGVyU2NyaXB0VVJJKTtcblxuICAgICAgICBpZiAodGhpcy5kZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBtYXRlcmlhbENvbmZpZ3VyYXRpb24uZGF0YU5vZGUgJiYgdGhpcy51cGRhdGVSZXF1ZXN0KG1hdGVyaWFsQ29uZmlndXJhdGlvbi5kYXRhTm9kZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZGVzY3JpcHRvci5mcmFnbWVudCA9IGFkZEZyYWdtZW50U2hhZGVySGVhZGVyKHRoaXMuZGVzY3JpcHRvci5mcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgc2V0U2hhZGVyU2NyaXB0OiBmdW5jdGlvbiAodXJpKSB7XG5cbiAgICAgICAgaWYgKCF1cmkpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiU2hhZGVyIGhhcyBubyBzY3JpcHQgYXR0YWNoZWQ6IFwiLCB0aGlzLmFkYXB0ZXIubm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVyaS5zY2hlbWUgIT0gXCJ1cm5cIikge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJTaGFkZXIgc2NyaXB0IHJlZmVyZW5jZSBzaG91bGQgc3RhcnQgd2l0aCBhbiBVUk46IFwiLCB0aGlzLmFkYXB0ZXIubm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBnZXRTaGFkZXJEZXNjcmlwdG9yKHVyaS5wYXRoKTtcbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIFVSTjogXCIgKyB1cmkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZXNjcmlwdG9yID0gbmV3IFNoYWRlckRlc2NyaXB0b3IoKTtcbiAgICAgICAgWE1MM0QuZXh0ZW5kKHRoaXMuZGVzY3JpcHRvciwgZGVzY3JpcHRvcik7XG4gICAgfSxcblxuICAgIGdldFJlcXVlc3RGaWVsZHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGVzY3JpcHRvci51bmlmb3JtcykuY29uY2F0KE9iamVjdC5rZXlzKHRoaXMuZGVzY3JpcHRvci5zYW1wbGVycykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGF0dHJpYnV0ZXMgcmVxdWlyZWQgYnkgdGhlIHNoYWRlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3Q8c3RyaW5nLCAqPn1cbiAgICAgKi9cbiAgICBnZXRTaGFkZXJBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0b3IuYXR0cmlidXRlcztcbiAgICB9LFxuXG4gICAgY3JlYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVSTlNoYWRlckNsb3N1cmUodGhpcy5jb250ZXh0LCB0aGlzLmRlc2NyaXB0b3IpO1xuICAgIH0sXG5cbiAgICBjcmVhdGVPYmplY3REYXRhUmVxdWVzdDogZnVuY3Rpb24gKG9iamVjdERhdGFOb2RlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVxdWVzdE5hbWVzID0gW1wicG9zaXRpb25cIl07XG4gICAgICAgIHJlcXVlc3ROYW1lcy5wdXNoLmFwcGx5KHJlcXVlc3ROYW1lcywgT2JqZWN0LmtleXModGhpcy5kZXNjcmlwdG9yLmF0dHJpYnV0ZXMpKTtcbiAgICAgICAgcmVxdWVzdE5hbWVzLnB1c2guYXBwbHkocmVxdWVzdE5hbWVzLCBPYmplY3Qua2V5cyh0aGlzLmRlc2NyaXB0b3IudW5pZm9ybXMpKTtcbiAgICAgICAgcmVxdWVzdE5hbWVzLnB1c2guYXBwbHkocmVxdWVzdE5hbWVzLCBPYmplY3Qua2V5cyh0aGlzLmRlc2NyaXB0b3Iuc2FtcGxlcnMpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wdXRlUmVxdWVzdChvYmplY3REYXRhTm9kZSwgcmVxdWVzdE5hbWVzLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIGRpc3RyaWJ1dGVPYmplY3RTaGFkZXJEYXRhOiBmdW5jdGlvbiAob2JqZWN0UmVxdWVzdCwgYXR0cmlidXRlQ2FsbGJhY2ssIHVuaWZvcm1DYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0UmVxdWVzdC5nZXRSZXN1bHQoKTtcblxuICAgICAgICB2YXIgZGF0YU1hcCA9IHJlc3VsdC5nZXRPdXRwdXRNYXAoKTtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBkYXRhTWFwKSB7XG5cbiAgICAgICAgICAgIGlmIChuYW1lID09IFwicG9zaXRpb25cIiB8fCB0aGlzLmRlc2NyaXB0b3IuYXR0cmlidXRlc1tuYW1lXSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZUNhbGxiYWNrKG5hbWUsIGRhdGFNYXBbbmFtZV0pOyBlbHNlIGlmICh0aGlzLmRlc2NyaXB0b3IudW5pZm9ybXNbbmFtZV0gIT09IHVuZGVmaW5lZCB8fCB0aGlzLmRlc2NyaXB0b3Iuc2FtcGxlcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHVuaWZvcm1DYWxsYmFjayhuYW1lLCBkYXRhTWFwW25hbWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVVJOU2hhZGVyQ29tcG9zZXI7XG5cblxuIiwiWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwicGlja29iamVjdGlkXCIsIHtcbiAgICB2ZXJ0ZXggOiBbXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxuICAgICAgICBcIiAgICBnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50IDogW1xuICAgICAgICBcInVuaWZvcm0gdmVjMyBpZDtcIixcblxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXG4gICAgICAgIFwiICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoaWQsIDAuMCk7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgdW5pZm9ybXMgOiB7fVxufSk7XG5cblhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcInBpY2tlZHBvc2l0aW9uXCIsIHtcbiAgICB2ZXJ0ZXggOiBbXG4gICAgICAgIFwiYXR0cmlidXRlIHZlYzMgcG9zaXRpb247XCIsXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1wiLFxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMyBiYm94WzJdO1wiLCAgLy8gbWluID0gYmJveFswXSwgbWF4ID0gYmJveFsxXVxuXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIHdvcmxkQ29vcmQ7XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxuICAgICAgICBcIiAgICB3b3JsZENvb3JkID0gKG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKSkueHl6O1wiLFxuICAgICAgICBcIiAgICB2ZWMzIGRpZmYgPSBiYm94WzFdIC0gYmJveFswXTtcIixcbiAgICAgICAgXCIgICAgd29ybGRDb29yZCA9IHdvcmxkQ29vcmQgLSBiYm94WzBdO1wiLFxuICAgICAgICBcIiAgICB3b3JsZENvb3JkID0gd29ybGRDb29yZCAvIGRpZmY7XCIsXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnQgOiBbXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIHdvcmxkQ29vcmQ7XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxuICAgICAgICBcIiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHdvcmxkQ29vcmQsIDEuMCk7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgdW5pZm9ybXMgOiB7fVxufSk7XG5cblxuWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwicGlja2VkTm9ybWFsc1wiLCB7XG4gICAgdmVydGV4IDogW1xuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIixcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcIixcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDMgbW9kZWxWaWV3TWF0cml4TjtcIixcblxuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgXCIgICAgZnJhZ05vcm1hbCA9IG5vcm1hbGl6ZShtb2RlbFZpZXdNYXRyaXhOICogbm9ybWFsKTtcIixcbiAgICAgICAgXCIgICAgZ2xfUG9zaXRpb24gPSBtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcIixcbiAgICAgICAgXCJ9XCJcbiAgICBdLmpvaW4oXCJcXG5cIiksXG5cbiAgICBmcmFnbWVudCA6IFtcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgZnJhZ05vcm1hbDtcIixcblxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXG4gICAgICAgIFwiICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoKGZyYWdOb3JtYWwrMS4wKS8yLjAgKiAoMjU0LjAgLyAyNTUuMCksIDEuMCk7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgdW5pZm9ybXMgOiB7fVxufSk7XG5cblhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcImxpZ2h0LWRlcHRoXCIsIHtcblxuICAgIHZlcnRleDogW1xuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxuICAgICAgICBcInZhcnlpbmcgdmVjNCB3b3JsZFBvc2l0aW9uO1wiLFxuICAgICAgICBcInVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcIixcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcIixcblxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXG4gICAgICAgIFwiICAgd29ybGRQb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNChwb3NpdGlvbiwgMS4wKTtcIixcbiAgICAgICAgXCIgICBnbF9Qb3NpdGlvbiAgID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnQ6IFtcbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzQgd29ybGRQb3NpdGlvbjtcIixcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcIixcblxuICAgICAgICBcInZlYzQgcGFja19kZXB0aCggY29uc3QgaW4gZmxvYXQgZGVwdGggKSB7XCIsXG4gICAgICAgIFwiY29uc3QgdmVjNCBiaXRfc2hpZnQgPSB2ZWM0KCAyNTYuMCAqIDI1Ni4wICogMjU2LjAsIDI1Ni4wICogMjU2LjAsIDI1Ni4wLCAxLjAgKTtcIixcbiAgICAgICAgXCJjb25zdCB2ZWM0IGJpdF9tYXNrICA9IHZlYzQoIDAuMCwgMS4wIC8gMjU2LjAsIDEuMCAvIDI1Ni4wLCAxLjAgLyAyNTYuMCApO1wiLFxuICAgICAgICBcInZlYzQgcmVzID0gZnJhY3QoIGRlcHRoICogYml0X3NoaWZ0ICk7XCIsXG4gICAgICAgIFwicmVzIC09IHJlcy54eHl6ICogYml0X21hc2s7XCIsXG4gICAgICAgIFwicmV0dXJuIHJlcztcIixcbiAgICAgICAgXCJ9XCIsXG5cblxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXG4gICAgICAgIFwiICAgIGdsX0ZyYWdDb2xvciA9IHBhY2tfZGVwdGgoIGdsX0ZyYWdDb29yZC56ICk7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgdW5pZm9ybXM6IHt9XG59KTtcblxuWE1MM0QubWF0ZXJpYWxzLnJlZ2lzdGVyKFwicmVuZGVyLW5vcm1hbFwiLCB7XG4gICAgdmVydGV4IDogW1xuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIG5vcm1hbDtcIixcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcIixcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDMgbW9kZWxNYXRyaXhOO1wiLFxuXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIGZyYWdOb3JtYWw7XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxuICAgICAgICBcIiAgICBmcmFnTm9ybWFsID0gbW9kZWxNYXRyaXhOICogbm9ybWFsO1wiLFxuICAgICAgICBcIiAgICBnbF9Qb3NpdGlvbiA9IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50IDogW1xuICAgICAgICBcInZhcnlpbmcgdmVjMyBmcmFnTm9ybWFsO1wiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgXCIgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KChub3JtYWxpemUoZnJhZ05vcm1hbCkgKyAxLjApIC8gMi4wLCAxLjApO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIHVuaWZvcm1zIDoge31cbn0pO1xuXG5YTUwzRC5tYXRlcmlhbHMucmVnaXN0ZXIoXCJyZW5kZXItcG9zaXRpb25cIiwge1xuICAgIHZlcnRleCA6IFtcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjtcIixcbiAgICAgICAgXCJ1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XCIsXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IG1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXg7XCIsXG5cbiAgICAgICAgXCJ2YXJ5aW5nIHZlYzMgd29ybGRDb29yZDtcIixcblxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXG4gICAgICAgIFwiICAgIHdvcmxkQ29vcmQgPSAobW9kZWxNYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XCIsXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnQgOiBbXG4gICAgICAgIFwidmFyeWluZyB2ZWMzIHdvcmxkQ29vcmQ7XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxuICAgICAgICBcIiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHdvcmxkQ29vcmQsIDEuMCk7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgdW5pZm9ybXMgOiB7fVxufSk7XG5cblhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcImJveGJsdXJcIiwge1xuICAgIHZlcnRleDogW1xuICAgICAgICBcImF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9uO1wiLFxuXG4gICAgICAgIFwidm9pZCBtYWluKHZvaWQpIHtcIixcbiAgICAgICAgXCIgICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDEuMCk7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgZnJhZ21lbnQ6IFtcbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBzSW5UZXh0dXJlO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMiBjYW52YXNTaXplO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMiBibHVyT2Zmc2V0O1wiLFxuXG4gICAgICAgIFwiY29uc3QgZmxvYXQgYmx1clNpemUgPSAxLjAvNTEyLjA7XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxuICAgICAgICBcIiAgIHZlYzIgdGV4Y29vcmQgPSAoZ2xfRnJhZ0Nvb3JkLnh5IC8gY2FudmFzU2l6ZS54eSk7XCIsXG4gICAgICAgIFwiICAgdmVjNCBzdW0gPSB2ZWM0KDAuMCk7XCIsXG4gICAgICAgIFwiICAgZmxvYXQgYmx1clNpemVZID0gYmx1ck9mZnNldC55IC8gY2FudmFzU2l6ZS55O1wiLFxuICAgICAgICBcIiAgIGZsb2F0IGJsdXJTaXplWCA9IGJsdXJPZmZzZXQueCAvIGNhbnZhc1NpemUueDtcIixcblxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54LCB0ZXhjb29yZC55IC0gMS41KmJsdXJTaXplWSkpO1wiLFxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54LCB0ZXhjb29yZC55IC0gMi4wKmJsdXJTaXplWSkpO1wiLFxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54LCB0ZXhjb29yZC55IC0gYmx1clNpemVZKSk7XCIsXG4gICAgICAgIFwiICAgc3VtICs9IHRleHR1cmUyRChzSW5UZXh0dXJlLCB2ZWMyKHRleGNvb3JkLngsIHRleGNvb3JkLnkgKyBibHVyU2l6ZVkpKTtcIixcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCwgdGV4Y29vcmQueSArIDIuMCpibHVyU2l6ZVkpKTtcIixcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCwgdGV4Y29vcmQueSArIDEuNSpibHVyU2l6ZVkpKTtcIixcblxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54IC0gMS41KmJsdXJTaXplWCwgdGV4Y29vcmQueSkpO1wiLFxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54IC0gMi4wKmJsdXJTaXplWCwgdGV4Y29vcmQueSkpO1wiLFxuICAgICAgICBcIiAgIHN1bSArPSB0ZXh0dXJlMkQoc0luVGV4dHVyZSwgdmVjMih0ZXhjb29yZC54IC0gYmx1clNpemVYLCB0ZXhjb29yZC55KSk7XCIsXG4gICAgICAgIFwiICAgc3VtICs9IHRleHR1cmUyRChzSW5UZXh0dXJlLCB2ZWMyKHRleGNvb3JkLnggKyBibHVyU2l6ZVgsIHRleGNvb3JkLnkpKTtcIixcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCArIDIuMCpibHVyU2l6ZVgsIHRleGNvb3JkLnkpKTtcIixcbiAgICAgICAgXCIgICBzdW0gKz0gdGV4dHVyZTJEKHNJblRleHR1cmUsIHZlYzIodGV4Y29vcmQueCArIDEuNSpibHVyU2l6ZVgsIHRleGNvb3JkLnkpKTtcIixcblxuICAgICAgICBcIiAgIGdsX0ZyYWdDb2xvciA9IHN1bSAvIDEyLjA7XCIsXG4gICAgICAgIFwifVwiXG4gICAgXS5qb2luKFwiXFxuXCIpLFxuXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgICAgY2FudmFzU2l6ZSA6IFs1MTIsIDUxMl0sXG4gICAgICAgIGJsdXJPZmZzZXQgOiBbMS4wLCAxLjBdXG4gICAgfSxcblxuICAgIHNhbXBsZXJzOiB7XG4gICAgICAgIHNJblRleHR1cmUgOiBudWxsXG4gICAgfVxufSk7XG5cblhNTDNELm1hdGVyaWFscy5yZWdpc3RlcihcInNzYW9cIiwge1xuICAgIHZlcnRleCA6IFtcbiAgICAgICAgXCJhdHRyaWJ1dGUgdmVjMiBwb3NpdGlvbjtcIixcblxuICAgICAgICBcInZvaWQgbWFpbih2b2lkKSB7XCIsXG4gICAgICAgIFwiICAgIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMC4wLCAxLjApO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIGZyYWdtZW50IDogW1xuICAgICAgICBcIiNpZmRlZiBHTF9FU1wiLFxuICAgICAgICBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcIixcbiAgICAgICAgXCIjZW5kaWZcIixcblxuICAgICAgICBcInVuaWZvcm0gdmVjMiBjYW52YXNTaXplO1wiLFxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHNQb3NpdGlvblRleDtcIixcbiAgICAgICAgXCJ1bmlmb3JtIHNhbXBsZXIyRCBzTm9ybWFsVGV4O1wiLFxuICAgICAgICBcInVuaWZvcm0gc2FtcGxlcjJEIHNSYW5kb21Ob3JtYWxzO1wiLFxuICAgICAgICBcInVuaWZvcm0gdmVjMiB1UmFuZG9tVGV4U2l6ZTtcIixcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHVTYW1wbGVSYWRpdXM7XCIsXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCB1U2NhbGU7XCIsXG4gICAgICAgIFwidW5pZm9ybSBmbG9hdCB1QmlhcztcIixcbiAgICAgICAgXCJ1bmlmb3JtIGZsb2F0IHVJbnRlbnNpdHk7XCIsXG4gICAgICAgIFwidW5pZm9ybSB2ZWMyIHVDb25zdFZlY3RvcnNbNF07XCIsXG4gICAgICAgIFwidW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XCIsXG5cbiAgICAgICAgXCJ2ZWMzIGdldFBvc2l0aW9uKHZlYzIgdXYpIHtcIixcbiAgICAgICAgXCJyZXR1cm4gdGV4dHVyZTJEKHNQb3NpdGlvblRleCwgdXYpLnh5ejtcIixcbiAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgXCJmbG9hdCBjYWxjQW1iaWVudE9jY2x1c2lvbih2ZWMyIHNjcmVlblVWLCB2ZWMyIHV2T2Zmc2V0LCB2ZWMzIG9yaWdpbiwgdmVjMyBjbm9ybSkge1wiLFxuICAgICAgICBcIiAgIHZlYzMgZGlmZiA9IGdldFBvc2l0aW9uKHNjcmVlblVWICsgdXZPZmZzZXQpIC0gb3JpZ2luO1wiLFxuICAgICAgICBcIiAgIHZlYzMgdiA9IG5vcm1hbGl6ZShkaWZmKTtcIixcbiAgICAgICAgXCIgICBmbG9hdCBkaXN0ID0gbGVuZ3RoKGRpZmYpICogdVNjYWxlO1wiLFxuICAgICAgICBcIiAgIHJldHVybiBtYXgoMC4wLCBkb3QoY25vcm0sIHYpIC0gdUJpYXMpICogKDEuMC8oMS4wICsgZGlzdCkpICogdUludGVuc2l0eTtcIixcbiAgICAgICAgXCJ9XCIsXG5cbiAgICAgICAgXCJ2b2lkIG1haW4odm9pZCkge1wiLFxuICAgICAgICBcIiAgIHZlYzIgc2NyZWVuVVYgPSBnbF9GcmFnQ29vcmQueHkgLyBjYW52YXNTaXplLnh5O1wiLFxuICAgICAgICBcIiAgIHZlYzIgcmFuZCA9IG5vcm1hbGl6ZSh0ZXh0dXJlMkQoc1JhbmRvbU5vcm1hbHMsIGdsX0ZyYWdDb29yZC54eSAvIHVSYW5kb21UZXhTaXplKS54eSAqIDIuMCAtIDEuMCApO1wiLFxuICAgICAgICBcIiAgIHZlYzMgbm9ybSA9IG5vcm1hbGl6ZSh0ZXh0dXJlMkQoc05vcm1hbFRleCwgc2NyZWVuVVYpLnh5eiAqIDIuMCAtIDEuMCApO1wiLFxuICAgICAgICBcIiAgIHZlYzMgb3JpZ2luID0gZ2V0UG9zaXRpb24oc2NyZWVuVVYpO1wiLFxuICAgICAgICBcIiAgIGZsb2F0IHJhZGl1cyA9IHVTYW1wbGVSYWRpdXMgLyAodmlld01hdHJpeCAqIHZlYzQob3JpZ2luLCAxLjApKS56O1wiLFxuICAgICAgICBcIiAgIGZsb2F0IGFvID0gMC4wO1wiLFxuXG4gICAgICAgIFwiICAgY29uc3QgaW50IGl0ZXJhdGlvbnMgPSA0O1wiLFxuICAgICAgICBcIiAgIGZvciAoaW50IGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgKytpKSB7XCIsXG4gICAgICAgIFwiICAgICAgIHZlYzIgY29vcmQxID0gcmVmbGVjdCh1Q29uc3RWZWN0b3JzW2ldLCByYW5kKSAqIHJhZGl1cztcIixcbiAgICAgICAgXCIgICAgICAgdmVjMiBjb29yZDIgPSB2ZWMyKGNvb3JkMS54KjAuNzA3IC0gY29vcmQxLnkqMC43MDcsIGNvb3JkMS54KjAuNzA3ICsgY29vcmQxLnkqMC43MDcpO1wiLFxuICAgICAgICBcIiAgICAgICBhbyArPSBjYWxjQW1iaWVudE9jY2x1c2lvbihzY3JlZW5VViwgY29vcmQxKjAuMjUsIG9yaWdpbiwgbm9ybSk7XCIsXG4gICAgICAgIFwiICAgICAgIGFvICs9IGNhbGNBbWJpZW50T2NjbHVzaW9uKHNjcmVlblVWLCBjb29yZDIqMC41LCBvcmlnaW4sIG5vcm0pO1wiLFxuICAgICAgICBcIiAgICAgICBhbyArPSBjYWxjQW1iaWVudE9jY2x1c2lvbihzY3JlZW5VViwgY29vcmQxKjAuNzUsIG9yaWdpbiwgbm9ybSk7XCIsXG4gICAgICAgIFwiICAgICAgIGFvICs9IGNhbGNBbWJpZW50T2NjbHVzaW9uKHNjcmVlblVWLCBjb29yZDIsIG9yaWdpbiwgbm9ybSk7XCIsXG4gICAgICAgIFwiICAgfVwiLFxuICAgICAgICBcIiAgIGFvIC89IChmbG9hdChpdGVyYXRpb25zKSAqIDQuMCk7XCIsXG4gICAgICAgIFwiICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChhbywgYW8sIGFvLCAxLjApO1wiLFxuICAgICAgICBcIn1cIlxuICAgIF0uam9pbihcIlxcblwiKSxcblxuICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIGNhbnZhc1NpemUgICAgICA6IFs1MTIsIDUxMl0sXG4gICAgICAgIHVDb25zdFZlY3RvcnMgICA6IFsxLDAsIC0xLDAsIDAsMSwgMCwtMV0sXG4gICAgICAgIHVSYW5kb21UZXhTaXplICA6IFs2NCw2NF0sXG4gICAgICAgIHVTYW1wbGVSYWRpdXMgICA6IDAuOSxcbiAgICAgICAgdVNjYWxlICAgICAgICAgIDogMC45LFxuICAgICAgICB1QmlhcyAgICAgICAgICAgOiAwLjIsXG4gICAgICAgIHVJbnRlbnNpdHkgICAgICA6IDEuMFxuICAgIH0sXG5cbiAgICBzYW1wbGVyczoge1xuICAgICAgICBzUG9zaXRpb25UZXggICA6IG51bGwsXG4gICAgICAgIHNOb3JtYWxUZXggICAgIDogbnVsbCxcbiAgICAgICAgc1JhbmRvbU5vcm1hbHMgOiBudWxsXG4gICAgfSxcblxuICAgIGF0dHJpYnV0ZXM6IHtcbiAgICB9XG59KTtcbiIsIi8vIE5vdGU6IFRoaXMgY29udGV4dCBzaG91bGQgb25seSBiZSB1c2VkIHRvIGFjY2VzcyBHTCBjb25zdGFudHNcbnZhciBHTCA9IHdpbmRvdy5XZWJHTFJlbmRlcmluZ0NvbnRleHQ7XG52YXIgRm9yd2FyZFJlbmRlclRyZWUgPSByZXF1aXJlKFwiLi9yZW5kZXItdHJlZXMvZm9yd2FyZC5qc1wiKTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEdMUmVuZGVySW50ZXJmYWNlID0gZnVuY3Rpb24gKGNvbnRleHQsIHNjZW5lKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnNjZW5lID0gc2NlbmU7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBwaWNraW5nRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgbW91c2VNb3ZlUGlja2luZ0VuYWJsZWQ6IHRydWUsXG4gICAgICAgIGdsQmxlbmRGdW5jU2VwYXJhdGU6IFtHTC5TUkNfQUxQSEEsIEdMLk9ORV9NSU5VU19TUkNfQUxQSEEsIEdMLk9ORSwgR0wuT05FX01JTlVTX1NSQ19BTFBIQV1cbiAgICB9O1xuICAgIHRoaXMucmVuZGVyUGlwZWxpbmUgPSBudWxsO1xufTtcblxuWE1MM0QuZXh0ZW5kKEdMUmVuZGVySW50ZXJmYWNlLnByb3RvdHlwZSwge1xuICAgIGdldFJlbmRlclBpcGVsaW5lOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5yZW5kZXJQaXBlbGluZSA9IHRoaXMucmVuZGVyUGlwZWxpbmUgfHwgbmV3IEZvcndhcmRSZW5kZXJUcmVlKHRoaXMuY29udGV4dCkpO1xuICAgIH0sXG5cbiAgICBzZXRSZW5kZXJQaXBlbGluZTogZnVuY3Rpb24gKHBpcGVsaW5lKSB7XG4gICAgICAgIC8vVE9ETyBjbGVhbnVwIG9sZCBwaXBlbGluZVxuICAgICAgICB0aGlzLnJlbmRlclBpcGVsaW5lID0gcGlwZWxpbmU7XG4gICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KFwiUGlwZWxpbmUgY2hhbmdlZFwiKTtcbiAgICB9LFxuXG4gICAgZ2V0UmVuZGVyT3B0aW9uczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdMUmVuZGVySW50ZXJmYWNlO1xuXG4iLCIvKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQmFzZVJlbmRlclBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xuICAgIHRoaXMucmVuZGVySW50ZXJmYWNlID0gcmVuZGVySW50ZXJmYWNlO1xuICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB0aGlzLmlucHV0cyA9IG9wdC5pbnB1dHMgfHwge307XG4gICAgdGhpcy5pZCA9IG9wdC5pZCB8fCBcIlwiO1xuICAgIHRoaXMucHJlUGFzc2VzID0gW107XG4gICAgdGhpcy5wb3N0UGFzc2VzID0gW107XG4gICAgdGhpcy5wcm9jZXNzZWQgPSBmYWxzZTtcbn07XG5cblhNTDNELmV4dGVuZChCYXNlUmVuZGVyUGFzcy5wcm90b3R5cGUsIHtcbiAgICBhZGRQcmVQYXNzOiBmdW5jdGlvbiAocGFzcykge1xuICAgICAgICBpZiAodGhpcy5wcmVQYXNzZXMuaW5kZXhPZihwYXNzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucHJlUGFzc2VzLnB1c2gocGFzcyk7XG4gICAgICAgICAgICBwYXNzLnBvc3RQYXNzZXMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICByZW1vdmVQcmVQYXNzOiBmdW5jdGlvbiAocGFzcykge1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5wcmVQYXNzZXMuaW5kZXhPZihwYXNzKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucHJlUGFzc2VzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgcGFzcy5wb3N0UGFzc2VzLnNwbGljZShwYXNzLnBvc3RQYXNzZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYXJQcmVQYXNzZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnByZVBhc3Nlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVByZVBhc3ModGhpcy5wcmVQYXNzZXNbaV0pO1xuICAgIH0sXG5cbiAgICBzZXRQcm9jZXNzZWQ6IGZ1bmN0aW9uIChwcm9jZXNzZWQpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvY2Vzc2VkICYmICFwcm9jZXNzZWQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5wb3N0UGFzc2VzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5wb3N0UGFzc2VzW2ldLnNldFByb2Nlc3NlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBwcm9jZXNzZWQ7XG4gICAgfSxcblxuICAgIHJlbmRlclRyZWU6IGZ1bmN0aW9uIChzY2VuZSkge1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnByZVBhc3Nlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpLS0pXG4gICAgICAgICAgICB0aGlzLnByZVBhc3Nlc1tpXS5yZW5kZXJUcmVlKHNjZW5lKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoc2NlbmUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyBwaXhlbHMgZnJvbSB0aGUgcGFzcydzIHRhcmdldFxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdsWCBPcGVuR0wgQ29vcmRpbmF0ZSBpbiB0aGUgdGFyZ2V0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdsWSBPcGVuR0wgQ29vcmRpbmF0ZSBpbiB0aGUgdGFyZ2V0XG4gICAgICogQHJldHVybnMge1VpbnQ4QXJyYXl9IHBpeGVsIGRhdGFcbiAgICAgKi9cbiAgICByZWFkUGl4ZWxEYXRhRnJvbUJ1ZmZlcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNfZGF0YSA9IG5ldyBVaW50OEFycmF5KDgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2xYLCBnbFksIHRhcmdldCkge1xuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IHRhcmdldC5nZXRTY2FsZSgpO1xuICAgICAgICAgICAgdmFyIHggPSBnbFggKiBzY2FsZTtcbiAgICAgICAgICAgIHZhciB5ID0gZ2xZICogc2NhbGU7XG5cbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGdsLnJlYWRQaXhlbHMoeCwgeSwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgY19kYXRhKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNfZGF0YTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFeGNlcHRpb24oZSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnVuYmluZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSgpKVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlUmVuZGVyUGFzcztcblxuIiwidmFyIEJhc2VSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcbnZhciBGdWxsc2NyZWVuUXVhZCA9IHJlcXVpcmUoXCIuLi9iYXNlL2Z1bGxzY3JlZW5xdWFkLmpzXCIpO1xuXG52YXIgQm94Qmx1clBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xuICAgIEJhc2VSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XG4gICAgdGhpcy5fcHJvZ3JhbSA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQucHJvZ3JhbUZhY3RvcnkuZ2V0UHJvZ3JhbUJ5TmFtZShcImJveGJsdXJcIik7XG4gICAgdGhpcy5fc2NyZWVuUXVhZCA9IG5ldyBGdWxsc2NyZWVuUXVhZCh0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0KTtcbiAgICB0aGlzLl91bmlmb3Jtc0RpcnR5ID0gdHJ1ZTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKEJveEJsdXJQYXNzLCBCYXNlUmVuZGVyUGFzcyk7XG5cblhNTDNELmV4dGVuZChCb3hCbHVyUGFzcy5wcm90b3R5cGUsIHtcbiAgICByZW5kZXI6IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMub3V0cHV0O1xuXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLmJpbmQoKTtcbiAgICAgICAgICAgIHRoaXMuX3NldE5vblZvbGF0aWxlU2hhZGVyVW5pZm9ybXMoKTtcblxuICAgICAgICAgICAgdGhpcy5fc2NyZWVuUXVhZC5kcmF3KHRoaXMuX3Byb2dyYW0pO1xuXG4gICAgICAgICAgICB0aGlzLl9wcm9ncmFtLnVuYmluZCgpO1xuICAgICAgICAgICAgdGFyZ2V0LnVuYmluZCgpO1xuICAgICAgICB9XG4gICAgfSgpKSxcblxuICAgIF9zZXROb25Wb2xhdGlsZVNoYWRlclVuaWZvcm1zOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdW5pZm9ybXMgPSB7fTtcbiAgICAgICAgdmFyIHVuaWZvcm1OYW1lcyA9IFtcImNhbnZhc1NpemVcIiwgXCJzSW5UZXh0dXJlXCIsIFwiYmx1ck9mZnNldFwiXTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl91bmlmb3Jtc0RpcnR5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLl9wcm9ncmFtO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMub3V0cHV0O1xuXG4gICAgICAgICAgICB1bmlmb3Jtc1tcImNhbnZhc1NpemVcIl0gPSBbdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0XTtcbiAgICAgICAgICAgIHVuaWZvcm1zW1wic0luVGV4dHVyZVwiXSA9IFt0aGlzLmlucHV0cy5idWZmZXIuY29sb3JUYXJnZXQuaGFuZGxlXTtcbiAgICAgICAgICAgIHVuaWZvcm1zW1wiYmx1ck9mZnNldFwiXSA9IFsxLjAsIDEuMF07XG4gICAgICAgICAgICBwcm9ncmFtLnNldFN5c3RlbVVuaWZvcm1WYXJpYWJsZXModW5pZm9ybU5hbWVzLCB1bmlmb3Jtcyk7XG5cbi8vICAgICAgICAgICAgICAgIHRoaXMuX3VuaWZvcm1zRGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pKClcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveEJsdXJQYXNzO1xuXG4iLCJ2YXIgU2NlbmVSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vc2NlbmUtcGFzcy5qc1wiKTtcbnZhciBPYmplY3RTb3J0ZXIgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyZXIvdG9vbHMvb2JqZWN0c29ydGVyLmpzXCIpO1xudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XG5cbnZhciBGb3J3YXJkUmVuZGVyUGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KSB7XG4gICAgU2NlbmVSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XG4gICAgdGhpcy5zb3J0ZXIgPSBuZXcgT2JqZWN0U29ydGVyKCk7XG4gICAgdGhpcy5sYXN0UmVuZGVyU3RhdHMgPSB7fTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKEZvcndhcmRSZW5kZXJQYXNzLCBTY2VuZVJlbmRlclBhc3MpO1xuXG5YTUwzRC5leHRlbmQoRm9yd2FyZFJlbmRlclBhc3MucHJvdG90eXBlLCB7XG5cblxuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIG1hdDRcbiAgICAgICAgICovXG4gICAgICAgIHZhciBjX3dvcmxkVG9WaWV3TWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgdmFyIGNfdmlld1RvV29ybGRNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICB2YXIgY19wcm9qZWN0aW9uTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgdmFyIGNfcHJvZ3JhbVN5c3RlbVVuaWZvcm1zID0gW1widmlld01hdHJpeFwiLCBcInZpZXdJbnZlcnNlTWF0cml4XCIsIFwicHJvamVjdGlvbk1hdHJpeFwiLCBcImNhbWVyYVBvc2l0aW9uXCIsIFwiY29vcmRzXCIsIFwic3Nhb01hcFwiLCBcIndpZHRoXCJdO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2wsIGNvdW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBvYmplY3RzOiAwLFxuICAgICAgICAgICAgICAgICAgICBwcmltaXRpdmVzOiAwXG4gICAgICAgICAgICAgICAgfSwgdGFyZ2V0ID0gdGhpcy5vdXRwdXQsIHN5c3RlbVVuaWZvcm1zID0gc2NlbmUuc3lzdGVtVW5pZm9ybXMsIHdpZHRoID0gdGFyZ2V0LmdldFdpZHRoKCksIGhlaWdodCA9IHRhcmdldC5nZXRIZWlnaHQoKSwgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQ7XG5cbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XG4gICAgICAgICAgICB0aGlzLnNldEdMU3RhdGVzKCk7XG5cbiAgICAgICAgICAgIHNjZW5lLnVwZGF0ZVJlYWR5T2JqZWN0c0Zyb21BY3RpdmVWaWV3KGFzcGVjdCk7XG4gICAgICAgICAgICBzY2VuZS5nZXRBY3RpdmVWaWV3KCkuZ2V0V29ybGRUb1ZpZXdNYXRyaXgoY193b3JsZFRvVmlld01hdHJpeCk7XG4gICAgICAgICAgICBzY2VuZS5nZXRBY3RpdmVWaWV3KCkuZ2V0Vmlld1RvV29ybGRNYXRyaXgoY192aWV3VG9Xb3JsZE1hdHJpeCk7XG4gICAgICAgICAgICBzY2VuZS5nZXRBY3RpdmVWaWV3KCkuZ2V0UHJvamVjdGlvbk1hdHJpeChjX3Byb2plY3Rpb25NYXRyaXgsIGFzcGVjdCk7XG5cbiAgICAgICAgICAgIHZhciBzb3J0ZWQgPSB0aGlzLnNvcnRlci5zb3J0U2NlbmUoc2NlbmUsIGNfd29ybGRUb1ZpZXdNYXRyaXgpO1xuXG4gICAgICAgICAgICBzeXN0ZW1Vbmlmb3Jtc1tcInZpZXdNYXRyaXhcIl0gPSBjX3dvcmxkVG9WaWV3TWF0cml4O1xuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJ2aWV3SW52ZXJzZU1hdHJpeFwiXSA9IGNfdmlld1RvV29ybGRNYXRyaXg7XG4gICAgICAgICAgICBzeXN0ZW1Vbmlmb3Jtc1tcInByb2plY3Rpb25NYXRyaXhcIl0gPSBjX3Byb2plY3Rpb25NYXRyaXg7XG4gICAgICAgICAgICBzeXN0ZW1Vbmlmb3Jtc1tcImNhbWVyYVBvc2l0aW9uXCJdID0gc2NlbmUuZ2V0QWN0aXZlVmlldygpLmdldFdvcmxkU3BhY2VQb3NpdGlvbigpO1xuICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJjb29yZHNcIl0gPSBbdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0LCAxXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaW5wdXRzLnNzYW9NYXApXG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJzc2FvTWFwXCJdID0gW3RoaXMuaW5wdXRzLnNzYW9NYXAuY29sb3JUYXJnZXQuaGFuZGxlXTtcblxuICAgICAgICAgICAgLy9SZW5kZXIgb3BhcXVlIG9iamVjdHNcbiAgICAgICAgICAgIGZvciAodmFyIHByb2dyYW0gaW4gc29ydGVkLm9wYXF1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyT2JqZWN0c1RvQWN0aXZlQnVmZmVyKHNvcnRlZC5vcGFxdWVbcHJvZ3JhbV0sIHNjZW5lLCB0YXJnZXQsIHN5c3RlbVVuaWZvcm1zLCBjX3Byb2dyYW1TeXN0ZW1Vbmlmb3Jtcywge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BhcmVudDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzOiBjb3VudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1JlbmRlciB0cmFuc3BhcmVudCBvYmplY3RzXG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNvcnRlZC50cmFuc3BhcmVudC5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgIHZhciBvYmplY3RBcnJheSA9IFtzb3J0ZWQudHJhbnNwYXJlbnRba11dO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyT2JqZWN0c1RvQWN0aXZlQnVmZmVyKG9iamVjdEFycmF5LCBzY2VuZSwgdGFyZ2V0LCBzeXN0ZW1Vbmlmb3JtcywgY19wcm9ncmFtU3lzdGVtVW5pZm9ybXMsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzOiBjb3VudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NlbmUubGlnaHRzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRhcmdldC51bmJpbmQoKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFJlbmRlclN0YXRzLmNvdW50ID0gY291bnQ7XG4gICAgICAgIH1cbiAgICB9KCkpLFxuXG4gICAgZ2V0UmVuZGVyU3RhdHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlbmRlclN0YXRzO1xuICAgIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBGb3J3YXJkUmVuZGVyUGFzcztcblxuIiwidmFyIFNjZW5lUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL3NjZW5lLXBhc3MuanNcIik7XG52YXIgT2JqZWN0U29ydGVyID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3Rvb2xzL29iamVjdHNvcnRlci5qc1wiKTtcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xuXG4vKipcbiAqIEBwYXJhbSB7R0xSZW5kZXJJbnRlcmZhY2V9IHJlbmRlckludGVyZmFjZVxuICogQHBhcmFtIHtzdHJpbmd9IG91dHB1dFxuICogQHBhcmFtIHtSZW5kZXJMaWdodH0gbGlnaHRcbiAqIEBwYXJhbSB7Kn0gb3B0XG4gKiBAZXh0ZW5kcyB7U2NlbmVSZW5kZXJQYXNzfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMaWdodFBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIGxpZ2h0LCBvcHQpIHtcbiAgICBTY2VuZVJlbmRlclBhc3MuY2FsbCh0aGlzLCByZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KTtcbiAgICB0aGlzLmxpZ2h0ID0gbGlnaHQ7XG4gICAgdGhpcy5wcm9ncmFtID0gbnVsbDtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKExpZ2h0UGFzcywgU2NlbmVSZW5kZXJQYXNzLCB7XG5cbiAgICBpbml0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLnNvcnRlciA9IG5ldyBPYmplY3RTb3J0ZXIoKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQcm9ncmFtQnlOYW1lKFwibGlnaHQtZGVwdGhcIik7XG4gICAgfSxcblxuICAgIHJlbmRlclNjZW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5saWdodC5zY2VuZSk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNfdmlld01hdF90bXAgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICB2YXIgY19wcm9qTWF0X3RtcCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX3Byb2dyYW1TeXN0ZW1Vbmlmb3JtcyA9IFtcInZpZXdNYXRyaXhcIiwgXCJwcm9qZWN0aW9uTWF0cml4XCJdO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2wsIHRhcmdldCA9IHRoaXMub3V0cHV0LCB3aWR0aCA9IHRhcmdldC5nZXRXaWR0aCgpLCBoZWlnaHQgPSB0YXJnZXQuZ2V0SGVpZ2h0KCksIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0LCBmcnVzdHVtID0gdGhpcy5saWdodC5nZXRGcnVzdHVtKGFzcGVjdCksIHByb2dyYW0gPSB0aGlzLnByb2dyYW07XG5cbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XG4gICAgICAgICAgICBnbC5jbGVhcihnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICAgICAgICAgIHZhciBjb3VudCA9IHtvYmplY3RzOiAwLCBwcmltaXRpdmVzOiAwfTtcblxuICAgICAgICAgICAgdGhpcy5saWdodC5tb2RlbC5nZXRMaWdodFZpZXdNYXRyaXgoY192aWV3TWF0X3RtcCk7XG4gICAgICAgICAgICBmcnVzdHVtLmdldFByb2plY3Rpb25NYXRyaXgoY19wcm9qTWF0X3RtcCwgYXNwZWN0KTtcblxuICAgICAgICAgICAgc2NlbmUudXBkYXRlUmVhZHlPYmplY3RzRnJvbU1hdHJpY2VzKGNfdmlld01hdF90bXAsIGNfcHJvak1hdF90bXApO1xuICAgICAgICAgICAgdmFyIG9iamVjdHMgPSB0aGlzLnNvcnRlci5zb3J0U2NlbmUoc2NlbmUpO1xuXG4gICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgcGFyYW1ldGVyc1tcInZpZXdNYXRyaXhcIl0gPSBjX3ZpZXdNYXRfdG1wO1xuICAgICAgICAgICAgcGFyYW1ldGVyc1tcInByb2plY3Rpb25NYXRyaXhcIl0gPSBjX3Byb2pNYXRfdG1wO1xuXG4gICAgICAgICAgICAvL1JlbmRlciBvcGFxdWUgb2JqZWN0c1xuICAgICAgICAgICAgZm9yICh2YXIgc2hhZGVyIGluIG9iamVjdHMub3BhcXVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJPYmplY3RzVG9BY3RpdmVCdWZmZXIob2JqZWN0cy5vcGFxdWVbc2hhZGVyXSwgc2NlbmUsIHRhcmdldCwgcGFyYW1ldGVycywgY19wcm9ncmFtU3lzdGVtVW5pZm9ybXMsIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLCBzdGF0czogY291bnQsIHByb2dyYW06IHByb2dyYW1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRG8gbm90IHJlbmRlciB0cmFuc3BhcmVudCBvYmplY3RzIChjb25zaWRlcmVkIHRvIG5vdCB0aHJvdyBzaGFkb3dzXG4gICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XG4gICAgICAgICAgICByZXR1cm4ge2NvdW50OiBjb3VudH07XG4gICAgICAgIH1cbiAgICB9KCkpXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMaWdodFBhc3M7XG5cbiIsInZhciBCYXNlUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG52YXIgdmVjMyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjMztcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xudmFyIG1hdDMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDM7XG5cbnZhciBQaWNrTm9ybWFsUmVuZGVyUGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KSB7XG4gICAgQmFzZVJlbmRlclBhc3MuY2FsbCh0aGlzLCByZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKFBpY2tOb3JtYWxSZW5kZXJQYXNzLCBCYXNlUmVuZGVyUGFzcywge1xuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNfbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX3dvcmxkTWF0cml4ID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgdmFyIGNfbm9ybWFsTWF0cml4MyA9IG1hdDMuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX3VuaWZvcm1Db2xsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGVudkJhc2U6IHt9LFxuICAgICAgICAgICAgICAgIGVudk92ZXJyaWRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHN5c0Jhc2U6IHt9XG4gICAgICAgICAgICB9LCBjX3N5c3RlbVVuaWZvcm1OYW1lcyA9IFtcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIiwgXCJtb2RlbFZpZXdNYXRyaXhOXCJdO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqZWN0LCB2aWV3TWF0cml4LCBwcm9qTWF0cml4KSB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsLCB0YXJnZXQgPSB0aGlzLm91dHB1dDtcblxuICAgICAgICAgICAgdGFyZ2V0LmJpbmQoKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUKTtcbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG4gICAgICAgICAgICBpZiAodmlld01hdHJpeCAmJiBwcm9qTWF0cml4KSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0LnVwZGF0ZU1vZGVsVmlld01hdHJpeCh2aWV3TWF0cml4KTtcbiAgICAgICAgICAgICAgICBvYmplY3QudXBkYXRlTW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeChwcm9qTWF0cml4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2JqZWN0LmdldE1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgoY19tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KTtcblxuICAgICAgICAgICAgb2JqZWN0LmdldFdvcmxkTWF0cml4KGNfd29ybGRNYXRyaXgpO1xuICAgICAgICAgICAgaWYgKCFYTUwzRC5tYXRoLm1hdDMubm9ybWFsRnJvbU1hdDQoY19ub3JtYWxNYXRyaXgzLCBjX3dvcmxkTWF0cml4KSkge1xuICAgICAgICAgICAgICAgIG1hdDMuaWRlbnRpdHkoY19ub3JtYWxNYXRyaXgzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LnByb2dyYW1GYWN0b3J5LmdldFBpY2tpbmdOb3JtYWxQcm9ncmFtKCk7XG4gICAgICAgICAgICBwcm9ncmFtLmJpbmQoKTtcblxuICAgICAgICAgICAgY191bmlmb3JtQ29sbGVjdGlvbi5zeXNCYXNlW1wibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiXSA9IGNfbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeDtcbiAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcIm1vZGVsVmlld01hdHJpeE5cIl0gPSBjX25vcm1hbE1hdHJpeDM7XG5cbiAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybVZhcmlhYmxlcyhudWxsLCBjX3N5c3RlbVVuaWZvcm1OYW1lcywgY191bmlmb3JtQ29sbGVjdGlvbik7XG4gICAgICAgICAgICBvYmplY3QubWVzaC5kcmF3KHByb2dyYW0pO1xuXG4gICAgICAgICAgICBwcm9ncmFtLnVuYmluZCgpO1xuICAgICAgICAgICAgdGFyZ2V0LnVuYmluZCgpO1xuICAgICAgICB9XG4gICAgfSgpKSwgLyoqXG4gICAgICogUmVhZCBub3JtYWwgZnJvbSBwaWNraW5nIGJ1ZmZlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBnbFggT3BlbkdMIENvb3JkaW5hdGUgb2YgY29sb3IgYnVmZmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGdsWSBPcGVuR0wgQ29vcmRpbmF0ZSBvZiBjb2xvciBidWZmZXJcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBWZWN0b3Igd2l0aCBub3JtYWwgZGF0YVxuICAgICAqL1xuICAgIHJlYWROb3JtYWxGcm9tUGlja2luZ0J1ZmZlcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNfcGlja1ZlY3RvciA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX29uZSA9IHZlYzMuZnJvbVZhbHVlcygxLCAxLCAxKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdsWCwgZ2xZKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMucmVhZFBpeGVsRGF0YUZyb21CdWZmZXIoZ2xYLCBnbFksIHRoaXMub3V0cHV0KTtcbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY19waWNrVmVjdG9yWzBdID0gZGF0YVswXSAvIDI1NDtcbiAgICAgICAgICAgIGNfcGlja1ZlY3RvclsxXSA9IGRhdGFbMV0gLyAyNTQ7XG4gICAgICAgICAgICBjX3BpY2tWZWN0b3JbMl0gPSBkYXRhWzJdIC8gMjU0O1xuXG4gICAgICAgICAgICB2ZWMzLnNjYWxlKGNfcGlja1ZlY3RvciwgY19waWNrVmVjdG9yLCAyKTtcbiAgICAgICAgICAgIHJldHVybiB2ZWMzLnN1YnRyYWN0KHZlYzMuY3JlYXRlKCksIGNfcGlja1ZlY3RvciwgY19vbmUpO1xuICAgICAgICB9XG4gICAgfSgpKVxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBQaWNrTm9ybWFsUmVuZGVyUGFzcztcblxuIiwidmFyIEJhc2VSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vYmFzZS5qc1wiKTtcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xuXG52YXIgUGlja09iamVjdFJlbmRlclBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xuICAgIEJhc2VSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XG59O1xuWE1MM0QuY3JlYXRlQ2xhc3MoUGlja09iamVjdFJlbmRlclBhc3MsIEJhc2VSZW5kZXJQYXNzKTtcblxuWE1MM0QuZXh0ZW5kKFBpY2tPYmplY3RSZW5kZXJQYXNzLnByb3RvdHlwZSwge1xuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNfbXZwID0gbWF0NC5jcmVhdGUoKSwgY191bmlmb3JtQ29sbGVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBlbnZCYXNlOiB7fSxcbiAgICAgICAgICAgICAgICBlbnZPdmVycmlkZTogbnVsbCxcbiAgICAgICAgICAgICAgICBzeXNCYXNlOiB7fVxuICAgICAgICAgICAgfSwgY19zeXN0ZW1Vbmlmb3JtTmFtZXMgPSBbXCJpZFwiLCBcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIl07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3RzLCB2aWV3TWF0cml4LCBwcm9qTWF0cml4KSB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsLCB0YXJnZXQgPSB0aGlzLm91dHB1dDtcbiAgICAgICAgICAgIHRhcmdldC5iaW5kKCk7XG5cbiAgICAgICAgICAgIGdsLmVuYWJsZShnbC5ERVBUSF9URVNUKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuXG4gICAgICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQucHJvZ3JhbUZhY3RvcnkuZ2V0UGlja2luZ09iamVjdElkUHJvZ3JhbSgpO1xuICAgICAgICAgICAgcHJvZ3JhbS5iaW5kKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbiA9IG9iamVjdHMubGVuZ3RoOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IG9iamVjdHNbal07XG4gICAgICAgICAgICAgICAgdmFyIG1lc2ggPSBvYmoubWVzaDtcblxuICAgICAgICAgICAgICAgIGlmICghb2JqLnBpY2thYmxlKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgIGlmICh2aWV3TWF0cml4ICYmIHByb2pNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnVwZGF0ZU1vZGVsVmlld01hdHJpeCh2aWV3TWF0cml4KTtcbiAgICAgICAgICAgICAgICAgICAgb2JqLnVwZGF0ZU1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgocHJvak1hdHJpeCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgb2JqLmdldE1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXgoY19tdnApO1xuXG4gICAgICAgICAgICAgICAgdmFyIG9iaklkID0gaiArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGMxID0gb2JqSWQgJiAyNTU7XG4gICAgICAgICAgICAgICAgb2JqSWQgPSBvYmpJZCA+PiA4O1xuICAgICAgICAgICAgICAgIHZhciBjMiA9IG9iaklkICYgMjU1O1xuICAgICAgICAgICAgICAgIG9iaklkID0gb2JqSWQgPj4gODtcbiAgICAgICAgICAgICAgICB2YXIgYzMgPSBvYmpJZCAmIDI1NTtcblxuICAgICAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcImlkXCJdID0gW2MzIC8gMjU1LjAsIGMyIC8gMjU1LjAsIGMxIC8gMjU1LjBdO1xuICAgICAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIl0gPSBjX212cDtcblxuICAgICAgICAgICAgICAgIHByb2dyYW0uc2V0VW5pZm9ybVZhcmlhYmxlcyhudWxsLCBjX3N5c3RlbVVuaWZvcm1OYW1lcywgY191bmlmb3JtQ29sbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgbWVzaC5kcmF3KHByb2dyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvZ3JhbS51bmJpbmQoKTtcbiAgICAgICAgICAgIHRhcmdldC51bmJpbmQoKTtcbiAgICAgICAgfTtcbiAgICB9KCkpLFxuXG4gICAgLyoqXG4gICAgICogUmVhZHMgcGl4ZWxzIGZyb20gdGhlIHNjcmVlbmJ1ZmZlciB0byBkZXRlcm1pbmUgcGlja2VkIG9iamVjdCBvciBub3JtYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggU2NyZWVuIENvb3JkaW5hdGUgb2YgY29sb3IgYnVmZmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgU2NyZWVuIENvb3JkaW5hdGUgb2YgY29sb3IgYnVmZmVyXG4gICAgICogQHBhcmFtIHtBcnJheX0gb2JqZWN0cyBMaXN0IG9mIG9iamVjdHMgdGhhdCB3ZXJlIHJlbmRlcmVkIGluIHRoZSBwcmV2aW91cyBwaWNraW5nIHBhc3NcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyT2JqZWN0fG51bGx9IFBpY2tlZCBPYmplY3RcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJPYmplY3RGcm9tUGlja2luZ0J1ZmZlcjogZnVuY3Rpb24gKHgsIHksIG9iamVjdHMpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLnJlYWRQaXhlbERhdGFGcm9tQnVmZmVyKHgsIHksIHRoaXMub3V0cHV0KTtcblxuICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgdmFyIG9iaklkID0gZGF0YVswXSAqIDY1NTM2ICsgZGF0YVsxXSAqIDI1NiArIGRhdGFbMl07XG5cbiAgICAgICAgaWYgKG9iaklkID4gMCkge1xuICAgICAgICAgICAgdmFyIHBpY2tlZE9iaiA9IG9iamVjdHNbb2JqSWQgLSAxXTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHBpY2tlZE9iajtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBpY2tPYmplY3RSZW5kZXJQYXNzO1xuXG4iLCJ2YXIgQmFzZVJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XG52YXIgdmVjMyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjMztcblxudmFyIFBpY2tQb3NpdGlvblJlbmRlclBhc3MgPSBmdW5jdGlvbiAocmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCkge1xuICAgIEJhc2VSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XG4gICAgdGhpcy5vYmplY3RCb3VuZGluZ0JveCA9IG5ldyBYTUwzRC5Cb3goKTtcbn07XG5YTUwzRC5jcmVhdGVDbGFzcyhQaWNrUG9zaXRpb25SZW5kZXJQYXNzLCBCYXNlUmVuZGVyUGFzcywge1xuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgY19tb2RlbE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX21vZGVsVmlld1Byb2plY3Rpb25NYXRyaXggPSBtYXQ0LmNyZWF0ZSgpLCBjX3VuaWZvcm1Db2xsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIGVudkJhc2U6IHt9LFxuICAgICAgICAgICAgICAgIGVudk92ZXJyaWRlOiBudWxsLFxuICAgICAgICAgICAgICAgIHN5c0Jhc2U6IHt9XG4gICAgICAgICAgICB9LCBjX3N5c3RlbVVuaWZvcm1OYW1lcyA9IFtcImJib3hcIiwgXCJtb2RlbE1hdHJpeFwiLCBcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIl07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmosIHZpZXdNYXRyaXgsIHByb2pNYXRyaXgpIHtcbiAgICAgICAgICAgIHZhciBnbCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuZ2wsIHRhcmdldCA9IHRoaXMub3V0cHV0O1xuXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQgfCBnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG5cbiAgICAgICAgICAgIGlmICh2aWV3TWF0cml4ICYmIHByb2pNYXRyaXgpIHtcbiAgICAgICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3TWF0cml4KHZpZXdNYXRyaXgpO1xuICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KHByb2pNYXRyaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqLmdldFdvcmxkTWF0cml4KGNfbW9kZWxNYXRyaXgpO1xuXG4gICAgICAgICAgICBvYmouZ2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveCh0aGlzLm9iamVjdEJvdW5kaW5nQm94KTtcbiAgICAgICAgICAgIHRoaXMub2JqZWN0Qm91bmRpbmdCb3gudHJhbnNmb3JtQXhpc0FsaWduZWQoY19tb2RlbE1hdHJpeCk7XG5cbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQaWNraW5nUG9zaXRpb25Qcm9ncmFtKCk7XG4gICAgICAgICAgICBwcm9ncmFtLmJpbmQoKTtcbiAgICAgICAgICAgIG9iai5nZXRNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KGNfbW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCk7XG5cbiAgICAgICAgICAgIGNfdW5pZm9ybUNvbGxlY3Rpb24uc3lzQmFzZVtcImJib3hcIl0gPSB0aGlzLm9iamVjdEJvdW5kaW5nQm94LmRhdGE7XG4gICAgICAgICAgICBjX3VuaWZvcm1Db2xsZWN0aW9uLnN5c0Jhc2VbXCJtb2RlbE1hdHJpeFwiXSA9IGNfbW9kZWxNYXRyaXg7XG4gICAgICAgICAgICBjX3VuaWZvcm1Db2xsZWN0aW9uLnN5c0Jhc2VbXCJtb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4XCJdID0gY19tb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4O1xuXG4gICAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm1WYXJpYWJsZXMobnVsbCwgY19zeXN0ZW1Vbmlmb3JtTmFtZXMsIGNfdW5pZm9ybUNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgb2JqLm1lc2guZHJhdyhwcm9ncmFtKTtcblxuICAgICAgICAgICAgcHJvZ3JhbS51bmJpbmQoKTtcbiAgICAgICAgICAgIHRhcmdldC51bmJpbmQoKTtcbiAgICAgICAgfTtcbiAgICB9KCkpLFxuXG4gICAgcmVhZFBvc2l0aW9uRnJvbVBpY2tpbmdCdWZmZXI6IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGNfdmVjMyA9IHZlYzMuY3JlYXRlKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMucmVhZFBpeGVsRGF0YUZyb21CdWZmZXIoeCwgeSwgdGhpcy5vdXRwdXQpO1xuICAgICAgICAgICAgaWYgKGRhdGEpIHtcblxuICAgICAgICAgICAgICAgIGNfdmVjM1swXSA9IGRhdGFbMF0gLyAyNTU7XG4gICAgICAgICAgICAgICAgY192ZWMzWzFdID0gZGF0YVsxXSAvIDI1NTtcbiAgICAgICAgICAgICAgICBjX3ZlYzNbMl0gPSBkYXRhWzJdIC8gMjU1O1xuXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSB0aGlzLm9iamVjdEJvdW5kaW5nQm94LnNpemUoKTtcbiAgICAgICAgICAgICAgICB2ZWMzLm11bChjX3ZlYzMsIGNfdmVjMywgc2l6ZS5kYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmVjMy5hZGQodmVjMy5jcmVhdGUoKSwgY192ZWMzLCB0aGlzLm9iamVjdEJvdW5kaW5nQm94Lm1pbi5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KCkpXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBQaWNrUG9zaXRpb25SZW5kZXJQYXNzO1xuXG4iLCJ2YXIgU2NlbmVSZW5kZXJQYXNzID0gcmVxdWlyZShcIi4vc2NlbmUtcGFzcy5qc1wiKTtcbnZhciBPYmplY3RTb3J0ZXIgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyZXIvdG9vbHMvb2JqZWN0c29ydGVyLmpzXCIpO1xudmFyIG1hdDQgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDQ7XG5cbi8qKlxuICogQHBhcmFtIHtHTFJlbmRlckludGVyZmFjZX0gcmVuZGVySW50ZXJmYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gb3V0cHV0XG4gKiBAcGFyYW0ge1JlbmRlckxpZ2h0fSBsaWdodFxuICogQHBhcmFtIHsqfSBvcHRcbiAqIEBleHRlbmRzIHtTY2VuZVJlbmRlclBhc3N9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFBvaW50TGlnaHRQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBsaWdodCwgb3B0KSB7XG4gICAgU2NlbmVSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XG4gICAgdGhpcy5saWdodCA9IGxpZ2h0O1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG59O1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhQb2ludExpZ2h0UGFzcywgU2NlbmVSZW5kZXJQYXNzLCB7XG5cbiAgICBpbml0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICB0aGlzLnNvcnRlciA9IG5ldyBPYmplY3RTb3J0ZXIoKTtcbiAgICAgICAgdGhpcy5wcm9ncmFtID0gY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQcm9ncmFtQnlOYW1lKFwibGlnaHQtZGVwdGhcIik7XG4gICAgfSxcblxuICAgIHJlbmRlclNjZW5lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXIodGhpcy5saWdodC5zY2VuZSk7XG4gICAgfSxcblxuICAgIHJlbmRlcjogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNfdmlld01hdF90bXAgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICB2YXIgY19wcm9qTWF0X3RtcCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX3Byb2dyYW1TeXN0ZW1Vbmlmb3JtcyA9IFtcInZpZXdNYXRyaXhcIiwgXCJwcm9qZWN0aW9uTWF0cml4XCJdO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2NlbmUpIHtcblxuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbCwgdGFyZ2V0ID0gdGhpcy5vdXRwdXQsIHdpZHRoID0gdGFyZ2V0LmdldFdpZHRoKCksIGhlaWdodCA9IHRhcmdldC5nZXRIZWlnaHQoKSwgYXNwZWN0ID0gd2lkdGggLyBoZWlnaHQsIGZydXN0dW0gPSB0aGlzLmxpZ2h0LmdldEZydXN0dW0oYXNwZWN0KSwgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbTtcbiAgICAgICAgICAgIGZvciAodmFyIHNpZGUgPSAwOyBzaWRlIDwgdGFyZ2V0LmdsU2lkZXMubGVuZ3RoOyBzaWRlKyspIHtcbiAgICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSByb3RhdGlvbm1hdHJpeCBmb3IgdGhhdCBmYWNlXG4gICAgICAgICAgICAgICAgdmFyIG1hdF9yb3QgPSBuZXcgWE1MM0QuTWF0NCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPT0gMCkgeyAvL2xvb2sgaW50byAreCBvXG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTExID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIyID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzEgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMyA9IDA7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZGUgPT0gMSkgeyAvL2xvb2sgaW50byAteFxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTEyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTMgPSAxO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIyID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzEgPSAxO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTMzID0gMDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2lkZSA9PSAyKSB7IC8vbG9vayBpbnRvICt5XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTExID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMyA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTMyID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzMgPSAwO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzaWRlID09IDMpIHsgLy9sb29rIGludG8gLXlcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTEgPSAxO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTEzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIzID0gMTtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMyA9IDA7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZGUgPT0gNCkgeyAvL2xvb2sgaW50byArelxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTEyID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMTMgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIyID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTIzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTMzID0gLTE7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNpZGUgPT0gNSkgeyAvL2xvb2sgaW50byAtelxuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0xMiA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTEzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMjEgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0yMyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG1hdF9yb3QubTMxID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbWF0X3JvdC5tMzIgPSAwO1xuICAgICAgICAgICAgICAgICAgICBtYXRfcm90Lm0zMiA9IDE7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmJpbmQoc2lkZSk7XG5cbiAgICAgICAgICAgICAgICBnbC5jbGVhcihnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNvdW50ID0ge29iamVjdHM6IDAsIHByaW1pdGl2ZXM6IDB9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5saWdodC5tb2RlbC5nZXRMaWdodFZpZXdNYXRyaXgoY192aWV3TWF0X3RtcCk7XG4gICAgICAgICAgICAgICAgLy9yb3RhdGUgZm9yIHRoZSBhcHJvcHJpYXRlIHNpZGUgb2YgdGhlIGN1YmVtYXBcbiAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsKGNfdmlld01hdF90bXAsIG1hdF9yb3QuZGF0YSwgY192aWV3TWF0X3RtcCk7XG5cbiAgICAgICAgICAgICAgICBmcnVzdHVtLmdldFByb2plY3Rpb25NYXRyaXgoY19wcm9qTWF0X3RtcCwgYXNwZWN0KTtcblxuICAgICAgICAgICAgICAgIHNjZW5lLnVwZGF0ZVJlYWR5T2JqZWN0c0Zyb21NYXRyaWNlcyhjX3ZpZXdNYXRfdG1wLCBjX3Byb2pNYXRfdG1wKTtcbiAgICAgICAgICAgICAgICB2YXIgb2JqZWN0cyA9IHRoaXMuc29ydGVyLnNvcnRTY2VuZShzY2VuZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcGFyYW1ldGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbXCJ2aWV3TWF0cml4XCJdID0gY192aWV3TWF0X3RtcDtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzW1wicHJvamVjdGlvbk1hdHJpeFwiXSA9IGNfcHJvak1hdF90bXA7XG5cbiAgICAgICAgICAgICAgICAvL1JlbmRlciBvcGFxdWUgb2JqZWN0c1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHNoYWRlciBpbiBvYmplY3RzLm9wYXF1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck9iamVjdHNUb0FjdGl2ZUJ1ZmZlcihvYmplY3RzLm9wYXF1ZVtzaGFkZXJdLCBzY2VuZSwgdGFyZ2V0LCBwYXJhbWV0ZXJzLCBjX3Byb2dyYW1TeXN0ZW1Vbmlmb3Jtcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHM6IGNvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgcmVuZGVyIHRyYW5zcGFyZW50IG9iamVjdHMgKGNvbnNpZGVyZWQgdG8gbm90IHRocm93IHNoYWRvd3NcbiAgICAgICAgICAgICAgICB0YXJnZXQudW5iaW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge2NvdW50OiBjb3VudH07XG4gICAgICAgIH1cbiAgICB9KCkpXG59KTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50TGlnaHRQYXNzO1xuXG4iLCJ2YXIgQmFzZVJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9iYXNlLmpzXCIpO1xudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xudmFyIG1hdDMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDM7XG5cbnZhciBPUFRJT05fRkFDRUNVTExJTkcgPSBcInJlbmRlcmVyLWZhY2VjdWxsaW5nXCI7XG52YXIgT1BUSU9OX0ZST05URkFDRSA9IFwicmVuZGVyZXItZnJvbnRmYWNlXCI7XG5cbk9wdGlvbnMucmVnaXN0ZXIoT1BUSU9OX0ZBQ0VDVUxMSU5HLCBcIm5vbmVcIik7XG5PcHRpb25zLnJlZ2lzdGVyKE9QVElPTl9GUk9OVEZBQ0UsIFwiY2N3XCIpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2NlbmVSZW5kZXJQYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpIHtcbiAgICBCYXNlUmVuZGVyUGFzcy5jYWxsKHRoaXMsIHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cbiAgICAgKi9cbiAgICB0aGlzLnNldEZhY2VDdWxsaW5nID0gZ2V0R2xvYmFsRmFjZUN1bGxpbmdTZXR0ZXIoT3B0aW9ucy5nZXRWYWx1ZShPUFRJT05fRkFDRUNVTExJTkcpKTtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb259XG4gICAgICovXG4gICAgdGhpcy5zZXRGcm9udEZhY2UgPSBnZXRHbG9iYWxGcm9udEZhY2VTZXR0ZXIoT3B0aW9ucy5nZXRWYWx1ZShPUFRJT05fRlJPTlRGQUNFKSk7XG5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgT3B0aW9ucy5hZGRPYnNlcnZlcihPUFRJT05fRkFDRUNVTExJTkcsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoYXQuc2V0RmFjZUN1bGxpbmcgPSBnZXRHbG9iYWxGYWNlQ3VsbGluZ1NldHRlcih2YWx1ZSk7XG4gICAgfSk7XG4gICAgT3B0aW9ucy5hZGRPYnNlcnZlcihPUFRJT05fRlJPTlRGQUNFLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGF0LnNldEZyb250RmFjZSA9IGdldEdsb2JhbEZyb250RmFjZVNldHRlcih2YWx1ZSk7XG4gICAgfSk7XG59O1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhTY2VuZVJlbmRlclBhc3MsIEJhc2VSZW5kZXJQYXNzLCB7XG4gICAgc2V0R0xTdGF0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQgfCBnbC5TVEVOQ0lMX0JVRkZFUl9CSVQpO1xuICAgICAgICB0aGlzLnNldEZhY2VDdWxsaW5nKGdsKTtcbiAgICAgICAgdGhpcy5zZXRGcm9udEZhY2UoZ2wpO1xuICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgfSwgLyoqXG4gICAgICogQHBhcmFtIEFycmF5XG4gICAgICovXG4gICAgcmVuZGVyT2JqZWN0c1RvQWN0aXZlQnVmZmVyOiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdG1wTW9kZWxNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICB2YXIgdG1wTW9kZWxNYXRyaXhOID0gbWF0My5jcmVhdGUoKTtcbiAgICAgICAgdmFyIHRtcE1vZGVsVmlldyA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciB0bXBNb2RlbFZpZXdQcm9qZWN0aW9uID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgdmFyIHRtcE1vZGVsVmlld04gPSBtYXQzLmNyZWF0ZSgpO1xuICAgICAgICB2YXIgY19vYmplY3RTeXN0ZW1Vbmlmb3JtcyA9IFtcIm1vZGVsTWF0cml4XCIsIFwibW9kZWxNYXRyaXhOXCIsIFwibW9kZWxWaWV3TWF0cml4XCIsIFwibW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeFwiLCBcIm1vZGVsVmlld01hdHJpeE5cIl07XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvYmplY3RBcnJheSwgc2NlbmUsIHRhcmdldCwgc3lzdGVtVW5pZm9ybXMsIHNjZW5lUGFyYW1ldGVyRmlsdGVyLCBvcHQpIHtcbiAgICAgICAgICAgIHZhciBvYmpDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgcHJpbWl0aXZlQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXRzID0gb3B0LnN0YXRzIHx8IHt9O1xuICAgICAgICAgICAgdmFyIHRyYW5zcGFyZW50ID0gb3B0LnRyYW5zcGFyZW50ID09PSB0cnVlIHx8IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gb3B0LnByb2dyYW0gfHwgb2JqZWN0QXJyYXlbMF0uZ2V0UHJvZ3JhbSgpO1xuXG4gICAgICAgICAgICBpZiAob2JqZWN0QXJyYXkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc3BhcmVudCkge1xuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICAgICAgZ2wuYmxlbmRGdW5jU2VwYXJhdGUoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBLCBnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBndWFyYW50ZWUgdGhhdCB0aGUgUmVuZGVyT2JqZWN0IGhhcyBhIHZhbGlkIHNoYWRlclxuICAgICAgICAgICAgcHJvZ3JhbS5iaW5kKCk7XG5cbiAgICAgICAgICAgIC8vU2V0IGdsb2JhbCBkYXRhIHRoYXQgaXMgc2hhcmVkIGJldHdlZW4gYWxsIG9iamVjdHMgdXNpbmcgdGhpcyBzaGFkZXJcbiAgICAgICAgICAgIHByb2dyYW0uc2V0U3lzdGVtVW5pZm9ybVZhcmlhYmxlcyhzY2VuZVBhcmFtZXRlckZpbHRlciwgc3lzdGVtVW5pZm9ybXMpO1xuXG4gICAgICAgICAgICB2YXIgcHJldk92ZXJyaWRlID0gbnVsbDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBvYmplY3RBcnJheS5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqID0gb2JqZWN0QXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKCFvYmoudmlzaWJsZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICB2YXIgbWVzaCA9IG9iai5tZXNoO1xuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmFzc2VydChtZXNoLCBcIldlIG5lZWQgYSBtZXNoIGF0IHRoaXMgcG9pbnQuXCIpO1xuXG4gICAgICAgICAgICAgICAgb2JqLmdldFdvcmxkTWF0cml4KHRtcE1vZGVsTWF0cml4KTtcbiAgICAgICAgICAgICAgICBzeXN0ZW1Vbmlmb3Jtc1tcIm1vZGVsTWF0cml4XCJdID0gdG1wTW9kZWxNYXRyaXg7XG5cbiAgICAgICAgICAgICAgICBvYmouZ2V0TW9kZWxNYXRyaXhOKHRtcE1vZGVsTWF0cml4Tik7XG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJtb2RlbE1hdHJpeE5cIl0gPSB0bXBNb2RlbE1hdHJpeE47XG5cbiAgICAgICAgICAgICAgICBvYmouZ2V0TW9kZWxWaWV3TWF0cml4KHRtcE1vZGVsVmlldyk7XG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJtb2RlbFZpZXdNYXRyaXhcIl0gPSB0bXBNb2RlbFZpZXc7XG5cbiAgICAgICAgICAgICAgICBvYmouZ2V0TW9kZWxWaWV3UHJvamVjdGlvbk1hdHJpeCh0bXBNb2RlbFZpZXdQcm9qZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzeXN0ZW1Vbmlmb3Jtc1tcIm1vZGVsVmlld1Byb2plY3Rpb25NYXRyaXhcIl0gPSB0bXBNb2RlbFZpZXdQcm9qZWN0aW9uO1xuXG4gICAgICAgICAgICAgICAgb2JqLmdldE1vZGVsVmlld01hdHJpeE4odG1wTW9kZWxWaWV3Tik7XG4gICAgICAgICAgICAgICAgc3lzdGVtVW5pZm9ybXNbXCJtb2RlbFZpZXdNYXRyaXhOXCJdID0gdG1wTW9kZWxWaWV3TjtcblxuICAgICAgICAgICAgICAgIHByb2dyYW0uc2V0U3lzdGVtVW5pZm9ybVZhcmlhYmxlcyhjX29iamVjdFN5c3RlbVVuaWZvcm1zLCBzeXN0ZW1Vbmlmb3Jtcyk7XG5cbiAgICAgICAgICAgICAgICBwcm9ncmFtLmNoYW5nZVVuaWZvcm1WYXJpYWJsZU92ZXJyaWRlKHByZXZPdmVycmlkZSwgbWVzaC51bmlmb3JtT3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgIHByZXZPdmVycmlkZSA9IG1lc2gudW5pZm9ybU92ZXJyaWRlO1xuXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlQ291bnQgKz0gbWVzaC5kcmF3KHByb2dyYW0pO1xuICAgICAgICAgICAgICAgIG9iakNvdW50Kys7XG5cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5CTEVORCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9ncmFtLmNoYW5nZVVuaWZvcm1WYXJpYWJsZU92ZXJyaWRlKHByZXZPdmVycmlkZSwgbnVsbCk7XG5cbiAgICAgICAgICAgIHByb2dyYW0udW5iaW5kKCk7XG4gICAgICAgICAgICBzdGF0cy5vYmplY3RzICs9IG9iakNvdW50O1xuICAgICAgICAgICAgc3RhdHMucHJpbWl0aXZlcyArPSBwcmltaXRpdmVDb3VudDtcbiAgICAgICAgICAgIHJldHVybiBzdGF0cztcbiAgICAgICAgfVxuICAgIH0oKSlcblxuXG59KTtcblxuZnVuY3Rpb24gZ2V0R2xvYmFsRnJvbnRGYWNlU2V0dGVyKG1vZGUpIHtcbiAgICBpZiAobW9kZS50b0xvd2VyQ2FzZSgpID09IFwiY3dcIikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XG4gICAgICAgICAgICBnbC5mcm9udEZhY2UoZ2wuQ1cpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XG4gICAgICAgIGdsLmZyb250RmFjZShnbC5DQ1cpO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldEdsb2JhbEZhY2VDdWxsaW5nU2V0dGVyKG1vZGUpIHtcbiAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICBzd2l0Y2ggKG1vZGUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICBjYXNlIFwiYmFja1wiOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xuICAgICAgICAgICAgICAgIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpO1xuICAgICAgICAgICAgICAgIGdsLmN1bGxGYWNlKGdsLkJBQ0spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZnJvbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ2wpIHtcbiAgICAgICAgICAgICAgICBnbC5lbmFibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgICAgICBnbC5jdWxsRmFjZShnbC5GUk9OVCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJib3RoXCI6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGdsKSB7XG4gICAgICAgICAgICAgICAgZ2wuZW5hYmxlKGdsLkNVTExfRkFDRSk7XG4gICAgICAgICAgICAgICAgZ2wuY3VsbEZhY2UoZ2wuRlJPTlRfQU5EX0JBQ0spO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibm9uZVwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChnbCkge1xuICAgICAgICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcbiAgICAgICAgICAgIH07XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lUmVuZGVyUGFzcztcbiIsInZhciBCYXNlUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG52YXIgVmVydGV4QXR0cmlidXRlUGFzcyA9IHJlcXVpcmUoXCIuL3ZlcnRleGF0dHJpYnV0ZS1wYXNzLmpzXCIpO1xudmFyIEdMUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZShcIi4uL2Jhc2UvcmVuZGVydGFyZ2V0LmpzXCIpLkdMUmVuZGVyVGFyZ2V0O1xudmFyIEZ1bGxzY3JlZW5RdWFkID0gcmVxdWlyZShcIi4uL2Jhc2UvZnVsbHNjcmVlbnF1YWQuanNcIik7XG52YXIgT3B0aW9ucyA9IHJlcXVpcmUoXCIuLi8uLi8uLi91dGlscy9vcHRpb25zLmpzXCIpO1xuXG52YXIgYmFzZTY0UmFuZG9tTm9ybWFscyA9IFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFJQUFBQUNBQ0FJQUFBQk1YUGFjQUFBQUNYQklXWE1BQUFzVEFBQUxFd0VBbXB3WUFBQUtUMmxEUTFCUWFHOTBiM05vYjNBZ1NVTkRJSEJ5YjJacGJHVUFBSGphblZOblZGUHBGajMzM3ZSQ1M0aUFsRXR2VWhVSUlGSkNpNEFVa1NZcUlRa1FTb2dob2RrVlVjRVJSVVVFRzhpZ2lBT09qb0NNRlZFc0RJb0syQWZrSWFLT2c2T0lpc3I3NFh1amE5YTg5K2JOL3JYWFB1ZXM4NTJ6endmQUNBeVdTRE5STllBTXFVSWVFZUNEeDhURzRlUXVRSUVLSkhBQUVBaXpaQ0Z6L1NNQkFQaCtQRHdySXNBSHZnQUJlTk1MQ0FEQVRadkFNQnlIL3cvcVFwbGNBWUNFQWNCMGtUaExDSUFVQUVCNmprS21BRUJHQVlDZG1DWlRBS0FFQUdETFkyTGpBRkF0QUdBbmYrYlRBSUNkK0psN0FRQmJsQ0VWQWFDUkFDQVRaWWhFQUdnN0FLelBWb3BGQUZnd0FCUm1TOFE1QU5ndEFEQkpWMlpJQUxDM0FNRE9FQXV5QUFnTUFEQlJpSVVwQUFSN0FHRElJeU40QUlTWkFCUkc4bGM4OFN1dUVPY3FBQUI0bWJJOHVTUTVSWUZiQ0MxeEIxZFhMaDRvemtrWEt4UTJZUUpobWtBdXdubVpHVEtCTkEvZzg4d0FBS0NSRlJIZ2cvUDllTTRPcnM3T05vNjJEbDh0NnI4Ry95SmlZdVArNWMrcmNFQUFBT0YwZnRIK0xDK3pHb0E3Qm9CdC9xSWw3Z1JvWGd1Z2RmZUxacklQUUxVQW9PbmFWL053K0g0OFBFV2hrTG5aMmVYazVOaEt4RUpiWWNwWGZmNW53bC9BVi8xcytYNDgvUGYxNEw3aUpJRXlYWUZIQlBqZ3dzejBUS1VjejVJSmhHTGM1bzlIL0xjTC8vd2QweUxFU1dLNVdDb1U0MUVTY1k1RW1venpNcVVpaVVLU0tjVWwwdjlrNHQ4cyt3TSszelVBc0dvK0FYdVJMYWhkWXdQMlN5Y1FXSFRBNHZjQUFQSzdiOEhVS0FnRGdHaUQ0YzkzLys4Ly9VZWdKUUNBWmttU2NRQUFYa1FrTGxUS3N6L0hDQUFBUktDQktyQkJHL1RCR0N6QUJoekJCZHpCQy94Z05vUkNKTVRDUWhCQ0NtU0FISEpnS2F5Q1FpaUd6YkFkS21BdjFFQWROTUJSYUlhVGNBNHV3bFc0RGoxd0QvcGhDSjdCS0x5QkNRUkJ5QWdUWVNIYWlBRmlpbGdqamdnWG1ZWDRJY0ZJQkJLTEpDREppQlJSSWt1Uk5VZ3hVb3BVSUZWSUhmSTljZ0k1aDF4R3VwRTd5QUF5Z3Z5R3ZFY3hsSUd5VVQzVURMVkR1YWczR29SR29ndlFaSFF4bW84V29KdlFjclFhUFl3Mm9lZlFxMmdQMm84K1E4Y3d3T2dZQnpQRWJEQXV4c05Dc1Rnc0NaTmp5N0VpckF5cnhocXdWcXdEdTRuMVk4K3hkd1FTZ1VYQUNUWUVkMElnWVI1QlNGaE1XRTdZU0tnZ0hDUTBFZG9KTndrRGhGSENKeUtUcUV1MEpyb1IrY1FZWWpJeGgxaElMQ1BXRW84VEx4QjdpRVBFTnlRU2lVTXlKN21RQWtteHBGVFNFdEpHMG01U0kra3NxWnMwU0Jvams4bmFaR3V5QnptVUxDQXJ5SVhrbmVURDVEUGtHK1FoOGxzS25XSkFjYVQ0VStJb1VzcHFTaG5sRU9VMDVRWmxtREpCVmFPYVV0Mm9vVlFSTlk5YVFxMmh0bEt2VVllb0V6UjFtam5OZ3haSlM2V3RvcFhUR21nWGFQZHByK2gwdWhIZGxSNU9sOUJYMHN2cFIraVg2QVAwZHd3TmhoV0R4NGhuS0JtYkdBY1laeGwzR0srWVRLWVowNHNaeDFRd056SHJtT2VaRDVsdlZWZ3F0aXA4RlpIS0NwVktsU2FWR3lvdlZLbXFwcXJlcWd0VjgxWExWSStwWGxOOXJrWlZNMVBqcVFuVWxxdFZxcDFRNjFNYlUyZXBPNmlIcW1lb2IxUS9wSDVaL1lrR1djTk13MDlEcEZHZ3NWL2p2TVlnQzJNWnMzZ3NJV3NOcTRaMWdUWEVKckhOMlh4MktydVkvUjI3aXoycXFhRTVRek5LTTFlelV2T1VaajhINDVoeCtKeDBUZ25uS0tlWDgzNkszaFR2S2VJcEc2WTBUTGt4WlZ4cnFwYVhsbGlyU0t0UnEwZnJ2VGF1N2FlZHByMUZ1MW43Z1E1Qngwb25YQ2RIWjQvT0JaM25VOWxUM2FjS3B4Wk5QVHIxcmk2cWE2VWJvYnRFZDc5dXArNllucjVlZ0o1TWI2ZmVlYjNuK2h4OUwvMVUvVzM2cC9WSERGZ0dzd3drQnRzTXpoZzh4VFZ4Ynp3ZEw4ZmI4VkZEWGNOQVE2VmhsV0dYNFlTUnVkRThvOVZHalVZUGpHbkdYT01rNDIzR2JjYWpKZ1ltSVNaTFRlcE43cHBTVGJtbUthWTdURHRNeDgzTXphTE4xcGsxbXoweDF6TG5tK2ViMTV2ZnQyQmFlRm9zdHFpMnVHVkpzdVJhcGxudXRyeHVoVm81V2FWWVZWcGRzMGF0bmEwbDFydXR1NmNScDdsT2swNnJudFpudzdEeHRzbTJxYmNac09YWUJ0dXV0bTIyZldGblloZG50OFd1dys2VHZaTjl1bjJOL1QwSERZZlpEcXNkV2gxK2M3UnlGRHBXT3Q2YXpwenVQMzNGOUpicEwyZFl6eERQMkRQanRoUExLY1JwblZPYjAwZG5GMmU1YzRQemlJdUpTNExMTHBjK0xwc2J4dDNJdmVSS2RQVnhYZUY2MHZXZG03T2J3dTJvMjYvdU51NXA3b2Zjbjh3MG55bWVXVE56ME1QSVErQlI1ZEUvQzUrVk1HdmZySDVQUTArQlo3WG5JeTlqTDVGWHJkZXd0NlYzcXZkaDd4Yys5ajV5bitNKzR6dzMzakxlV1YvTU44QzN5TGZMVDhOdm5sK0YzME4vSS85ay8zci8wUUNuZ0NVQlp3T0pnVUdCV3dMNytIcDhJYitPUHpyYlpmYXkyZTFCaktDNVFSVkJqNEt0Z3VYQnJTRm95T3lRclNIMzU1ak9rYzVwRG9WUWZ1alcwQWRoNW1HTHczNE1KNFdIaFZlR1A0NXdpRmdhMFRHWE5YZlIzRU56MzBUNlJKWkUzcHRuTVU4NXJ5MUtOU28rcWk1cVBObzN1alM2UDhZdVpsbk0xVmlkV0Vsc1N4dzVMaXF1Tm01c3Z0Lzg3Zk9INHAzaUMrTjdGNWd2eUYxd2VhSE93dlNGcHhhcExoSXNPcFpBVEloT09KVHdRUkFxcUJhTUpmSVRkeVdPQ25uQ0hjSm5JaS9STnRHSTJFTmNLaDVPOGtncVRYcVM3Skc4Tlhra3hUT2xMT1c1aENlcGtMeE1EVXpkbXpxZUZwcDJJRzB5UFRxOU1ZT1NrWkJ4UXFvaFRaTzJaK3BuNW1aMnk2eGxoYkwreFc2THR5OGVsUWZKYTdPUXJBVlpMUXEyUXFib1ZGb28xeW9Ic21kbFYyYS96WW5LT1phcm5pdk43Y3l6eXR1UU41enZuLy90RXNJUzRaSzJwWVpMVnkwZFdPYTlyR281c2p4eGVkc0s0eFVGSzRaV0Jxdzh1SXEyS20zVlQ2dnRWNWV1ZnIwbWVrMXJnVjdCeW9MQnRRRnI2d3RWQ3VXRmZldmMxKzFkVDFndldkKzFZZnFHblJzK0ZZbUtyaFRiRjVjVmY5Z28zSGpsRzRkdnlyK1ozSlMwcWF2RXVXVFBadEptNmViZUxaNWJEcGFxbCthWERtNE4yZHEwRGQ5V3RPMzE5a1hiTDVmTktOdTdnN1pEdWFPL1BMaThaYWZKenMwN1AxU2tWUFJVK2xRMjd0TGR0V0hYK0c3UjdodDd2UFkwN05YYlc3ejMvVDdKdnR0VkFWVk4xV2JWWmZ0Sis3UDNQNjZKcXVuNGx2dHRYYTFPYlhIdHh3UFNBLzBISXc2MjE3blUxUjNTUFZSU2o5WXI2MGNPeHgrKy9wM3ZkeTBOTmcxVmpaekc0aU53UkhuazZmY0ozL2NlRFRyYWRveDdyT0VIMHg5MkhXY2RMMnBDbXZLYVJwdFRtdnRiWWx1NlQ4dyswZGJxM25yOFI5c2ZENXcwUEZsNVN2TlV5V25hNllMVGsyZnl6NHlkbFoxOWZpNzUzR0Rib3JaNzUyUE8zMm9QYisrNkVIVGgwa1gvaStjN3ZEdk9YUEs0ZFBLeTIrVVRWN2hYbXE4NlgyM3FkT284L3BQVFQ4ZTduTHVhcnJsY2E3bnVlcjIxZTJiMzZSdWVOODdkOUwxNThSYi8xdFdlT1QzZHZmTjZiL2ZGOS9YZkZ0MStjaWY5enN1NzJYY243cTI4VDd4ZjlFRHRRZGxEM1lmVlAxdiszTmp2M0g5cXdIZWc4OUhjUi9jR2hZUFAvcEgxanc5REJZK1pqOHVHRFlicm5qZytPVG5pUDNMOTZmeW5RODlrenlhZUYvNmkvc3V1RnhZdmZ2alY2OWZPMFpqUm9aZnlsNU8vYlh5bC9lckE2eG12MjhiQ3hoNit5WGd6TVY3MFZ2dnR3WGZjZHgzdm85OFBUK1I4SUg4by8yajVzZlZUMEtmN2t4bVRrLzhFQTVqei9HTXpMZHNBQUFBZ1kwaFNUUUFBZWlVQUFJQ0RBQUQ1L3dBQWdPa0FBSFV3QUFEcVlBQUFPcGdBQUJkdmtsL0ZSZ0FBblJ4SlJFRlVlTm9FNFhlTXBubUNHT2I5MHB2RGwzTjlsYXU2cXJzNlQzZFAzdG1kM2IzYlM3eWpqcUlZWkpLd0xNS1dMY3VDU2Rpd0RNZzJMRUEyRFFNR0JGaXdxVDhzK2NSNFBwRzM1T2FaMmNuVHVhdEQ1ZmpsL0wwNS9JS2ZCLzdEL3pYL0FmWmNVL3AvTHJ0WHMxcWhyMTF3OXZmNzA3MWM3cjhLSm5lOTh0OE9SbCt5a3ZkdXJOckpsOU0wZTJoLzJPQ041ZjdQdUtYdFpyMWpIanJKWDc5S0Q1ajU3YXBmN091bk1QZ3dOTWdJV0JMbkNMQzYyRk9GbU9MbENINTdIdFhxYWxhSHNKbWtqNlIzaS80L2k5V2RxM1QxV1B3M2MvNC9yZk14VjU0dFVRWkExM0xqbnZwM2orUzJxK3plVGU0ZVN2OWRNdC9jay8vNEoreTRiL3ZMYWVNNS9JdUY5R09vck5Rbm45VUZvcmdtd0RldmpkWXI3eDhlcGJTby82TlNjdU9lZGN2Qm54ckozM0hvRUtxL01iZytWTTV4OExlcHRLRVBQOGZWcDRVb1UwaUFIUjVmU2l0dXRqRW5oWG9vUWh5a1dEZzRuNGtqUnhyTnlHcy9lWjd0L05YWnNoNkpSWngrWjBzckVFd3AzTXZFLytFdy9NZXVwaEgwSDFZbTUxZVUvMXNyMmtHRnhVUHl3b2ovUVczV2lUUC85VVZ5NVdsc21LcGIxd3dkSXdRY245MlJCWVFnVjJLa1FvbTZKdm9sZ0VDYVU1RWJnUTJaV1NmU2tCamlBdDRiRmN5WGc4Y0w5cHRickdRbnBhR1NweElWUXVuaXJsUm1HS3hWbzlPZW1wbVRQVThkYS9EcXdBaWZNU2JvY1VOY1YwR2RCZC9FNWt5bml3eW1DamhOQWI0TkxTaXNDNUNPSkR5a2wyVnRwc1ZFNTI0VFZSZlJRT2ZWa3hnQzh0TDF0L0pZQ1V5blNsTUY2Z3laSHIzVzBjSEErZnFyZkxRTnl2bTRWQUxMQTdNN0ZvdGQvVHpoVlNSWkJSL3F2SHhOVDY2QWlZVXppSmY2U21rdktMZEZWOE9qQXVtLzdhNWxwSktHeDNPOFpBSzNFaUxPOHE1Nk9aWHpaM0xUbFM5bnpMR1UyMGxDTGJCSFJOT0lnaHpyYk5GR0xBM09zNVhkMktIZ3hZSU1NVWhXMC9KamZKcERCNlpkWGVkQkNDWllkU1JvVjNFdUFXb0ZOcnVTd3pRd1lXVkRteXdTM1ZScm84UWJwMjJGNDZZQ0ZLU212SnVSUVE3aVAweiswemZVUE5SUlphcXYvQnlwTDlQUlNDVFhaRjBSZDd2dUdkQmZHU0s1SnNnMzJ0V3YvZmxyNUhnTVJ2SmhDK29HK1VFMFNWTjlpSERZb2EyTTBPZlkySUJUR1ZGYmJHdWlySWFIRS9Vc29iVXpVczZ5YUE5SVhPcnZKMjRSYi9YU3lvTHd2Z21QUjBuMFFsNkxzQkVvdzk4QW9DbXRQbUVIc1BGVEZKN3hiRVVHbWpocXcrYXlBRGVnK3lGSkI3SkdVTnhSbW9VNDM0VmZLQ3lWZERvaHhiYk1Maldpa0xzeFJoaDhvbkNRb3NaQXJ2ZjloZTc4ZUVTL2t0TlJOZGtxS2xsWHl2Ymd3cW0vZDFUb1BCZUY3MUI3TjhtRnlqMG5lQlZCOUUxOG94V3d6eVAzaTRoK0s3b1grdGtDc3pBMlkvVyttM2hjK2lMdnIwNFZVWUFPeFUyS1VBaEFHL1VROTZHV0lLeWw2c0tBaERHc2NDQjZYR0dzZFVXalZ3RzV5Z1pGcVhJSE9UVWkyNmhzUUdDQ05FSHBQaWFqcWk3ZStPcFVyVTBUdFM2M0JtSmhYWG96Z2JVMTlsYWwxK1RydnpxZlNPZjRlNW5pNGxieTM4ZHlBbmpsQnUySDBNTXMyRmZwcXZDdmhac0oxbzZVdVNhQ2VyeWlTK2N0ZG40a3FoL0M2Z3oyZkJJT0tGTndyd1JDUVhQTHlnMmJlYmZKcXl6N1F6K1puT2gvUWRydm5GZlZDbTRwYUdVbG5jYlFYc0wxblBwRUZVOG8rRUhLMWhmeFo5bjBSam02NytITHV0NStIZ09QZ25VVVg0RktJM0N6N3BXRG5ORmwrOC9UYmdJbEpoZFZtYmpzL2hndlplTDUyenI2OTJsaXdQbmNVWHBHNVVBV3J4TXpqZzhYaTVjeXU3V3VrZ1RHQ2xVUXpGeFFIS3QrTERHYjkrb1c0REJlQmdjZ1NtZW8wTkYySWg0K0VPQ0FaSkRpVHRMc3I0QjNEWldwZUxYSTlDNTVpNURKRE1KTGdvVzR6SUJsS0lxTHFiY2p4ZVUwZXdDVHh5Z054Tm9TU1gzZ3p1TGxsbWhydUZBbVRSYk5SNENNM2daOHFMdFJtb055NW40YTJtd2NBM0VnZVMxNXZxRmlMU2d1UmRwQlNTbjZyb3UxWEdUTjFQRzVqQzdUcFhZeVhWZjJaYkE0VTY2Mi9YL3puTEdRMGw4bm9hVmtseldyZ0tLblVyZ0lWdnBZcytDYlM2cmRrc0dWMEIrSzVKQ1k1Mkd3cEZubDZDTXEvdGxaOUFvanRvNmtiYTh6MFBRKytyN1BPaHkyWE8vZGM2VXc2Lzh5VUdZb09Tcmtxd1gxNm1xY1g1TjN4L2lGUktwOTJqeklQaC9QZGlCVE50SFpXK0ptb3RvWjdtUllITEdjRHpzamFiOUpmMEtTR2lUZ3dpdyswZFcrMTdkVjY2WWVYVXZxUXFnSjlIZVZabHVlVGJ4UXBVWU9qTGJ4YUZHYVhldFp0dHNsU1c1bVhmMTg4YVRGOWNzRWE5b3NENVowTXE5eU9TTEdCS3FDVjA2azVBcU5kbkZmNTRDSTJ4YVllVkM2akkrYlNuK0Jmei9MYlN5bTk4WFU1YVVBckQxeVFUK1paSlRUTEY2dnFCL09Ka0ZlSW9QZCtFN2UxRGphM1VqSGg3TGVFTGRQdzE4aCthS1h1SjJDZEUzVHFXek5aTzhaMnIydUV5MG9hdEFVNG80QzVUejZLbFhPWG9ZM1VpbE5oUDVBMTFVeE9CT1VDQmR4S1FmaVBYRHVpcmNNUHJrR0QzbWk1K0w2dnJYUUZyckI1Ukx1ME9oRnJyUjU0M0l0cWwxTVFScEZXNEdVUzRXNlRNbHpnQVdBSEpCM1pTbTI4dDFzT28ya0FQb1M3QllJQXJ4U1J2QU5IM2RCR2lWbHFDaUdtTXd4WFk1OHlQZ3BsaDZ4VWd6elp0Z3JtZVJudk0zeUJ5RnJYSkYzTkVsYlN4MUN3czJrTzhPLzA0Zm1DKysvVjFqRFZ0VWRleVJUVTRkSDJEK0RldVlYdFM2cnlidEpJVU00NXpVSjBmdnF5d200bW1mc0hQNExOWHkzWU5ZcFB3dVF0TytoMXhBbjdGcGUvcTZHQnBlNDVJUVhFdW5ITkFXaWZabTlXcDVCYmo0ZFFkWG1zeitSb1lIVm9WSjlDZWQ3N0tCV3RINDRJMHQvekkwVHBuNUprekViUmZFN2gvSlV4N2FiaENYOEJHZThNY3g3Wk1lRFpweCtlWWFEdGxTdlN5c2lTbVgwelRXMW00bktrcVJtdyt3dzh2S3l2cWY5THZMKzBTaEt3dmhQZzF4d2ovUm1zV29oSlNiQVExdXZkZnJhT1ZzeklwT3NmaGlBQkJ6WGswVW8xcGVjOWloSmRxM2lVOFBSQUc4bTJiZG5TV0NoVTJRUFFkS0E0VkpjZGVUMkNmUENjUDNYa0djSXhVZ1VFVnVCVm9QMXRLVHY2RkViWlYvSURRbUtrSjVkeDJhTHNFVnhNRWkvTHdIVEQvOWlDZGxYWVowTGVvbkhnMVI4RHBjRFZNcDZCK3ZaWWxWa0RkN3FJemdEbzNNd0sxQVFTeklUMmVPRUN5QVBFM3hObmVlQVVtU3JYUmdNd0I3bk44Y2tnTkZRSTFzTnR2K0JHYnRpY0N2Qll5a0trd0lsNVl3WTVVVCtrYlRYRDgrSVZGYjBZQ0kzemxsVVJsTVRWU3V6c0JCazVJeHlLRjFXWVNhTENIMXB4Rmx3OVZiNlBOTFNON0ZmazBlTG9GaEkrNWoydGFRa1VFM2kva0FSdG1BZFlmV0o5RWg0Q0dwMUFUQ2dtRy92cTN6SURrSkpKNlF3OThLTVVERXAySG8za1lOdnhXcVdqTS9ZNTBXNk0xQlcydE92ZENtd09Lc3puVWc1SnFxL1VYc0hLSWJ5bFlJOGlGbmd4dE9pRkJ5RFpNdndnTEtUSU8ycDgrWno1bDZGOWlhNlY0SEhJOUl0QXI2SUJBTUx4V2d2VkE3SGZHV1d0ZXF4SG5OMUM3ODRZUTl1UUl3RTN3SVlNRkRBOVd2Qmlhbk0rMDc5eUFRekhpMGlkSnVYZWpJYmlWRldDN2FUZ1J5dHZNbGNmNTJjNkZKWTRSbERzVUt4Qm9QZGh0NjZ3cll2cEpNRUtGOUc5VENaUUJ6Zk5HbWQzZ3pJZHkxOFVFaXUyMXlYeUxHVlZoQmZMc1h5V1BFbU1EaVdYcXRnamNCMVZ6MFEzb2RUdk5pZ0o1czRtSUNqaDJuNnRGUmJCcldHRDR2aTUxMkl2ck5JNXVjK1hUUTY3OGlKR1JtYmFLV1gvTnhEVUNNckVUdzZaNDJSR05yeWRBWDg3cFFxUitRM1RuQXNxU3VyL0dSQnZoekhkNzlSUzRmOVU2aXdIK2VhSmx0VzJYUFptT1RQdCtTU053RFRnVlRLTWVCaUV3RHRKcGRONkZwZTJLTzN1cG5aMStvOGpyYnh6Q25KUjBxNk00WW1od2M2TE13WXlhSlh6NVRzWFZEYXBPWU5hRjZhNGdTOGlJS3JHWTI4RlFtWlU1VXU5TlQ0VEhwSm8yWlJycnBpL0ZLMlExNHRvTTRHRTFnb0x4QXRvcEd2MmpYSVRtUzNxT2swL25ndmtLYitMeTRVc20ydEoxUjA0MThRcFg4Vy9VMUprNExrdUtHZ0ZUYUlBNE5KalhINGhtZ25heXlyaW1JdHNjN3dMMnFvb1ZuWlZmNXZ5NlBOZWJaY21YbDZMcTE3NGtKWHNBaDlGajlWdFNtVEpza2dCVndrOXdVUmlCMmJZbGFPeGxxK2IwSVFnVzFPeFNXWUIvUHpWNUFzbU5lQ2FVM0p2aVF4NGI5cmpTK0Y4Ump6RFlBMzQvd0UxbnZhL25QM0ExbGJ6aERIVDNnT2QyZkp5RkN1b3RtclREWWV4UjJoN2UrSjIzVWxVeGY4ZXI2SndiOHkzQnFSZDJ6bldBTEtWTDlEcFVzUHkvVTA0ckMzNEZYT1RMc0xqbmcyeXZtbFFKWEdzTmFKb3dtZEZNakZUU05aNlZNVnFCRXU5VlU2UlRGTDR5dmtMSVFHRTdIT2M5dXppbFk2dVhBemlaRnE4aUZNUHpqUzhsSGFTbUU5cnlSbklqUmhhb0R3RGgyT3NjcVFkYzQwQ1E2Z1VDbVRRdW5TMDRybjZVS3FHbkx5NnZ1MXdXejJJQ2FBMHZhMkVSYmo5WE45d3NSMEdSV2F3VEdFcFpmYVNodDVNaThTMXQxSGJpK21CZFJxU05JREw4dlM5bFFMUGtNYi9mUnNyZERPK3UrK0tVMERPbEN4V1VQTkNiTE5ORW5BZUVsOXZVZ1NqYTROeWJ0ZnNma3hhTEY0dEtIQ2hsZzIzZlB0M1BnU2Nvc2NLSERySTBKVUJpZ2pkMFR5cHF3OFBZMFdmODFPZnBPZTM4cmV2cEVjUndwNUE2VU5tR1hFaWNYczJTaDlVSXZlUnJyRXpDODF1QnVtQ2UyNVJyNkVraHgvSVVHdHBaUVV5Zld5c2lrYmg5anhaQ0RnckM0SlNXU1FlczFOK21NNWV1NW5iQmhxcWJVRjREMU1JdldWTGtLZDV5UEQxVkJlWW5EYnlVMVVOMEI2R3lBS1RoK0tiTjJXcTNIaitpUzN5Q1p2aFBFMVZBT2dLU2twY29DaHVaK08wL1MwcW14ZFFlbXAwanlpOGp4NTJsUzBEYkUxQnljbG1Wd3c5QTd0TUFKTUtwbXhiVXp6VXdpbS9KQ2hsWWF6UHlTK1JqSU5ldTdJYWtpa3RtVG4rZUpNRUNxZXpSRGpiQzNtMFpCRklaNTNRUnRyU3lOdjFVTU9UMXVua05SUWN4NEhIRVlvVFFLNE9Bd05rVDdDUnJzWTNVZ2tYRXVpY2dCdU0vSmFOVSsxK1dVYVQ0R2ZrOU83aWZRT3ZmOUd1bnpHdnY2NU9WM0h1Z0ZJOXFFckxETGVURDVZTUZ1ZWZCekQrMEJVVXFWN0YxamZzbVl0ZVgwSXB6ZFFjc0tvcDJCUFVqOUtPaE4xZlk3ME4vUlh3L0FHTWxZV0tiVGdoUktYUGIwYWdSVWdDMVU0WTg0a09KbXhoYUUwd2tKYVlac1ZaWEFKMjU1N3hyWGlRcmpKRWkrVWZuUENNNWVTT3VlSGtyeGV3NUxMWGdrMkFLaFFJZGtjb1MrVDhWanhQeU9sRFFneE1OYlIwbEROVGQxdkVxdTdsYjUvbTM2cDhlN1VYOFY2MDZIZFZXbUdTVlNnaWNwM0VxNWc4a1pIZzRHU25YUDlOdngxbUFHQy91NkZPaVB3elNsZk9EZmhLR25lQjhlaDdNbjh3Uzlqa1lpVUN5VUwycElzcmFLTlBKM1k2bFBFL1lUZnZEQWhFWHhaYXpUQkpSZGtLbWtPNEFheEloYWtFQjFHZGhaMjhzYjVqV0NKcS9sZDhPd3ZZUU5wOVQ5RXVYeXlwanNqMXpxTy9lTWxRMjZqbkVGSzMwd0d4UG9zblZhbitVV2hFUDVBS2JTZ2s4YlFORllyK0x1WHJuVnUzeFBwbkpOWFJYaDdLVWJYOU1KWVg3d01qcitpRUVheGF5Zkw2RzRZL21WRm1hZHBMc08vNjRwTURyNTNJQVU2d3EvVG5FR2ZVTWlyZU8wWmk5eEU3MDNtTjB2bkx2cjRCL09NWlF2QWc1SG85SlhxTEszdXVTOUh4QWlaS2xnQTROa2x2MVpXOHI0SXQrUjR3RWEzMlJXWnhBeEdQVkg3TXVJcWhrekVaYVh2RXdWeThRTHV2eU9KS1RZZ0RjWkVyUGtWT2Vyb3dPdklteDIxMmh1ZHpUSWE1TE01ZDZiSnhoZkJMaEhyR2RQWVl0OU94UFZobXNWTTZyanpjYTRmUnp0M2MzWk51SzdVaFVuN3VwVEp4YmlyREE2eHE0RGdQVmN0QlFzcitISnVkaEtJc2tsRWtrWExZQUZTOTdoVUV0WWxjcmUwVnpXeUtDVXd3cU52Mk1mTnVKZlhmQXlmL1JNdnJwS3NuYTRUdnJzQUw0N0F4aXgrUGt1VEQ4ekY1Y1JBa24vR0JBUGtJalNBRGhubnUzMjQweENOZDZYU0laOWw4UG1ScUwxUDZRbVpJR0VleWd1bHNVOEsvM29sWGVpSTBreWtHc3Jmb2gwWCtsd0FKQ3dGTkNaZTd6R2RqS0xwM2Vxd1Fhc1BvdXl1YWltNmx4alRVRkFtdk45WVZoT2JWSnU2Zk9zVkx3Z0hBdUUxemFDTTM1SVlwOUk0SjZ3d05oVHRxOWIwMW1wT2owQzZ3b3BoRW05aXQyL1M1NVJDdUhRK3oyK3AveXgxUVJucCsyYmVJNFlsUytjMDdhdlJCWlZWZ3FQVU1pZ0ZzQkZFcmFMZXI5SGZMMko2bkQxUEhUU0hDd1ZVTmFYeVhickxqSlVMQzB6WU4yeTJ3OEI4bmVpNXBLSlNlQzRybjJFYzA0NkV1NHQwZkFTS3gvbWFGTU9aL0xRa0dnOFZlWW01SWJhYlNieEJzdzc5d0l2LzdWRGFlK0xYRFNKN0Nhd1p2azdxYTFCMCtSTW9Xb3IvWnFPQTFnSTladm52MEdZaGVKNjEvN0lSMytiU3Uvdm1vK053SW1JU1hvMnlabkN0blNsZG9JTzJhTXZKVHhSNGlHVjZpeEdIWEZSZ3RrdHF2eE5NVXR4ZG1sUTVLNHNnNjJndjdXaCtibC9MS2ZnaDh2Sng1akhXbTh6ZnpDbGJZZEFIMlQyQy8xdCt2b1pYUTU2V3hLVEx2R3UwTzlNNEJkbElMaUtNbDFDdllEZk4rYTFFK29RR1Q1WlF0akpQWXVKMzVDeWxxOEllWk9KZ3dyZGp1WExnait6c3VSQWZ2RTIvdy9Jc3pGY1hvbXlLdHJnNi94WmtqM3h2SGpsQ3ZKanJ6YnA2ZzZmL0xDdW1Lc0Uza3E2bXlpU3dPc29jd2N5SC9xS3ZFRE45TkljM2VRejFwRHRGZitPdDJhTlcyZWtsVWlMMk8vcEp4cSs2MHVwaG5FUmlVdERrTlQ2WFF0VEd6VUJ1YzF3ZnVPbzg4OHlMM2psU1poTjZzTWVYN3BFb24waS96K1NwZmhvbWNsMjgxYzBkeHVEOGk2aFdTU2VXREg5b0dVRndNa0FMZ2Jrd0JiazhGNmRpV0V6N243Z2ZHN215Y0wvSWs2bVJrbDRwTUdmeUNwWFVCRnhDcGp4RStyMDQ5eFNmWlZDNEgydjNaRWRsblI3bzFMVlNYMGd0ZzNTVWNqLzlKbU90SGFjbFNWeDBaakF2aGdWNVhwSlEzUi9aU1g2b0xLM0RVeUliQmtBeFNGOExyVTdtUTRhYlZCVWdET2pPQVZkbVNXY2ZUKzhVdXhaQUdSNWRhQXZuNnJnTG84VTBKYWl1b3JQWG5LYXBQUWR6VllXK3VQWEdDM1VjZGlhWnY1TS9uVWgrYzFyOTJ0d1loMjRZUnlscnJadHhFNXNQa3JyUHpRQWJ6L25zWWFhenJGcXl5QnlnU3dST0Y2MjdXSHkzeCtjZWE5cnBhV3pwbDZtZWhkRW9MUmJNUWNUY21TaWVLU3FCMG1ZVWZKeSswa0lGd3BXK2pyaVM3ZE8yZ3F5cjJ2bzVRMER1SDRVc0wyc1Q5dkFyOUlNbHJYNnRYeGVaMWxJYVBNOTY2N1MveDYvK29UU3hhV3A3T1ptZm5ISDlHRlovTXhDVHRDZEo4azQybXlMZjFvK2hYTFBDRDgva1I3OGQ0dDl0LysvelQ3bmFock5GcWFQUW1xWjVaN0lKeGVvd2ZnM0JSWUprRFdkYnN2NVlncStreVl6SUJEVXMxa3BScmk1WGl2ejBscTVqdGNIaHF4WUJ6MG51cFRyMXNITEhpMjlOTndPbE1rbVBNL0pGUHNJUjJ2cVMwa054TklyZmkyZ0F5ZWNRYkVKVUMzbnJqQXd1by95ZVdFNzRxRTlPSUxpU1l4ektYWkxjUEdKa0ZSMnI4dUpONW1KdGIxdG1BelE1cDJiYjNGeG01SDRjL2dGTmYwUUdONk1rbHZNamJhSE42VWpkM08zMVQ1SmZuNDQrbkJzNkZXY3hsdzlvdVErOFBwL3l0R3JxL1FZa0g4UlgxWEJjczNzS1JEYWhSVmpnR0UycFo2cnptU3JQMVhSZm13ZWdZYUROSUoxUFJCb1RwQ00rNWZPS1JGUkVieFA3aEpFdWJlOFpwYVBZK3lWRlR5ZWxGeFJNeVhsRnZsQ1lrVTlEWDg0bzVFWXhnZGVVNklGTmw2eDRHN1FNV2pGVlJZUGRCWHkxRWhtb1FPWXlHaThacVFMOUZGUTcyS2hBR2pKNEQwUkU0aGF0WGNyc1pkb1RkRHJoeVgwOVdJb2ZoQlQ2NE1JS2E5ZkFUSTBWaFJ0TDVyZ3ZHNmVrbW1IT1BwK1lQUHF2aVY2c0tDeGxHUWhDVVhrRGZJVjNsclJJZ3pVaThXSm9jNTYvUWtlZmFQbEJ5czduOHJwWlhGT2c0TzU1cW96WTRVaHJSaFRFNmk3aXFDMnJWMW11NUx5ODVXU2x0SHBSbE0vbC9ua2FQc0pnMDNqT3lWMDdLWjRWUmhjODA2Y1h0cXhnVWZzVGRDWVZhVHkxV3VLMFRPUUR0cXFpNTBMZ0RMa3R5ZCtjeElxbTFEM1NLOGw1Nmk4Zm1vTmhrbVpBYm8yZ2RmeHN5dDQ2RnRtRS84b05Ga3pES29QUm9nelc0S1FQR3hXNmVDTjlhYVk1VDEyWlMrcUtqQjArWlBCS2c0WjZybjFGaHh5MWVGcjdCdkdlSlBZMVRRV2V5aHdGYURmSERjcUxsdjdyci9SWk9iME9sRUVBL0lUZ3JSai9MM3Y0dy8vNC95VHJNQ2U0OHlvOTBoTXU0Y29PN01yQUZrRFg0UFFTYndkVVRQaHNTeHRqNEExRmZVZ21CbWxaYWQzUnRYTzEwOWMyUTFnc1JXZ3FaUk1hRHNWek9ZWUFienNzS1NucEZYQzhIV21iZUIwcXdJQytJdVFKaklVUzljbEZLalVWMkxnLzNmc0JCQ1c4QUNRVkNDVkxSSXJQaHE1cUs1a0NIdDhEbEVDUjU5SzVFYytNK1hPN2dwSGg0MEJHS01IK0ZBNHUwZUt1a3AzZ1dwZVZCKzVYRXV5dWk5cEh3OUZpd0t2MGZRODhkL1dWUkpTVytEOWZHbTNjays5aTZoN0NzNzB4L1RKWmx1MG9WREsyTU0vUi9zek5IWkd0SU4zcmNNMldxeFovdm9tY3JGajNrZTJ4SUNHYlFmajVGTy9wb0p3RndreHZ2WUx3Q3V0cjB2UjdmcFhpYURObHAvcTFQamlZa1l1R1Z5bkp0VGRzTUdUR2NSb3B5c21lZG1Nb2lxL2o1MlU5N3JBUEhZNi9tbi9sZUU0clgwNXlaR2tPd0VuYUgxQitRMGRaN2xzSmtDVTVnV01mTHoxSnhCS2NQaUJMYy95cllUb2JSZTl4SzF0TU94ZXlJY3V6VHFwd1VGV1JHekxxaW0zVVAyRDY0WFhqL1RrNTJ3U3pLUVlLYUhWQjB6SGtoYVNuZ2VJUlR3YVJZVW9PSTdVeU02Yms5WDEzTFJUSVYvUTlMYXV6UVlZWWhTUjNEWkMrUHN4VFZZWWtndG9NK1JmaWZBVnRQa3RBakZ0UFUvdHR2TzdpcFV6eWJSZWRGZDIvUW5VYThTTUYwN2Z5WGhKVmV1VG8vN0U4czlIdk82RlRBZWRwZEhlSHB5UEpwMkU4THR1V3MvMnU5ZExKWEFhc2w1TXBBbGNpenlwbzZnbnd2Zmk1YmVTeWNNdU9ud1dLWjNoWGMvYmFQUGpXTTk1NHdjWTFzT2lUeDlOVUc2azFFN05xNUROc3lpSTlNMGFRRjM4S2xTTnYzQjFmYnBETlhQbWV5ZmV5a21meHVpTmRKTHdWQnV3bVpWZFNwZUNvSjZveUVJdFhOWXNKc0Q5Rlg4MUliakdJZDVqUUFUQUhvQ1VEVjU2TThJMTJvc1JzOXNZL0lKbElpTCs5NGVVYWh0TkhWNzI0dXd0T0VsZlZKTGl0Q2dWd0FKdkhpVWlvaDdYdURhdGI4NittV25vbUxuWDJWazdNNXZqNFBHbWVrdUpWc2ZBZ3l2VFU1ekdJWTNZbEJGS1A3M1Y0SDJhKzU3RHpKRDJURU1tTDRqSDBaYW5Kd1BTcjhEbEo3NllLWFNFSGNxSWJTcjBSbkJqWlRvZXVkb1R3MlN1QVJSMVZKYU9USmRVd2ZVc0pwbE41RXJqS1hEYVlwTGRaV2tRZGJLeFljRkQxSmdtK25pNmsvelo5dnBOZmVIOVFzcWpheWxVK2pWOTI0REFyeis0ZzZWMUlUSzdQMGprUW82NVVtb0swTFNZaHl4YkRjTTB3Wk95dHpudFRZTWlSOUtYUzNFdVNPbmtpZ1pWYlVYNVBZeG13a0UvbS8yTThNWXRhR0xTUGsvSElMSzd5Y3luaGVkQTQwT1pDMmQ4MzFodWUxakUyZktUa25FZnZjQXpEbTYrTFY3NmorRjd1LzNocHFINHhtWjRidFltKzJKTERybGhrdEozWCtCK2hVUVYwTXU2L3V4LzJuTUtMMDluSEhncXJtbGRWbXhDL0dRVTBJbXV5U0pkUW9TTE9QcFMvdzJFK2g5NFpzRmFWSEJSbWI5bG80NUxPSi9pcEdzUlZWS21rS01lcUxUSTdZMUdLOHlZODFXa3VvMThyKzArdWFpNUQ5N1QwQ01pOWxOdWJvT1poeXdFOUlNWUx1STRrY01DaFVHeExuS3pIbStkRUxrS0IwRGpMUjJmaHpwUmtKb2tVOFU5NzZMS1IzbjA3cSs1Z1cxZkZWZnlGblZ3RE9EcVcweDVzK3FUdEpGSlA5TjNzOUV3ck1ubEpVTldVSm5YSlRkRXNuNFl4UWdEVkhHbkw5dzl0ZWRqbnQwWlNMZ0cvUWtKUVdIeHMrYTVVU05YMU9WaStHUC9MVnNwVGZNVlFaZ0t1dW1sVWhHODBRaFErT2ROTUtLMld3RE9ONmkzbGJvdTNocWpGVXlKSWlRRVo0RG1FS1NHeUt3UEh5Ry9Nazk4WmsyOUMzLzVPdnRiTm9FQ1lXWmg2QXVzUUZxQ3QwNmd2U1pjb0R1Q3hWdVFhMkZqTml6anVMbk1hOGJJUHlVUzBjSEE5TVNTTFMwcTZkUWcrMnhOOG1qb2xaV2ltYVExcWJiaWNETDY5c0RIeTU0ZkJxMmJoZTFjcHFrZXlyTThKS0NSQXJhQTlQLzA5NFZrMGMxaU5lWWtPQzZrb2VaWkF4UjNvRHpLc1M5Z1JneWxJTGJTN0lWWWxzZWpwMm8yMFk4TlR3R3RkdFdUYmpzdmtrRlR2Y3VWdmhpc1RHYnpBNS92aFcrdG9mbzU5T2M3YjlKTElDdU9hQXRjV0REUmxuK3kxeTVYOHRUeEhUVHBab0QyS01oZjZ6bi9GcDROWlJvQzlLMFZZdFRZVzZSdGRGalV5R01qOE9KRlhkRmtHcWdmYkI5RTdTYmhROURxK3ppMSs3MHQ3Y2VMN0t2NjhvY3NMdUtTU2tzMEN5RjBmM2ZzR1hxYjBjSnhrYTdnNVFWNkordzdTb3BUbTVWMEdUSWJNUHVKN2VTbHZFT2QzVTJPZzE1LzV6eUNvOWtqOXV0ek5zSkFqN1NWOVBZRlFoaXRMbWJET2laMm1hamhNeVNTRVRZMHZQcGhTRmNjUmx3SjVIMkRUSk10RHoxNHJ4Q042K1FFcURramlhSkNMK1RzYStHdkljaTM0VkZ2NndwcytkY09GdlBzMkg2NDdPVVZwT2tRTHlaaWEvWWl0V0xMUFFLZFBONEw4NGs4VHY2Q1dZemhmUkQwUnZXV1JneHg4VGVkWGtMVjZBWDFGN25YZ1NwV2JYT3lYaEw0TVI2dFV5QWsvenBXZUlEWkt0Sm9zS1FMR1VHQndaaE83R1lWMWZ6b3lTaUdFSHFaY29vZ2Y5N1dTS2hYSGpITlNUaGk5Wjc3QVdqb21aaFpKQ2poVkpIMGpXUkpKOEphb3ZEQmFJblJpWXpYRCtJeW5LK3JyN1RwYUdKVmlUVzloTlRZaWhHWVNxeHFRRUI3Tm9ZTHg1bFB2eURZUDdPU1BmeXpSQzloK3dub3o3K1ZpOXZZMVlFK2d1QUFyWVhxMkpIOHIrTzJoUXBhNTFWU0lYS0NnakhHWHpCUG9QNk9MMUVsZFByaFdtQytIVmw2TW50bGVDMllEcEZvVVlOd2pPTWdhSnBlVmN5Nk51T1N3MDN0VzhlN2tqdTU4QmFQaGJxMk9BRHNoTDNaSXNjTHFTcXhMK05sV2xHc1lrbVArQW5HN25telA3UkFBMEVkM3pzUHpSU3NNMlYzQmZ2WWF1UnByQ2wwdTBiNkc5NWZCZFVqbHE5cStDNllPdFdkcW1PSmxFdmY2T0F5WTlHMXFwSWtGSmMrUVNGNGJxNFlGUVA0dENtTGtKT0RzdVNnVmdScmp5Vk9SRTJTNG1rOFZzYnJtOWxSRndhenhSTGVCNk1ydzVvUlJJcjJ3OE1mdlgxNDMxQ01wMUkvTDgwQUtoaGdBa1RDY09qaHpoYWVYYW1FWWtZR3dtVGdWMnRNMHZUb3Rzd201YUtPUDEyYWZLdGx4RUt5bFdkckRLeGZjZmpOSlJKd1dTSDhyL0ZZeTMxOFB0N1p4YjJSSUhtS1l6K3JNaEhpWTRQZ3N1YllxWnl4S0tqSzBUQ2JmU3lSWG8xbkJPeUJwUXFDVHZCK3hQcDhkQlF0eEpya09rcXhneXh4ZWdLd0hYQURTRGl3NlFobEVjNE5jbXZEcUtYMENGaU1EM0V6ZzdHbXNLR2hCeDJjdVQvNU0rZDdFK1RlTzdHeUp0WGRuYis0U040cTNYdFNpQTBxUFo2dUc3QlRsYjN4UmhLUnhNWm9JRFNvd1o5RHBDaGdaRVNtNVljOWNPbEhQQTN4T29sV29HYVAwSUtzWWI3TXNsOHlJdUZDL3lFZHJNNlcweThPQTVUVng4a0lhTzJrRDQzQ1J0RXU4TkpHekdMMkp1SEhFeTFsMDFzbGtpTmh1RnloUGhqb1JmWkNuSGkyb3gwYjQzaGVsVnF5TWNmU3hRaVk1T0R2aHl3ZlNaSloycmlyeWV2bzJRZkdPTWprV2k5OUx2cHZCRXpyLzR5OEtpSWw5UXZkbnVXVW94bDZ1SDdPOFFacnJQTTNuV1owZUJoajVjZjVUSXVXNGN4OU9yS0NjaDlFYnFaS0R5a1pDYlVyUHRjdXhtSHFZbFA3ZnZzYm9idGFZVnVON1JjTnhlZlVNWE42MHdJWlNmeEJyUHl2eUNYdm9KL2VBdlBPWWp4MitYMHIwVlp6STJBSmtxNis2RXpRbENRdmdpMm1hemVEZkllR2IzMWN1aC9nNjU2OEhmR0VjTjVxeDlFcU8rODVmL0xRaXI2bHZSMkRuWlBnbDFNeUtPYWtyWnpWZ20zeDVDZ2NWTS9Lb2xTSHNXeG9ma24xRm9FcitkbzBWYWZEYU1sZ3NDaFRXVVR4dGk4TWhxS3dxQmt1N0ZRem1SRnFNMklLWWNEUU1zRGtBTzFrWVVIQ1I5MFdLYWtXMFB1UG5CQmxUV1EzQjZXbXFWS1JjVGdwdGdJWmlWZ2FRazBJL0hVem1JYzVkcTRNM1VpeVBVQUxJc0VqZmora2pWVDFOZ2taUFZYTTBLOGN2MStUSG1RU1JxQkdpUWlWMlF6a1ExRlZ4OFlTdlRkR243WG5uU2w1ZjQ3VWIwMU1EWnlmYWgyOXlCMm1BVG5INWhCVU5OWnVWZzNWeGx2QVZoeVRuc2xWaFJRdDVHVURNZFNOV2NNc0VXaTNWZkQ0VnBOSUhMdzlRM2pYZVdYTS9lWXNwZTNKd0htbHZPbElhN0pxWkZLbHJyamJNUzFJQ3BuZmhZUkhMdGxnZDA5T1lSTitsdXBuc0ZoVzFRYmZPNSswRGMzakY4T3RoN25veDZLZkhrbmdyRDRnazhJNnFjdDNUMkxWOTlyT0FWUjd4SlROOXJKc1pPYm42Q3ZYOUZFT1dreUhiZDQ1clZ2eVdsaXV5cGRkYWJrWmh5R1o1UW84Y1BFNTh3UTZyeWxuUisyaVlSeVhtWXBLdStFWWhPakZTNDl3dVR0WFRDVzBnWXAwRjJYMHVDaUJOZWZTTzFOTFlXMWJTT2RLZWEzRldrMllyQUs2TEhOSkdCSksrTU9keXoxVFVTQlRXd0pTaG9weVNRelRzSkF0bjRSdVV1Y1FndTZqMHBIVEhsWW1YemxKaVFjUkdYSklUVmxQaTYzaEs0bjRvbFZ1bUFJcmtvdzAxU1c1cGsxck1BUzVmeU9yRGVIN09jVk1aMkhCVFp0b3JObS9IZWo4ZzJiODVHbUdwR3pESlZ3Z2doRXZWRDhJWEkrTzMzRjJjYWpmTC9LUXVMRk9wTCtlanRkd3dIK2IzamVwWHdaT3poRmlLMWpCUWxhM29wTXR3ZVJjdFRaSnY1dW9sZEg2Y3k2dHF5amUxczJ2ek0wbHZyclh1bmhSN3IwWC9zN0IyUlgvMUFCczQzRG9qQjF6UlhWRmZrNDhYbFVzamVXdXFGRGg5ZkUxN041TWVwMlRVaDRvaEdTRm9uUEJjaDhialpMQm9XSFVNYjluUkJSNFdSSm9KbFF5RlBUNE1wUFJVaUpmbUpSQ1ZETG81ZG43RGpSNXpjcHFaTkNSUlVnb0NlaEh3a3poQmtBMmxvc0ZzVXlxK0ZzTzJHVlp3UTdmMlVyaVRnSGVwY1ZyZ202OFpJK1FoRlg4a0I0ZEV2eGpOQndYRFdVSHJmVER1QU84c3dCWXF4bTdiVVV3M3puSDZlS3ZnWXJBV1dzNEI3VTZUblNvU0FCbFZHR1RoMkk1eWpyd2Nzek1GRFA0OUlZOFVqcmc1eEk0QmNZeEtPM2h3UFUvbW4xZGNoSXFZMVk5Z1pBa25SdFkxcVhTT1pnM2pCSkVJSjVsbTJLRGdiR2thTTF5ZmE3azY0LzhqZ0JScHF5Yy9QUkw3Kys0Zm95eXRDTE1KeWorTVhrVlc5bGdqZlhDUUtlWi9mK1RPdzR1Q1d2T1VJb0VOVFd0ZllmTUowMytqY1FHVWNtTGVUREk5c2tEUzNpTTBMVEFaQ09jMkdMZ3hrT0dIdS9GZlZxVlhudlArR1lpN3dXNHhzM1RIT0wyYWR0MzRlajExRzlCUktPa1RkcXhJRk9nbUQrK0w0aVVLSVhKUHFHUnhPT0ZSVTBBZGFUQzFxM0k0Z2QxbWN1dWZKMVp2Y3Bnd1o2ZG0ydEpTMSszdGhnZDUrWG9NVTR4ZVpLU3JPV1Z5eUdHY2NncG1OTUVObnV2enkyVlpUamxydzZNS2F3NndldDh3NW5pZU04WlpYSTQxQTZRWEVlY3B2L01NdU8zNGpTRmVVRnU5SXVRQVdNL1pVa3NjS3FHVzR1V0NtSDBGQTFWY3NDVFN4VHM1ckZXWktaSW9SV1RpSW15Q0xNSkVCMTdBSXlqY0FiWTV4eDNVZHRsbUlQZXdySEFnZjZrZEtTQ3ZvTlY2bFBnSzEwV1FZSzBDc2t3cHp0UHBhMlNQNC9pNS9yd1Exa3NteUlMek1ncE9zcVdKNlI0b1JpSnVMdnQrRlJ3cWJQdWhScytqOXRBUGI5bTdjM0JiZytRc2ZaakgyWUJrRnZub0NUWnRLSGZpVVZIcnBtNFdLZVU3d1pobllhcHFydWc4aExFS2xGUDlkVjZJREZ2MEpCeklzeFM3RWdJK3o5alVoU2gzRjdGbW1FaW8ydGFTUG5KZmc0c3EzNFJ3RWNySjkyUXIxczVxS1F6UUQxT3dlQTN1bzZySG95S1R6MzB5OGtOZFEwU1IyaXNRUktBYXFwY0tsWE5rcFNSK2M0bVhxZGlSUUlSRUtTU25VODVYTUt5SEpUbldlOUkwbEd3VEY5NFhwWW42cWkrbXZhVDRXcHFYQU5tU2pUVzQ1TU9xeDdzSTdXbkpqMGJ4UkpJdjQzakNqSFFnR1FGbGljQi80KzcvcnU5QS95eFozc0N0Q3JKdFJIemhZeFFVUmNiSGFZLzNPa201VEZJQi9SSllqa1Vma080WlhtbWpQT0ZkR2ZVeS9rMVh0aEVMUGJpdktEUEkzNjZwOGdGWEhrYnB2KzJQRHdONnllVXhBb0hhaStXTmIwV1YwRk5KNnZ4SWNrcWt4aVdyUVF1bUdINFVlVFlrbXdrWnFsdE1USHcwZWx1a1piQVVhQ1VnWGk5S25hdlRHbEFna0VhVTRqS1I1ekFmRTlnQ2hnOUpqL2E2S1p5amFpeDZnRkJaNUJNSjdodUZGM2gweWRYN01sMFJuWTFBUzZXM1ZrZk8xWEMzUExOeTBDNEpXK1orZy9WQ3VKU0Y1VWk4S0NhT1JwYWJLWXh4YndEWEJQWkhKTFI1NHhtY0dxaUV3R1VDcytkVWJhVkhOZ2VPcEgySDg0OHgyQk5Ub3FjdExoZGt1WjdNbDdnTnRlSnBISjhuT3BhVlBPK29JQVdveVdtbVFzSnRkS1pDZjRITFdGSlcyV3Jac2NzcGZwRDdCNGQ1dUt6S3BVNzA1RHlXa1Z3aGdzZWc1Yk1IazBURTRpbnpibm9TVi9GdWtGUThVdW1scmtuOEJwaHlySFdoK1F4cHBxUVd1ZklUdDN1ZFh5eDUzTldiZWJnTmdxQlVhSE9ZcFdob1k2MVBveVdKRmtqOFkyOThNMm11T1NEUW9nSzljaWFtTnZuMlY2enFHNVd2c2JFR0lvemFINFZkRDhvQ3ZUVUNSMEJKVzNpTHlkMTZBdXN4YkZJdTBCcEhyWm1ZS1B4OVFUTmVlbm5wRzhQWWRlQUxHdDA4aEpWdkp5OFBZek9qNm92U2ZnNUk1eVRGV0ozaFVnZGYvb1dzL2d2S25zdnNRRjFtOExCbHNoQ3RUTEhuNDduQUFvR0FZVDFHbTMyb25OQk9od2FZS0UySVE0Z2RrRytsdFNWeFZGT09xOTRhMEVvUWNKdWtkL0hwUXFyWlJPOWlGSkJZQTlubDhJWk1MNEZ4K0d5SXhsS3BMOHdpT2pSUXo2Wm1MVjJTa0JFcHJVNXk1MWtpRXZtVEpFUEUzMVVTSE9VeHhXZFNNa1NaUEV4U01OcWlEMzVLN1J6N2NrS05xOGJzZFRyeWdTeHo2YVlZQ2drQllmZEFxQU9MODVtQm53ZjhUN3NCZnlXOUhJYjFiTFpSeHFNRjBQaVRnRm9SWU13K3J1aEg4bVhFaTY5UzhoNSsvdExFbTM3Mk4vV0ZFYmQ3Y1hMdXFCaWFRcndwOG0yaE94R2VBNkJTSkJKWUVxUlk5NGVLZmpBVjRKQjRIUzJud3BJQXlSRXR6ZVluSmF1bHhXS1paSVFvNXdydW9kdHJ5SWhIQ3ptaEJaRG1NMjhhWURVTEoyMm1ZZHc0d0plRTUwQzBlVlU5WFN1M2VhQkZ4TTJCa1p3cXl4RkxJRElwSHN2QUpZdXZwV2dKT0JXUTJSWXJMOGdUaFI4SXZuTS9TVUlTY1RDVkdJRFJSNTltN1g1MHFLTEdEV2xraWpRRlZ4dXBDUEhwQ0lBTHJCWU1Xbk16UHc2MXU0VU81bVJYWHVwSEY1YzhVMU5hTDVWS0VlY3U2ZXNDTDQ3R0k2WDBTSjNoek4vOFgvbHo4RDBrUkk0cXdBRGZKa2U5dURpUmE0dndiRVZSQ21wY0YzUkowZSt4WHBNYUNtbGd4aFhZaWFDaWd4V2EwaFV5NnJMck1KMzB4ZWRYb1ZwU1NvYmtIZk1FMkR5VkYyTTF5OEFSZ01VVmRtVU1EcDhrd1ZmRHpMY2sxeFByU1hqbVlQRk9wdit1SnU0cFBnUHlvbm9sVGgvUG1YaUM3RWkyemtUdUlCbTlnZ0hIalNMcUJEekFZTEhOMURYc3JxdUt3TXlGWTRlVVBvekpBMi8yQStaWEVNaEs3K0EwdTh4K3Jhb3Q3bTZGT211QTBnemxXM0Z3NkZzT09HaVkyVVVRWUR5WG1kRGxic1ZmZGpYRkoxRlh5L1hsOUJJYVBVcGVSNjBRcVRWc2JvWGVYSEgyRW1ta3JiWUVGK1NvS3hrUitkN2g0TkxCbjhMeHRwMXgyNmdmcEhlT1pVbUdFeHRtQlZKNkRMcjRsQ2hneFk4QlVOYVQrNUg3cUpCNWxrNGZNTjJVaEdMREtFY2FQNEluVzlKdVlVSVcvNHR3cHFBbjlkd0dvczFxR2dUeDgzVjU1b1hYSGtUWmk4eDRJODMvQ29NcTdGK1Fhb0NsTVF2Yk05MVF5akVMTGZYTEpUVXM4Zm90d2lvSk0zRkdkZUVJYjcxR2o3YWt3NGRKY1VuTjlhaFdnUGZtL0NpRVhHWjNFUHRwU1I5SFhCTmdtREdxTlRDdGlDa0F4YkYwZVpERWFRcEhIbDgzVG5QSnpoV2toc2lLUWFvcm9BVlNCRlVLL1F4M3E2aG94VE1DMXdkZ25KRVArNDdpbUJrU042eTQ4ZHg0N3JBOVU3bFpUUEpOY0JrbmNTWkNjNUt1Y0hNRFZDYVptY1o2akYyZHdlVTJlWVM5d2t0dXk5SmxkNlplTGZnYTNJQ3Bqd2pjbEVzeE9oN3c1NytOZm5CRGJWUnBxd2htRjRJTFNBZVFjVkVkaXVMTmVMcVFueUcvT2tqWXBUUjZrcll6RWc5QUlRdVhEeHpTYzc0TndKdDkrUFpTemN5aWVJVkZUZmVPNGMrSFJqc1dhWVptVmJGK3FCenJ4RGlRZitRdTRnLyt0LzlYbURGei9UUXBLdEU2enY0a0hDTk53dExGdmhycStKMDRmbE9RckQ0RWtVaDlWbS9LdFFMMmJkWEZ4TXZKKzh0UnZnYlhxNkdEcFQ1QnlVa09IaWhYWTY1ZEFIbEN3ZVBCVkZFaWlXZ0dqQVdhYnhMdEQzejJQZURma0JhYXVsRVFjWWdlcGVMa0luai9Dak5VWTFLR04xVFJ5V2hkR2k2ZXFjM0RVQUxvVVI5ckJXUzNlSXJRWUpSUVFqWU8rR0NmMkRaSTZyQzl3Sk56SE0ybG13ZFEwL2dlaHB1NldPN09IaC9ieDVGajBrd3h3Y1ZDTXMremFzWG5GajkranV0Vk9OU2dzeDA5R09EYTd1QTFUMmszSmlYRGlBWEV5SFdFbW9FeHdjcUk5VjlIekZIV2ZLbkRPTXVSSlR1ZFdOaGphQWZOdmdTWnc4SHNvNHlOQVVwTjFTMmlZWld2U1dCVDhaS0NGVmgyNUxDejRaVE9oZDFHMVJGdVh4cG5VN1kwbElJK3lsQnBjeEo5OVZJcXZreHVqeDBpSlZESmc0c2Z5NmlVTmlES01QeldNV2oxMmJQaEpDTlZ1azBGcklWM1ZmUlZvb1lPam1yY3liUEtuRjJXNEtVK0I2RlFqc3J6bDdMaGNiMklsdG84enFPRENwR1dlWFk1bWJVclF5bTkxUWFaWnZoTWdSV1R0U0VHakZleXpCVUpTZUg5MEQwMXNoZlY5S0pCMDBxNkJjUVpoY29aTDF4cVNZOUtsSjBqVTVuVHEzWFlUZ0N3QVBIQnJKTkVXWEpMaWZmejJpNVBGcGZneWh0NGNSQjNHTmQvaEdjRkQwNk1hVVVkeDJsVldEZStZUGI1OEZNSkpiYjB0MjRxVTZnM2F6REtKTEhLNzU1a210Ync5UThXanBhNytxU0lKQUE4ckdxaUhjSVNBTlVLU0UzdERaTzhEc01FV3hTUmdTRGpkQ0hrazVEdmJWVGdQaTFiMmNrQkZqY2crTWpITGJYU0k3bHUxTDlpVExlaVNzSjYrL2tqZjFMeXpRMkhmZU9vc3gzd3ZTWTZpNm56U3RSYTByd29YWFdnL2g3dVN4SytGLzB2VnQ2NHlsQjY4bklxaEwzemtKV0tpWWZVcHpzcDdLUHJmVGI3RmM4NHVIc21acEJuOStDWWE3b3QzRUxTUFZNMkQzT2JyOU05QU5ZRmd4QzJBNkhhK01SajVXVm1DK0dzemRXSjRadWlsMHBKSnRrODBtZVB0TTRibkl1Tm5DUnN4TUdhZndTbCtqZG01cytDWnkrQm9lYzBReFEwWnBSUlVzT3IxOUpYeTBDcDQwd01uelRUK3dWeFdZZldPYm9UQktORCt0MlFLZnVwZWFtdVhEb1JrWG9SblRMMWVCNzlUeVlqMGdQL2hGUGIweFp5V3BnM25HMDlxVWliRUE0MU10MEt4d3cwQnZMaUlPMXJSdm9INHhuWHIydnkvQmx2VjZGVkY5YzRqVnZnK1hsaWIrUFZLYXhkeElNWGs3WVhoNWlzcXBBWTZOeVU2cXB3czhwQnhhMk9qSndueHQraEpFQWJlMkdneTd0QUZqVlIwNzNNaXYreTVxbzEvR0VtT2IyRFhsaXpSVVBhdVlRQlZVQU1pSUpLaUtvWHRQMG9KdlEvaDljL2sxLzl3cGtxL2RwVE5iNWpEcTl3bUEwV09HcW02c2podklqZExSS2tJTGNaeTQrSXB3ajJGT2VmbU9Sa3luTHlwS21zUnh3a3ZOM2ovRHJaZXV4cVo4R2puODNOYkc2am5sOEZiRkpRbmlsMFo2cVhVZlFGSWtaSmJud1c5Rnc2QkNDN2syOUs4bWdWSkxqQTdRZytwTDIrWHBRRWIvSW9BbW9FNENzbGo2SE5rMWtwVmZyS3hsaHErM0Uzd2ZFdEsyUEFnUjFmLzAyeWJjOC93ZXJSVzhrZnBhaCtKRitvdVRpQkVFVWJmWEtyNlR6Wk5vYzhsbExVR2lzRFE3QTk3ZW9wdlhtMC96aklmYnFwZ3llbUJ2Q1ZWbnFZa3haYXNQZ2ttaVVpTVVGV2tmYk82WmFRci8xRWZESE1Td0xVTEVtS1l6dE5DeFBwNXliT1ZPZ2F5aVFmQW53S1dRak5tU2czNFc2VnZGRG5IeC9ac3lwRVkxSk1NbWtDcFpJM0NhR3haOTV1UjYySjFGMkFaQUhiQ0MyblRqZFd1bldWbExvbXVOMG43NXNFS3ZHQnFvVHN1SzlTVlZ6cDZqWE1JaHV1R1VSMEJYa3lTYitXWDVjRUtKRmNTVjROa3MzMUFvNTRPMlFGQ1JucmFQbEFITXpocWE1WmY4Vk1aN1locVM2RGJJM0JFT0lVR2dHMFZGcVpLSVB6S0JXd0lLTzlqTlI2RThNY0VIbFovVGpJalVuWGdadlBQYVJpOEhuRVZzMHhrN1E2SEpoQ3lhUHFwY2FKOEZWWS9TTk1UZFlyajJnS044Zm0xUWZjOFhPSHFhL1dVS09ieklFeXpvRDhRcXl2MFAxeCtKTlQwSDdLMXcraktoZW5lZGF0b2N5YWZIVSt5bWVUSnlFN0tJei80SnQ2dVVMbWtDMEkzTUtVUTlMNG03eGRETTFNU0g1ZFRWYmlVVG1xZm56SmVzWGdkYTVQNVpvV3BTV2VOM2tTd3N5RmN1VThhVnNLdlM4Y1JRd2dVVnllU3JUeWhzcHZ3SVhMMVFMSzl0bFp3WFlRZjUrb2tSTkN6bU5Ga0JZdjVNWGpSbTdobzlHT0VSRDVaOUIvUDhPMll6V1ZyQVdxUFVhWi9YVHdHVXUwTkxzdVRpL3czTVkwQWRydkZiTkhYRVlDZmhVUGZvekpRcHF6dk1LL3Nycjd3YXlva1FWcHB4TFp4M0N3ZzhDSFBVTUtjdWUxeWFVeUoyeTdrcnkzS3l0NThTcXhKeHQ4ZWE0blYraDB5VStKVzNBVXh3TlBPODZQdjdYWFpNZzJlRU9Xanh5Y0JEUksyYVdsNUMwUktDQnA0ZDk3TWZWVCtEaExiYWJ4U0ZKZkZrQWtJTVBtWXRmTkF3NTlaVmpjNkk4a0tmUC9BblJUTWQ0NU5ZWXhEN0pSYlZOTTNyR2RDV1lEZ2FLRVRrVDJEcDNmUTVHZUZtbFUrcGtFTCttWG5DMlZTVzBMRmUrQVlFcThMNlNGeEp3UjhXVVF5Ly9jcktpWmJwQXVXOExkUWlXQTZwWDRYNTN6a3FyODBLUHRodnJDamphenlHQndRc1Q2ZVhwMzM0eFBSbElTdnRncW96RzRZVXJEUFc5YW9QSGRjdkI5ekJTQXUxejZMY2kxM1BOQzloQVZ6QzJYRUFsKzlhMys2ZzBwcWRiM0Vxd0xOeXpwNXd2cFBhWmdQUmczSlhQTnpSdVJxYWF6ZTlaOFR5TkhjdjZuNGNTVVNGbmZ1anUvVjdLZVBrdG0vOS94N0lNU1hzVURLUm4vbDZaV0xtWXJaSjdub3dGWU9xVm9Gdndyb0ZkM3RJMXI4YVhxSjJQTjZPbzNIcHF6YlJEdXdvVWQyT3FLL0JxbkE0emVpZ1dVcFZWLzhYbUpweUQ2UE9VR0dycXM4ckU1VTNDcVRwU0JqS0MwTktjWEZQazVvSXpBNTdtTWNhSmZNMHczQzhVZFVPaW9VQlh0aUdZMFBGWEpuTUxLK2x6M3BXUmRHcDVEc2NjNVFmMzk1VTU1VnA0dExHd0V3eTBTMnBFbHg1Y0JuaVQ0N3FXc0YvRVl3SGRpenp2VHVrbGNaaUpveWd0SmN2QWRmY2k0WFZiWGM1QWprTmc4dVJHNmt5aHpuaTErT245ZTBHQld1dDVnUmR1WTQvekp4blF4elRaSzRadGIyWHFiYTIrU1Y4KzErcnNFeGJ6NDErTjRybHpNdU4yU3pGRU92LzkvK04vUUxWWTBsRWdCc2lOVjZuUzhBd2VMM29wUXloNDk5T1ZMeVBGZU52ZklFc2RhcVNIeVpZaWhlaGhHUVFiZHlOSWNpZmZMeHNXbVJOOU41SFgvWmt6c1Bmek1tL3VLVXFvZ2UwQ1cwc1M1cWJwWDVINDU3bDJRcklwdVBZWEJJeEc5bnFZVGFhUWl5Y0ppZ2VmUFNNSGxmbGNXWFFMM0xQaUN1UXhIQmZLMkhKL1ZsWXRyNGNieXVHMkkrWE55SlpaeExGb21YSHFTbUhQNHkzUDVXbGV6eHpqVjVTYnl2L0drNmNOd3k5TVVoczRnUmd3dVBGTDZSMnJzU2pWRzRpb3dKTTJaU3AycCt1NVhLTkhWWnlHc0NUbDhyZ2VIYURPU3lWWWtOMU52eTNOTXRhN2laWXdPRVE1aWVuMGV2VW93YmFvbEM1MFNobDFRVDhUdUdjcStnQ3N6NFJvS3loQWxoL0ROeFAyK08vaGczTUx3YW9OWWtZd0xURFhJUTUyV1pjV1VRVERGaFZnbU1mS1drbTRsUW9sTVprZnFwQnJsVFZvZnlxVTZQNnJKWjRBdmZWR3NqZUtCTEErTlZKN0pPN05Jc2NBVEpzRWgrUGlFZWh2Z3FZbHlETDM2WEY4cDArYkgvc2gwM0haKytZbVI4K1BrSTZMMzdMUEl6ZTltRjdQQ3lOSnZKS01ic0dhaW5QWlk5bERPVVdlcUc1Zi9VVzdPaEZYMzJhSGhVdDVraVNmd1l3N1dZMEJrb0phd3Rzd25NVXBNNFIzd3cwOVNtOVYvN0tjOWpvYzlIeTFxbFQ0UEY1UVFpTVlZMHh3OG5TVkpRN256N1d5cGtIMVU5N0dFN0tQb2txYTRxS0Fzb2psb0o4RFJSUVI0dEJtRm1hVFFNVWhPN3B5aDRrd3NlUFFjOHFBR2xjUFVmd3A3azFneFZYTkxVbTVGZzAyUUJyQjBvWUtGZU4xVnZzMkYzVDcrWFNvOXo2T1hIRFpkU0ZXcGI0TGtnZE1jeVFmbnl2UVhVdm1kMGtrdGFFS3g4Y2FZWGlJM2hWdjVsS25hOUhZOG9UQnA4TFhmOHJNcFluL0pyeTJZcmdUd3ZkcC9Wdnd5TGZSa2Q4d25OZVFOcFlyQTlSaElSZUJrTUt0RGVZUkVYazRRempMazdDZk5lZnFtcUozRTN2Y2xsY1JBVWNIUGV5RCtXdnJSU3p3OHBmR1NsbW1HcmlrTkdWMjR4RmRBNm5YQmIrZkMwcVFHQm1wQThJeTUyNXArTHpxd1k1YWk0a1QxVTNqM0cxN2l5Uk1xajI3SDd5M0c0elZ4V21OTGwxZzhTZ0pYT1YraDY4UXNoTUFKZ2JHTW94UVBkUlJsVWY3dHhGdUFlQk9rVGU0MmVXNGwzbXI0ajY3Sm5aei83MEkwVjlSTEJpUU9OeGx0VWZLR3hkY2pQTzZLMFluU3ZGQmhwSmdtZ3dESkZNNE1mSHFGMlN0aU9ZOHdKbFpSZFNuNDJrNU1xRjNKZW0wVnNYV25ZTElJWStuVWlBT29JVHpUaEtLQzdZUW1FdjdhOHhvdmplOTlmZkdrcTd4U2dzV1pSdjRpWkFjeW5PQW1UbW1HZE0rQU4rWGVLeXBjOGs0ZjZXWCtwS2xJUzRyWm9yZ1RrTndmTW5CcHVvK29qZURrR1pOaUd1ZEpyNFpxaTRtRGhOYVN5aG9nTVQ5cGdyTEt0TnU0b3dFUCswdWVzamdMVGp3OWNubitTWkFhSk16aDhlL2dua1lyUXI0L0ZpRzF4amsraFJKNFYxb2Zra3VZdGcvdysxSVFDUERMSnlMZjBSS0xBUUNXVWhESGlDOUlhQlpMaWNqOVdkekg2QlRIOVpLeDdBeFRaUDlyN0FKRC9MMXA5TWxJVDN4cWVhai9IamNNQmxYcWRMUmx4dGRuOFg5andvVHhEN3NxRnZqNkw2VlB6UGl6cW5udkIzMkxLNFVYR2UxVmRCRFRhdE5BQ25CbHNkd0g1d0RKTGcvbnhKSGh4dTNneXd3dGhGTHBVSE0xcnQyT1oxbFdQdFA4UytuNVFVam4rZXV0WkRvamoxUDI3ZzVHQ244MENxN1VyV3dQU3dqRVhhclJsQmRFT0tIR0tzcWZvYW9yb2NOSlFsbnpVZnV5bUp1VWJmUTl4WG9QVnZNSjdhajZybURQKzJjM3l0TVN2ZkYrVXNySjg4Z2tTM05RdE55SDk2ME81K3RQeGNURVIxRzhtV2pLQ3pJcW9DdXhzR3JwcHlPaWNsQkJkS1NBczRvcmRlMFB4c1I1a2loeHJHN2l5d1hwUHM0TUEzRFk5dDhYaGtOQUp5Y1dDZ0pDU1Vnc0hxSGFnTFhid1htUnZMVkJuT3NvSFFsQTRXWVBhK1AwYWNKemFaSzlUK0laRHRkUlgxYTJyeW9JaW5tV0d4NU1WMU40RE5DVStDcHEvRkg2TWtGZ0FNaUFETE1KQXFTR1JmVWd1cEIxMnZlWEZneG5ESWFGek5Wa1ZJMHpYN2NITnc2ejVRd2toc0Evb1lXK2RTcmNPNDY1WHBYTzY2eVM0U3hDcFFsVHV1akZvWGFaOFQ2WWE0YlAvZGRVS1VyWlJNcnEvTG5IWEpQNnRsZ3IrTHZDdkF4aUVHTUxzYUt1VFU2NFlHS1dSK3BIWUkzRm1aN01OdkJvVlVnaXplNmJTYzhpZDhPVm9mMzFWQVE0L2ZzOFBwc29YNTJCdjVJd0ZLV1RabTR3U1Z1U1YvNXBYdjJBcWptWDZHTUlCMWl6NEZZYnpMZWxJQkdTVGR3VGJyVzkrYW5rcXZLQ2xpeE5RWXZTLzJFQlpYUHkxZTlLYkVnalNValhKRkRuZTlXd3BMdFprTXc3VnUxQTVSRndVcTRib3VLQmlTWGk1eHc3c1NHWVZ0R0hPSGdOOUd3cGVMK1p2amt6SjVmd3JzcWZGM0Exd2gwWHpUYWtXN1dndWtwMldkSko0M2ZMcUZ0QXNjeld1SjEwd0xtTW9uTll5Yk5waU9aSlVuc21wWXk3Qlp6VG8zWlRuVTZUVWtFeEFjYmxSUHdOSmdMcTdDZjhDeVlTM0N5bXM3cmwrK0lHc3c4Y25qcmkvVkg2WlFRMUZXN2wyVm1BMlNodGR0UE1ZbnBrWS9zanJMem1mZ3FIREJmdkNnZWo4WkRwbWNSNE94NVF0NVVYOWxodVlMVDZCVHpudUZlTVk0VXQyK0hkdWY1bXpKLzBWbXB2T2ZKSGwybWcxVS90emZGWUd4ZWYya2NYNm5XYUZVemhWOEpwVUpRL1daU1hQTVdXcFBaRldxQVloRExwZlphYU56UUdBRjlHMU9RVExkbWNLVTJST2swRE1CRGEwcFFCMXBTV0R2RThUTklnclhoc0Y1RHVqbnl0R1E0Vy9WSEhFRFBiZHRWbUczQ0dadzczaXp3NklkbHpOelMxU1k2c2ZFUVgzOUJIRVhKYmJzdVR1eS9JbmJ4YVZ2RjZKaTd4dURmaHhXWnViY1k1UXVQUDFITUxEcE9va3JXOGMzeFpZc3RkMnJUNE13ZU5PWGNQazNoTnZWV2ptcEQyTFdaME9IVGphVjVKeDRBWTBEaUFuU1djM2JmcU05Q0ljbm1QQlRseUlMT2JJVDA5VTJUQUdwYjR1a1NMc1pUdVNJVVhnS1ZDN1lRM1JQU2JPVDdOVTVxSFVvTlhNa3k5bjJ4UHhLdUo5VTFudXBGa3FoRU9ZcWtUbTh3SWNLS1B5cEdKUk8xSHMvMHdNOTlMdGoreGhwSXF0c1NtaFBGK2VuWnVkSzhZYXlWZ09vSlBvYVVUM2RmeVdkcTFCY3FtYWp1ZXp2U3pRWFRIa2xTSVBTdXh2alA5ODVUSU5hV0w4ZGptYXpWLy9Od0tkSkRwOGM3Yk1KdUtteUYrelNqSWdkSkdOL2llRkY0UWZLeWJGWnBOcGNjd05BOTEwdGZxSTZqTitSc0kvbm95RUo3MS94dUZKRFZERzV1M29BaHdyMGxYQTZ6VlluRU80bmV4SkdUT0FPU1ExMmxmRVpxSGw3dFd3WVZEaGc3YThlMGI4anRLOHF5dkhmV0Q5VU14V3RPOW5MSlI4dStNeUdTS0h0ZFpKY2ZQRlNRa3NGb0gyWXcwbU1EWmpDK05KdG1ZSDRJZU1PdGdDZmllQWlKZ21TU3RJME1SVmt4OVdSdEtzYTZCK3BrU1l6R3dZTzFIZElMaHlYZVoyMklxMnhiUE1hTEQ4U0FGWFdtbEFMTENPY0dtMFBrMndBQ0NZMjZER0ppQm12d1VNS3pOaWppYm83YXQ2bE5PZEhRaStOVVRnVXJzZkZPZUFaNzVPbHBWbWF5Q3p1OHJFMjJhbitySGo0bi9TLzkyREwwaWFtY1Zld3pQaWdTNzBsMU56VjY2WVNTSWMrd2Y3OGRCV1cyWExLVUNTQXlEVGJoMVJGdU9BbnFwWktBTEtQVGZsUEo1VURLaHBNTDVHRTFDeUJCMGJiNDJob3R0OStWeCt1VWlnRGFRTnZHMEx0VUJydmRvS01paEpsQWJXL3N1WDhkS0ZXVlRZejZnTWtJWFZlSWVvc0pOcm1UQ3pFYml2TXF0VU81NnlvbVdVRmNwQXRqU2liVkJNdWRoKzFqTTl2Q0NIVjlVN1NtZFdaWVUrOHB0TlRrNVZ5NWtjRjFKSjllVktaSHo1WGdjMHNwdlJmZ0dGS2JlTXBKZjRHaXZhbmRyOFhBTDVLSmtrYXJzQmNFQTRFajBEMm5SZ2tXQ2tuVXdYUUdUeFJZWjRPM3ZNbWNINHNMeVo0RmV1UUd6dWFReTBtRUxqSHNzK2hGSFNicWFxTktNREVNeHdrejB1ZFFUcWtrV01mM0VFdU5qcUdVd3JiSktQZFFzZlhJc3psTllpeFhkNVhkZ1ppbkhXOXVHaDhHNFNneVpJWU03UTc0aVZLTkZWY3diZFlWNEwvZFBOeXczYXo1bzJwczAyZFhFMFVpc2pZWEZhR3RaMFJPeGNKRzRBL2M4ME1KRlZLVXlPbzJxa0xSMU1IVHBnaUhseW9uYXlFLzlRVnFSd2lXcUtzbGl5N0xPNHVFck9xcXdUVnNYOStRM2lsNExnSGl1K2dmREFvT09xUUFFWHd3czJ6ZXZscVFYTmNnVEJIelFmeG5jeitFdGRmN1lVVjl1a3UxMTFaV0Z2NGRYVWZmOFhOSDZ3Y0tuNG5tUmxxaTFqZDJuUHU3V2pHa0ZhanZPQ29kUlMzS0tXUFVTTFF2Q0ZCOVg1dmxGOC9mT05Md2Z1WWN1S1dxSEVyK3lJTFVnM2l1THNxMnduSEFYWTFFUVpHNWVWMkd6R1V3c1hUMkdYWUlyci9WdWhXeDlKN1F5RzhiMDJtL0lKQVliL1NpNkk4OFJNOHNZOVVCc29MNFVXRk9WQnlpNW9senJlcC8zY2ZGWDVFL2ZjaDQvMElkVmg2bkNIR2svZkNwT0J2TFVFTmtWTUFnVkgwTkE0b3dCTEozblV3anVLQ05mSWZSWFZhV0ZneEVmZFVGeEJzMERVWjlGL0RaeEM0VFc0K0srZ3Q2UkdaZVJ4dUVsa3dUd2J5b2hSR3dpOUM0SEFFZzJ0eTJtanNtM2NxN2ZCNDBHdkhjVW12WGtuMENyVlo5OHJDbUZXZmh6eTF6all2UHYrR2RmTkphUG9rY3Z1MWhWem50SjlrYjFSalloRWRCOXZxQmp2MkNkY01RbVZsUEhaK05rOVlwMHMrNENhTVRueXU2aVJEYnp0YjdSMlorVUpIWlV6YjVhU3QvTGtjUUI4ejgzS3pOUlVNSDk1Vmd4UmIrVW9UV2FoU2o3aW9TOTVDQkUwWVBpZFZPOHJJaEhWSlFiOFRLSHZoSkFpdVFZdWI4dEZnL1MxR2U5Ty9LYXhHWjErY0JMcnlIODRKQkhHZklxZzl3cklOTUI4WEY2YmQ1NytPZURvM3k2MEd3ZS84RG1lcnJqV3BYZU5OUFNoa2R4RW5wQlRlMnBVdUlTZHliYnY4ZzBMajNVNllhRW44aEdmenZqY0cyTmlMQUJvejI4bWdIK0NFN3FNR2p3VVg1S3Fsb29tQVdmeTBVdWhzdFl1c211WFpDOXVYSTZvWC9TcGc4elNnSUF1ZUZVZjVzcG5yS080eXhaZUNjSXZzYWl0NGp5ZFlXR2lNMlJrVmZNTWZBUFV6Y256NGx3UG1KNnhCWmpZM0JFYXI0U0N4U3RwNG5DRi8rZ1hVNG84ekpFSUhyT3AzV25jQzUydXZCNERBY1ZYaW1RWENpNm05SVc1NjlwK3RXL2pmNWFXWGNzNHQ4V3E1VnBrSjA2UUM2UExkcFMreUZjdFpFeEVNRitLc3Q0ZEJlbjlmZzhJUlhFUkQzUVo1YXhsNVgyNmEyMTZHUkJmNmxRcDB1Nlo4bjF1VlI3Q0Q2ZkJyS0VZVlhkbVFzZ0pXTUNtdzE1MEFGK2htU3VwQ09SRnIwb1RxMERpOHhaaWhTUXV4N3dOWTFsQ3M1WnJqcE1Fby8vTEFLYlJWb3lRUXF3ZlZXUGVqQ2I1Y3RkZXhURTMzVGsvZFhveGtma3lsZkl5NWVGZ2xOYnVXeE83bDVvNmczNjVSUmxHcmd3cDhlNm5JVUFIbWlCcGVEL2ZQQVBTZyt6Qi8wZ0k1bHlSNHc5dEtqQ3d5SVkxSU83eTRsYkY1MFVrTDcyQitjOUxZWS9wMTVhekZ6UHMzM2JiTW56RFppNXBublBGOVQrc3JlUUk4aVVVNGJvSGFISWpNNFUvSlNzUDUvRk84YXZ3R3piMUNyL1dKek1pNEd0b0N0ZFV3WWVJL0dSZG0yRXJpYjlQWlo1SGJvM0YrVmhBZXhid2RVQVMyTmRqakNpT0swaXZjaE92eXljSE1qbFQvSWZ5R3crVjcrS1F1TlNMVklJcjJEcFRoTDNpZkdHWkFmSTBTVjVLamMvNFJkVGpCZWxXZzRjdlNDdE45R2lLa2RWdERBUWpmMzJwT1YyWU9wcTZNYWF0aFU2N1VCK2pDSlJKR1VUVGtjbzZzRUZRdlJHRXBiaEx2UU5LSlVsc2haN3FoWHRyUWl4RlYxQ09wK203eHdZaTBNUnlKTGZZT0thbDVSZ29Fa1ZYeGtoa1VDd25SZndYZ2grUEc5OWtIZ2xtVG5LNXNOWU8wd2ZYc3lrdWxFalVyVElQQ2dnaEZJWEUwTlB4eTY4M0FtcldRNnJxUEFHRzJGVXZWQmVsNFhEcldDQkFNb1ZCODAvSkZVbjFMZ2RZOTY5N2dzOEwrOWE4RHZXelZwekdkbW5tVldRemdEcnFQamdhOEVHMG5YWmV5WVpzOVhNT01TTTh1d0pybWpwN292Z2szMy93OEtHUVhrd1NtclRrRXZ4cEtCNEJhajNnUGhubzFpVnFFNWJQekFVQk9RL1lQQno0Z3hBN3d2Y1dLUGYyR3pjaEhBWG1veGVIUkYvVVV3aGh0bWsrMG91ajZBV2k1ZVlYMzBGcXhQWExScG1qUGhKU3Ayb21ZVlAzZ1BIR2wyS2NIbUhpZzhMdkF6OEZnMDdmRjZBOWl6U3BqbzVjSW96TWhmQTlhSzBMRjBzcW1xZVozQ3kyTGZTaVVoOFBLZ1lmbUJYVytpR3hNSkIyc2xFOE9rb1p1bGpWVGN4cnViVUNRVjNpc25aQm41NjRsZEg4djVYNGRaR1ppR2pSaVVERjJuZTRybi9BT1crNGhxVDV0OU9PNDBxQ3JHU2dvekJwMlZCWHBzTDdvZWtiaHY4UklBVUxtWEZLMXNaZE5nU05mYU9XZFVSY3hON0pUNHpjRndQTmdoNmM1Njh1Q2hjVTdneFVUc1dmS2hvaVpHdStGTFVvczh0Zk50SjAvUFE2enF2VjR1UHI4Wi85SFk4T3JORnlsYk92Zm8xN3hYQ1BSWUFYbHJxQk5PY0ZqSXdYTExjdW1nMHFCUmFhQjllSkVseERxY3YyZm93ckwrQ3Y1Rzk1cGJWdUVPZUxrSDVGZElYeFptbEtjdUJPZERQd3NRK1ZSZCtDYVVUQjkvS2hnalFSVEhzay9VUDRjaWdpREJyckEwMXhjdEUyaFI2Yzc1eXdLd2kzY1dtdHpaY0tScE9UQWJmVU9OYXZMRUUvNm1TZ0JIOHUxNzZlV3A3TFRmK3AvT1RuTkpZTTdMTG9ueENyZFp3cENpZHQ3T3JDNnlYU09FMC90NlpNbDJ6Rk1MRHU5ajFRQ1lEeVFUVE9MMWtvblpUSytTNTJzczZYYkRQaVUrQVlySTFEa3M4MVcrbUlRZVRKWjRhQXZrZ3gwRXlnME5GWVB2Ly9KLzJGNFk1R3lKSHQ4L2xaWmdLR1RaTjBFRndYQUdaQW81Q1lKeUwxK2VLaWF6R1hCNUpaSEtDcW0zdDR6ZG4zWFB5Yjlnb0M4emJDd25LdzhNclNXR0xMdXlrODV2Rnk3bzBOS05Fa3UvTzRUVFNpN3VpeHZ4WHgrYWMwblhQc0hVd0xFckdOVncyNmRmcjlJUWtmd3o5Qm9uK3VSM282MHFoSUtleTNQRGlzNnlpRExseEJ6MmNDck1nYmU2aE00SFdweUJkb09lZTJGNUFxb3hiNzhwekMyd1AyT3lJTzdOVVd0UUtuOE9OcCtEMWQzUm9hQTVCK1pheE1DTFVRaGpDTTVjY1BPRnZEYzNjbU1SelpwWDFiazZlYllkYUdWUnVCNkFvRmFmR25NSkRKYlNhV3QyQjloVWcxdld6SzVwSHhSMHRpUFBJclpOYkRENWR4dlByZ0M4RW9wemVUbGlxdys0Q1B5LzU1V1p5OWJVNkRIQks0UFJCRUJmallrY3pmeTI4Nzdpbm1oU3BJZ3Z0TnpJZWcrc1h6clROOXk4ZHZQTDMveVBVeWJ4M21kY2xuTy9CekR6OTdwRDdWVGsvZ1VJZzNRR3VBUlFMQVJOR1k2d0Q2Si9MY29xTUVDeHRKN1ZwOGxrb25MM1JOWnJUT216M0NPSElXQzE2L3ZiOHBaVlVYbWZXUGhWbmJTUW92cmJEeERMOHhXMmFGL1p5RHpaY1g5b1BkMC9UNlptWStMSTVWR3NheERFODlVMnJSWGdlWE4wTWx6YmNQOHRIcGpBL2FBZGZPYkNVbGE4T2svM0xkTmFCZktxcVl3SlRIQlNFdWV5WGp0VjF4ZjlNNE11ZHFPWVlWeXcvMEpYZmx0aGFTd0o3UUZDVTRXQyt5cGRoakN2Z3hTVE8yT29xWmFVNnV1eklyNHRjdk5acFYycStzY3NKYUZhaTlnM2x6RXAzMmdyL1pqS0dHcXdnZFMwOG9RSldpUjRETjg5TFRUcUFaSUtwdm1jQWlzMnUwcHlteVpGOGRDNnN4M3FqbThJRUhlWjR5SkRkMVJaRHZzRjk1N3J4VEFManVnOG4wb0lpMnhyTWw4R3NyZzBXSmZ5blcvLzN0WitKTjk5NndSNy9LSEZlQmZwSUZ0Y2I0QVJCa3lESEZSbUF6SXp3VHptSUFXMXhrY1A2U05paE1EV29ieWUvWGlPaEpxMGFOakd3QmFYeFhqZ2UyTktwVlF2MWZCL216eDEvUm84OUg5NDJ3OFhVS2pHN0FJdVM0bXpJbzJ1cS9CYTI3a09leU1Nd3JSRTV2ZWVFVlNoTTNEK2dUYUhrQS80Q2FOVmJxV0VvSjJWdWp1V2ZqQzhPUU82M2pka0hCVzNSWTErTW93bUhXeWVLUG1iUkdtNHZRcnNJMWVkazRWYm9YRWxQM3U1bHQzQ3hwQmhqVXBpbWowNVRyNm1WOWRSZmhTU1ZRQW5FR3hISkkrNFJmQ3d5VTNnUmNWU1FOdlBUZzdFbHYwSFh6dDF1eWR5RE1mZUoyWlVyWTRKOTRrK3dMY05XbGkxSDJQZEkvelJlQkVwWlliTmxVT3d6ZU1qMzU3TWIxNDNEdC9pZTZpekh4dVlZUkJhRVd4UVovUFVVV3FmeTBsaStzenVlUEhPK2tUVjZTNUN0Z0t5OENDMmRQcTRZcUl6MWZKaVYwRGltN1VPa0U0aHRrRjVuamdOSWdxcDFyS2U4SlJNd1lMaUlsZk80L1JyREZXTjlUWDc1VnJjZjBGVVF4YUYyVkZDcWJkREhLUGRWWkgyTS9idVdXd3ZFbWRvTkFENnpzMTJVZUpDWHVGNk5wWG9RQ25nUllHVVIzbTJnN3h4KzVYWHBuaFkrVm9WcFN2YVk3UmZzSkRPRG9XNFV3cXVCNFJnZ1dkV3lHY0lId3AyZ1p1REdHQStIVHBub2Fvbi9oVkRjTkwyOWIxamo4TWxuMlo0bXJraTVsWGtLRXVIMDNkMnNERGpqSVd6NzZuS1dEendZT3lqcmExRXQ1UnF5MzRQS0daRlNjZXB5cVo2dmJYbWxkU1FBSVlpYVBoeTdTUWxKTW9YZU9WNFlKUHRUY3ZFYzNXdFMxOU9tV1l4Ny9JMkJmL0RLS2F2ZUk1Njd1RWQvYWNQYkxocDJzcUVQZkEzT1VwZ2Z5Ym1FYmlMNWpSZjZHdnZydktzNjhiLzU3blRqaSt3SHFrd3lUWmhCbkZ6eVk4MGRqbzJNeERRSGVrVTRXMDMxQXNVVCtUNU85MmZLNFVaeWowSFpBTjR4TVhQQ0tpQ3FvazhrT2ZzQzNvd2JSM04vcDJGa0NseHBnSEFGcEF5V2wwRXdRaE9ONzd3d3pxejQ5TVF2eXBseWlYV3lTSlJUK1VBOXVKRHpEdm5RVHZac1BBMlFuYVhlSHZLS1NyV0ZDZ1R1WXF3TVlCTmxCay9aSEZsci9mZ2lFZjM3Tm5mUmRsQVlUMmp2aWxsWVNrWXp4Z1NjRVRMcHNacW01azAyK2x2Q0RXalZ3eHMvZHk0blBFNTU0WSt5L2tKUzVvcjJjOXJyQjdpZ2tnMlpRekRmNDJGZXdXdWlrS05Oemg2MzBhNHlia3JWdDNuNDJqUSt5eVQxREZpaytDVGhqVjFlRHNOZitQSXFFWkNoQzNVNkx4UndtUzZFWktVYi8xWWkvcFNQL3NTcXZqYmZHMnV2djdtRWN2NXFSaHVQZzc0dVZTVDQwcGJ1WWxaYTRtTkRrVEVNL25aV3E4YkJoVno2N3pKV3IwM2FUY2t4d01xaU5HOEJqK084bmdRVlBNdW5KVmZxT0RBM3dlV1JzeXVJKzdOUTNkRjlSSXdhVjg1UnU0WnpDazFYNTltQ3hvZVNjcUpwbko4a2l0dE5yMmZoNUp3TVZsSG1nc2V2UUx3L3VKV0lEa3RhMVRRMTlWc2wrT2drTnRWa0dlT2piSG9HaUF1NURjUWtBMHNyd2tPSUxjTXFvSE5Lb0FmOEMxYjJzRTNTV1U2aHkzaVh5a3FXcnl3QUwwSlJESExQTkdnRWppT1ZqYmc4VWM0eW9aelhseUZuQ2NwTllYbFQrSXI5eTVWb0MzTG1JSCtDcjk0UkU4TklLTWgzSUxGQVlRRzFJT3c5UzJSYnRpSW5lOXVtZlRCRzRxeW5Kd0xtUm9wY0JZdkhkSWhKandLN3FvUlZBbTNLc0NoT0xHOVBrbWQ4SzRyeDBGZG1hWElyK3pNZ3FYOWw4cmYrQmYyZkY4VWxUdis5Q253RTFLOFNCMmR6VzFrK1o3STdoMnN6K2htSlB3M3E5M012M2xwUUYyNkNiTmZFUC96VC8wek5KR3pSNzlvOHZ3SHNER05FSDc3azZYNVM3S0VvRlp0TC9MeWhEaHZBU0JRY1FwUWdCR0Yyd051aEJEOGwyU0pKSWh4dnhsY3ZRQ3NoSjE2NE9wYzVCM01IRmU3Rmk4dE1mYUFPaThXekc1cVVTbWxSdGh4QTN6V1REUm12U2FNc1dNOWp0b1FIV3d4YUVCZVlnY0FHQzMxSGVuUEIxaVhvVEVIRjRZVnA4Q29sRXcyVk9KekkwSmlqaUlBamhWWVZmT01aOFR2SkM1ZVVya3ZsRXpROWpjOGZzMHFzNW5JTTNBN3FhYnpyNnBPZmg4dWhOakJaYm8wYTFhZzl4dVdFMU4rRUxWT1dqK0xRd3ZtbnM1dTI4OS8yWWJjdyt3OWFTbHFTdmxMWk1pTHBQcHU1b0F4Z3hSS3pSYnh2SktWbTBueXV3SmRvL25Ua3g2Sm1JL1dHMGk5a3p1NkRaejMzVHl4UVh4cDh1bU01bGZUN0kwV3FTbDlYMCtLaWxrRm90QXptQURiZkRycUw2QVRFcFZjTDVmT0NsRTh1RmoweUdaTHFWeVEvRVBmYWZsQ1IvM3hWdjF0SGVsN3g1cFRMTVBEamthdkdMakRYNGNSZ1JCSDNYcVlYY3luc3gzNVdnck5rOUxuaWhVbTFvWE1wcXMwcFlhS2pBL3lBVWdhTkRyYkc2ZTZ5Vmx0TTQ2SjRLbWhwVlZRNjJNdXo3MUR3Z1M3Zm0rSDRDeW9Ha1I2bEZ6a2dtSlMzMVlrbERZdmtWbGxBSUdJa05ySjhrRnFYZGI0OEE5NENiSWVwcnBIM24vaTdudEkxNkcxSlBIcExkeVJhMkFpc21XRmVncS84YUlERWtpOHVYaFRqUW1Sb1F2bDcrT3FUOU5WYytQOFhwd2k0SVVYUmxVSjNUWXVLZkswQzh6TjB1WmI1ZWluSFpQODZYSWlCT05wTnMwZ3NKTUhqa3VIZEF6OE82WEdndk42TGw2RWE3R25BWlQ4c2hkK1lwWk9hcUM0TGI5MHBTczVGakJoSTJTampLTm1pYkpncFJrVTJMWUZDUjBzdlFCU0xzQUtXSWFjeitiRGw3S3haeHB3ZksvTGt1NUpkeitHL0IvOWp6dEd4SUhiVGREMjZaMFpiaTdLeUhub0ZDVmdvTUJBb2thSE9tek9KbklMQ3NUQTgrc2FXRjJ1NHdNREJ1dVFTWUYrVGx4OTdVVmE5SkhoMm5TK09pSE1Cd3k2c1JHQlNrUWRWbXN2RVVWOHpvVno4QnJrKzhiK056Z0RiT2xGWFQzMFhTM3VMMGtKWmw2QThScXhpS2VZeUhOYUJhRkJKQnFvaWdic3NxT1A1VnVDVXhYVUUrQm54WkNEcDBzVUdpa053NjhmdW13VVdLK0xPVHpIT282d2hucTdUNUp4dGpjVnhRdklWVWJMWU15MXNBblhKa1RDVHBqbDlzS3JWWXBnUU9CbUpZSWRMQ1Y3NDRleHlpUVlTdXJHbk9RbDB0NVdGSENuN3lXUE9CMTV5MjBVMjU5OWxVenNqVnlESTFFWGQ5SGQxODNreWxwRys5bHExdjFhOFAyZG53OFRTQ3JWQUNOOTJEbUYwazNCRktJdFVrVWl3eHBJSnVkM3lSNC9CY1NmY1BETTBUL1F0Y2hMSHNpdVQvRnZxWUpsTXF2SEdjanYyYlA4MGxiNnk4cjlPUjdMVXJZSHBlcnlZbFdUSXBRbVVISmpweGNtMlBHeWtxQjdWbnhMUkkvS01xeUZXWk5pYWNFY1RPVTgrV0dFUG52SjlIYjllSmc4V1o4OGRFMnBLWWRtN05NT3JzR0NCOU5kYmlvSTVuQ0Nrbzk2dEVHWG5CUVRxbjlaYUUvbGJQMWx2RXIySHlnRWNjMXpLME5aTTFzZm8ybjdtdHpBOExoUDdCc3MrUTJ1V2w0eXR6MnYwWHptbThVWjZXeExITWIyb3BQY2I2YzFFbWN0RW1kSlNETDk2Z1JmYWZJWHJzMjJwdkpTRWZ6aVBFMGtWTEdwbjRrTlNIVUQzU3luZEJOS3hzVHNWbTBQMWdlbjhmeW82S3NaL05IVjNQOGllenFhMzA0S1NSaWVSTERLSkdjS294aThBckJ0NG04VUhzVFliTUo1Z0V6TjV5OVlFSDdacFVKWVhMcUlMZ0lOL0hJZWI1bndEM2NEQTNNWGRwMTc3TGYzOHh5Q1gwVE9mNGpSbThEaE5GbGdvT0praStkZHA2dkxnNm1tMXh2bjczZExVQkdMQjhyYUFkWWw0VjQxK2xXQUQweXl3MThSeU52MVZZdXhmOVA4ME1QTlpYK1BGWGoxcTlHSHR4L3daUThmSVg1K2I5d2RJWHhYN0lMenpTbk9mS2FrWGphNGJaV0hWcXBadVJaT01tTXpvWC8wVkFzN3N6M09xM1ZYbHNlYkc0alp0LzhxdXZFS0QyN05GUmVFemhyTjlqalBnYkVKdmJHSVpRK0dCcXljSlY5QXpHVm85ZGRJUDVBS2NtMkJMazZVQ205N2tOVTl5aHFUMENNZ05QTGdVY3hNa0RXQytqVk9LNkJIc2VuS3dXK1FxTitaNEZkT1RLMG5yZWxvNDFaMFJkQ2JTYlEyRHB0ak42NkxrVlk0enBodmxoeXpOVWlRQkZJbUpEV09IYVNxUWpxR2hvK21xZXJRVUxuWjE0a3BqRzVqWHZZem15U2Q0Y0VsNUFNcFhVaFFxWTZJeHlIcUQ2R09vNUlmQlpkbDR2aUQwRE51eWNQb09qeVNoNzh2TCswdzZINVBCbzFDVitEUW5uWldON1NadFpDbTQ0VU01bFZXZUZETExqMVNuSWljQkRRd0kyZ0JWdVdzeUNEbVIyZGtDTWN2OUd3eWpNWDhGWVNaTU56UVFuREUwaDZHRmtwUmRyWExUNFhNZDZ4SS91d0JhQjlBc2NTdWtTTVZPc2ZjUTVCNHRqUDRkMkx5bGlDOVQ4ZGIzcld5TngwNjQ4RlZhR0RoZitQTDVGYU8wQmRac1lnSStzdUJkcEorTStVa3Z1dlV4ZUREcGYzNjk4WnZaTkljMGY0bjVDRXkxNk80VEtYNFRlbTY2OGlwMU1hRkYzVUhpV1E3ZlR5R29zRis1eWMxWDZxWWlEczdTbVFTSWdIeERYWXI1WE1FdnF2QTJZRTg0aUY2U0h3N1VrMUZ3a005Mnl4TGlLRlE0V2FLTmtMODZ4WE5GRkFPMkIySDZRak45ZFlFTHM1ZCs2Y0t6WWY1Mkdkeml5S1dpQjRCV0EwdHpFTDRYZkhYSnRVaGVmeldaRm93RVNlMkRJTGVYYkJJSlo0Uy9vVml5U0hmVXN6b202WDhDd2k2cGZLZldkdDFYRjdLMnBncHMzditGWDM3VCs1ZHlQTDVldWZNT21yK1daMGZSSkdMalFDMEJDSExvR2JjTFNoeUY2bzBua3Nmd3c0aGR5eEdqSjArUFhQbUIvbXNPODdheXFZNC9zV3FUNG5UaldEZTJoT2lBWGdiT2oxaXVnZDMzc2J2a2FVR1FUUjNDV0tDd1N5TE1LYnArdUtMMmdza29uUzhZblZ5OE1OV3FMbjg2ZzhOSzhvZDFZVlhUbmlvZHpNSDNYWmlvTUo2bmpWek8vVXFNUzBCTnJSMTExRythMzRsTXRldjFTc1p1NGdtT0sxK2dST2I1RllCMW1Ga1JhWUQ4R3lobjBXY1VwbE9lMXpqcmk5RUM4NEZjc1RnK0I4M0x6a09qL09mM3BYZS9kN2sxVjhLeGI1eFNVL0RLQ0h0Vi9tUUpMdDhJZVZ1elA2T3VSWUF2OENZWnRFTlR5SlU1T0NMSkhVNlV4K2dnSzBwZlpGYm5MSmlsQTlOMENqS093Y1pFV1V1alBTemVRTytHbWN0bDZiMG95aE9UMlA5Y1ZVc0FtcUNXZ1lkOTd6aHdmdnhRTG1iZDltTDVmSTNscnlTRnRoTFdnQjRvaWdWZkV0aVIyRTllWnpLajhTZGZSR285VzZ4R1k4MGNONUxWT2Jzb0tCUEppcGh3TDVMclkrektoUFFkZUFkM2tuU2RTMmJNM0FSSE9sUjA4U2dxeUoyMDJOY21BOU1zcGJJaXppU2tqL0I5QkhKM2txaG8rVHBvelNacHAxSElKOUVHeVJFY0VzWmFPaVhRL2laRjd6Q204VXBWWngyUkV2RE9FLy94TEhobEs4WjdVcXBENzY5d3cwa0tHTXJmYXJXVXZnWU1EWW15RGlFUkJ1YzNHT3FmUy9OYWRCdHB5dHcvSXBJZnh1RUNDUU5VL2xHZy9wNkljdTU0d3V3dmFvMUxlVy9xSDlWTmVUMTY3eVBwc3ludjBmRFdRek1TRUJiSnJJSHlOVkhHZEtaSXJBUHFaOU9zcGY4OG0vNGtLeThvdUQ5a3hFVGJpVXh0MFk3bE5VemJUYksvazAxMXBza2N0TUZrUmhaZjhOeG9Ua2cvZ24wV2IydnIyLzd6N2VyZWZsZUhhUHBPUHJrYXE2cHp0bzh5YWpGUDQzL3h0cHhQU0ZsbksyZXl0SXdDSmtLYitEcW5OOFJZb2xvS2NuRjRpTlg1ZGd4NnBER1g4MkcwYitmYVA4Qm1Fa0ViNWh6dTc4QWdGc3FObEZ6S0YwTzAvRmpaUnNBeEJIM0NjeElaV0hDN0poWVd2V2xMSFNSazV4ZVI1K1BVR3g1ZnlSMlZuZmNtV2VYU1ZaSUVWVEtUYTlMUmlua1pwejhNdE9jSklIblVzTW0vaml3dEpiMk0xQzRHVnlqb2FSeTV4TGhOYzV0SUdwRExQbGUrWnVmYmNxaWhKVDF1YVdvY3MxVTFwU0V5SUZ4cnkrMDNTWVlDZUt4Tk5xc3pDVW5uakp5bks3TlFTc0F6REF4cTNINHdMdmZ5NTBFcUh3UlNYVzIvTFRqamZZeVVoMUs1QmlZTmtMbWxMT3pwWDJlZGNVWko2Z0VMNFJLR0V3aE9Fcnp3SnRFOTlwQkRjak1zdWZKcEpOd1d1eHNsZGV5QWdrMnFQOFJyM3luL2N0eitaV1A1eHNwc25DK3hLZndOZ2FJckw4Vlc5cERObDZFM0loeWtPUmZwTVRoMnhROFcvUFo5Rkh0ODdaWDEzYWNzQldBSEtvZFp4VmRCUGxDcHh0Y0xJSGhiSHNkd3Rla2N0dUU0WVFwUjI2YWdEQmRtSlBNNkxZelRBeE9QMW1IbHFzaWVnN0tIRC9lRGVaY0lwR3pEZVUvSkdVTGtWZ3Y5SSsvT3hiejAydUZaTWkvbzhmM2NBSVJ2Q3h6L3lnZ1ZzaG40ajVIMnVoaDg3L3RlM1FZbkFKUGR3dFlyUS82cXY3K2hTR1d5ZFRPMVpyQWR3Wm5LcEpMa3p0bk9IR3pOKzUveldzZWEybFpCS2RENWtTUnprSm5FUEdHdlI4NUIyN3labFRVZGpkYmdmSTNOck5UZkUrVTJuMytlTld6NHd6aWZHTW1MaU05ZWlRODhFdWxvWXNLYlBtV250SGZGR0cybUhLWnRGNzd6Q1NKdjVwK2Z1MGVMT3YyVGl2THhETXRCdlZkc1A5R1ZsOG4xQU0rWFFNOVVsVHVaYmtrUUtSSFM5ekQxUVg4cFdBN0p3dTM1ZUt5VGtaeVBzZmxVSkJiNDVnamR2NVkyWjBwbkp2SVUzTXJSOEFWNGVDNFhwcUNXaFcwRktBVFZLdWdpQnlTRjUzMDRHOEZ5anFVZEVuVjQveGZLQW1lT2paU3htOGhxRjBiTnJDb1pVQU00SXNnZng0MC93MVYxY25BdWpjc0VWZTI3VlJ4c2t6TTFlYWM0YTNEdEhDWVRxakxmVGhLNUVMUDl4aXdZVUpuakNaSzR5bGlXTFEwa0dvTW5Qek9kVEZwZFkxcWJuV2NRdUpkelZzTVlodHFGTldHNDJVeXZqT0VYSytEODFGK3UyVTJja1JXMDBpdGlqKzA2VnZXamRIUE12dnZRNUM2cTJQeFVpUmIyeWZJby9PN3JlQmdZVjR0cUo4ZWpBTzFib3VxS1pqNzVScEczVytuZ1VmUUNjV3ZOVmhaZ055Q1ZWZENiSVM2Qk8ybWhMK2cwd0xjYlNWSnFUdExoOEJXN3ZtZXJ5MnBIa1JvMk5IOUlzdCtoTjhOMFJFRm1TVHZQcGlRWTRLZ3NkQ1MxSDJOd2tGWjE2NXVyME1weFVhSFdqckpPOFA2Y2hoMXBwWjNNQlQ1Y3dPOWN4SFhKT3hvRks0djVkN0R6anpUVUtHcVdZS2M5bkhQQmxibnppR29QQ2Y4WW9Qd0RYanlXUndYdTlwS3lqYlplZUxFVGgrSHcrTDNGM0YyNW92SEQ0MlJ4aitudTZLVlM2ZDdteFcwYU9KTFBwT3lwcG5iNSthNFV2NjNVRmJGbVNOTUpmdW1yN29GV29MUlc0ZTNsZUhFaW15M1FkYmtMMHBSSXRTUFE3aXZYZUhqbENuMTVEOU1remJkTlJpQXNNVTdCR1pYSWsvUjZyRmRPd3RGZHZWOEpHcDR4MWRraFlZdTF3SndqVEdYTVlPMEM3VDZQb1N4TE91WFg3TW5sYkxldmJoYzF0TTdERUNxV21HUXd1KzBEQUhKRFF6OGtVWmNlUFF4M2Rzek03VG5GNnVXWmVHdGlGaEdPdng5YnlzUnV5TkV6TUR0SnY1bklEeWJLUmhGVmN1SExITEQvL1hoekxsOGU2UmVQMHZoelFJNysyT3RObEQvNGJpRWNzbU1aYjhhUi9yTVVHYkpHRUZvQnU1Qk9hckdtS2FnQW9DbmltVERyQ1ZaVHFrTXg0R0lFakM1eUFncEhZcEd6bHdhNEQ5aHFFWDUrT1FkWFN2b01QOStPTEkzZkZFYXdFMWRrVGNrWDJ3L0Q0OFZZUmZCdnlEU0ZlZmZmb1VFaEFldGgya3R6cDRWeW1uNDIxSzhob1hBUnJRdEkrT2lwdVRTZ2lVZnRKVW1ZYUpRVFp4TTFISUtOaTRCTkE4aklhdFBBR2VqV3NPYUN3WTRTUlhnd1lkdVBzMEtGWjMwcTU2V0NZTFdicWNLa2dSQ0RiMlBqTHgxQzQ5S3lPdHlTK29YZzFyK3g4c3FRRHczdUpwSU1qSncrZUE4Mk5YUkhkUWNIVnBpeVNRUml3amVmTTJzWi83ekRrSWJ2TGZoeUpYN1lKTk16ZFhObUZMLzAzL3hhR21aaDgyMVZBU0QxNE1renBXVXZOejQxUDZDQUg3cnR0L0NGcXJvV25UdmF6YytDOXMyTVAwYVZkMTJIVzJVaWtjS2hkVWtBcjRqbExEakJSR0NwT0xBTzNzd3JVNnJ2cGlLSHJCN1FzL1FzcjAxZGRxL0ZSd1Y5WUJnVkt6VVRjcjZzTEY0WHVlZHFId25uQ2kvTFl0YmdwenpTVWhGMmhQWU50MWUxVXlmNmEzb2E5SXpKQTdheDJqcjRJMnAvVTUyNXRIZHVycG9DRGRGUk1ZdS9rK292VTNyb2pjdEswd1MwRGxzbGhXU2p0QzlWODRtL0NUeUhoSE9ZUFVtMWhGNW04WUtNU3V1VWxZd2h4d3Q5RkExNXZNSXJOVHpBS0V2QjlneGRjdEV6aFZmRzI0c01JellZS0piQ2x4M1krL3ZJeGtyeE1MOHZKMWJJYnlWNnhvMk9qYnkyaml0WjNvRW9YUnlEbWQyUDVPWUYyVW1rTHpwUjZFSHpHSVpMc2hJd2JvTFNUMEhQVjVDS2kzZjA5SWFmTThIVmF2Qm52ajFGeWUwVEtCKzdpSU9KeXFOVlhMVG9zeExtSmJOMnhNRDVPRTlaMnJCcG1uYitkU0pGdEQ3SVJldWlhRkw4UDlQK2s4RWJhYTZTR3p3NmxBajJTUDJ1b3l3WmsvZmg3RDRxWjQzUzgrVHNNbnF1ZzhLaWREc2ZIMlFWUHdQdXRERy9nQWVYVUFLeVdXZkQxWlRvUEJWZzlSSzNJeTJKU2QwVTdqb1FLY1k5dUpHbSsxQjl2UjRzSDJkeUEwdjVKYnJ3MDZJanY2VTVuODNWMXlmZ3FpT2JzangvRzFjTndtdzRtWUpKU3NJQTVSSnBNNlpCS0tVbjZON1J1SC9rSHRJZ2xyRlZWRE5GTVdoQWFxRUhxVGhoK0JBNDc0UXlPaFRCcTlCb0ozTUp6M3lxVWt5NjVJempzaWwyUE8rRm9wNzIrSWVDQ2lCOTZjOU5ycnp2VXB1bjdWQ1pVVVNYMktVTG9oUXRmNk5LR0h0NWNOVnl4Nlk1eE54WWtzRzFKRjJuck1tcWltNENndXJTUll1ZVh0S2R2ckwwUWIvZnlQa3VNWjQ1cG94T3Q0eklRc3NXT1ZFVlh1TGFaZ1NyVW1aRE40VTZtNlZyTmVqa3pjdjc2Z1hrYVZWc3lTa1ozYlVuS1NLZXdCMUdpWGkrUlIrY21lVkNldWJBWnFDc2d2VGw3NWdaelVpU29DTkZpcFZRbmNpWGNsWVB2eWdyOGd5YXh5S0t5R2dscVE2MUI4UGtmS3FjNkxRUnE0MlozNnFZZWlzR092bktWRlVMNEtkbVo0UldVYkwyTnZnNmdWT0JScXBpV3J6S2NTSTRBYUlyK3l0WmZUdU1mMXFYUzQ2ODBTRzdjbnBZVnBvK3RhNFIxWkNMUDg3R2d5RE04SEhLdUNJRzU4WkNGMVRUMlptUWZEVXVLYUZXa2IrK3JvTWl0Zk9SZWFaR3B5Q0tSWFlLRXdPMkZoVEZqaGFlS1pOSHdBb1NzNjcwcFpDdkVZSHBXS0h6aEpvSjJxWjQ5NmtTVzRqYmZKQkpIcmhoMlREYkdkR1lnZlkvNVROTHFsT3dtRThPcThxaG1kU3VvQi8vbkV3bC91M255K3M2Szhlb25kZThMVzBLWTVibHc1eDBYblUxQ0JlT2RBMEpXV0xXWFRwMGpFY0NaTEtNYUd4WWliYUhHZjAwSmk3RWxnMWtHekNDaXg3S2ZwTEE3dFJCcU5kQWJoMWMzUkRabXg0ZDZEZCtwdTBmOTc4c0ZhNUkxRFhSU1U2cmZPaHpCcDBBeHkva08vOUNGTWE5bHhIZ2Q4b1d3T2tDZElsMnhQaldOV1hUb0w5QnJPNmdlaGQ2RlJoVVVZR2x4TVZUd1N4T0oxUkpZcFQzb1ROaWRpVEhaVG5Vd0hZa3RWemV5NHBiSFlSOWNDNUwwbVk4dXVOQ0VCVG5jdmhiallmQ2ZRNDFtYzVNUE51V1YxSTF2MHRtL2VEVm1xa1VnRHJHZTY4TnRNZ3FWMFhNbURmQTFhY01MWkJwaEJyclhNcUJVMDJ4ZkFoSGdQK1N6cTRicGk4TmIwUnZqdERINWJTV1YvcjUxQm9SWmFySnZsTUNJSmJaRE1QRlplVVJwQUNTalRvZEdtazJ5NjZITFBoSTZyZnhFSUgzRndQVFRwN1l1RGdpa2lNZ0FNWVV6R0twZnFrYU5qODdCVXNhZ2hndTVQZzVRdjBXTmhHS1JleHpJRGNBSnRmK0laemk5d3JKR0NzWHE3U01WZWtkcmJWbytOdmdxcUhDQ2Y3TkhuODNrRGV0NUxkcmVLZVBLenA3WWl1dFRUcEt4TzJRd0VEU0VHb3cwVjdJR0xmTWZoVTRJU3NKa2wxbC9yVzBZakVXNG9OTHRqNkdTUWIzWXhyWXVEWVQwNHc4TnBQM2RnTjNxcjhhQlV2WDhCcmhMNkVZQWZaeDdFY0Q5RlJpNjFCV2krajRQRkV0a3I1R0hkVkFmYU5KMFBvTEF0NTRmQlMyQzVxekErVUY2Z05jbzNKVVVvYzVVQmtENVdHWWRPaGxJcWlNVnhOU2NtR0dzZk56SHN6cGtnTTlTTHBWbHJ1UTVRUnA1L0U1MUdZS1hEMUVRWW9xUGFnWXNIZk1ISWUrKzlMUE9jRmZ0bENPcTJvZGQ2NUZ5bTAvWHdXR3pYcGR4ZDRsOU5QWXRPVm14UFJMK3QweDZxcFdvY3pVZ01RSVJpT29VSG5lNGRmbkxKRVFVTEY4bFordUM2T2VoQXVKbitWd0tTNEZ4anR1UkthTU5EY1YyOFh6UTJBS3FvK1Y1RjBmVkJ4RFloc1BhK2x2bzR1RVdRcE5ONkhYUkhXaXp0K1RlNWdNU29HQjRmcXBNZkdBSjRPU3h1VS9ubGNpNVVTQitGUHIyaHdQRDRMUCtzak15TUFDRXhVdDNPRzVsS29Ic0pPQTA4dmtnNDMwNmxBYUh3b29Rd2RCam1EdVg3cTluSjVtS2E1SzVDeXhxbm9yOGE1TjVRTGx4MHZ5MldxeWNhbmtmeDFmNUtVTkY4bDN3V3dsbTE0UHBCbUl4cUQ5d25nd0RtZjM2YSt0c0tCQ1EwRGpIU2cwUUo5Qk1BYkxaNTQ3WWFjNUhhd3IzbmJJSHNKOE8zcjhMTjBtVWpzbkpSOW1vQVFtdVhoclFBYjUrSEttTFN2cERzZWpBWE5TRUpxR3Y2RnhqVHRLVEdmaXdWRWVPZUJvd0s2TGxNUnNkMTN2QWZTZWttWkovRC9ZWWpHVXRFUERCdno2Qy80d1lVNk9WeVdKWDJlN1o3eHltK2tSYk9PMFlhWnJNK2x6TFNVQldTdlRsaUtUbVVLU0RTYy9NQ1FGRFlHa0Q4SHBiNVZDdDFET0VYTVk2NXZrQlZLMWxCNm1hRHlWN3NXd1VRci9jaXhqSW0xL2gwNlRXQ2E0aklXYzhHLzI4NlNNMzRMSm9ReGhBd2RyU200SU44N2l5dzFOYzBXOHlFZDlwYnlXdUpnYUEwVjdFK1dlajFhbjZjdHJSU2J6eklZeW1FbVR0d21Ic1dXRDJZYWNjd0tEWUdtQW5Rd1k0dkQ2MURBelBGaFhsTDNZelJQOUF1by9jaTlRdkJ6anQrYm80RERaSzZqT0JiRDY1RWQ5cnpVRm45M1ZhM1cwbk9PVHFWQU5BUnZxcXh5L1kvT2lxMHczUUJNejJEVUl4S2txZGd2eHRVaHVQcEZrbUtJZUZEWGdxekI1VjFTbmlpSkpVUkxOckVDWDhkVlgxc3M0N0IzNkMvY00vemF5TW5GK3luNEpVWW80V1F4NFpTNVROSnZSSDM1blVSZjJJNUF1NGRZOC9yMlJBUHRKeTJicVdkNUlJV2lwb3E5R0JuUWt1dUpMZDhMcFlTWDc1azZNLzZyeVg1UzZZSmJEUVprMnNpbHpaZTB5VVJrWTNGTHRxOUdGRFdJWjJEVTR5RVhyZGQ3SDBxVkpmKzhyRGhQeFFtWHlIZm10bnBjNUhuNTZOcDVudE50VkFBd0lScUJuQ3h6Q1RTLzlaQnEwTmI2YzZGZ0M3MDZHRCtmV3VCditvSmo2NnpiOFhlTlpEWHFML0dhRlQzL2doUVNtQXVhZUtKa3FoaTd1UURXeWVTT0VRd1hvcjJCR2h5d3JxbGRFZHhHZVVnRDMxZXFmOCtWdlFxbVhIcW80M1NEMkFGZ3hqRDN3ZWxsVk1DcU40TXJyeEUzd2NwcGM3R2pmOE5tR3FZbEhJRmVFS2dWeUhXSWZQWnI1dGJGYW40cXBqYUdCMHc2bkxqZ0t4T3BHdXFFNGp3dG9sb2NGTEk4RHNYbU90UWlIT1VsVzBDbE9WeGhlT1o4T3Y1R2Z0NFpVcjFvR0dmbjYrc0RlN0lSbkdRMXNvTWt0YjFhaVAxeW1zV3BNTzhnNzkvMEJiUUFaOTJMSndLMkFaeXhTY2RQekZ2QStDOGhZaDJxWmlBbW9ITUJZa3hKRjFQNkk3QVp3Vm5FYVRMcEdSTXNrOHpZMFJ2Ly9ndUFyeHRMc1FBenpTZi81ODM5enFsdDFLOGZPM2RQZEV6bmtjRWt1dGRwZGFTRUlrbUY1OWVRbisyVUJBd0pzV0k4Ry9HWS82Y21BRFJsZVlBSEwxRks3UzNMSjRRd25kWmp1cnU3cUNsMjU2dVo4LzV6T09mNCtTamlJcWxKSkl1cDJtRXlraENUaEhnT3JSUHd3QndUdWRnSTN5RWdBdFBNb2M4ZzNXQ3B0U0gzRjMyaFEwaElUZzAvN1duR0NJSmE3bHRTNzUxSUdySUd1blNqdEU5RitqaDQ2MlBGakVpWHRYd2g1aDZ4RzlHMGxzb2NrVjVIQWZUQXpHR2tUV2tyOVUzVjVua1Zqb0pVVlBRYkhVQTdlQTZ6SHNoZ3ZTUXo4Q0xzVlgzSm81TkZDTndwbDZXa3hrL1BGL2NOY21rWDlDcWNXVjdyU1JpZDhxMGkrbG9BR2kwTnM1V0lMTUxxSjFTSG1aK0xpbHhBWmRGMkR6UlhROThRdFQ4N1BwZnNxbkJhRCtST2p0Z2N1TXRKREVxM2VWdjdhRDVQWGlkYzBHVXRMR1lpcVlqYWZkS28yN2VrYkRNL1VBSDVvMSs4WVQ0WjRvV3R1anFLRGRlMUNpSkpNWlFGN0g2dnlRc2h0RGY4M2YvTHZzMmV4LzJMV2Q4RmhEdGRYNEFxTDNuRFVtb1RyT1dtcHhmWlQ0ZzM1UXdtRFZuUjRFYVlPbUxzSjNMb1laV0YrUkxPTDNGc09MU2piMTNLNkx3cDFwS204dHd5R0M1RGQ5a1dncDhkRXZJa0xIaW51SkhKZU9sZ0wyWm5CZ0Z3OG82dkg0bUFDVzNyODBKSFdRUEJteWthUFVYbFpTV3RDVFZEUEYwVEQ5NDZqQ3hmNzM4VHJHTDVvMGJRRVZnQjNWSFJ2MGV2Y3BlZXJFQ2RvOFF6S0N1eEFSUHJvM2JkKzVZb3Vwa2g5bjNlb2JEK3lGMDhrcllKM3o3MWtIVDd1UVhPUURHWDVlSUhMV2J4NkxiY2RNSWlnd2NqYVNCVDI0dUdyOGNBTk84dnFYQU5rZGdWK0djMW00bnFCbUFMVmh6SUt4S2lHMGp6Y3VPRU9Id2R2YW1uWnpLK2V4S0tWa3F0Z3hJMkxQZ3A4V2U1SWhaQ0VVMWtOaUxFMnNWT3RRcERSNFdjNUxDbHdEc0I5SThWVDJnQmlUREQrTlBydkpqSHl0eks1bitHdURMUStLVDN6bmFjaGUrTTFEK0FkVDhTS2RvYVRSeGsrVzVVWm9MUkNYcDN5Tlpsc0hvTXV3cnVYL014UkgwMmhXcUFMTTBDZVRvZGZUNlM5NURVRjZKMytVVnM0NytJaDVXUkI5bHdscjZYZEtkVWt0UFdWaDlycEVWQzYvOFRCcStGbitWaXkwYmNNU2pheUtXaTQySVM4SFNGSDhOdEpNdTJBVXkydHI4bkRtcEExc2RWUHAxUFNLa25HR01mVkZEMGxqVTNRdXVRNUZhMTA3V05KR3VPMDRCSm15bWtIanM1eDlaclZGdGtyRTNBYmJGeHlPUU11OG5TV0NqRkJxUThUV2RRRnJ2ZlR3UUJsQzJKK1M5MWZWenRqYjFOUzZtbDBWdFhqV0dSNndyMkkrWGtZRXh3V1lONURsTkxUaTV5SHlIMUFUUTNaZFJYTDlMQUtWc2VnOENiYTc5bWY3ZG4ydGZqZFJaUUc1WTB6L1A3TDlyQUxmb1U4cnlIdU40U1hTSWtMMERzNGFDTlMvVXNMYWV6TCtmSEpWRnBGbWc3RitMK1NxakpPRHZQVHAzNUxsOE1CTndFYWpORFZJemIvZzFSNklZZEgvdGtwWHNZOFV6WXVRRnFacXROTndTamovelNJSmhZdnFxaW5SQU8zdXNmbnMvNnZ0MVVqd2RaSkVqZmRvS1lPakpDK3A5R1BpWjJEa0RMYzB2TGZBb202cm9ucFF6aStpbmN1Q0NYcEtDZGxZMEY5b0lPSUwrcURKZWZJbEtIQ04xOUpYWmU2S3F5TW9YcVpPQk5GTFVJNjc4bWVuaVBzT3B1aFpqcDNpWnNVdEk3WTZtTjROWVhwUjd5VHdJY2pMVHFMejd4MDdnUHBtcVY1aHVrVVR1K0hYaUpLSFRwSnNiME5xK3R1c3h5Q3Jsby9OcU4zZ2kzRDZsTDR3Z1diWCtBTUJ3T0syeG5SNmRrL0hTUHZ0WGdyZ3B1eTV2TjBVS2Z5dzBUWllLVXIrWHBackdTMWpYUGNWcE1aUW1DZE9xZFJiWTduSmZzNFUxYk9lbytPeWZjazZSZmpyWWVtS1dBNVFyZzQ5ejgzTC9CMUIrcDk5Vk9TakN6azJIUTlTY1paMkxQUUtzS2pvY0F5U2xWOGVoVXZXdEtDRkpHR2NWd2w3SWVTOVFQSHphaWVDOXdMbkIzakJjVFlYSGpTR0dsenJwU1Y5R1dzMWtGM0hsaEZSRzJwUEMrZksyUmdzS3FROVlVVXpubURqaFllUWpPQzZDZG9lRHN1VmhPc3FBQklsb0ZaQ0t3RXVCNFBkQldwcU4xaDB2ZTh1b2MwaXB4dFZKQ0U3YU5aaWZUbjQ2MDhWNC9KQ1lURjdlaHF4eW5VNG1VRm54amN3TkxqYS85c1g3UXVzUlBSMGhLYks0UGVrbnplQnhVZDFZVHdSdkI2UCtGbjRLNEUzRlU0ZFpGOHJRVFBySXl2V1Jva0dQZFUwZ3hRdFo1VUhqbWpoMEJhbHVzdmdIL215eWxWTkh4VlZZeE96SXJ5WGlITnBuU2psMHhQWUtmR2F6dUplWi9oRDNuL0hnb3E3T2FwTkF1eDlTbkdQNG1lYjBJRkZkU0s2aTZoUlpmb1NNeDhTRlFPVnl6a01ibExndmhNUmdtYXp0aUZvVzJMcEZhbXB3T2dOWEFxZ2JjNTM0Z2tmNGE3ZFZTYTc2SllhVUorZDA5UENINkpHTnhFZ2NwM1kxWGQxY2gzV1VIZ1Jwa3hnNTJab2pLbEZjaTlIZTZ0MjA0TUY3b2FlQ2ErUEFkL0dpcWZtTzd2QXMzK2tYakY0VUpBODYvbDh3RGM5RUMxNmZ5V1VWcWp5M2N4enJMdUVKRXlWSW9hWTZnWWhlaEw4YjJLeXNzeWVqUlJ4bkxqUUZ6TkZBUEMweWw5TjJZZjFlRmE2aHdNQzJPY29tbmlsMldISjBWR2M0aXBLZEEwVVh6aTlTSGNoN3o4TUVNVVNVNWdhSWwzRTFSUFlYRVFIWVdrMEJjcUJLTTYydW9tTmlON2UyRGpWcWFvSUFmQzdWSjRuUmhIR3RwNktDVjFtL3hjS2pwc3RDOTFUeEpqV1ZuK05IZ2FzdWQ5K20rei9oZVNCUTdwbzVHd1M2Z0UyTk9xMmdmSlozY2NhN04xTVRHOEFlaStsZWJtRTdLRlNQWmZCTzZwN2owSldaNDFjL0k4aWNrcWlYeDBvcUcya2E3Y1MySTlGUk81MFZkcWJlaU8yY3RyOEMrTCtaL3ZSNzg2OGI2RGlmNmpXcm9ZU3hSdlBrL1NVZkpFb3I0a0tqcTl2aFNrS3NrbGFXdVNoaUUrU0tFMXkvcEc4cE1wR0JCd0NkaW9vU201VUErbGk5KzVxczJacGxSeTRjTUJ2SURZaklHMUpoOWxnMHlPcnAyRCtUNi94S2dvUUpnVng1Zm9kakNiRE9ueHVjMStEN1o3TXpNWGZGdXErOHZTemx2RkU2bDBsWlhWc0Q0R2lRdXpDeW5iVG5ycDdHZG55dmt2V0MxSmxTVUozVGF6RWp4bS9ucEdGQlBTaXVOVFI5NGNwaVVjUjZPMHBCS1hpYjRHQmVFbVN5V0dSN0g3OHFSMGsvSWM1ZmhXdXZBSlBqekJsMzFJanpSMEM3T1hvRDVPVGt4eG5tQ1Y0SGxiR1ViSjZYVittN0IrbnlHZlZRbHdBdkg2ZjQrVXJGcFBhZ0dFOGpUYzRhS1dDM3RmaDhPTVRLei9EVGdiRU4wbmhnNmtrVWdKZEJ4a3Rka2NpRHRBZW5JVC9QTnJaUmlRdy8xWjBRMWFxdEtxaHhOUldxN3hRcUh1TEFPakpVZ1h1eDF1cHVGWTRHc3BLcTNxSWdmU0FGRUo0Q0hFU09TZEtERG9ZTURxRGpWUXdCQWtCdkVET05ZcEsvRk1UcDVLeWNhVk1EdkJSUWYwRnczK3gxb3daNk0yVnB1a0FOMXBSWGM3a1R4R3ZvZmplN1JVRDYrNEZiMVFsNmRJV2NyeVZiY3ZRR0U5emZSRXdkYW1yK1BwcWxMS3NtWUI3d2Q1WnovV2RhUHVCdTdIZWxjVFNpVXVaRHdPU0J5RS9HczFQK0dYbEkwV2VhME9mSWExTVdwTXhhOHlRTW9CeldUZWd6UkRXVDZRbGc2Z2I2TzJRVzZNVXp4VENnbWNlc3hPWStVTHFsUnc0N2I0bnZCdXovbmhkL1JJQWFIS1lKa1VUZ05Udzd0ZCtNVU8vbE5DYnNMQzN3MEhOMFIrTXc1ZVZ5MTQ1Z2QyTE93d1B3M0k1TCtXcHdYYm9nazZ5amd6dU43eDQ1Q2VGR1RpazVDbDVmL0hrVVRNRklPVlpPTm5xcU5ncFlXSUJrL3ZrTng4Vnh3WExxNmhQNDZYS2thZHV1TnFxWW43WlYzaUFrZUMzejhpMDZPMGFaRkdBWHZMU1RxRkRSZEVBV2ErMk9iU3JoL2M2aE56bTB4amFER3lQeFpiZDR6dGo0THpSSHAxR2F6MnpUbFZKQUM0T1ZMbm9WNlZVa0E5eUpLRWFidWlVS0w5ajZlb3pEMHAzYWV4TmNPcEs5ZEg4aTJYcG5GNFpxdnlqTzlVZVNjbHZ1R1hYQ1dZWXlORndHcmt2bEZEWFdZcHJHYlY3YUxuamRIZmNkdmFCZXZsK0RzNVMyL0c4eGtIQjFKazQzd3NKeDFWSDJJYUorMngySUdwSFV0OUlGTkZ5R1d3SktOSkVaNEc4TUY4MEV0UVpWY3hvWHJXandlYnFRa2tIMEN4Z0dJZCt4K2lPU01XY2N3MGtHblQwWUs3M0JOZXhqZG1kQU1HWDFrbVZGT1M2S24wcmNXT1FockcrU1dFRW9ZUklDZWVzU1RyUkJvOHlQUnVrYW5CMWFvcnJxaDFJbU1mSG8yaEcrdlZKK2FqTUxpc0tOOE4rUkN4RTcwNFNVbGpXSlRlNFdzRTZvQ29jdUpscFg0ZTV3MllzY0VWOERPVUFBS0dTeVNSeEwxSThXYm9YWktzQkJJZnAzVURqRTNVWEFJWlA2dzJGWGlXU2h5QU5Yd0o1RUkyemhFQUE2SGFKSFpFeXZGNExIeGJtdlBWUzRxcHoxY3NkSnFHbDJYcHNlUjBsOVQvRE9MTlplVUhpVE1PTFBrYTFDYjgxWnd5OGRJN0p1M1BXREZLWFFiOHB0TlpOME9kYUNVbDVORHJnWm1jcGx4YVhsQnVIQ2pmOGVBOERSYlhOU3pnK3pOSkxZRnpTc2VGZEluRW5pQnZEZitXMEVvUWpTMWZicW1TeXU1UHVCMkFneExTdXFJUUFlZnpTZnVEekhnOWtUSWgyamZGQlZOY3hPZkR5WlU2WElvTGdpbTVDTGhpSnJqUVBNS2ZxN1VVMk51cU9SWjlGYXFmNlZiTjZSQ1Vjd2lWa2gwT3BTQTVpWVI1cWZzUnZNdFpLVGJITFY5NjdTR0o3TjdPY1JkQ0ErbnZrdlFtNmhKMHJ5UEhxbmpoenBiejJXVi8vSTdVbnB1MnNxYklMbHAwdE0yWHJWbWZuM2xTcnBJOVdKYVROWGF2U1F6Q0xpSDh2TXF5ci9EZHJnV0tZT3RobEhmcDgzYmNPb2tMSHlwS0piNTdxaW5YZ0QrZE9Ndm1jTTBFalNScXBnN0NFNTNwZFpqeEFBUUFsQks3d1pqaEZNWnFvZ1FEd3ZOa2x1bExkLzhBZG1mcGtlcjhPU1pEMDR5bUxPYVFHL1NLU290WjNoQ0dyU1phRG5aTHZDZTdmOVFqbStYbzFUVlVBeFJlZ3Q0dG50dE9ISS9NSFFvYWsxMU04dk5wbzJ0UlRVeEdJT01aaXAxMkU3cFdpRlJFL2xOMTl0Z3UxaEdZTUtzL2c2K2VvalVqYzhkTWdqc2lHYUdpTE1XSFBPT0J5eXVwTlU5dStMYUI5SXZ6a0ZpTFBLL0ZIWjFucmxUREJZY092U1ZyUzNudUtxeCtwZzA5OVBWSldLc3FqWXZFdmtzeTFSUXVRQXkwWllza0xlL3dmSVlLeXVJSHNwOEhWeGZRaTBGMVV4QUIxcDRaNWQzQnU0QzlyYzlJREJTYlFpRWFWNG5pT045TDlWZVB3ajlYdEdVbi9mdnZBMHJVeW5EMkc0eE56YWlVOEdBZ1dnTmVIV3U1dXk3OEdQRkxvczF3OUF0dGVleE1pTnhlTi93MTBRZEs2WUtxVTVwMVlpOWh3eTFGMVRsV09mZ055Y3JpMHNnQmphdVgzR2NvcDNFNEwxR0RwVEx4b3dSbGlEd0YzcC9UY3NoelJmSDZXK0ZPa0p3eVZoU0g4M29HZ0t4dDJXcDZlU09wMzBKZ1FGOGZwc1k1ZnNDaE0wVVVzMWtUREROaVRrSTNYc2RmUzJLQ2doOFhyQmtoTkJKSkFRN3JtQUJBRjFLVkp1MmZSS1VqMDUrbUVhTjVFcDhOMWZsK3N1K0JpNHl2ZDdpaEc3dXhQMzFNTXBpVE5ZTmMvUFcwbTFOTlNkck0rc096NU1DTlJtNThYRGRMdW5vWDJ4Y0ZFNzhIUzNxcVlISjZKSGhlMmw3MG4vOFVUZk9CaFVSdkVqWWkrZjdmQlc4OTBoT2lwMEtyQ0dzdUxQMFlrWXVjdkJ4SFpoU0VTZm5iRkYwbk01V0VmMmxOM3V0dGgyaTVEenIvSVZ2cVJZSHJIbjFTbTI1TU16MkVKNkp4NWNRT2VOcEtGdTVsTnF2aWM1SFE1NUdjc0hCZW5kNGg2ZGF3TURhbUNSSnRvUlpGZEVLU2hQZWI4WDBrbVMyVWdQUXB0RVlac0FrUnZRZjNJL0pUMjZ2TnlNbjdmQTVGQmdUamM5bTRGNTFua3BDQVd3T1lXNGJqY3BDVFlDSkhkcGRxTWRUYjBMSHc0Q3VwTWM5REFxKzIwOG81UFhvdUdPQS91dTkrdDZtRk5GbCtDcWNOMmxjaTNnQkxIZThseTF5WHVEUXZlbHF3UFRacGh3eFBVZGxTNjBPblBzWEhZRnpLWm5JeWt5VkdVeUlNUVQ3Z0JTVVZKNmpaVWFFaHFqc2VVZGN6WGhVWWdzenFISzdKanlOTFA0amFWcVFRVXJnWnRTZXlZeWYzaG1hNEU1R2JJR0p3ZUtuTThnbHNHOW4xd2FxUTNjUzNkdVRWQ2Y1LzFWaWpoTCtpQlRjc1plSFJoMm1uT3EyTzlaMU9HVmxjcjFLN1FQNDJxYjU5Ty8za3FqRDNkaFRleGJsUy9ySVNVTWxwSlBpT0IwOTlnWCtxNXpSbVhDcXRBK0Yreno3aWtNL1JzM21ZM1BTS3UxajVRL1pxYXQ5ZXlhVU40TmVqVXNQZkVNcithNXpmRGJUcjRUZUdwV0p0cUlxWkNUN1dValBQT3lTVmcvQWNwUXNkZlRWck5WVkpabW45OTBaSTRYZ3V6VzQ2SFpBR1RXdG5UMjBOa3V3MGFXekwzNC9nT0o4c1h4UEZGVlpNOG02VUtPaThnYytRWWZoSTZrbVdONzdjcHAzcDlDZlg4OG5sOUJ3bjZnUFV0T1hhTWRJOWVPb203eFdJY1JHNkZtM0VUQWJ5M3NUL3dab0diakM3ajBBQ0pwZDZaRWlMRHVnUGhYZmwzL3hiUUtJLzljUzVXai9uczFNNnVjRnV5ZmJvSnA2OURrbko4QTdWbkpDU1Fkd3VBa3VYcFdMS1plN2NDSGlFUWlCYWJ5cUZKcmtiTU1PYW5qekUwNWxUQy9PMUlUZXVwdGZmSlUrK2cyQW44MzdkWEQ0SkdBZlRPZlY0MGZlbi9PUFBjdy9tN2V0NnhubmdGem02MU55a3JlMTByUFcyMnduMFpBOUpxNURSMlA0aDBRSmFjZm13Qjl2WFladVFmNXVHcXhYOWFKSFlPY3cwNFoxVFg4ZXJlMEpyTVdVODY3eS9jR0M1TndVbHgwa2lBeGxBejVkWlZza1YwV3ZadnhGQ3gxRlVYNFJUS2RUaHdqUjk1c0R5cjZ5eUFZM2pPSy9FbHd1VUw5RklZMmtlNW9vUUFSWjRXTE9scENEb0RNbzkwVDNrR1RkcVYyaFVwdjBaWVNIZm1LYVpURnc4bzcyL0NTY0kxQUFzWk9RVHpMdVB5Y1lTQ3VaQ1R3RmIxK3F2TDluZUFENlkwZ3pDaVVSbkx0RmkvaDRVci9NRTJMVHVCQ1QrRzdveFNFaUd2eDFIbFRQRm1kUGJINGlIODRycDQyTnEzQ21BYnlwcXF4VUhIVWsvdzh1SlNMak1SMG1XQTJWc1gxYTFtVVVxa2dxK1Y5ZkdaTEdiUmlKaE42em9MeVRYdGF1dlNXVXZuSlhveVYzT3F2WW1SMWN6Wk5aUkQyalJEQ1gveGZ3R2hSK2NXSkdNMzFGLzdzOUlZdm1OWFkzOHhzbWFrck9KUm92SkJ5Um93V3dYK0IvMTgrcTZhMUlwU2VMWk9jd2M4U3VVdUFHYVgrSkpVZTQreUhhdFdTMDdMYnNKT2MyODY4UkRXVmtJNERpRmc2bllrdlFVaWNFa0xSYUpTb1hhaUhTWDJ3a2dxbnhUNTJHT0VEa3hqNEczeEUvYnFGUUF6VGZBbVlDdGJHRDNwZDA1c0p5aDVTMCtXcE9xQ2w1djQ3RW01R2R4S1dlNENiall5TnBicURiV1pwZHNrZmkvNGZMcDNMak9kQzBRczdmR1RBTTNTLzVHMXJoYUNIcEg2dklPMDMrRFdRMWNuQUg2UTdqNGd1Zm5JV3hUY3EzNGpmY0wrVVZ2S2lNRGdJdEM0QTZVVFZrNHgranNUbmduRkpzRGhiOXp4ekI2V3hKM1pHcGUyak1pWlFHZG4xT09FSWdxQWxZWUdBSm1vWWFiN3BaVnBjYVhxRnNhR2RWbU5CNTZRVk9wdlliZm11eWM4MXRtUnRubXJ4ZlFJeThxUnVEcmE2VGRWcTRZR09rK21wTDhRSjR2dW1kL2Fsek9QQ3VLaTIzS0M2Rys3aGRqN010aTBEU0RzYlRqWnF2dHFlK25Jb3VhZVhPT2d6eUlqdzdWcjJQdnR0M0lhNkFkd1hwTnpweWxEaUY4eGxJSXRIWm9wR25QaURPVllsMFZ6UWhzQjN3WnFrNEN3VFVHT3ZUN2hLWkEvME44dGtwdXZHQkZMZzRaMTdHVVhaVENhVEEvRUZwVFhIdWd1eTBMRHFpQzErYlo2VWo3TGZaL250VTJWeHlwUXZUQS9KMXBOR3ZPUmczU2w2RFhwOVRsVGc1Y0VMMVJEZHQ2WEd0THlTNDRaZW1ZME5rOVZpK0cvQ2ZDbkRHbERQRGRmLzN2NFJ3WFkwV29ZT05FZWpuRzZFUzZ5OU8wQmZ0RDRseExIM1ptdVlUdk5TZHROVjVhS2RRL2psKzhqNlhIK09HU2YrMVpwNmNqR3VYTUJiWlFFdDRhSHVsZ1NBVitKVzg3d0xtaGpYOHU4NDh3TVV4emlHc2hRbjN2RlNFVERqNHJUNjVNcldtVE8rdlJMZ1hSVWxENlhodTN4SzJSbjJmc2JVK3llWkp0UWkybkhMYW9GY3ZySThCVTFMbkphbGxKZm9qc2h0bTdKOHc4M1dvRnN4NThldUVyUUhuYzR2RjVpTnR4ZEJKZkF3d0swZzBydktaMExoQnpjdm81OWtlamVBNlpOMTZsMmxGNCtqenVobnkxbVJvMjkxdnBvc3c2RWRxTlozY3FSckpBM2p3SVA4NEIxR0RQZVpxZDErS1VNSjNFWTE2eVVFbE8xV3JpYU5wVWNPa1Z1SGdLczJleXZpWmFHMTdBUk9FeTgrQmJWd0x3T0NYT1pxSTNKVldDQitmZ016TWtOdGhkbDNDRDh4aTVoeFJFZExFeWE2OGxwT1lxVjA2dzBDVG1pdHk4Wkk5NzhZRHk1ME5wYXg3Y2UrNzhvZ3dmRkdUcm40L1IrWHljanA0SGFhV1JtZ0V4UnpJL1pmb0NVT3FhSS9PRlVEUTFPTTdHZDF6SkQ1RmZRdWllRCtPVXgxQ05jZUdqMGVneDZicG9xWlgzL1RnZHBORk1NWWR3N1NiL2cwMHBFWThPQ2pBRDRvL0RFd3VMQUMzR3FIT3RSQ1VVTWFncFFBQTR6WUdkTUI3c0tjT0NxSHJBcnlYZWpBM05KUGtzeWFCNFo1WTcvU0k1WEpKaFR0WVgyUG9MbkdLdzc2WDViVmtsWEh6SWJBTHdXQ3BkWi9oUkdpY2lxU29vUzhzNWxCVEFNSU1xQ2V0a2tGdE90M3VGa1FHVUdNUWtuV2dLNmNGcVRJb3JjWnJGWk4xTzNscitDSXhld2p6aDBaSVlGVU93bkNsekNTd0VJSUxoa1FhUFloMEErWTdVTWFXMkV1ZW1kREZoN2MrWkN0Sjh4ckZ4L3AwL0xyd3AzNTRrYnlKd2RzM3F0Q0R4QVAvbFgvMFBOOTRxdkIyZkhjNXFpN3BZb3Z0em9FU2xVaVVwRk1FM0ZaRXNLcVY4eE5iOUlVQ2VCNnFqYkdaZlhqdEp4a3krWEV2WmhyMSticElENWx6QVV3NSsyblJLZitqK2N0Ky9ibW5GbGxKNnh2cGZPTTZoc1hVdEYyemxzQnhEREc2MVpicVg3REpWVVVneVJ2VTJucmtpSGJQY1Byd2VhVVpGcVBQT0ZCRmdNQWtRSkFOemhFUUU2OE53ZXBwNjc2SkpHdzhDU2JLSkF2RzlZUUlDNmF1WlpLNWhkWjduU3F3c3hHU1JIMXFjSm1TZDg2c3h6bVNGTmlZaklGdGRXdWdreHB4VXdIR3JySjZkelhCRENSWlQ4NDRUcnRrNHB0c0JlUGVVN1lYUjdiZGFudU91aTlOYjZka1pLaVhFZXFmeUlmcndldXBNeEl0NXd5dXk3RlpLaTBrV1E3aXJESCtWNUs5NFFrbS9MdGFxZ2lzZ2JGTFVGTDZGYTR1d241TnFWQllaZktoZ21PREdReEdWSlJsSzR5UHhia1pKZTllNHcwUGxodlJ1eXZNMThDUG83Y3IwdEJnWkJXR3RPWitjbHI4ZWU4YnowcjJsMFArRGVLdEg3eHgzYnR0VWxzQlpDUjdQb3ZlK0t6KzJlNzgyeXdkU2xFMnBQMCsxRHpURlVxWXRzWUpqd3NWNWtnMGljTzRUQkVCOGdqNjRBaGFLM3NYRTNZQXp4QmRrVk5aWnowTUxPVFM5akZ1bmZtbWZSTmxzVWdKbUNTc0E1YWZNOWpodmhmWUdkZjRNdWFWZ2M0UUtBL2lkdzdLbjZOUlZ4QXBkM1dHaTR2ZDNMZnNNZ2hFbmQ2WEZXc29mZTZkZGxZZGNmMDJ1RWE0Mmt4dFM4blpSYnRhRWtjZzMrMUZ2d2ZBdjBra3NTcWU1MGl3NWpiSHNCYVVOM2UraG9JQmZxbUJGQnBzbjBvc3Bqd3R3a09lcUNpcWw4TG1hT2FtT3l4cnhYWlI3WWF5NXdTQk5TK3ZTSUM4ZDBFbFpVYzNkZERhQlpPVE1xZmlKUk55UzlGNlZqU2tZSzl3UTZmWTE4VHBnaVBtbktQMUhDMTFGTHVtLzljdjNvdllXWkhHd2RzMHZqcFd4SEg0VWE1Q0FucCsvNmN6K29Jb25PVysxaHV2L1ZHNUhsRFdSV2hkSEJTd3dxM01sN3pLbHdrZXhFS3NDMkdEL0h0dlMzV0poNW9IQ3pOZk5BTjVtNG9rTDFZbW81Zm5CTUJtWE5GckN1VWI2M2RTcEpkcWFHUjBzNHREbURSSG5jL0kzQkE1NzJrckNXa1BtalJueklUZmd6SlNxZDVXRTh2NFFyanE2N2FOK2o5OGRvbXZBQjNjVWFTbWFEYVc1WDZqVzJMbllOUGtpR1FmaTZQdm9Wc080NThadkZQbW9JQjZCY0dEUkp3a21TN0VxQ2JzK0xkaElHTnc5ek1vTUpXMlFVMUp0SGZmbVVKNEgzRk54SjMyT29teE8vK3hGNTd0WStWYm5IMjhWcTJuYXk1dlRhZ1RHZFAzM2VyY1Q0VFFvU0pOOXJmeTBnZWJuMk03YnpHUVdueHU2OFlodFUrWGFsODdjUVlVVkl4ZXJDRlF1NFpLclhHRkdBRnpsc01FbU16VXpWRjNpWVA1L1IxYmpETTFsU1p6QSthM0lUQ1c3RDFmZWVUNUVnL2VzbkpLR1p0SUtaT05lWCtVUTdTaGdMek84SkR2TjFGYXdXSVhkZFVXNlFGbGI5cy9qdDlSUU8rYThpZ3dCMlR4RDE2S1FTMmVKbUczQTRoVFV0MVF6bS9ZNTBtZWtNdEFUbC9mcjhuUUcxbFVlUWloUzhPbklqRnJ4WlliTUtLdjZXRWFnTlVkek13NUs0bmNUOFA0ZUsrNWQvUUVvOEViWmZ5QkZPQjBtQXI5VmJyWWpQQWNQNzJSR05NbFBrZGtYTlVkeXBxbWI4RHlQRGhmQnVrckZabnhqVHo3OVR1cjFmS3RRZnVCZFB6NlcvMTRmMDZ3MnVDbVpTaHlmS3BlbjBtZVhYcWtJL2dhbVRoQnRUUkM1cFl3TUNSaEN2aERSVkZ4SVd2b1VQSjdRdU9tTlZiQzlvSS96K1hjbG5xdnhzb2ZESmVMMFNZR2sraUI1RW1uakJqZm1pVFNHdUFseW5RQjRhZE5oL0g1bWZSdVhXNXoxTUdoR2hrNklBdEYwSEc4ZjRZYXA5ZzFZc2dpVHViZkFpdy9TbzVKb0pVaytoZWdyWTNBUW52MDJzNmhUVWNTaEowb1lKQVRha0NkMVVTTFMrZzEzZUdxOG1nZDh5SE1Xc0VQQVJvQjFSSUFFMVZHVWpWQ0ZoL044eVpYU3Q0cHpFcHNWTXNsRk4rYlV2ZzJsTXk0citIbForOEhtVEI0cXZ5empCc0lQaS9STnl2SStEYzAwT2lPRjQwUmpNSGRUR0IrV1pnUE5JNncraGdZanZKVVNJbmdkczVVMGNYa01tWkVoU2xhMFRsRDVNdklvUkp3UHg4SCtYR0diZy9ITnVINU90Vmcxci96cmJGYWFKM0dkT1Y2eXBjQWhVdGJkQkhSQWY4RmNWTU42VVc5UC9LbWtWQnBCZ21NbGtmSXFrelh4ZFFab0hWaGI1YTkrVEVuQnExOUhKR1M4aVU4OFZqK1IxdTd3U1lRT0FNNU04TXBXT3ZGd1k4OVlhVG5QTVZ3bzRibWxVR1BGNzdVT1BhbjhtVHdhcnVsV0tsY3VJZjZMLy9YZnVSTlo4dEdVc1c2QlB3cmljYUttRnp5WDBPYWwzbk5ScHE5KzVvZUJvcHhNWEl1VFV0TjNPZlFnbEc0aVpZUkdQVEY1anNwRnlYSkFKeVBpb2RoU29IQWhCOGpud0x1Rnh6VVJjbVFkcThYZjhzWUxyM01TOTJwVW1pTmpNNVVwcWdkUW5nbVB3M2JNclNXeGd1emVMZlphY1Zja2FXNUkyeW5vT2V6MkhWOUZxT21RaWd4bmF5bmZDQ3ZINXRsNWdHeStZK0ZSd0NOSzJvNDBOd0w2SlQ1S21XYmkvTU1JcmNpelQxTzZUV1lOSlBVbGVrcFdBaDR0OEZnbEt4UWMvSmp3ditqcjcvblhGbEJHV25VK3BRdUovVDVMcXdBdnh5L1VXS3FBenpCL0FZMGp6LzlNeW1Rd1QxUjRGY0Z5RmJERitBWDNWMmZtK21WNjBkTDRaYXIzSVZlSU5vYmpnQzlxeVBzNHVtcjQyQVFycm54dk9velB3dGRVbTY1a3AzY0MyNFdaUUY3ZVlvUFZSTHdYVlc5VC9LLysyZjlJRFN6V0dkOWlPaUZ6c3RoaktNbUJjaCsyQ1pqM3lOSkJOSlBwc0lpRFIyREJsSXNZWHFpa2EzSUZFNXdIWVFSdmplUE9PUXpHNEwyRDRNM0FIN2wwN2dZQ2Q2T2tncnRXSW5sa3JVMG1MckRHeWZ3ZDhleW1OZnBrZW5Na3V4Y1lmUjgyaHZHNG9Sd2FpVnlBb0tsQVRZcGNKUnpMNzcvajhsSHl2Yzg5TnkxVTVheWE1RmVTN3pDNlR0R2pWR1JMU1dzTFNqdEN2eHVFODRSa1lLaUtqWElFZkhJRUV5ckkrZ0JseCtMNU1iRVhrK0pVTFNERXp0SVJsL0E1dk9WNDB3cjlhekRTUlBZSEw0M1R2bzRucURFbUFtQTRrTFZ6ZkpYS28weG81WGdENG53TG5ZUjQ2UWtnRWQ3RFJLd2tqOXZwNEZ0eThzeTVzNGZWdk5TK0RiUS84cU9TTXFxeGlrcVdaZEM4NWdmZitaVVRTeG5MdHlzZWFFaFBieFZ4alU1a29WQ294d3FPRUd4cDFUZEE3aHV0dGtMcTU4Q3JnQmR4dXRoWDV3OTVXNVo1aHQ5cThIWVZsWHI0MXBmOWR0UDdybTVOUDFEdVpCQ1BlVlZFcTFmNDljeFpQRkczc3VLZFNmWWZhVXNETVUxaHBUOWJzNVhadTdQa3RleW52R1ZwN1R5T3l0blN1cnlUTXZSanNvdGxkM25LT3JLaHNJK1orSjJGUFkrSGdaaGE4Y091M25YNVMwRlhzMks5aDhUWlZHTjhVSUNFUS9xNWNwQTNhdmZDT1V0Y1JHSTRVK2NXUitWKy9pU0o4Y1JZYnpnTFYzVC9hL1FpUTVTN01KOUY0Sld3WHZlR1BneGhvbjJqZ0RtaUxzaitSeGhJZkg0L0haYlVMeTFlQStiSzd6VEhTNVFTQWtzOGJwS3BMMld1VW1PZFh3MlI3MHQzVHF5a0pwd1lGMlVVbDdCWEIyRTFnUWtrbGJRU1NGVXQ3MkE2SEtibTcwRTBscWNOa0Vxd29pZitPWjhXSkdiSXNZN2tYaHAyZ1haVExPejRiM0hzdG1pdXIxUTR6a1dnTlVoWHg2Rjg2TnNPSThNUzhsM2NtT2oxQVhQWGNMK1NZRG5PdkZIbE1iaDJVdnlCVVZyUm9oWnhtRC85cFpsL1h3eVdrYkVXcmgvbm9BSGZCc0lyUlBWeXFzK2xZa2JGQXkzQ2hzTlY4cVZTSEVSbkV2Yk00RDZpc3dEMk1pU2ZpYThZVzlqUDBWUGhXS0JRUytydjR5T0dtTThLcmh4R3NFeEU2elJCRjdOTVJUL2F5TjVjdG0vdUcyZWRTWFExcEJpL2VnSnJxcnpKZU45eEhGWEJWYUJrcUFzRmVXNFNOVEEyMU9NQ3Z6MENUTkN6VW56angvNXpkZkdJZC80NEtaTnJjUnF6YXB1VXhpa0RZaExpOCtMazVyVFFJTkhBZzViTGgrY3hsZ1gyYUgrSmxHRVE1amxzZ1p3SytqTzhvQ1E1WGJxNDVWVVZFTG53NGVleXRBQzRCZTZwdEhtYStnNWJZZWtnNEZFN05YTnFPOFE3VmM5aDlHMG15aU81ZUFQN2x2U1dLbGR1OUFOSFA0UjR5cUZKZ01nRHVnWERDZ2dOemxSRzdIK0FvN3lJRi9sT2p0Y093dWcvUlYwV25pekplUTB0YmNEV0N1d3R1NDlJN3N0bjhuam03M3lodEpkMHNKTzhOeDhyQWY0OGkydzlaRjliZWp1NE12RzMvMUl2WllOaWZSRGVSVVQxd0RoZjNzK0hMK0JKeTExNnJBbWJaQVZZZnhPTmUrbWVoc3YzVkFra3JCZ3VYaG55QU01Q2tlMkZtMDdjWm1BTW9iTVozb3pCWmdVY0M1cmVLK1NIN0xxWEtFMi9ETk5EenNlQVdUTFNJUml3dUkrVXdoMkFOM3ZNa2ZpVEFyZ0NzQTZhOS9GMXZuOW5wTjNvQjUrSE5KTDRRb3ZyaVB0THBKbUNYRk92VHdBcUFyNUZ0V3Zob0xCWmxLVWE5ODBVWFlHY0lqRUZLS3VNdkFPZG1FU3Y0M0VQM1RnRk9ZSkdYdWdpblVoZ3FSN2FFZzNmSjhERTZZTmhjS3l1MjVoNzhOa0dVcU00TzVZS3AyZ2w1Z2VRem52Q0pOcXpFUzlBOU40N2Q1Y0JtS1AzRlJCRzJrVkJZWGRqWWg4T0UwTk94a1pyWGEyVkFjN3EyaVNaVXhCUzRKc3BLUDY5aEthWk5TdDYzVkNEQldRTzJKTTNkcm1wM2RmOXRtdzQxKzZHRFJmRzEvdUZRbE1UOUtVY1IxSUpaTlVzV0pnTExFSnVEYkc5eFlranRZd3c3aWsvYVhtSThJTlZ5NWxQUVNiWmVFdFNWZThKZUdjcHVlRDRZVkVBSkwydEdGMDVuRXhUcnBMaTNkRWNKQUZ3TEFjWUJrQXRLeFBHSENxZGdrME9jUmJBanBmTU52aGJwaVl2OVQ5K2wrU0x6djhoNkRBS25lTXkxK1dNa3FiWDBuWVd6MndpUjZrM1I3NjBvait4UmVNQS9VYU1NMU5yYzgzcHFWWm9DbVhNMVl1ME13b0hPL3BZUy9FQ2gwMlNJNm13SkUvQ01nU1NDa0lWYjBySkxvSFRtRzFZU1dsZWZpRXh0MHZvYnFrU2dxSUh2c1h4OHBUVzY3TUcxR2dJVGxvb25BSWxFTE9KbUU4RjBJVnozOGd3T09DTVh5WE5nbkxKa3N3YmlYai9VMUUrbE1PTEpIemxrNThqNTk0RW1rNzRldDZiU3ZNdHRDMzdYMk95UnpTaUFWcEYraHkzcUhreWlBWU50V0E0OStieUx3WlJlMmxCM0o0TVEvdkROM09lUzg3R2NRYlI2S1drVXdrc3AwMkRTYmxrOVlrK0k0QWJXSytuc2dQSFVWVC9CNXhESVc4N3ZjY0Z4NVFlSU9ZYXhOWlJ2K1NDRkRRR1JpL0graU81enNINjc5UGRndUtYeE9yR3BJTmtYM0t5a09lMjR2SVlQMHRqN2FXTUpKamJ0OGtTNlIxenVBSHhsWGc1MHVHRWJkeVVyeHRwSldWWlY3cXNrRWdIbVNiMURTaDlCaFZkbmdsb25FVmFFWXJ6eExVZ2hIQkhKNmN4akwxazN0RE9VL1REbWhzTkVJbWhqNFg0SVFHSzhGb3E2b09PbnN3dUZiak04QkJObDhLVjF3b3RRRnNSNzE5SjcxNm5YL25LelFWbEo3VC9RVGZmeWQ3UE5oSnRxditEZ0RzT1lSdmhPQVFWanMwODVDdGhJTUp5ckpGc1ByQTJCSnZLWnpQKy8zMFJhVSt0UnI1VVc0bXZURGE4SFdmZG9DWnlWeUdNejFsNVFua1lEdklKcllCbWxWdE1MajhjTEREYTBXZGh5MXp4TEowTE1oSm1pbzZ1NHZ3S1ZoSnhoaUFma2kyWnJGL2IzL240U1ZuWnZzRUR6YS8xNk4xbEVWYlU2WkRJQ3ZSKzVlWncyaXliclZWQ0ZYbmx0VkxzeCtPVDJhV0tQNVFSbWxQZXBxN0ZhZVdwYUFyOU9HUC82WW0xR0xqL2VRSlJnUzFGd2ZNVTNzclNqQmE1SEhDZno3aXZXRG1RSWUvR2ZPRUk1ekpwandOamkwMDZhS0lsMHhWNHh3bHl2dDU5QmRrOEtnelRXek9kOWYzZXNqcjVaNmw5SWxiUFZQQnJtd3N3cmFHVEROYktNRDlDM1NkOGFxSVBHdVByUm5FaUJiR3E5K3JSbXF4Y0lkeVo0OFppQWwweWo0VmVrNllqb0pRQkdPSFk1V3ZmQXZmeitHbE9GZThSVm1UblUzVC9EYXFHNFM4MUpUbUZtM3BPYXlmNGoyNy9Md1dVTG91Zys1NThvRVhaVmJrNHdZb0QyWjV3T1JWMWlLcStobEh1blZSOE9lNk94Q3Zzd1NyT1QvVkNBaWdHeHg1MXJ0WEdpV3FOTVRlRldlQWFJYnpMUzhjUkhmTHZ6N3o4aVZCNktGUEJ3YWIydWhndEo3S2NUMkZQcVd3RnA3N2l2bTlMVE42b3lOdVc5MzJndFhoS1QrQmNCRUFLdWpkTWQ0dG1IOHZrWWRpYUU1bEFYdWJnSUV2N05mOWppc2s4N0VQZFNxU1ZOTmt6Y1BnREtpMGo4V2RPaXF6cmFyRFIwWVVCbzZtb3p4SVBrS0dLSFFLTkZLbzVkREJoYzc1c1RvbVhSZVhWV0M1eSt6NDVLc05nZ2IwWFlNTWhDb0RYWmVJdHl4dUxzTDhPZzVVd3JRRFNnSVlncTNFNHZKSTdKd2xKamRNKzNMUkE5aXZvVGFIMEhSczVlQ1V2Q2pIWXk2YmdMU3A5RW5PaUZLQmtqTU5uRFdxTDVDNlV3bDJVbEVqVmo0UkQwRlhvOVVPZkNidzIvVy9adWFROXhpK0lvSXZ4MWxpWFUzUWx3VVhJZXlsNmFmUDdDT044R05YUjhrY002dFpYMWFsNkt0ME9sU3ViNUorQ3lrdHgwUlRDSXVVbGR1NUNiY3RyY0RhZWwzQVhSV1hLRXl4VlpVK0NPNnRSUjViZUVlL0RMK00zYnlpN1Rrc04vTDNDN2plTjNDV09DcEF2UVp5bHZRQXdqMjNjd2RFT0dIMDh4RGxnbGNQem5wNEw2TVl1NkMxSjNWd3FRM3lYSjRxYVBKdkh1SXlXSU9vQVFuWVRyVTNPeTdLbUNKQW9vWXR6REc1NHNXckF2OC95NEdHd1ZHWjVTVndPWVAzenFGRkQ1eFBNUC9DN1RYTTdQOG1GNk91c0wwbm93VmNnbktGTEFwTVB3aDJOUkJoOU9RczFLSDFnd3hTaEF6KzltNGw5U1hFc3BUT0pFaWp1WkVSL0hVMDI0c1ZRTFhyaVlqY0ttYVQzRWFxVG5rOXZnR2l6UFB2MmNmWk5aVkpINXRhYlpCb0lyMHptdGxLWUoyZFZ5c3V5OVJFbVIwdUlZR201allkeGZEc3RrQ0c3eXZENkZxL2IvZ3ZQR25WOC9WcHl1VDY1STdGTlovckRpYjVIRzhSZ2w3RkRJUzdqRWtqTVZqcHB1dXdMSEMzcTc3N0JDNStpYko3RC8zN0lVNnlGMHRhKzhjMFZmTGFuU2lySVk2Vys0UGpJR05Uak96N21CaU0ya0RrL080V0tKaXZ2OWN1cDVEdFVlMEYyUGR6NlN2c1RHMSs0cUp1SjNsdlRWelgzcTVjYVBMSTNFUG92T1hudGh2bXZzZjFMdzNxOUNYNDRTLzllSnY1Wk5QdFcrbGtNRFl0K2tYby9jbkh0c3ZzZlNiRzE1SDNjTFFmbnNBclRyQTlyZFhYNis5a3NZc0dKRXQ5S1lhQ01GQzExK0kyZU9WOGJmcWVvay9tZ3VtY0VQUzRuTEcvUmVJVGFLYzcwNDQrbWlaTWorNnZJMm9saFh4cWRKNVBmaU9DR0pHb1EvWFRHcjNSbG9oZGljVUVBTjJObFNISk9aTS9KNHo3NjBLbW1WK25SdkJwdkpuWWNueE41OWNhd2xJR2dhOVcrbGtuMEwySnRJaVcvajVTQkM5TDRmTXRBTmRUdjQ4d2dXT3FyZXl5SlF6aE0wZHUza1R3cDNkeWVQVXh6UllvOEE5cEpERXBFeVVEK3lCeDBnMUtQbmlad2pHTm5sL2dBRFM4ckprYnoxVVFhQXJXR2Fnb0lGWkE3aEZJbW5ialJCRVRqbWVVYmFYWTVKVlYyS1RQend0aHBacmtuQjR1cDVQR3NMZzEweVd5Z3pKQVlFZXVQeEFZR2xneW5aVTNWU1hlUmF6Zmk5UkNZWFJnZDROa0dmM1NQWHp3bSt3ZnVxSmdyWGJITmdUd2VCTXI5eW13WkFDR2sxOENJT1ZGNGlTTmxGZXFoVXNpcVg4NEc1UUdSZVdJVGpCWTUxa0NZaFRaTDVENHRkVm13aU0rckxEYUQrVlBMc3RoS0doNFp4bTg5cmdYdzVsZmc3TmcvSzhlSEN6azNtNWduZVAwUXB4UC90MXZXK1pSdjVmRHBvUWdzbnF5Q0swbUdVbG9ncUsvZzZVSzAzWkVPT2JnZVF3M21jMTlLWnN6SEhVWStmZGRZdWs3WU1OcVM5Sk02N0VyT25EQTJtaENWQkJCa0ljenFydGRzcU8xODkzWkJ2ZTZhSzFOb1p0blhPdFJXa1gySWFRT1hETTdLU0oybS9wVk1pVG9kNFdiTUtzY1FNZWFlb3NxTmRLZU54eFRGejhOTkFvNXBkaUtINWFybVZVZ1dnV3VBcWNDZnRtSHE4VGR2VTNXSmRxODR1UmRKSE1VN2ZtRUVyMnJXdE1QTGZUeGVsb081cExnOWdsMHJiY0xxL3dtVkpkN2ljYTFHMjBNS0FWQ1hvL1d1S1dXQU54YlZodFRlbGdZLzdsUnRSWHRYY0NqWU1ubXpMUFY3MEtnbCtTd1RjK0drNy8vMG9wSmVPeSs1SHljaXU1WGFmYTNrVVRvUkJSYjNEM2gvTjRxcUVsc1UvQXJ4UENMenpERDV4QmJYQTNteGpvNjRJbEpRUE1GMHlzNTZiTFpvYWxkaVE0SHBGODVWT1YwNW83RWtuWXpKdlpJSXFEaVp0M1dDaFV3MngrZzZCVWQ3cEpFSGxkdDJ2eXJ3di9tcnYxb3VCcTMzMWU0LzhjdFp2UjhKL0NiZHNZaEYyVkZSRlExUW1zTUhBbVpQcWZrMGJZL0FnekJNY3ZoRk83cDVMWk1KKzliQVFRem5RaW96QkxPb0ZwQUlRSkJEY1JVSmlMSmM5TWM0SU5Bb0M3Q0Z5US9EMFFlK3U1bVVhaHhPbEoxOXpsOTRwMitDMWF0QTc0ZjdHMFpySzlaTXJNelVjSXFoU3pkMmsyR2l6R1R3d09UdnNIUVFKbHVEVFBVQUQxOUxheGk4MFkxcEJmd3M1ejk5d3dIQ2EyOVl0MEZHYjlJN2VSYlgwVC9VKzRXTDhnZWZ3K1E1TzZkc0xpTEZYbkpwNFRZQzJrM1BaUEJDb0VhTmJCVzhOemQxcHl0TVg4dElRTk5Ba0lIQ3hJTjUxQzB6SzVhc0NNc2FWTzU2ZmtCTEI0Ujh3NjYyQUwzcnJuWFY0eGZ1c0d2L1JJZktzdkxOTFk0YVlFRVZOVHZaRnpoUXdNNXJwKzNoNkNCb01TazhZTm1lV3NxaU5DUE1GQVl6TU1sQnFPSHpBQlBwYzIzU1NNL21RaGFRaFZ3MG1XZ1hpejVBVUhhU3BNY1ZCVWtGQUtiQ1ZSbmIxTzF5NGhYeE9JSHl2Tmg4RXJ4ZDArMU9lS3N1aXduc0ZRQkhnaThtNmlVWnFpTGZSWENadXo2T1RLN00rNENtUG9TcmIrbDN6SmlPM1hzamJab3dRZUg0eDJidVNpd1daNjg3WnE4Umt3dFlRVVFlcGwwTXVBN0xlZThQc1hXc3pINWVVYTFyeVkxVGUwby9EWnI4V05xdEZyOVpuWmczdzhJVjNGeWIreHI2ZHlmNDRVQjhDZGhwV1QyRFREa3o3cDNIaVlMb3RpTEJ4S1pFRHNCWVM3TW5tSWY1dm85TUtpVVdwVGpkZmkyM1Q5MWVNak8yTXp2WjRFeFZGQWxVbC8xakVNaVJsaHdUQU1Ib1ZYWWdvM3RWZDFqVlptZXAvU2J6MmV6U2lITC9WK0s5Tkl1VExUYnhvZzlpRldTVDZiOUpQM21XLzhmRUd4ZEsrUWFlWUxGd0NXZFVEZzhtNDJPNVFBQ3JxWDBUaEVQKy90TlFHeWZrMlV0NzBjOHFVMlU4VEhJTlhrS0lOWlRCSlo3bHRhcUJkaWZwK1pBK0F1TEpCcjFNdzBVaW53U0VXYXcwRjZNL2k5MEVoSU8wMktXVG5sRDI0cW1HQjdmUS9jVW9DcVRSUkJUSHlGWEZ6RXhFWHpJOU5ldEQwZ21rVkdSY2xLK0Fub2JGZGloWkFYckE3QTRrR3lrNmdTa1FwUm5Iak9kc01aZ3l0MExudWlHazhhdEozcnFWTHRncXJTQWVLT1JSL2dXSTFDdnBqMTViQjRUM1BrNHkxWURlUk9hUjRsYWcwdVpCRGtScHF0MkZNQmEyem8wekxEdDhzSUJ0TmNnMXFQUXR5bU93MGNlRE9MaWsxbndtWE56T1gzTGZpdmxZbGhLZEFRS3VUOVhGNStST0VMOTBaNWVxOUhqbXhyWHNGeDlvOVIxN0xhdDNUb1d4eUhoZWJmY25xb3htRGlCWkFjYVE3aUYza05WTVZrUlNkNHZGZWpTenZOcUM4ZWtKL1Y0cnZJMmlQd2xSYjVWNGRyUmFrb01RVFJjSTRmOE9Yc1J1cnErdE5PRFJrQzUzbWRFU3p3ckJ5aGF1WmFmSFdQSURxWlN3cTBsUXVkUWZEUDFmU0VqV3lFMDFwN296dzZYelNESWRkNitnM2lOaUd2RnZYdlozR2pXNUF0V0swUHBnN0lMaUU0SHRpSVp4ejFUZFR5bklpZGhJdlpCSGdyOTF5ZnF2SmIwSzM1bklXdmNmVlpVOW1iV3I2TWRSM0F6TTd0Z21TT0JGR2tMZ2Q1TDZNeVFMY0pMajc5MG1mS3VsaytqR3IzZEVNLzUxQVZTSk1IMUZlTUJjY2pRcXQrZWt3Z1NyQTh1L1RFVXJNUlR3TGh1dkJlbXJaN1FuVDlidnpZTlB3akVUYWxmS0RPbEVwMlFoWHAyQ3M3N29zSGlKU3BsVGJCbzg2dkdkUENHdGlMcXhEbEN2YUYwUWNOUjBObCtvUzNmVFBRT2MzbGJXcDcwYkRlUE5WNUVMa2tKSHFhTndqNm1EcnZqWnZIL3VtTStHL3JLbUxpdXFYSXgxTFNuZUpRTVhSQmsrOG5qalVxcS85VTgyTlBJamovRC9xRTJ5WE5Hd3VzWHFYVllZKzZNWmNyVDBId2ZHVHdPWXJZdW9SZk95bCt0b2NoMHJ1dUFBT1RFclh5VWpsYWF6UkY1VXJnMWpiaEhwRW9ldXJMUTE3MTJVTklrdVFhQkN1WmNrRkUycUNsbXhLZ04yUGNQU2szQnB5ZXJ0dVJWVFNrYWhSc1RoVkJsdlN1ODdKS2xFODVoV0xvRjI0WHNWWTFhTGh6ZGhJbnNWeWtxbm1QNCtGazVLZmZuTUtZeStMZFU2MFlmejd0djNqQXUxcDdXS1c4OXhvb2lqbFdKQmhwWDE4STByMEFiUGZlbWJPSHpkNXRjbEw3eVJ5VWhFM2xkSEw2TitUMXVweEQ3Z2dJSFJBQjA0OHZ1eXVKMGFUVHU4ZXM1TGdHZkNNRW5SS2c0dU4zSjc3OE03S3hJM2s3d0F1WmJVdUxBdi9sNjZtcHROek1yQ2J1ZnV2dlFOR3RpZnFNWVNVcHowUmhJOEg2cGZEa3lFUUtVbURTL1RSNzEwTDhSZ25hNFAyTGRKTW0xYldrNHM1VmdxMGIyK3ZmUzNCc205N3ZkS3VGZk5LTEcyTkIxbnJQZ2ZrMEtpSloxTGYxSXlsQWhxQVFBekpDS2hPOWpYaEpYaUtVd0tGck8zWlc5S3hhMXdKS0Nhb0NBRUZjaEtEUTF3TXV0R2VSbkRCRm9tY2RaSVo4blJsK3pORG1sMUxhMUpvTTFEQXF0cGVzaVluS2NURTc2THh6ZXV5MUxBVFFDV3ZVRG40ZjUwRnFneDlMVVRXOUVndXVmNFdpUDUvVXh6d3VEREpwaUVTSEVqdjZoOWZ4RVptcnJTQlpiZ1NTQ2U5ZFBGR01lQk9wNTZuenlnbGVVZ2dEVENpZ2VHcjNPRmg4WmtVOHBjSFBxMGgzWkd5Y3lYekpFdnlhU2RUZm1tdFVyNTFSQWticXJYWk1weHlnbnMrZTlTNUZnK0xjaVhFYjhUcVBmNmFyM1F1d2lLSXp3NTNtLzhST3JleXh2L1lXbW9RL09PWmdBV3A1ZG9vUlVkcUdSU0I1WUVyUkFYMUdDcVNGRUtQeEZwV2FnbkljdGl1SmtmdjFqTHVXZGliZ2orZjY4V3kxeWdWNUdFQUFBQUFFbEZUa1N1UW1DQ1wiXG5cbnZhciBPUFRJT05fU1NBT19TQ0FMRSA9IFwicmVuZGVyZXItc3Nhby1zY2FsZVwiO1xudmFyIE9QVElPTl9TU0FPX0lOVEVOU0lUWSA9IFwicmVuZGVyZXItc3Nhby1pbnRlbnNpdHlcIjtcbnZhciBPUFRJT05fU1NBT19CSUFTID0gXCJyZW5kZXJlci1zc2FvLWJpYXNcIjtcbnZhciBPUFRJT05fU1NBT19SQURJVVMgPSBcInJlbmRlcmVyLXNzYW8tcmFkaXVzXCI7XG52YXIgRkxBR1MgPSB7fTtcbkZMQUdTW09QVElPTl9TU0FPX1NDQUxFXSA9IHtkZWZhdWx0VmFsdWU6IDF9O1xuRkxBR1NbT1BUSU9OX1NTQU9fSU5URU5TSVRZXSA9IHtkZWZhdWx0VmFsdWU6IDV9O1xuRkxBR1NbT1BUSU9OX1NTQU9fQklBU10gPSB7ZGVmYXVsdFZhbHVlOiAwLjJ9O1xuRkxBR1NbT1BUSU9OX1NTQU9fUkFESVVTXSA9IHtkZWZhdWx0VmFsdWU6IDF9O1xuZm9yICh2YXIgZmxhZyBpbiBGTEFHUykge1xuICAgIE9wdGlvbnMucmVnaXN0ZXIoZmxhZywgRkxBR1NbZmxhZ10uZGVmYXVsdFZhbHVlKTtcbn1cblxudmFyIFNTQU9QYXNzID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpIHtcbiAgICBCYXNlUmVuZGVyUGFzcy5jYWxsKHRoaXMsIHJlbmRlckludGVyZmFjZSwgb3V0cHV0LCBvcHQpO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dDtcbiAgICB0aGlzLl9wcm9ncmFtID0gY29udGV4dC5wcm9ncmFtRmFjdG9yeS5nZXRQcm9ncmFtQnlOYW1lKFwic3Nhb1wiKTtcbiAgICB0aGlzLnJhbmRvbVZlY3RvclRleHR1cmUgPSB0aGlzLmNyZWF0ZVJhbmRvbVZlY3RvclRleHR1cmUoY29udGV4dCk7XG4gICAgdGhpcy5sb2FkUmFuZG9tVmVjdG9ySW1hZ2UoKTtcbiAgICB0aGlzLl9zY3JlZW5RdWFkID0gbmV3IEZ1bGxzY3JlZW5RdWFkKGNvbnRleHQpO1xuICAgIHRoaXMuX3VuaWZvcm1zRGlydHkgPSB0cnVlO1xuLy9cdFx0aWYgKCF0aGlzLmlucHV0cy5wb3NpdGlvbkJ1ZmZlcilcbi8vXHRcdFx0dGhpcy5fcG9zaXRpb25QYXNzID0gdGhpcy5jcmVhdGVWZXJ0ZXhBdHRyaWJ1dGVQYXNzKFwicmVuZGVyLXBvc2l0aW9uXCIpO1xuLy9cdFx0aWYgKCF0aGlzLmlucHV0cy5ub3JtYWxCdWZmZXIpXG4vL1x0XHRcdHRoaXMuX25vcm1hbFBhc3MgPSB0aGlzLmNyZWF0ZVZlcnRleEF0dHJpYnV0ZVBhc3MoXCJyZW5kZXItbm9ybWFsXCIpO1xufTtcblxuWE1MM0QuY3JlYXRlQ2xhc3MoU1NBT1Bhc3MsIEJhc2VSZW5kZXJQYXNzKTtcblxuWE1MM0QuZXh0ZW5kKFNTQU9QYXNzLnByb3RvdHlwZSwge1xuICAgIGNyZWF0ZVJhbmRvbVZlY3RvclRleHR1cmU6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHZhciBnbCA9IGNvbnRleHQuZ2w7XG4gICAgICAgIHZhciB0ZXggPSBjb250ZXh0LmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgdGV4LmNyZWF0ZVRleDJERnJvbURhdGEoZ2wuUkdCQSwgNjQsIDY0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCB7XG4gICAgICAgICAgICB3cmFwUzogZ2wuUkVQRUFULCB3cmFwVDogZ2wuUkVQRUFULCBtaW5GaWx0ZXI6IGdsLkxJTkVBUiwgbWFnRmlsdGVyOiBnbC5MSU5FQVJcbiAgICAgICAgfSk7XG4gICAgICAgIHRleC5pc1RleHR1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGV4O1xuICAgIH0sXG5cbiAgICBsb2FkUmFuZG9tVmVjdG9ySW1hZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBpbWcuc3JjID0gYmFzZTY0UmFuZG9tTm9ybWFscztcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcbiAgICAgICAgdmFyIHRleGhhbmRsZSA9IHRoaXMucmFuZG9tVmVjdG9yVGV4dHVyZS5oYW5kbGU7XG5cbiAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleGhhbmRsZSk7XG4gICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGltZyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY3JlYXRlVmVydGV4QXR0cmlidXRlUGFzczogZnVuY3Rpb24gKHByb2dyYW1OYW1lKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dDtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBHTFJlbmRlclRhcmdldChjb250ZXh0LCB7XG4gICAgICAgICAgICB3aWR0aDogY29udGV4dC5jYW52YXNUYXJnZXQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbnRleHQuY2FudmFzVGFyZ2V0LmhlaWdodCxcbiAgICAgICAgICAgIGNvbG9yRm9ybWF0OiBjb250ZXh0LmdsLlJHQkEsXG4gICAgICAgICAgICBjb2xvclR5cGU6IGNvbnRleHQuZ2wuRkxPQVQsXG4gICAgICAgICAgICBkZXB0aEZvcm1hdDogY29udGV4dC5nbC5ERVBUSF9DT01QT05FTlQxNixcbiAgICAgICAgICAgIHN0ZW5jaWxGb3JtYXQ6IG51bGwsXG4gICAgICAgICAgICBkZXB0aEFzUmVuZGVyYnVmZmVyOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3IFZlcnRleEF0dHJpYnV0ZVBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIGJ1ZmZlciwge1xuICAgICAgICAgICAgcHJvZ3JhbU5hbWU6IHByb2dyYW1OYW1lXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICByZW5kZXI6IChmdW5jdGlvbiAoKSB7XG4vL1x0XHRcdGlmICh0aGlzLl9wb3NpdGlvblBhc3MpXG4vL1x0XHRcdFx0dGhpcy5fcG9zaXRpb25QYXNzLnNldFByb2Nlc3NlZChmYWxzZSk7XG5cbiAgICAgICAgdmFyIHZpZXdNYXRyaXggPSBYTUwzRC5tYXRoLm1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciB1bmlmb3JtTmFtZXMgPSBbXCJ2aWV3TWF0cml4XCJdO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKHNjZW5lKSB7XG4gICAgICAgICAgICB2YXIgZ2wgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0LmdsO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMub3V0cHV0O1xuXG4gICAgICAgICAgICB0YXJnZXQuYmluZCgpO1xuICAgICAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgZ2wuZGlzYWJsZShnbC5ERVBUSF9URVNUKTtcblxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS5iaW5kKCk7XG4gICAgICAgICAgICB0aGlzLl9zZXROb25Wb2xhdGlsZVNoYWRlclVuaWZvcm1zKCk7XG5cbiAgICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xuICAgICAgICAgICAgc2NlbmUuZ2V0QWN0aXZlVmlldygpLmdldFdvcmxkVG9WaWV3TWF0cml4KHZpZXdNYXRyaXgpO1xuICAgICAgICAgICAgdW5pZm9ybXNbXCJ2aWV3TWF0cml4XCJdID0gdmlld01hdHJpeDtcbiAgICAgICAgICAgIHRoaXMuX3Byb2dyYW0uc2V0U3lzdGVtVW5pZm9ybVZhcmlhYmxlcyh1bmlmb3JtTmFtZXMsIHVuaWZvcm1zKTtcbiAgICAgICAgICAgIHRoaXMuX3NjcmVlblF1YWQuZHJhdyh0aGlzLl9wcm9ncmFtKTtcblxuICAgICAgICAgICAgdGhpcy5fcHJvZ3JhbS51bmJpbmQoKTtcbiAgICAgICAgICAgIHRhcmdldC51bmJpbmQoKTtcbiAgICAgICAgfVxuICAgIH0oKSksXG5cbiAgICBfc2V0Tm9uVm9sYXRpbGVTaGFkZXJVbmlmb3JtczogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHVuaWZvcm1OYW1lcyA9IFtcImNhbnZhc1NpemVcIiwgXCJzUG9zaXRpb25UZXhcIiwgXCJzTm9ybWFsVGV4XCIsIFwic1JhbmRvbU5vcm1hbHNcIiwgXCJ1UmFuZG9tVGV4U2l6ZVwiLCBcInVTY2FsZVwiLCBcInVCaWFzXCIsIFwidUludGVuc2l0eVwiLCBcInVTYW1wbGVSYWRpdXNcIiwgXCJ1Q29uc3RWZWN0b3JzXCJdO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3VuaWZvcm1zRGlydHkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgdW5pZm9ybXMgPSB7fTtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5fcHJvZ3JhbTtcbiAgICAgICAgICAgIHByb2dyYW0uYmluZCgpO1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMub3V0cHV0O1xuXG4gICAgICAgICAgICB1bmlmb3Jtc1tcImNhbnZhc1NpemVcIl0gPSBbdGFyZ2V0LndpZHRoLCB0YXJnZXQuaGVpZ2h0XTtcbiAgICAgICAgICAgIHVuaWZvcm1zW1wic1Bvc2l0aW9uVGV4XCJdID0gW3RoaXMuaW5wdXRzLnBvc2l0aW9uQnVmZmVyLmNvbG9yVGFyZ2V0LmhhbmRsZV07XG4gICAgICAgICAgICB1bmlmb3Jtc1tcInNOb3JtYWxUZXhcIl0gPSBbdGhpcy5pbnB1dHMubm9ybWFsQnVmZmVyLmNvbG9yVGFyZ2V0LmhhbmRsZV07XG4gICAgICAgICAgICB1bmlmb3Jtc1tcInNSYW5kb21Ob3JtYWxzXCJdID0gW3RoaXMucmFuZG9tVmVjdG9yVGV4dHVyZV07XG4gICAgICAgICAgICB1bmlmb3Jtc1tcInVSYW5kb21UZXhTaXplXCJdID0gWzY0LCA2NF07XG4gICAgICAgICAgICB1bmlmb3Jtc1tcInVTY2FsZVwiXSA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX1NTQU9fU0NBTEUpO1xuICAgICAgICAgICAgdW5pZm9ybXNbXCJ1Qmlhc1wiXSA9IE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX1NTQU9fQklBUyk7XG4gICAgICAgICAgICB1bmlmb3Jtc1tcInVJbnRlbnNpdHlcIl0gPSBPcHRpb25zLmdldFZhbHVlKE9QVElPTl9TU0FPX0lOVEVOU0lUWSk7XG4gICAgICAgICAgICB1bmlmb3Jtc1tcInVTYW1wbGVSYWRpdXNcIl0gPSBPcHRpb25zLmdldFZhbHVlKE9QVElPTl9TU0FPX1JBRElVUyk7XG4gICAgICAgICAgICB1bmlmb3Jtc1tcInVDb25zdFZlY3RvcnNcIl0gPSBbMSwgMCwgLTEsIDAsIDAsIDEsIDAsIC0xXTtcblxuICAgICAgICAgICAgcHJvZ3JhbS5zZXRTeXN0ZW1Vbmlmb3JtVmFyaWFibGVzKHVuaWZvcm1OYW1lcywgdW5pZm9ybXMpO1xuICAgICAgICAgICAgcHJvZ3JhbS51bmJpbmQoKTtcblxuLy8gICAgICAgICAgICAgICAgdGhpcy5fdW5pZm9ybXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfSkoKVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU1NBT1Bhc3M7XG5cbiIsInZhciBTY2VuZVJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9zY2VuZS1wYXNzLmpzXCIpO1xuXG52YXIgVmVydGV4QXR0cmlidXRlUGFzcyA9IGZ1bmN0aW9uIChyZW5kZXJJbnRlcmZhY2UsIG91dHB1dCwgb3B0KSB7XG4gICAgU2NlbmVSZW5kZXJQYXNzLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlLCBvdXRwdXQsIG9wdCk7XG4gICAgdGhpcy5fcHJvZ3JhbSA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQucHJvZ3JhbUZhY3RvcnkuZ2V0UHJvZ3JhbUJ5TmFtZShvcHQucHJvZ3JhbU5hbWUpO1xufTtcblxuWE1MM0QuY3JlYXRlQ2xhc3MoVmVydGV4QXR0cmlidXRlUGFzcywgU2NlbmVSZW5kZXJQYXNzKTtcblxuWE1MM0QuZXh0ZW5kKFZlcnRleEF0dHJpYnV0ZVBhc3MucHJvdG90eXBlLCB7XG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuY29udGV4dC5nbDtcbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMub3V0cHV0O1xuICAgICAgICB2YXIgd2lkdGggPSB0YXJnZXQuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRhcmdldC5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIGFzcGVjdCA9IHdpZHRoIC8gaGVpZ2h0O1xuXG4gICAgICAgIHRhcmdldC5iaW5kKCk7XG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUKTtcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuXG4gICAgICAgIHNjZW5lLnVwZGF0ZVJlYWR5T2JqZWN0c0Zyb21BY3RpdmVWaWV3KGFzcGVjdCk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJPYmplY3RzVG9BY3RpdmVCdWZmZXIoc2NlbmUucmVhZHksIHNjZW5lLCB0YXJnZXQsIHNjZW5lLnN5c3RlbVVuaWZvcm1zLCBbXSwge1xuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgcHJvZ3JhbTogdGhpcy5fcHJvZ3JhbVxuICAgICAgICB9KTtcblxuICAgICAgICB0YXJnZXQudW5iaW5kKCk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gVmVydGV4QXR0cmlidXRlUGFzcztcblxuIiwidmFyIEJhc2VSZW5kZXJUcmVlID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSkge1xuICAgIHRoaXMubWFpblJlbmRlclBhc3MgPSBudWxsO1xuICAgIHRoaXMucmVuZGVySW50ZXJmYWNlID0gcmVuZGVySW50ZXJmYWNlO1xufTtcblxuWE1MM0QuZXh0ZW5kKEJhc2VSZW5kZXJUcmVlLnByb3RvdHlwZSwge1xuICAgIHJlbmRlcjogZnVuY3Rpb24gKHNjZW5lKSB7XG4gICAgICAgIHRoaXMubWFpblJlbmRlclBhc3MucmVuZGVyVHJlZShzY2VuZSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmFzZVJlbmRlclRyZWU7XG5cbiIsInZhciBCYXNlUmVuZGVyVHJlZSA9IHJlcXVpcmUoXCIuL2Jhc2UuanNcIik7XG52YXIgR0xSZW5kZXJUYXJnZXQgPSByZXF1aXJlKFwiLi4vYmFzZS9yZW5kZXJ0YXJnZXQuanNcIikuR0xSZW5kZXJUYXJnZXQ7XG52YXIgR0xDdWJlTWFwUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZShcIi4uL2Jhc2UvcmVuZGVydGFyZ2V0LmpzXCIpLkdMQ3ViZU1hcFJlbmRlclRhcmdldDtcbnZhciBGb3J3YXJkUmVuZGVyUGFzcyA9IHJlcXVpcmUoXCIuLi9yZW5kZXItcGFzc2VzL2ZvcndhcmQuanNcIik7XG52YXIgQm94Qmx1clBhc3M9IHJlcXVpcmUoXCIuLi9yZW5kZXItcGFzc2VzL2JveGJsdXIuanNcIik7XG52YXIgTGlnaHRQYXNzPSByZXF1aXJlKFwiLi4vcmVuZGVyLXBhc3Nlcy9saWdodC1wYXNzLmpzXCIpO1xudmFyIFBvaW50TGlnaHRQYXNzPSByZXF1aXJlKFwiLi4vcmVuZGVyLXBhc3Nlcy9wb2ludGxpZ2h0LXBhc3MuanNcIik7XG52YXIgVmVydGV4QXR0cmlidXRlUGFzcyA9IHJlcXVpcmUoXCIuLi9yZW5kZXItcGFzc2VzL3ZlcnRleGF0dHJpYnV0ZS1wYXNzLmpzXCIpO1xudmFyIFNTQU9QYXNzID0gcmVxdWlyZShcIi4uL3JlbmRlci1wYXNzZXMvc3Nhby1wYXNzLmpzXCIpO1xudmFyIEVWRU5UX1RZUEUgPSByZXF1aXJlKFwiLi4vLi4vcmVuZGVyZXIvc2NlbmUvY29uc3RhbnRzLmpzXCIpLkVWRU5UX1RZUEU7XG52YXIgTWF0ZXJpYWxFdmVudHMgPSByZXF1aXJlKFwiLi4vbWF0ZXJpYWxzL2V2ZW50cy5qc1wiKTtcbi8qKlxuICpcbiAqIEBwYXJhbSB7R0xSZW5kZXJJbnRlcmZhY2V9IHJlbmRlckludGVyZmFjZVxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVTU0FPXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEZvcndhcmRSZW5kZXJUcmVlID0gZnVuY3Rpb24gKHJlbmRlckludGVyZmFjZSwgZW5hYmxlU1NBTykge1xuICAgIEJhc2VSZW5kZXJUcmVlLmNhbGwodGhpcywgcmVuZGVySW50ZXJmYWNlKTtcbiAgICB2YXIgc2NlbmUgPSByZW5kZXJJbnRlcmZhY2Uuc2NlbmU7XG4gICAgdGhpcy5fZW5hYmxlU1NBTyA9IGVuYWJsZVNTQU87XG4gICAgdGhpcy5tYWluUGFzcyA9IG51bGw7XG4gICAgdGhpcy5jcmVhdGVNYWluUGFzcygpO1xufTtcblxuWE1MM0QuY3JlYXRlQ2xhc3MoRm9yd2FyZFJlbmRlclRyZWUsIEJhc2VSZW5kZXJUcmVlKTtcblxuWE1MM0QuZXh0ZW5kKEZvcndhcmRSZW5kZXJUcmVlLnByb3RvdHlwZSwge1xuXG4gICAgY3JlYXRlTWFpblBhc3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dHB1dFRhcmdldCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQuY2FudmFzVGFyZ2V0O1xuICAgICAgICBpZiAodGhpcy5fZW5hYmxlU1NBTykge1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9uUGFzcyA9IHRoaXMuY3JlYXRlVmVydGV4QXR0cmlidXRlUGFzcyhcInJlbmRlci1wb3NpdGlvblwiKTtcbiAgICAgICAgICAgIHZhciBub3JtYWxQYXNzID0gdGhpcy5jcmVhdGVWZXJ0ZXhBdHRyaWJ1dGVQYXNzKFwicmVuZGVyLW5vcm1hbFwiKTtcbiAgICAgICAgICAgIHZhciBzc2FvUGFzcyA9IHRoaXMuY3JlYXRlU1NBT1Bhc3MocG9zaXRpb25QYXNzLm91dHB1dCwgbm9ybWFsUGFzcy5vdXRwdXQpO1xuICAgICAgICAgICAgc3Nhb1Bhc3MuYWRkUHJlUGFzcyhwb3NpdGlvblBhc3MpO1xuICAgICAgICAgICAgc3Nhb1Bhc3MuYWRkUHJlUGFzcyhub3JtYWxQYXNzKTtcbiAgICAgICAgICAgIHZhciBibHVyUGFzcyA9IHRoaXMuY3JlYXRlQmx1clBhc3Moc3Nhb1Bhc3Mub3V0cHV0KTtcbiAgICAgICAgICAgIGJsdXJQYXNzLmFkZFByZVBhc3Moc3Nhb1Bhc3MpO1xuICAgICAgICAgICAgdGhpcy5fYmx1clBhc3MgPSBibHVyUGFzcztcbiAgICAgICAgICAgIHRoaXMuX3NzYW9QYXNzID0gc3Nhb1Bhc3M7XG4gICAgICAgICAgICB0aGlzLl9wb3NpdGlvblBhc3MgPSBwb3NpdGlvblBhc3M7XG4gICAgICAgICAgICB0aGlzLl9ub3JtYWxQYXNzID0gbm9ybWFsUGFzcztcbiAgICAgICAgICAgIHRoaXMubWFpblBhc3MgPSBuZXcgRm9yd2FyZFJlbmRlclBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIG91dHB1dFRhcmdldCwge1xuICAgICAgICAgICAgICAgIGlucHV0czoge1xuICAgICAgICAgICAgICAgICAgICBzc2FvTWFwOiBibHVyUGFzcy5vdXRwdXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMubWFpblBhc3MuYWRkUHJlUGFzcyhibHVyUGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1haW5QYXNzID0gbmV3IEZvcndhcmRSZW5kZXJQYXNzKHRoaXMucmVuZGVySW50ZXJmYWNlLCBvdXRwdXRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblJlbmRlclBhc3MgPSB0aGlzLm1haW5QYXNzO1xuICAgIH0sXG5cbiAgICBjcmVhdGVWZXJ0ZXhBdHRyaWJ1dGVQYXNzOiBmdW5jdGlvbiAocHJvZ3JhbU5hbWUpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLnJlbmRlckludGVyZmFjZS5jb250ZXh0O1xuICAgICAgICB2YXIgYnVmZmVyID0gbmV3IEdMUmVuZGVyVGFyZ2V0KGNvbnRleHQsIHtcbiAgICAgICAgICAgIHdpZHRoOiBjb250ZXh0LmNhbnZhc1RhcmdldC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29udGV4dC5jYW52YXNUYXJnZXQuaGVpZ2h0LFxuICAgICAgICAgICAgY29sb3JGb3JtYXQ6IGNvbnRleHQuZ2wuUkdCQSxcbiAgICAgICAgICAgIGNvbG9yVHlwZTogY29udGV4dC5nbC5GTE9BVCxcbiAgICAgICAgICAgIGRlcHRoRm9ybWF0OiBjb250ZXh0LmdsLkRFUFRIX0NPTVBPTkVOVDE2LFxuICAgICAgICAgICAgc3RlbmNpbEZvcm1hdDogbnVsbCxcbiAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgVmVydGV4QXR0cmlidXRlUGFzcyh0aGlzLnJlbmRlckludGVyZmFjZSwgYnVmZmVyLCB7XG4gICAgICAgICAgICBwcm9ncmFtTmFtZTogcHJvZ3JhbU5hbWVcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGNyZWF0ZVNTQU9QYXNzOiBmdW5jdGlvbiAocG9zaXRpb25CdWZmZXIsIG5vcm1hbEJ1ZmZlcikge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQ7XG4gICAgICAgIHZhciBzc2FvQnVmZmVyID0gbmV3IEdMUmVuZGVyVGFyZ2V0KGNvbnRleHQsIHtcbiAgICAgICAgICAgIHdpZHRoOiBjb250ZXh0LmNhbnZhc1RhcmdldC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29udGV4dC5jYW52YXNUYXJnZXQuaGVpZ2h0LFxuICAgICAgICAgICAgY29sb3JGb3JtYXQ6IGNvbnRleHQuZ2wuUkdCQSxcbiAgICAgICAgICAgIGRlcHRoRm9ybWF0OiBjb250ZXh0LmdsLkRFUFRIX0NPTVBPTkVOVDE2LFxuICAgICAgICAgICAgc3RlbmNpbEZvcm1hdDogbnVsbCxcbiAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBTU0FPUGFzcyh0aGlzLnJlbmRlckludGVyZmFjZSwgc3Nhb0J1ZmZlciwge1xuICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25CdWZmZXI6IHBvc2l0aW9uQnVmZmVyLCBub3JtYWxCdWZmZXI6IG5vcm1hbEJ1ZmZlclxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgY3JlYXRlQmx1clBhc3M6IGZ1bmN0aW9uIChpbnB1dEJ1ZmZlcikge1xuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMucmVuZGVySW50ZXJmYWNlLmNvbnRleHQ7XG4gICAgICAgIHZhciBibHVyQnVmZmVyID0gbmV3IEdMUmVuZGVyVGFyZ2V0KGNvbnRleHQsIHtcbiAgICAgICAgICAgIHdpZHRoOiBpbnB1dEJ1ZmZlci53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaW5wdXRCdWZmZXIuaGVpZ2h0LFxuICAgICAgICAgICAgY29sb3JGb3JtYXQ6IGNvbnRleHQuZ2wuUkdCQSxcbiAgICAgICAgICAgIGRlcHRoRm9ybWF0OiBjb250ZXh0LmdsLkRFUFRIX0NPTVBPTkVOVDE2LFxuICAgICAgICAgICAgc3RlbmNpbEZvcm1hdDogbnVsbCxcbiAgICAgICAgICAgIGRlcHRoQXNSZW5kZXJidWZmZXI6IHRydWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBCb3hCbHVyUGFzcyh0aGlzLnJlbmRlckludGVyZmFjZSwgYmx1ckJ1ZmZlciwge1xuICAgICAgICAgICAgaW5wdXRzOiB7XG4gICAgICAgICAgICAgICAgYnVmZmVyOiBpbnB1dEJ1ZmZlclxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VuYWJsZVNTQU8pIHtcbiAgICAgICAgICAgIHRoaXMuX3Bvc2l0aW9uUGFzcy5zZXRQcm9jZXNzZWQoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fbm9ybWFsUGFzcy5zZXRQcm9jZXNzZWQoZmFsc2UpO1xuICAgICAgICAgICAgdGhpcy5fc3Nhb1Bhc3Muc2V0UHJvY2Vzc2VkKGZhbHNlKTtcbiAgICAgICAgICAgIHRoaXMuX2JsdXJQYXNzLnNldFByb2Nlc3NlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tYWluUmVuZGVyUGFzcy5zZXRQcm9jZXNzZWQoZmFsc2UpO1xuICAgICAgICBCYXNlUmVuZGVyVHJlZS5wcm90b3R5cGUucmVuZGVyLmNhbGwodGhpcywgc2NlbmUpO1xuICAgIH0sXG5cbiAgICBnZXRSZW5kZXJTdGF0czogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYWluUGFzcy5nZXRSZW5kZXJTdGF0cygpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcndhcmRSZW5kZXJUcmVlO1xuXG4iLCJ2YXIgR0xDb250ZXh0ID0gcmVxdWlyZShcIi4vYmFzZS9jb250ZXh0LmpzXCIpO1xudmFyIEdMU2NlbmUgPSByZXF1aXJlKFwiLi9zY2VuZS9nbHNjZW5lLmpzXCIpO1xudmFyIEdMU2NhbGVkUmVuZGVyVGFyZ2V0ID0gcmVxdWlyZShcIi4vYmFzZS9yZW5kZXJ0YXJnZXQuanNcIikuR0xTY2FsZWRSZW5kZXJUYXJnZXQ7XG52YXIgRGF0YUNoYW5nZUxpc3RlbmVyID0gcmVxdWlyZShcIi4uL3JlbmRlcmVyL3Rvb2xzL2RhdGFjaGFuZ2VsaXN0ZW5lci5qc1wiKTtcbnZhciBSZW5kZXJJbnRlcmZhY2UgPSByZXF1aXJlKFwiLi9yZW5kZXItaW50ZXJmYWNlLmpzXCIpO1xudmFyIFBpY2tPYmplY3RSZW5kZXJQYXNzPSByZXF1aXJlKFwiLi9yZW5kZXItcGFzc2VzL3BpY2stb2JqZWN0LmpzXCIpO1xudmFyIFBpY2tQb3NpdGlvblJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9yZW5kZXItcGFzc2VzL3BpY2stcG9zaXRpb24uanNcIik7XG52YXIgUGlja05vcm1hbFJlbmRlclBhc3MgPSByZXF1aXJlKFwiLi9yZW5kZXItcGFzc2VzL3BpY2stbm9ybWFsLmpzXCIpO1xudmFyIEZvcndhcmRSZW5kZXJUcmVlID0gcmVxdWlyZShcIi4vcmVuZGVyLXRyZWVzL2ZvcndhcmQuanNcIik7XG52YXIgR0xVID0gcmVxdWlyZShcIi4uLy4uL2NvbnRyaWIvZ2x1LmpzXCIpO1xudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcbnZhciB4bWwzZEZvcm1hdEhhbmRsZXIgPSByZXF1aXJlKFwiLi4vLi4vYmFzZS9mb3JtYXRoYW5kbGVyLmpzXCIpLnhtbDNkRm9ybWF0SGFuZGxlcjtcbnZhciBNQVhfUElDS19CVUZGRVJfRElNRU5TSU9OID0gNTEyO1xudmFyIHZlYzMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzM7XG52YXIgcXVhdCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikucXVhdDtcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xuXG52YXIgT1BUSU9OX1NTQU8gPSBcInJlbmRlcmVyLXNzYW9cIjtcbnZhciBGTEFHUyA9IHt9O1xuRkxBR1NbT1BUSU9OX1NTQU9dID0ge2RlZmF1bHRWYWx1ZTogZmFsc2UsIHJlY29tcGlsZU9uQ2hhbmdlOiB0cnVlfTtcbmZvciAodmFyIGZsYWcgaW4gRkxBR1MpIHtcbiAgICBPcHRpb25zLnJlZ2lzdGVyKGZsYWcsIEZMQUdTW2ZsYWddLmRlZmF1bHRWYWx1ZSk7XG59XG5cbi8qKlxuICogQ29udmVydCB0aGUgZ2l2ZW4geS1jb29yZGluYXRlIG9uIHRoZSBjYW52YXMgdG8gYSB5LWNvb3JkaW5hdGUgYXBwcm9wcmlhdGUgaW5cbiAqIHRoZSBHTCBjb250ZXh0LiBUaGUgeS1jb29yZGluYXRlIGdldHMgdHVybmVkIHVwc2lkZS1kb3duLiBUaGUgbG93ZXN0IHBvc3NpYmxlXG4gKiBjYW52YXMgY29vcmRpbmF0ZSBpcyAwLCBzbyB3ZSBuZWVkIHRvIHN1YnRyYWN0IDEgZnJvbSB0aGUgaGVpZ2h0LCB0b28uXG4gKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybiB7bnVtYmVyfSB0aGUgY29udmVydGVkIHktY29vcmRpbmF0ZVxuICovXG52YXIgY2FudmFzVG9HbFkgPSBmdW5jdGlvbiAoY2FudmFzLCB5KSB7XG4gICAgcmV0dXJuIGNhbnZhcy5oZWlnaHQgLSB5IC0gMTtcbn07XG4vKipcbiAqIEBpbnRlcmZhY2VcbiAqL1xudmFyIElSZW5kZXJlciA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbklSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyVG9DYW52YXMgPSBmdW5jdGlvbiAoKSB7XG59O1xuSVJlbmRlcmVyLnByb3RvdHlwZS5oYW5kbGVSZXNpemVFdmVudCA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG59O1xuSVJlbmRlcmVyLnByb3RvdHlwZS5yZXF1ZXN0UmVkcmF3ID0gZnVuY3Rpb24gKHJlYXNvbikge1xufTtcbklSZW5kZXJlci5wcm90b3R5cGUubmVlZHNSZWRyYXcgPSBmdW5jdGlvbiAoKSB7XG59O1xuSVJlbmRlcmVyLnByb3RvdHlwZS5nZXRXb3JsZFNwYWNlTm9ybWFsQnlQb2ludCA9IGZ1bmN0aW9uIChvYmosIHgsIHkpIHtcbn07XG5JUmVuZGVyZXIucHJvdG90eXBlLmdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UG9pbnQgPSBmdW5jdGlvbiAob2JqLCB4LCB5KSB7XG59O1xuSVJlbmRlcmVyLnByb3RvdHlwZS5nZXRSZW5kZXJPYmplY3RGcm9tUGlja2luZ0J1ZmZlciA9IGZ1bmN0aW9uICh4LCB5KSB7XG59O1xuSVJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZVJheSA9IGZ1bmN0aW9uICh4LCB5KSB7XG59O1xuSVJlbmRlcmVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgVGhlIDx4bWwzZD4gRWxlbWVudFxuICogQGltcGxlbWVudHMge0lSZW5kZXJlcn1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgR0xSZW5kZXJlciA9IGZ1bmN0aW9uIChlbGVtZW50LCBjYW52YXNIYW5kbGVyKSB7XG5cbiAgICB0aGlzLl9jYW52YXNIYW5kbGVyID0gY2FudmFzSGFuZGxlcjtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzSGFuZGxlci5nZXRDYW52YXMoKTtcbiAgICB0aGlzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcblxuICAgIHRoaXMuY29udGV4dCA9IG5ldyBHTENvbnRleHQoY2FudmFzLCB0aGlzLl9jYW52YXNIYW5kbGVyLmlkKTtcbiAgICB0aGlzLnNjZW5lID0gbmV3IEdMU2NlbmUodGhpcy5jb250ZXh0KTtcblxuICAgIHZhciBmYWN0b3J5ID0geG1sM2RGb3JtYXRIYW5kbGVyLmdldEZhY3RvcnkoXCJ3ZWJnbFwiLCB0aGlzLl9jYW52YXNIYW5kbGVyLmlkKTtcbiAgICBmYWN0b3J5LnNldFNjZW5lKHRoaXMuc2NlbmUpO1xuICAgIGZhY3Rvcnkuc2V0UmVuZGVyZXIodGhpcyk7XG5cbiAgICB2YXIgeG1sM2RBZGFwdGVyID0gZmFjdG9yeS5nZXRBZGFwdGVyKGVsZW1lbnQpO1xuICAgIHhtbDNkQWRhcHRlci50cmF2ZXJzZShmdW5jdGlvbiAoKSB7XG4gICAgfSk7XG5cbiAgICAvKiogQHR5cGUge1JlbmRlck9iamVjdH0gKi9cbiAgICB0aGlzLnBpY2tlZE9iamVjdCA9IG51bGw7XG5cbiAgICB0aGlzLm5lZWRzRHJhdyA9IHRydWU7XG4gICAgdGhpcy5uZWVkc1BpY2tpbmdEcmF3ID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyA9IHRoaXMucmVxdWVzdFJlZHJhdy5iaW5kKHRoaXMpO1xuXG4gICAgLy9DdXJyZW50bHkgdXNlZCBhcyBhIGhlbHBlciB0byBjYWxjdWxhdGUgdmlldyBhbmQgcHJvamVjdGlvbiBtYXRyaWNlcyBmb3IgcmF5IGNhc3RpbmcsIHNpbmNlIHRoZSBzY2VuZVxuICAgIC8vbXVzdCBiZSByZW5kZXJlZCBmcm9tIHRoZSBwb2ludCBvZiB2aWV3IG9mIHRoZSByYXlcbiAgICB0aGlzLnJheUNhbWVyYSA9IHRoaXMuc2NlbmUuY3JlYXRlUmVuZGVyVmlldygpO1xuXG4gICAgdGhpcy5pbml0R0woKTtcbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gbmV3IERhdGFDaGFuZ2VMaXN0ZW5lcih0aGlzKTtcblxuICAgIHRoaXMucmVuZGVySW50ZXJmYWNlID0gdGhpcy5jcmVhdGVSZW5kZXJJbnRlcmZhY2UoKTtcbiAgICB0aGlzLmNyZWF0ZURlZmF1bHRQaXBlbGluZXMoKTtcbiAgICBPcHRpb25zLmFkZE9ic2VydmVyKHRoaXMub25GbGFnc0NoYW5nZS5iaW5kKHRoaXMpKTtcbn07XG5cbi8vIEp1c3QgdG8gc2F0aXNmeSBqc2xpbnRcbkdMUmVuZGVyZXIucHJvdG90eXBlLmdlbmVyYXRlUmF5ID0gZnVuY3Rpb24gKCkge1xufTtcblxuWE1MM0QuZXh0ZW5kKEdMUmVuZGVyZXIucHJvdG90eXBlLCB7XG4gICAgaW5pdEdMOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblxuICAgICAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgICAgICBnbC5jbGVhckRlcHRoKDEpO1xuICAgICAgICBnbC5jbGVhclN0ZW5jaWwoMCk7XG5cbiAgICAgICAgZ2wuZW5hYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgICBnbC5kZXB0aEZ1bmMoZ2wuTEVRVUFMKTtcblxuICAgICAgICBnbC5mcm9udEZhY2UoZ2wuQ0NXKTtcbiAgICAgICAgZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuQ1VMTF9GQUNFKTtcblxuICAgICAgICBnbC5ibGVuZEVxdWF0aW9uKGdsLkZVTkNfQUREKTtcbiAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLlNSQ19BTFBIQSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5QQUNLX0FMSUdOTUVOVCwgMSk7XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19BTElHTk1FTlQsIDEpO1xuICAgICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCBmYWxzZSk7XG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19DT0xPUlNQQUNFX0NPTlZFUlNJT05fV0VCR0wsIGdsLkJST1dTRVJfREVGQVVMVF9XRUJHTCk7XG5cbiAgICB9LFxuXG4gICAgaGFuZGxlUmVzaXplRXZlbnQ6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuY29udGV4dC5oYW5kbGVSZXNpemVFdmVudCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jcmVhdGVEZWZhdWx0UGlwZWxpbmVzKCk7XG4gICAgICAgIHRoaXMuc2NlbmUuaGFuZGxlUmVzaXplRXZlbnQod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMubmVlZHNEcmF3ID0gdGhpcy5uZWVkc1BpY2tpbmdEcmF3ID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgY3JlYXRlRGVmYXVsdFBpcGVsaW5lczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGlwZWxpbmUgPSBuZXcgRm9yd2FyZFJlbmRlclRyZWUodGhpcy5yZW5kZXJJbnRlcmZhY2UsIE9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX1NTQU8pKTtcbiAgICAgICAgdGhpcy5yZW5kZXJJbnRlcmZhY2Uuc2V0UmVuZGVyUGlwZWxpbmUocGlwZWxpbmUpO1xuXG4gICAgICAgIHZhciBwaWNrVGFyZ2V0ID0gbmV3IEdMU2NhbGVkUmVuZGVyVGFyZ2V0KHRoaXMuY29udGV4dCwgTUFYX1BJQ0tfQlVGRkVSX0RJTUVOU0lPTiwge1xuICAgICAgICAgICAgd2lkdGg6IHRoaXMuY29udGV4dC5jYW52YXNUYXJnZXQud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHRoaXMuY29udGV4dC5jYW52YXNUYXJnZXQuaGVpZ2h0LFxuICAgICAgICAgICAgY29sb3JGb3JtYXQ6IHRoaXMuY29udGV4dC5nbC5SR0JBLFxuICAgICAgICAgICAgZGVwdGhGb3JtYXQ6IHRoaXMuY29udGV4dC5nbC5ERVBUSF9DT01QT05FTlQxNixcbiAgICAgICAgICAgIHN0ZW5jaWxGb3JtYXQ6IG51bGwsXG4gICAgICAgICAgICBkZXB0aEFzUmVuZGVyYnVmZmVyOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBpY2tPYmplY3RQYXNzID0gbmV3IFBpY2tPYmplY3RSZW5kZXJQYXNzKHRoaXMucmVuZGVySW50ZXJmYWNlLCBwaWNrVGFyZ2V0KTtcbiAgICAgICAgdGhpcy5waWNrUG9zaXRpb25QYXNzID0gbmV3IFBpY2tQb3NpdGlvblJlbmRlclBhc3ModGhpcy5yZW5kZXJJbnRlcmZhY2UsIHBpY2tUYXJnZXQpO1xuICAgICAgICB0aGlzLnBpY2tOb3JtYWxQYXNzID0gbmV3IFBpY2tOb3JtYWxSZW5kZXJQYXNzKHRoaXMucmVuZGVySW50ZXJmYWNlLCBwaWNrVGFyZ2V0KTtcbiAgICB9LFxuXG4gICAgY3JlYXRlUmVuZGVySW50ZXJmYWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVuZGVySW50ZXJmYWNlKHRoaXMuY29udGV4dCwgdGhpcy5zY2VuZSk7XG4gICAgICAgIC8vVE9ETyBuZWVkIHRvIHByb3ZpZGUgYW4gaW50ZXJmYWNlIGZvciBjcmVhdGluZyBzaGFkZXJzLCBidWZmZXJzIGFuZCBzbyBvblxuICAgIH0sXG5cbiAgICByZXF1ZXN0UmVkcmF3OiBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiUmVxdWVzdCByZWRyYXcgYmVjYXVzZTpcIiwgcmVhc29uKTtcbiAgICAgICAgdGhpcy5uZWVkc0RyYXcgPSB0cnVlO1xuICAgICAgICB0aGlzLm5lZWRzUGlja2luZ0RyYXcgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBnZXRXb3JsZFNwYWNlTm9ybWFsQnlQb2ludDogZnVuY3Rpb24gKHgsIHksIG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqID0gb2JqZWN0IHx8IHRoaXMucGlja2VkT2JqZWN0O1xuICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB5ID0gY2FudmFzVG9HbFkodGhpcy5fY2FudmFzSGFuZGxlci5nZXRDYW52YXMoKSwgeSk7XG4gICAgICAgIHRoaXMucGlja05vcm1hbFBhc3MucmVuZGVyKG9iaik7XG4gICAgICAgIHRoaXMubmVlZHNQaWNraW5nRHJhdyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tOb3JtYWxQYXNzLnJlYWROb3JtYWxGcm9tUGlja2luZ0J1ZmZlcih4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0V29ybGRTcGFjZVBvc2l0aW9uQnlQb2ludDogZnVuY3Rpb24gKHgsIHksIG9iamVjdCkge1xuICAgICAgICB2YXIgb2JqID0gb2JqZWN0IHx8IHRoaXMucGlja2VkT2JqZWN0O1xuICAgICAgICBpZiAoIW9iailcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB5ID0gY2FudmFzVG9HbFkodGhpcy5fY2FudmFzSGFuZGxlci5nZXRDYW52YXMoKSwgeSk7XG4gICAgICAgIHRoaXMucGlja1Bvc2l0aW9uUGFzcy5yZW5kZXIob2JqKTtcbiAgICAgICAgdGhpcy5uZWVkc1BpY2tpbmdEcmF3ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja1Bvc2l0aW9uUGFzcy5yZWFkUG9zaXRpb25Gcm9tUGlja2luZ0J1ZmZlcih4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0UmVuZGVyT2JqZWN0QnlSYXk6IGZ1bmN0aW9uICh4bWwzZFJheSwgdmlld01hdCwgcHJvak1hdCkge1xuICAgICAgICB2YXIgaW50ZXJzZWN0ZWRPYmplY3RzID0gdGhpcy5zY2VuZS5maW5kUmF5SW50ZXJzZWN0aW9ucyh4bWwzZFJheSk7XG4gICAgICAgIHRoaXMucGlja09iamVjdFBhc3MucmVuZGVyKGludGVyc2VjdGVkT2JqZWN0cywgdmlld01hdCwgcHJvak1hdCk7XG4gICAgICAgIC8vVGFyZ2V0IHRoZSBtaWRkbGUgb2YgdGhlIGJ1ZmZlclxuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IodGhpcy5waWNrT2JqZWN0UGFzcy5vdXRwdXQuZ2V0V2lkdGgoKSAvIDIgLyB0aGlzLnBpY2tPYmplY3RQYXNzLm91dHB1dC5nZXRTY2FsZSgpKTtcbiAgICAgICAgdmFyIHkgPSBNYXRoLmZsb29yKHRoaXMucGlja09iamVjdFBhc3Mub3V0cHV0LmdldEhlaWdodCgpIC8gMiAvIHRoaXMucGlja09iamVjdFBhc3Mub3V0cHV0LmdldFNjYWxlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5waWNrT2JqZWN0UGFzcy5nZXRSZW5kZXJPYmplY3RGcm9tUGlja2luZ0J1ZmZlcih4LCB5LCBpbnRlcnNlY3RlZE9iamVjdHMpO1xuXG4gICAgfSxcblxuICAgIGdldFdvcmxkU3BhY2VOb3JtYWxCeVJheTogZnVuY3Rpb24gKHJheSwgaW50ZXJzZWN0ZWRPYmplY3QsIHZpZXdNYXQsIHByb2pNYXQpIHtcbiAgICAgICAgaWYgKCFpbnRlcnNlY3RlZE9iamVjdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB0aGlzLnBpY2tOb3JtYWxQYXNzLnJlbmRlcihpbnRlcnNlY3RlZE9iamVjdCwgdmlld01hdCwgcHJvak1hdCk7XG4gICAgICAgIHZhciB4ID0gTWF0aC5mbG9vcih0aGlzLnBpY2tOb3JtYWxQYXNzLm91dHB1dC5nZXRXaWR0aCgpIC8gMiAvIHRoaXMucGlja05vcm1hbFBhc3Mub3V0cHV0LmdldFNjYWxlKCkpO1xuICAgICAgICB2YXIgeSA9IE1hdGguZmxvb3IodGhpcy5waWNrTm9ybWFsUGFzcy5vdXRwdXQuZ2V0SGVpZ2h0KCkgLyAyIC8gdGhpcy5waWNrTm9ybWFsUGFzcy5vdXRwdXQuZ2V0U2NhbGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tOb3JtYWxQYXNzLnJlYWROb3JtYWxGcm9tUGlja2luZ0J1ZmZlcih4LCB5KTtcblxuICAgIH0sIGdldFdvcmxkU3BhY2VQb3NpdGlvbkJ5UmF5OiBmdW5jdGlvbiAocmF5LCBpbnRlcnNlY3RlZE9iamVjdCwgdmlld01hdCwgcHJvak1hdCkge1xuICAgICAgICBpZiAoIWludGVyc2VjdGVkT2JqZWN0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMucGlja1Bvc2l0aW9uUGFzcy5yZW5kZXIoaW50ZXJzZWN0ZWRPYmplY3QsIHZpZXdNYXQsIHByb2pNYXQpO1xuICAgICAgICB2YXIgeCA9IE1hdGguZmxvb3IodGhpcy5waWNrUG9zaXRpb25QYXNzLm91dHB1dC5nZXRXaWR0aCgpIC8gMiAvIHRoaXMucGlja1Bvc2l0aW9uUGFzcy5vdXRwdXQuZ2V0U2NhbGUoKSk7XG4gICAgICAgIHZhciB5ID0gTWF0aC5mbG9vcih0aGlzLnBpY2tQb3NpdGlvblBhc3Mub3V0cHV0LmdldEhlaWdodCgpIC8gMiAvIHRoaXMucGlja1Bvc2l0aW9uUGFzcy5vdXRwdXQuZ2V0U2NhbGUoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBpY2tQb3NpdGlvblBhc3MucmVhZFBvc2l0aW9uRnJvbVBpY2tpbmdCdWZmZXIoeCwgeSk7XG5cbiAgICB9LFxuXG4gICAgY2FsY3VsYXRlTWF0cmljZXNGb3JSYXk6IGZ1bmN0aW9uIChyYXksIHZpZXdNYXQsIHByb2pNYXQpIHtcbiAgICAgICAgdGhpcy5yYXlDYW1lcmEudXBkYXRlUG9zaXRpb24ocmF5Lm9yaWdpbi5kYXRhKTtcbiAgICAgICAgdGhpcy5yYXlDYW1lcmEudXBkYXRlT3JpZW50YXRpb24odGhpcy5jYWxjdWxhdGVPcmllbnRhdGlvbkZvclJheURpcmVjdGlvbihyYXkpKTtcbiAgICAgICAgdGhpcy5yYXlDYW1lcmEuZ2V0V29ybGRUb1ZpZXdNYXRyaXgodmlld01hdCk7XG4gICAgICAgIHZhciBhc3BlY3QgPSB0aGlzLnBpY2tPYmplY3RQYXNzLm91dHB1dC5nZXRXaWR0aCgpIC8gdGhpcy5waWNrT2JqZWN0UGFzcy5vdXRwdXQuZ2V0SGVpZ2h0KCk7XG4gICAgICAgIHRoaXMucmF5Q2FtZXJhLmdldFByb2plY3Rpb25NYXRyaXgocHJvak1hdCwgYXNwZWN0KTtcbiAgICB9LFxuXG4gICAgY2FsY3VsYXRlT3JpZW50YXRpb25Gb3JSYXlEaXJlY3Rpb246IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0bXBYID0gdmVjMy5jcmVhdGUoKTtcbiAgICAgICAgdmFyIHRtcFkgPSB2ZWMzLmNyZWF0ZSgpO1xuICAgICAgICB2YXIgdG1wWiA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHZhciB1cCA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHZhciBxID0gcXVhdC5jcmVhdGUoKTtcbiAgICAgICAgdmFyIG0gPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAocmF5KSB7XG4gICAgICAgICAgICB2ZWMzLnNldCh1cCwgMCwgMSwgMCk7XG4gICAgICAgICAgICB2ZWMzLmNyb3NzKHRtcFgsIHJheS5kaXJlY3Rpb24uZGF0YSwgdXApO1xuICAgICAgICAgICAgaWYgKCF2ZWMzLmxlbmd0aCh0bXBYKSkge1xuICAgICAgICAgICAgICAgIHZlYzMuc2V0KHRtcFgsIDEsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmVjMy5jcm9zcyh0bXBZLCB0bXBYLCByYXkuZGlyZWN0aW9uLmRhdGEpO1xuICAgICAgICAgICAgdmVjMy5uZWdhdGUodG1wWiwgcmF5LmRpcmVjdGlvbi5kYXRhKTtcblxuICAgICAgICAgICAgWE1MM0QubWF0aC5xdWF0LnNldEZyb21CYXNpcyhxLCB0bXBYLCB0bXBZLCB0bXBaKTtcbiAgICAgICAgICAgIG1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24obSwgcSwgWzAsMCwwXSk7XG4gICAgICAgICAgICByZXR1cm4gbTtcbiAgICAgICAgfVxuICAgIH0pKCksXG5cbiAgICBuZWVkc1JlZHJhdzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWVkc0RyYXc7XG4gICAgfSxcblxuICAgIHJlbmRlclRvQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubmVlZHNEcmF3ID0gZmFsc2U7IC8vU2V0IHRoaXMgZWFybHkgdG8gYXZvaWQgZW5kbGVzcyByZW5kZXJpbmcgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBkdXJpbmcgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMucHJlcGFyZVJlbmRlcmluZygpO1xuICAgICAgICB0aGlzLnJlbmRlckludGVyZmFjZS5nZXRSZW5kZXJQaXBlbGluZSgpLnJlbmRlcih0aGlzLnNjZW5lKTtcbiAgICAgICAgdmFyIHN0YXRzID0gdGhpcy5yZW5kZXJJbnRlcmZhY2UuZ2V0UmVuZGVyUGlwZWxpbmUoKS5nZXRSZW5kZXJTdGF0cygpO1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIlJlbmRlcmVkIHRvIENhbnZhc1wiKTtcbiAgICAgICAgcmV0dXJuIHN0YXRzO1xuICAgIH0sXG5cbiAgICBnZXRSZW5kZXJPYmplY3RGcm9tUGlja2luZ0J1ZmZlcjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgICAgeSA9IGNhbnZhc1RvR2xZKHRoaXMuX2NhbnZhc0hhbmRsZXIuZ2V0Q2FudmFzKCksIHkpO1xuICAgICAgICBpZiAodGhpcy5uZWVkc1BpY2tpbmdEcmF3KSB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzUGlja2luZ0RyYXcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucHJlcGFyZVJlbmRlcmluZygpO1xuICAgICAgICAgICAgdGhpcy5zY2VuZS51cGRhdGVSZWFkeU9iamVjdHNGcm9tQWN0aXZlVmlldyh0aGlzLnBpY2tPYmplY3RQYXNzLm91dHB1dC5nZXRXaWR0aCgpIC8gdGhpcy5waWNrT2JqZWN0UGFzcy5vdXRwdXQuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgdGhpcy5waWNrT2JqZWN0UGFzcy5yZW5kZXIodGhpcy5zY2VuZS5yZWFkeSk7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIlJlbmRlcmVkIFBpY2tpbmcgQnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGlja2VkT2JqZWN0ID0gdGhpcy5waWNrT2JqZWN0UGFzcy5nZXRSZW5kZXJPYmplY3RGcm9tUGlja2luZ0J1ZmZlcih4LCB5LCB0aGlzLnNjZW5lLnJlYWR5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGlja2VkT2JqZWN0O1xuICAgIH0sXG5cbiAgICBwcmVwYXJlUmVuZGVyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NlbmUudXBkYXRlKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVzZXMgZ2x1VW5Qcm9qZWN0KCkgdG8gdHJhbnNmb3JtIHRoZSAyRCBzY3JlZW4gcG9pbnQgdG8gYSAzRCByYXkuXG4gICAgICogTm90IHRlc3RlZCEhXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2FudmFzWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjYW52YXNZXG4gICAgICovXG4gICAgZ2VuZXJhdGVSYXk6IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIGNfdmlld01hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX3Byb2plY3Rpb25NYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoY2FudmFzWCwgY2FudmFzWSkge1xuXG4gICAgICAgICAgICB2YXIgZ2xZID0gY2FudmFzVG9HbFkodGhpcy5fY2FudmFzSGFuZGxlci5nZXRDYW52YXMoKSwgY2FudmFzWSk7XG5cbiAgICAgICAgICAgIC8vIHNldHVwIGlucHV0IHRvIHVucHJvamVjdFxuICAgICAgICAgICAgdmFyIHZpZXdwb3J0ID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICAgICAgICAgIHZpZXdwb3J0WzBdID0gMDtcbiAgICAgICAgICAgIHZpZXdwb3J0WzFdID0gMDtcbiAgICAgICAgICAgIHZpZXdwb3J0WzJdID0gdGhpcy53aWR0aDtcbiAgICAgICAgICAgIHZpZXdwb3J0WzNdID0gdGhpcy5oZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIGdldCB2aWV3IGFuZCBwcm9qZWN0aW9uIG1hdHJpeCBhcnJheXNcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy5zY2VuZS5nZXRBY3RpdmVWaWV3KCk7XG4gICAgICAgICAgICB2aWV3LmdldFdvcmxkVG9WaWV3TWF0cml4KGNfdmlld01hdHJpeCk7XG4gICAgICAgICAgICB2aWV3LmdldFByb2plY3Rpb25NYXRyaXgoY19wcm9qZWN0aW9uTWF0cml4LCB2aWV3cG9ydFsyXSAvIHZpZXdwb3J0WzNdKTtcblxuICAgICAgICAgICAgdmFyIHJheSA9IG5ldyBYTUwzRC5SYXkoKTtcblxuICAgICAgICAgICAgdmFyIG5lYXJIaXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgICAgICAgICAgdmFyIGZhckhpdCA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG5cbiAgICAgICAgICAgIC8vIGRvIHVucHJvamVjdGlvbnNcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gR0xVLnVuUHJvamVjdChjYW52YXNYLCBnbFksIDAsIGNfdmlld01hdHJpeCwgY19wcm9qZWN0aW9uTWF0cml4LCB2aWV3cG9ydCwgbmVhckhpdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmFsc2UgPT09IEdMVS51blByb2plY3QoY2FudmFzWCwgZ2xZLCAxLCBjX3ZpZXdNYXRyaXgsIGNfcHJvamVjdGlvbk1hdHJpeCwgdmlld3BvcnQsIGZhckhpdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmF5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgcmF5XG4gICAgICAgICAgICBtYXQ0LmludmVydChjX3ZpZXdNYXRyaXgsIGNfdmlld01hdHJpeCk7XG4gICAgICAgICAgICByYXkub3JpZ2luID0gdmVjMy5mcm9tVmFsdWVzKGNfdmlld01hdHJpeFsxMl0sIGNfdmlld01hdHJpeFsxM10sIGNfdmlld01hdHJpeFsxNF0pO1xuICAgICAgICAgICAgcmF5LmRpcmVjdGlvbiA9IHZlYzMuZnJvbVZhbHVlcyhmYXJIaXRbMF0gLSBuZWFySGl0WzBdLCBmYXJIaXRbMV0gLSBuZWFySGl0WzFdLCBmYXJIaXRbMl0gLSBuZWFySGl0WzJdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHJheTtcbiAgICAgICAgfVxuICAgIH0oKSksXG5cbiAgICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc2NlbmUuY2xlYXIoKTtcbiAgICB9LFxuXG4gICAgZ2V0UmVuZGVySW50ZXJmYWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckludGVyZmFjZTtcbiAgICB9LFxuXG4gICAgb25GbGFnc0NoYW5nZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoa2V5ID09IE9QVElPTl9TU0FPKSB7XG4gICAgICAgICAgICB0aGlzLnNjZW5lLnNoYWRlckZhY3Rvcnkuc2V0U2hhZGVyUmVjb21waWxlKCk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURlZmF1bHRQaXBlbGluZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdMUmVuZGVyZXI7XG4iLCJ2YXIgWGZsb3dNZXNoID0gcmVxdWlyZShcIi4uL3hmbG93L3hmbG93LW1lc2guanNcIik7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEcmF3YWJsZUZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7fTtcblxuWE1MM0QuZXh0ZW5kKERyYXdhYmxlRmFjdG9yeS5wcm90b3R5cGUsIHtcbiAgICBjcmVhdGVEcmF3YWJsZTogZnVuY3Rpb24gKG9iaiwgY29udGV4dCkge1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIkRyYXdhYmxlRmFjdG9yeTo6Y3JlYXRlRHJhd2FibGVcIiwgb2JqKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgWGZsb3dNZXNoKGNvbnRleHQsIG9iai5nZXREYXRhTm9kZSgpLCBvYmouZ2V0VHlwZSgpLCB7Ym91bmRpbmdCb3hDaGFuZ2VkOiBvYmouc2V0T2JqZWN0U3BhY2VCb3VuZGluZ0JveC5iaW5kKG9iail9KTtcbiAgICAgICAgICAgIG9iai5tZXNoID0gcmVzdWx0LmdldE1lc2goKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKGUsIG9iai5ub2RlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRHJhd2FibGVGYWN0b3J5O1xuXG5cbiIsInZhciBsaWdodE1vZGVscyA9IHtcbiAgICBwb2ludDoge1xuICAgICAgICBwYXJhbWV0ZXJzOiBbIFwicG9pbnRMaWdodFBvc2l0aW9uXCIsIFwicG9pbnRMaWdodEF0dGVudWF0aW9uXCIsIFwicG9pbnRMaWdodEludGVuc2l0eVwiLCBcInBvaW50TGlnaHRPblwiLCBcInBvaW50TGlnaHRDYXN0U2hhZG93XCIsIFwicG9pbnRMaWdodE1hdHJpeFwiLCBcInBvaW50TGlnaHRTaGFkb3dCaWFzXCIsIFwicG9pbnRMaWdodE5lYXJGYXJcIiwgXCJwb2ludExpZ2h0U2hhZG93TWFwXCJdXG4gICAgfSxcbiAgICBkaXJlY3Rpb25hbDoge1xuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJkaXJlY3Rpb25hbExpZ2h0RGlyZWN0aW9uXCIsIFwiZGlyZWN0aW9uYWxMaWdodEludGVuc2l0eVwiLCBcImRpcmVjdGlvbmFsTGlnaHRPblwiLCBcImRpcmVjdGlvbmFsTGlnaHRDYXN0U2hhZG93XCIsIFwiZGlyZWN0aW9uYWxMaWdodE1hdHJpeFwiLCBcImRpcmVjdGlvbmFsTGlnaHRTaGFkb3dCaWFzXCIsIFwiZGlyZWN0aW9uYWxMaWdodFNoYWRvd01hcFwiXVxuICAgIH0sXG4gICAgc3BvdDoge1xuICAgICAgICBwYXJhbWV0ZXJzOiBbXCJzcG90TGlnaHRBdHRlbnVhdGlvblwiLCBcInNwb3RMaWdodFBvc2l0aW9uXCIsIFwic3BvdExpZ2h0SW50ZW5zaXR5XCIsIFwic3BvdExpZ2h0RGlyZWN0aW9uXCIsIFwic3BvdExpZ2h0T25cIiwgXCJzcG90TGlnaHRTb2Z0bmVzc1wiLCBcInNwb3RMaWdodENvc0ZhbGxvZmZBbmdsZVwiLCBcInNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVcIiwgXCJzcG90TGlnaHRDYXN0U2hhZG93XCIsIFwic3BvdExpZ2h0TWF0cml4XCIsIFwic3BvdExpZ2h0U2hhZG93Qmlhc1wiLCBcInNwb3RMaWdodFNoYWRvd01hcFwiXVxuICAgIH1cbn07XG5cbnZhciBBTExfUEFSQU1FVEVSUyA9IGxpZ2h0TW9kZWxzLnBvaW50LnBhcmFtZXRlcnMuY29uY2F0KGxpZ2h0TW9kZWxzLmRpcmVjdGlvbmFsLnBhcmFtZXRlcnMpLmNvbmNhdChsaWdodE1vZGVscy5zcG90LnBhcmFtZXRlcnMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBBTExfUEFSQU1FVEVSUzogQUxMX1BBUkFNRVRFUlNcbn07XG4iLCJ2YXIgU2NlbmUgPSByZXF1aXJlKFwiLi8uLi8uLi9yZW5kZXJlci9zY2VuZS9zY2VuZS5qc1wiKTtcbnZhciBEcmF3YWJsZUZhY3RvcnkgPSByZXF1aXJlKFwiLi9kcmF3YWJsZS1mYWN0b3J5LmpzXCIpO1xudmFyIEMgPSByZXF1aXJlKFwiLi8uLi8uLi9yZW5kZXJlci9zY2VuZS9jb25zdGFudHMuanNcIik7XG52YXIgRnJ1c3R1bVRlc3QgPSByZXF1aXJlKFwiLi8uLi8uLi9yZW5kZXJlci90b29scy9mcnVzdHVtLmpzXCIpLkZydXN0dW1UZXN0O1xudmFyIFNoYWRlckNvbXBvc2VyRmFjdG9yeSA9IHJlcXVpcmUoXCIuLi9tYXRlcmlhbHMvc2hhZGVyY29tcG9zZXJmYWN0b3J5LmpzXCIpO1xudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi4vLi4vLi4vdXRpbHMvb3B0aW9ucy5qc1wiKTtcbnZhciBTaGFkb3dNYXBTZXJ2aWNlID0gcmVxdWlyZShcIi4uL21hdGVyaWFscy9zaGFkb3dtYXAtc2VydmljZVwiKTtcbnZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xuXG52YXIgT1BUSU9OX0ZSVVNUVU1fQ1VMTElORyA9IFwicmVuZGVyZXItZnJ1c3R1bUN1bGxpbmdcIjtcbnZhciBPUFRJT05fU0hBREVKU19FWFRSQUNUX1VOSUZPUk1TID0gXCJzaGFkZWpzLWV4dHJhY3RVbmlmb3JtRXhwcmVzc2lvbnNcIjtcbnZhciBPUFRJT05fU0hBREVKU19UUkFOU0ZPUk1fU1BBQ0VTID0gXCJzaGFkZWpzLXRyYW5zZm9ybVNwYWNlc1wiO1xudmFyIE9QVElPTl9TSEFERUpTX0NBQ0hFID0gXCJzaGFkZWpzLWNhY2hlXCI7XG5cblxuLy8gQWxsIHRoZSBzaGFkZXIgZmxhZ3NcbnZhciBGTEFHUyA9IHt9O1xuRkxBR1NbT1BUSU9OX1NIQURFSlNfRVhUUkFDVF9VTklGT1JNU10gPSB7ZGVmYXVsdFZhbHVlOiBmYWxzZSwgcmVjb21waWxlT25DaGFuZ2U6IHRydWV9O1xuRkxBR1NbT1BUSU9OX1NIQURFSlNfVFJBTlNGT1JNX1NQQUNFU10gPSB7ZGVmYXVsdFZhbHVlOiB0cnVlLCByZWNvbXBpbGVPbkNoYW5nZTogdHJ1ZX07XG5GTEFHU1tPUFRJT05fRlJVU1RVTV9DVUxMSU5HXSA9IHtkZWZhdWx0VmFsdWU6IHRydWUsIHJlY29tcGlsZU9uQ2hhbmdlOiBmYWxzZX07XG5GTEFHU1tPUFRJT05fU0hBREVKU19DQUNIRV0gPSB7ZGVmYXVsdFZhbHVlOiB0cnVlLCByZWNvbXBpbGVPbkNoYW5nZTogZmFsc2V9O1xuXG5mb3IgKHZhciBmbGFnIGluIEZMQUdTKSB7XG4gICAgT3B0aW9ucy5yZWdpc3RlcihmbGFnLCBGTEFHU1tmbGFnXS5kZWZhdWx0VmFsdWUpO1xufVxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XG4gKiBAZXh0ZW5kcyB7U2NlbmV9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEdMU2NlbmUgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIFNjZW5lLmNhbGwodGhpcyk7XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnNoYWRlckZhY3RvcnkgPSBuZXcgU2hhZGVyQ29tcG9zZXJGYWN0b3J5KGNvbnRleHQpO1xuICAgIHRoaXMuZHJhd2FibGVGYWN0b3J5ID0gbmV3IERyYXdhYmxlRmFjdG9yeSgpO1xuXG4gICAgdGhpcy5zaGFkb3dNYXBTZXJ2aWNlID0gbmV3IFNoYWRvd01hcFNlcnZpY2UoY29udGV4dCwgdGhpcyk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5LjxSZW5kZXJPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMucmVhZHkgPSBbXTtcbiAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgdGhpcy5saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB0aGlzLnN5c3RlbVVuaWZvcm1zID0ge307XG4gICAgdGhpcy5kZWZlcnJlZCA9IHdpbmRvd1snWE1MM0RfREVGRVJSRUQnXSB8fCBmYWxzZTtcbiAgICB0aGlzLmNvbG9yQ2xvc3VyZVNpZ25hdHVyZXMgPSBbXTtcbiAgICB0aGlzLmRvRnJ1c3R1bUN1bGxpbmcgPSAhIU9wdGlvbnMuZ2V0VmFsdWUoT1BUSU9OX0ZSVVNUVU1fQ1VMTElORyk7XG4gICAgdGhpcy5hZGRMaXN0ZW5lcnMoKTtcbn07XG5cblhNTDNELmNyZWF0ZUNsYXNzKEdMU2NlbmUsIFNjZW5lKTtcblxuZnVuY3Rpb24gcmVtb3ZlU2FmZShhcnIsIG9iaikge1xuICAgIHZhciBpbmRleCA9IGFyci5pbmRleE9mKG9iaik7XG4gICAgaWYgKGluZGV4ICE9IC0xKSB7XG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5YTUwzRC5leHRlbmQoR0xTY2VuZS5wcm90b3R5cGUsIHtcbiAgICByZW1vdmU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmVtb3ZlU2FmZSh0aGlzLnF1ZXVlLCBvYmopO1xuICAgICAgICByZW1vdmVTYWZlKHRoaXMucmVhZHksIG9iaik7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVhZHkgPSBbXTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgIH0sXG5cbiAgICBtb3ZlRnJvbVF1ZXVlVG9SZWFkeTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAocmVtb3ZlU2FmZSh0aGlzLnF1ZXVlLCBvYmopKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5LnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBtb3ZlRnJvbVJlYWR5VG9RdWV1ZTogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAocmVtb3ZlU2FmZSh0aGlzLnJlYWR5LCBvYmopKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gob2JqKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlnaHRzTmVlZFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5saWdodHNOZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpZ2h0UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgdGhpcy5saWdodHMubGlnaHRWYWx1ZUNoYW5nZWQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZU9iamVjdHNGb3JSZW5kZXJpbmcoKTtcblxuICAgICAgICAvLyBSZW5kZXIgc2hhZG93IG1hcHMgaWYgbmVjZXNzYXJ5XG4gICAgICAgIHRoaXMuc2hhZG93TWFwU2VydmljZS51cGRhdGVGb3JSZW5kZXJpbmcoKTtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCBzaGFkZXJzIGFyZSB1cGRhdGVzIEFGVEVSIG9iamVjdHNcbiAgICAgICAgLy8gQmVjYXVzZSB1bnVzZWQgc2hhZGVyIGNsb3N1cmVzIGFyZSBjbGVhcmVkIG9uIHVwZGF0ZVxuICAgICAgICB0aGlzLnVwZGF0ZVNoYWRlcnMoKTtcbiAgICB9LCB1cGRhdGVMaWdodFBhcmFtZXRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnN5c3RlbVVuaWZvcm1zO1xuXG4gICAgICAgIHRoaXMubGlnaHRzLmZpbGxHbG9iYWxQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLnNoYWRvd01hcFNlcnZpY2UuZmlsbEdsb2JhbFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG5cbiAgICAgICAgLy8gRGVyaXZlZCBwYXJhbWV0ZXJzIHRoYXQgYXJlIGltcGxlbWVudGF0aW9uIHNwZWNpZmljLlxuICAgICAgICAvLyBUT0RPOiBQdXQgdGhvc2UgdG8gYW4gYXBwcm9wcmlhdGUgcGxhY2VcbiAgICAgICAgdmFyIHNwb3RMaWdodEZhbGxvZmZBbmdsZSA9IHBhcmFtZXRlcnNbXCJzcG90TGlnaHRGYWxsb2ZmQW5nbGVcIl07XG4gICAgICAgIHZhciBzcG90TGlnaHRTb2Z0bmVzcyA9IHBhcmFtZXRlcnNbXCJzcG90TGlnaHRTb2Z0bmVzc1wiXTtcbiAgICAgICAgaWYoc3BvdExpZ2h0RmFsbG9mZkFuZ2xlKSB7XG4gICAgICAgICAgICAvLyBNYXAgYm90aCBwYXJhbWV0ZXJzIGludG8gY29zaW51cyBzcGFjZVxuICAgICAgICAgICAgdmFyIHNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGUgPSBbXTtcbiAgICAgICAgICAgIHZhciBzcG90TGlnaHRDb3NGYWxsb2ZmQW5nbGUgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BvdExpZ2h0RmFsbG9mZkFuZ2xlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlW2ldID0gTWF0aC5jb3Moc3BvdExpZ2h0RmFsbG9mZkFuZ2xlW2ldKTtcbiAgICAgICAgICAgICAgICBzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlW2ldID0gTWF0aC5jb3Moc3BvdExpZ2h0RmFsbG9mZkFuZ2xlW2ldICogKDEuMCAtIHNwb3RMaWdodFNvZnRuZXNzW2ldKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbWV0ZXJzW1wic3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlXCJdID0gc3BvdExpZ2h0Q29zRmFsbG9mZkFuZ2xlO1xuICAgICAgICAgICAgcGFyYW1ldGVyc1tcInNwb3RMaWdodENvc1NvZnRGYWxsb2ZmQW5nbGVcIl0gPSBzcG90TGlnaHRDb3NTb2Z0RmFsbG9mZkFuZ2xlO1xuICAgICAgICB9XG5cblxuICAgIH0sXG5cbiAgICB1cGRhdGVTeXN0ZW1Vbmlmb3JtczogZnVuY3Rpb24gKG5hbWVzKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyRmFjdG9yeS51cGRhdGVTeXN0ZW1Vbmlmb3JtcyhuYW1lcywgdGhpcyk7XG4gICAgfSxcblxuICAgIHVwZGF0ZVNoYWRlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zaGFkZXJGYWN0b3J5LnVwZGF0ZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlT2JqZWN0c0ZvclJlbmRlcmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgb2JqLnVwZGF0ZUZvclJlbmRlcmluZygpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgZm9yRWFjaDogZnVuY3Rpb24gKGZ1bmMsIHRoYXQpIHtcbiAgICAgICAgdGhpcy5xdWV1ZS5zbGljZSgpLmZvckVhY2goZnVuYywgdGhhdCk7XG4gICAgICAgIHRoaXMucmVhZHkuc2xpY2UoKS5mb3JFYWNoKGZ1bmMsIHRoYXQpO1xuICAgIH0sXG5cbiAgICB1cGRhdGVSZWFkeU9iamVjdHNGcm9tQWN0aXZlVmlldzogKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNfd29ybGRUb1ZpZXdNYXRyaXggPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICB2YXIgY192aWV3VG9Xb3JsZE1hdHJpeCA9IG1hdDQuY3JlYXRlKCk7XG4gICAgICAgIHZhciBjX3Byb2pNYXRfdG1wID0gbWF0NC5jcmVhdGUoKTtcbiAgICAgICAgdmFyIGNfYmJveCA9IG5ldyBYTUwzRC5Cb3goKTtcbiAgICAgICAgdmFyIGNfZnJ1c3R1bVRlc3QgPSBuZXcgRnJ1c3R1bVRlc3QoKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICB2YXIgYWN0aXZlVmlldyA9IHRoaXMuZ2V0QWN0aXZlVmlldygpLCByZWFkeU9iamVjdHMgPSB0aGlzLnJlYWR5LCBpLCBsLCBvYmo7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgTVYgbWF0cmljZXNcbiAgICAgICAgICAgIGFjdGl2ZVZpZXcuZ2V0V29ybGRUb1ZpZXdNYXRyaXgoY193b3JsZFRvVmlld01hdHJpeCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSByZWFkeU9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gcmVhZHlPYmplY3RzW2ldO1xuICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdNYXRyaXgoY193b3JsZFRvVmlld01hdHJpeCk7XG4gICAgICAgICAgICAgICAgb2JqLnVwZGF0ZU1vZGVsTWF0cml4TigpO1xuICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdNYXRyaXhOKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kaW5nQm94KCk7XG5cbiAgICAgICAgICAgIGFjdGl2ZVZpZXcuZ2V0UHJvamVjdGlvbk1hdHJpeChjX3Byb2pNYXRfdG1wLCBhc3BlY3RSYXRpbyk7XG4gICAgICAgICAgICBhY3RpdmVWaWV3LmdldFZpZXdUb1dvcmxkTWF0cml4KGNfdmlld1RvV29ybGRNYXRyaXgpO1xuXG4gICAgICAgICAgICB2YXIgZnJ1c3R1bSA9IGFjdGl2ZVZpZXcuZ2V0RnJ1c3R1bSgpO1xuICAgICAgICAgICAgY19mcnVzdHVtVGVzdC5zZXQoZnJ1c3R1bSwgY192aWV3VG9Xb3JsZE1hdHJpeCk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSByZWFkeU9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgb2JqID0gcmVhZHlPYmplY3RzW2ldO1xuICAgICAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KGNfcHJvak1hdF90bXApO1xuICAgICAgICAgICAgICAgIG9iai5nZXRXb3JsZFNwYWNlQm91bmRpbmdCb3goY19iYm94KTtcbiAgICAgICAgICAgICAgICBvYmouaW5GcnVzdHVtID0gdGhpcy5kb0ZydXN0dW1DdWxsaW5nID8gY19mcnVzdHVtVGVzdC5pc0JveFZpc2libGUoY19iYm94KSA6IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KCkpLFxuICAgIHVwZGF0ZVJlYWR5T2JqZWN0c0Zyb21NYXRyaWNlczogZnVuY3Rpb24gKHdvcmxkVG9WaWV3TWF0cml4LCBwcm9qZWN0aW9uTWF0cml4KSB7XG4gICAgICAgIHZhciByZWFkeU9iamVjdHMgPSB0aGlzLnJlYWR5O1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHJlYWR5T2JqZWN0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvYmogPSByZWFkeU9iamVjdHNbaV07XG4gICAgICAgICAgICBvYmoudXBkYXRlTW9kZWxWaWV3TWF0cml4KHdvcmxkVG9WaWV3TWF0cml4KTtcbiAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbE1hdHJpeE4oKTtcbiAgICAgICAgICAgIG9iai51cGRhdGVNb2RlbFZpZXdQcm9qZWN0aW9uTWF0cml4KHByb2plY3Rpb25NYXRyaXgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5vbihDLkVWRU5UX1RZUEUuU0NFTkVfU1RSVUNUVVJFX0NIQU5HRUQsIGZ1bmN0aW9uIChjaGlsZCwgcmVtb3ZlZCkge1xuICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkRXZlbnQoY2hpbGQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENoaWxkRXZlbnQoY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vbihDLkVWRU5UX1RZUEUuVklFV19DSEFOR0VELCBmdW5jdGlvbiAoLypuZXdWaWV3Ki8pIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KFwiQWN0aXZlIHZpZXcgY2hhbmdlZC5cIik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm9uKEMuRVZFTlRfVFlQRS5MSUdIVF9TVFJVQ1RVUkVfQ0hBTkdFRCwgZnVuY3Rpb24gKC8qZXZlbnQqLykge1xuICAgICAgICAgICAgdGhpcy5saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyRmFjdG9yeS5zZXRMaWdodFN0cnVjdHVyZURpcnR5KCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIkxpZ2h0IHN0cnVjdHVyZSBjaGFuZ2VkLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub24oQy5FVkVOVF9UWVBFLkxJR0hUX1ZBTFVFX0NIQU5HRUQsIGZ1bmN0aW9uIChsaWdodCkge1xuICAgICAgICAgICAgdGhpcy5saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2hhZGVyRmFjdG9yeS5zZXRMaWdodFZhbHVlQ2hhbmdlZCgpO1xuICAgICAgICAgICAgdGhpcy5saWdodHMubGlnaHRWYWx1ZUNoYW5nZWQobGlnaHQpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RSZWRyYXcoXCJMaWdodCB2YWx1ZSBjaGFuZ2VkLlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgICB0aGlzLm9uKEMuRVZFTlRfVFlQRS5TQ0VORV9TSEFQRV9DSEFOR0VELCBmdW5jdGlvbiAoLyogZXZlbnQgKi8pIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gdXBkYXRlIGxpZ2h0IGZydXN0dW0uIERlZmVyIHRoaXMgdW50aWwgdGhlIG5leHQgcmVuZGVyIHBoYXNlXG4gICAgICAgICAgICAvLyBUT0RPKGtzb25zKSBPbmx5IGxpZ2h0IGZydXN0dW0gYW5kIHNoYWRvdyBtYXBzIG5lZWQgdXBkYXRlLCBub3QgdGhlIHdob2xlIHNjZW5lXG4gICAgICAgICAgICAgdGhpcy5saWdodHNOZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgT3B0aW9ucy5hZGRPYnNlcnZlcih0aGlzLm9uRmxhZ3NDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgfSxcblxuICAgIGFkZENoaWxkRXZlbnQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PSBDLk5PREVfVFlQRS5PQkpFQ1QpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChjaGlsZCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQucmVxdWVzdFJlZHJhdyhcIk9iamVjdCB3YXMgYWRkZWQgdG8gc2NlbmUuXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHJlbW92ZUNoaWxkRXZlbnQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PSBDLk5PREVfVFlQRS5PQkpFQ1QpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgICAgIGNoaWxkLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KFwiT2JqZWN0IHdhcyByZW1vdmVkIGZyb20gc2NlbmUuXCIpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGhhbmRsZVJlc2l6ZUV2ZW50OiBmdW5jdGlvbiAoLyp3aWR0aCwgaGVpZ2h0Ki8pIHtcbiAgICAgICAgdGhpcy5nZXRBY3RpdmVWaWV3KCkuc2V0UHJvamVjdGlvbkRpcnR5KCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZURyYXdhYmxlOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdhYmxlRmFjdG9yeS5jcmVhdGVEcmF3YWJsZShvYmosIHRoaXMuY29udGV4dCk7XG4gICAgfSxcblxuICAgIHJlcXVlc3RSZWRyYXc6IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5yZXF1ZXN0UmVkcmF3KHJlYXNvbik7XG4gICAgfSxcblxuICAgIG9uRmxhZ3NDaGFuZ2U6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChGTEFHU1trZXldICYmIEZMQUdTW2tleV0ucmVjb21waWxlT25DaGFuZ2UpXG4gICAgICAgICAgICB0aGlzLnNoYWRlckZhY3Rvcnkuc2V0U2hhZGVyUmVjb21waWxlKCk7XG4gICAgICAgIGlmIChrZXkgPT0gT1BUSU9OX0ZSVVNUVU1fQ1VMTElORykge1xuICAgICAgICAgICAgdGhpcy5kb0ZydXN0dW1DdWxsaW5nID0gISF2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBHTFNjZW5lO1xuXG4iLCJ2YXIgU2hhZGVyVXRpbHMgPSByZXF1aXJlKFwiLi9zaGFkZXItdXRpbHMuanNcIik7XG52YXIgU2hhZGVyRGVzY3JpcHRvciA9IHJlcXVpcmUoXCIuLi9tYXRlcmlhbHMvdXJuL3NoYWRlci1kZXNjcmlwdG9yLmpzXCIpO1xudmFyIFVSTlNoYWRlckNsb3N1cmUgPSByZXF1aXJlKFwiLi4vbWF0ZXJpYWxzL3Vybi91cm5zaGFkZXJjbG9zdXJlLmpzXCIpO1xuXG52YXIgUHJvZ3JhbUZhY3RvcnkgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5wcm9ncmFtcyA9IHtcbiAgICAgICAgZmFsbGJhY2s6IG51bGwsIHBpY2tpbmc6IHtcbiAgICAgICAgICAgIGlkOiBudWxsLCBub3JtYWw6IG51bGwsIHBvc2l0aW9uOiBudWxsXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuWE1MM0QuZXh0ZW5kKFByb2dyYW1GYWN0b3J5LnByb3RvdHlwZSwge1xuXG4gICAgZ2V0UHJvZ3JhbUJ5TmFtZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHNjcmlwdERlc2NyaXB0b3IgPSBYTUwzRC5tYXRlcmlhbHMuZ2V0U2NyaXB0KG5hbWUpO1xuICAgICAgICBpZiAoIXNjcmlwdERlc2NyaXB0b3IgfHwgIXNjcmlwdERlc2NyaXB0b3IudmVydGV4KSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlVua25vd24gc2hhZGVyOiBcIiwgbmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVzY3JpcHRvciA9IG5ldyBTaGFkZXJEZXNjcmlwdG9yKCk7XG4gICAgICAgIFhNTDNELmV4dGVuZChkZXNjcmlwdG9yLCBzY3JpcHREZXNjcmlwdG9yKTtcbiAgICAgICAgZGVzY3JpcHRvci5mcmFnbWVudCA9IFNoYWRlclV0aWxzLmFkZEZyYWdtZW50U2hhZGVySGVhZGVyKGRlc2NyaXB0b3IuZnJhZ21lbnQpO1xuICAgICAgICB2YXIgc2hhZGVyID0gbmV3IFVSTlNoYWRlckNsb3N1cmUodGhpcy5jb250ZXh0LCBkZXNjcmlwdG9yKTtcbiAgICAgICAgc2hhZGVyLmNyZWF0ZVNvdXJjZXMoe30sIG51bGwsIG51bGwpO1xuICAgICAgICBzaGFkZXIuY29tcGlsZSgpO1xuICAgICAgICByZXR1cm4gc2hhZGVyO1xuICAgIH0sXG5cbiAgICBnZXRGYWxsYmFja1Byb2dyYW06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2dyYW1zLmZhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IG5ldyBTaGFkZXJEZXNjcmlwdG9yKCk7XG4gICAgICAgICAgICBYTUwzRC5leHRlbmQoZGVzY3JpcHRvciwgWE1MM0QubWF0ZXJpYWxzLmdldFNjcmlwdChcIm1hdHRlXCIpKTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3IuZnJhZ21lbnQgPSBTaGFkZXJVdGlscy5hZGRGcmFnbWVudFNoYWRlckhlYWRlcihkZXNjcmlwdG9yLmZyYWdtZW50KTtcbiAgICAgICAgICAgIHZhciBzaGFkZXIgPSBuZXcgVVJOU2hhZGVyQ2xvc3VyZSh0aGlzLmNvbnRleHQsIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgc2hhZGVyLnVuaWZvcm1Db2xsZWN0aW9uLmVudkJhc2UuZGlmZnVzZUNvbG9yID0gWzEsIDAsIDBdO1xuICAgICAgICAgICAgc2hhZGVyLmNyZWF0ZVNvdXJjZXMoe30sIG51bGwsIG51bGwpO1xuICAgICAgICAgICAgc2hhZGVyLmNvbXBpbGUoKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXMuZmFsbGJhY2sgPSBzaGFkZXI7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW1zLmZhbGxiYWNrLmJpbmQoKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbXMuZmFsbGJhY2suc2V0VW5pZm9ybVZhcmlhYmxlcyhbXCJkaWZmdXNlQ29sb3JcIl0sIG51bGwsIHtlbnZCYXNlOiB7ZGlmZnVzZUNvbG9yOiBbMSwgMCwgMF19fSk7XG4gICAgICAgICAgICB0aGlzLnByb2dyYW1zLmZhbGxiYWNrLnVuYmluZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnByb2dyYW1zLmZhbGxiYWNrO1xuICAgIH0sXG5cbiAgICBnZXRQaWNraW5nT2JqZWN0SWRQcm9ncmFtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwaWNraW5nID0gdGhpcy5wcm9ncmFtcy5waWNraW5nO1xuICAgICAgICBpZiAoIXBpY2tpbmcuaWQpIHtcbiAgICAgICAgICAgIHBpY2tpbmcuaWQgPSB0aGlzLmdldFByb2dyYW1CeU5hbWUoXCJwaWNrb2JqZWN0aWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBpY2tpbmcuaWQ7XG4gICAgfSxcblxuICAgIGdldFBpY2tpbmdQb3NpdGlvblByb2dyYW06IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBpY2tpbmcgPSB0aGlzLnByb2dyYW1zLnBpY2tpbmc7XG4gICAgICAgIGlmICghcGlja2luZy5wb3NpdGlvbikge1xuICAgICAgICAgICAgcGlja2luZy5wb3NpdGlvbiA9IHRoaXMuZ2V0UHJvZ3JhbUJ5TmFtZShcInBpY2tlZHBvc2l0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNraW5nLnBvc2l0aW9uO1xuICAgIH0sXG5cbiAgICBnZXRQaWNraW5nTm9ybWFsUHJvZ3JhbTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGlja2luZyA9IHRoaXMucHJvZ3JhbXMucGlja2luZztcbiAgICAgICAgaWYgKCFwaWNraW5nLm5vcm1hbCkge1xuICAgICAgICAgICAgcGlja2luZy5ub3JtYWwgPSB0aGlzLmdldFByb2dyYW1CeU5hbWUoXCJwaWNrZWROb3JtYWxzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaWNraW5nLm5vcm1hbDtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2dyYW1GYWN0b3J5O1xuXG4iLCJ2YXIgRlJBR01FTlRfSEVBREVSID0gW1wiI2lmZGVmIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXCIsIFwicHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1wiLCBcIiNlbHNlXCIsIFwicHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XCIsIFwiI2VuZGlmIC8vIEdMX0ZSQUdNRU5UX1BSRUNJU0lPTl9ISUdIXCIsIFwiXFxuXCJdLmpvaW4oXCJcXG5cIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGFkZEZyYWdtZW50U2hhZGVySGVhZGVyOiBmdW5jdGlvbiAoZnJhZ21lbnRTaGFkZXJTb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIEZSQUdNRU5UX0hFQURFUiArIGZyYWdtZW50U2hhZGVyU291cmNlO1xuICAgIH1cbn07XG4iLCJ2YXIgU3lzdGVtTm90aWZpZXIgPSB7XG4gICAgbm9kZTogbnVsbCxcblxuICAgIHNldE5vZGU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgfSxcblxuICAgIHNlbmRFdmVudDogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBkYXRhLnN5c3RlbXR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KCd4bWwzZHN5c3RlbScsIHRydWUsIHRydWUsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy5ub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeXN0ZW1Ob3RpZmllcjtcbiIsInZhciBYQyA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xuXG5mdW5jdGlvbiBjb252ZXJ0VG9KU0FycmF5KHZhbHVlKSB7XG4gICAgdmFyIGpzQXJyYXkgPSBbdmFsdWUubGVuZ3RoXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGpzQXJyYXlbaV0gPSB2YWx1ZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGpzQXJyYXk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtHTENvbnRleHR9IGNvbnRleHRcbiAqIEBwYXJhbSB7VWludDMyQXJyYXl9IGRhdGFcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhJbmRleFxuICovXG52YXIgY3JlYXRlRWxlbWVudEJ1ZmZlciA9IGZ1bmN0aW9uIChjb250ZXh0LCBkYXRhLCBtYXhJbmRleCkge1xuICAgIHZhciBnbCA9IGNvbnRleHQuZ2w7XG4gICAgdmFyIGJ1ZmZlckRhdGEgPSBkYXRhO1xuICAgIHZhciBnbFR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XG5cbiAgICBpZiAobWF4SW5kZXggPCAoMSA8PCA4KSkge1xuICAgICAgICBnbFR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xuICAgICAgICBidWZmZXJEYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgfSBlbHNlIGlmIChtYXhJbmRleCA8ICgxIDw8IDE2KSkge1xuICAgICAgICBnbFR5cGUgPSBnbC5VTlNJR05FRF9TSE9SVDtcbiAgICAgICAgYnVmZmVyRGF0YSA9IG5ldyBVaW50MTZBcnJheShkYXRhKTtcbiAgICB9IGVsc2UgaWYgKCFjb250ZXh0LmV4dGVuc2lvbnNbXCJPRVNfZWxlbWVudF9pbmRleF91aW50XCJdKSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiVHJ5aW5nIHRvIHVzZSBpbmRleCBkYXRhIHdpdGggaW5kaWNlcyBsYXJnZXIgdGhhbiA2NTUzNSwgYnV0IHRoaXMgaXMgbm90IHN1cHBvcnRlZCBvbiB5b3VyIHBsYXRmb3JtLiBJbmRleGluZyBlcnJvcnMgd2lsbCBvY2N1ci5cIik7XG4gICAgICAgIGdsVHlwZSA9IGdsLlVOU0lHTkVEX1NIT1JUO1xuICAgICAgICBidWZmZXJEYXRhID0gbmV3IFVpbnQxNkFycmF5KGRhdGEpO1xuICAgIH1cblxuICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGJ1ZmZlckRhdGEsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICBidWZmZXIuYnl0ZXNQZXJFbGVtZW50ID0gYnVmZmVyRGF0YS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICBidWZmZXIubGVuZ3RoID0gZGF0YS5sZW5ndGg7XG4gICAgYnVmZmVyLmdsVHlwZSA9IGdsVHlwZTtcbiAgICByZXR1cm4gYnVmZmVyO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0dMQ29udGV4dH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqL1xudmFyIGNyZWF0ZUFycmF5QnVmZmVyID0gZnVuY3Rpb24gKGNvbnRleHQsIGRhdGEpIHtcbiAgICB2YXIgZ2wgPSBjb250ZXh0LmdsO1xuXG4gICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgYnVmZmVyLmxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgIGJ1ZmZlci5nbFR5cGUgPSBnZXRHTFR5cGVGcm9tQXJyYXkoZGF0YSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn07XG5cbnZhciBnZXRHTFR5cGVGcm9tQXJyYXkgPSBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgR0wgPSB3aW5kb3cuV2ViR0xSZW5kZXJpbmdDb250ZXh0O1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIEdMLkJZVEU7XG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgICAgcmV0dXJuIEdMLlVOU0lHTkVEX0JZVEU7XG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSlcbiAgICAgICAgcmV0dXJuIEdMLlNIT1JUO1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5KVxuICAgICAgICByZXR1cm4gR0wuVU5TSUdORURfU0hPUlQ7XG4gICAgaWYgKGFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSlcbiAgICAgICAgcmV0dXJuIEdMLklOVDtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBVaW50MzJBcnJheSlcbiAgICAgICAgcmV0dXJuIEdMLlVOU0lHTkVEX0lOVDtcbiAgICBpZiAoYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpXG4gICAgICAgIHJldHVybiBHTC5GTE9BVDtcbiAgICByZXR1cm4gR0wuRkxPQVQ7XG59O1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldEdMVW5pZm9ybVZhbHVlRnJvbVhmbG93RGF0YUVudHJ5OiBmdW5jdGlvbiAoeGZsb3dEYXRhRW50cnksIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHZhbHVlO1xuICAgICAgICBpZiAoIXhmbG93RGF0YUVudHJ5KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh4Zmxvd0RhdGFFbnRyeS50eXBlID09IFhDLkRBVEFfVFlQRS5URVhUVVJFKSB7XG4gICAgICAgICAgICB2YXIgd2ViZ2xEYXRhID0gY29udGV4dC5nZXRYZmxvd0VudHJ5V2ViR2xEYXRhKHhmbG93RGF0YUVudHJ5KTtcbiAgICAgICAgICAgIHZhciB0ZXh0dXJlID0gd2ViZ2xEYXRhLnRleHR1cmUgfHwgY29udGV4dC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICBpZiAod2ViZ2xEYXRhLmNoYW5nZWQpXG4gICAgICAgICAgICAgICAgdGV4dHVyZS51cGRhdGVGcm9tVGV4dHVyZUVudHJ5KHhmbG93RGF0YUVudHJ5KTtcblxuICAgICAgICAgICAgd2ViZ2xEYXRhLnRleHR1cmUgPSB0ZXh0dXJlO1xuICAgICAgICAgICAgd2ViZ2xEYXRhLmNoYW5nZWQgPSAwO1xuICAgICAgICAgICAgdmFsdWUgPSBbdGV4dHVyZV07XG4gICAgICAgIH0gZWxzZSBpZiAoeGZsb3dEYXRhRW50cnkudHlwZSA9PSBYQy5EQVRBX1RZUEUuQk9PTCkge1xuICAgICAgICAgICAgLy9UT0RPIENhbiB3ZSBnZXQgWGZsb3cgdG8gcmV0dXJuIGJvb2xlYW4gYXJyYXlzIGFzIG5vcm1hbCBKUyBhcnJheXM/IFdlYkdMIGRvZXNuJ3QgYWNjZXB0IFVpbnQ4QXJyYXlzIGhlcmUuLi5cbiAgICAgICAgICAgIC8vVE9ETyBBbHRlcm5hdGl2ZWx5IHdlIGNvdWxkIHNldCBib29sZWFuIHVuaWZvcm1zIHVzaW5nIHVuaWZvcm0xZnYgdG9nZXRoZXIgd2l0aCBGbG9hdDMyQXJyYXlzLCB3aGljaCBhcHBhcmVudGx5IHdvcmtzIHRvb1xuICAgICAgICAgICAgdmFsdWUgPSBjb252ZXJ0VG9KU0FycmF5KHhmbG93RGF0YUVudHJ5LmdldFZhbHVlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSB4Zmxvd0RhdGFFbnRyeS5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICBnZXRHTEJ1ZmZlckZyb21YZmxvd0RhdGFFbnRyeTogZnVuY3Rpb24gKHhmbG93RGF0YUVudHJ5LCBjb250ZXh0LCBlbGVtZW50QnVmZmVyKSB7XG4gICAgICAgIHZhciB3ZWJnbERhdGEgPSBjb250ZXh0LmdldFhmbG93RW50cnlXZWJHbERhdGEoeGZsb3dEYXRhRW50cnkpO1xuICAgICAgICB2YXIgYnVmZmVyID0gd2ViZ2xEYXRhLmJ1ZmZlcjtcbiAgICAgICAgdmFyIGdsID0gY29udGV4dC5nbDtcblxuICAgICAgICAvLyBBbHNvIHdyaXRlIG1pbiBhbmQgbWF4IHZhbHVlcyBmb3IgZWxlbWVudEJ1ZmZlcnNcbiAgICAgICAgaWYgKHdlYmdsRGF0YS5jaGFuZ2VkICYmIGVsZW1lbnRCdWZmZXIpIHtcbiAgICAgICAgICAgIHZhciBpbmRleFZhbHVlID0geGZsb3dEYXRhRW50cnkuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIHZhciBtaW5JbmRleCA9IDEwMDAwMDAwMCwgbWF4SW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIGkgPSBpbmRleFZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IE1hdGgubWluKG1pbkluZGV4LCBpbmRleFZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICBtYXhJbmRleCA9IE1hdGgubWF4KG1heEluZGV4LCBpbmRleFZhbHVlW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdlYmdsRGF0YS5tYXhJbmRleCA9IG1heEluZGV4O1xuICAgICAgICAgICAgd2ViZ2xEYXRhLm1pbkluZGV4ID0gbWluSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvL25vaW5zcGVjdGlvbiBGYWxsdGhyb3VnaEluU3dpdGNoU3RhdGVtZW50SlNcbiAgICAgICAgc3dpdGNoICh3ZWJnbERhdGEuY2hhbmdlZCkge1xuICAgICAgICAgICAgY2FzZSBYQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfVkFMVUU6XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlckRhdGEgPSB4Zmxvd0RhdGFFbnRyeS5nZXRWYWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGJ1ZmZlci5nbFR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgZ2wuVU5TSUdORURfQllURTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJEYXRhID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX1NIT1JUOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlckRhdGEgPSBuZXcgVWludDE2QXJyYXkoYnVmZmVyRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIGdsLlVOU0lHTkVEX0lOVDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHdoYXQgd2UgZXhwZWN0IGFueXdheVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlVua25vd24gR0wgdHlwZSBmb3IgZWxlbWVudCBidWZmZXI6IFwiLCBidWZmZXIuZ2xUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCAwLCBidWZmZXJEYXRhKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYnVmZmVyU3ViRGF0YShnbC5BUlJBWV9CVUZGRVIsIDAsIHhmbG93RGF0YUVudHJ5LmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgWEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX05FVzpcbiAgICAgICAgICAgIGNhc2UgWEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1NJWkU6XG4gICAgICAgICAgICBjYXNlIFhDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFX1RZUEU6XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnRCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gY3JlYXRlRWxlbWVudEJ1ZmZlcihjb250ZXh0LCB4Zmxvd0RhdGFFbnRyeS5nZXRWYWx1ZSgpLCB3ZWJnbERhdGEubWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGNyZWF0ZUFycmF5QnVmZmVyKGNvbnRleHQsIHhmbG93RGF0YUVudHJ5LmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBidWZmZXIudHVwbGVTaXplID0geGZsb3dEYXRhRW50cnkuZ2V0VHVwbGVTaXplKCk7XG4gICAgICAgICAgICAgICAgd2ViZ2xEYXRhLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHdlYmdsRGF0YS5jaGFuZ2VkID0gMDtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGJvdW5kaW5nIGJveCBmcm9tIHBvc2l0aW9ucyBhbmQgb3B0aW9uYWwgaW5kaWNlc1xuICAgICAqIFRPRE86IFJlbW92ZSBGbG9hdEFycmF5IGNyZWF0aW9uXG4gICAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IHBvc2l0aW9uc1xuICAgICAqIEBwYXJhbSB7SW50MTZBcnJheXxudWxsfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHtGbG9hdDMyQXJyYXl9XG4gICAgICovXG4gICAgY2FsY3VsYXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uIChwb3NpdGlvbnMsIGluZGV4KSB7XG4gICAgICAgIHZhciBib3ggPSBuZXcgWE1MM0QuQm94KCksIGk7XG5cbiAgICAgICAgaWYgKCFwb3NpdGlvbnMgfHwgcG9zaXRpb25zLmxlbmd0aCA8IDMpXG4gICAgICAgICAgICByZXR1cm4gYm94O1xuXG4gICAgICAgIHZhciBiYm94ID0gYm94LmRhdGE7XG5cbiAgICAgICAgaWYgKGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgaTAgPSBpbmRleFswXSAqIDM7XG4gICAgICAgICAgICBiYm94WzBdID0gcG9zaXRpb25zW2kwXTtcbiAgICAgICAgICAgIGJib3hbMV0gPSBwb3NpdGlvbnNbaTAgKyAxXTtcbiAgICAgICAgICAgIGJib3hbMl0gPSBwb3NpdGlvbnNbaTAgKyAyXTtcbiAgICAgICAgICAgIGJib3hbM10gPSBwb3NpdGlvbnNbaTBdO1xuICAgICAgICAgICAgYmJveFs0XSA9IHBvc2l0aW9uc1tpMCArIDFdO1xuICAgICAgICAgICAgYmJveFs1XSA9IHBvc2l0aW9uc1tpMCArIDJdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAxOyBpIDwgaW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgaTEgPSBpbmRleFtpXSAqIDM7XG4gICAgICAgICAgICAgICAgdmFyIHAxID0gcG9zaXRpb25zW2kxXTtcbiAgICAgICAgICAgICAgICB2YXIgcDIgPSBwb3NpdGlvbnNbaTEgKyAxXTtcbiAgICAgICAgICAgICAgICB2YXIgcDMgPSBwb3NpdGlvbnNbaTEgKyAyXTtcblxuICAgICAgICAgICAgICAgIGlmIChwMSA8IGJib3hbMF0pXG4gICAgICAgICAgICAgICAgICAgIGJib3hbMF0gPSBwMTtcbiAgICAgICAgICAgICAgICBpZiAocDIgPCBiYm94WzFdKVxuICAgICAgICAgICAgICAgICAgICBiYm94WzFdID0gcDI7XG4gICAgICAgICAgICAgICAgaWYgKHAzIDwgYmJveFsyXSlcbiAgICAgICAgICAgICAgICAgICAgYmJveFsyXSA9IHAzO1xuICAgICAgICAgICAgICAgIGlmIChwMSA+IGJib3hbM10pXG4gICAgICAgICAgICAgICAgICAgIGJib3hbM10gPSBwMTtcbiAgICAgICAgICAgICAgICBpZiAocDIgPiBiYm94WzRdKVxuICAgICAgICAgICAgICAgICAgICBiYm94WzRdID0gcDI7XG4gICAgICAgICAgICAgICAgaWYgKHAzID4gYmJveFs1XSlcbiAgICAgICAgICAgICAgICAgICAgYmJveFs1XSA9IHAzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmJveFswXSA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICAgIGJib3hbMV0gPSBwb3NpdGlvbnNbMV07XG4gICAgICAgICAgICBiYm94WzJdID0gcG9zaXRpb25zWzJdO1xuICAgICAgICAgICAgYmJveFszXSA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICAgIGJib3hbNF0gPSBwb3NpdGlvbnNbMV07XG4gICAgICAgICAgICBiYm94WzVdID0gcG9zaXRpb25zWzJdO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAzOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1tpXSA8IGJib3hbMF0pXG4gICAgICAgICAgICAgICAgICAgIGJib3hbMF0gPSBwb3NpdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMV0gPCBiYm94WzFdKVxuICAgICAgICAgICAgICAgICAgICBiYm94WzFdID0gcG9zaXRpb25zW2kgKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb25zW2kgKyAyXSA8IGJib3hbMl0pXG4gICAgICAgICAgICAgICAgICAgIGJib3hbMl0gPSBwb3NpdGlvbnNbaSArIDJdO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbaV0gPiBiYm94WzNdKVxuICAgICAgICAgICAgICAgICAgICBiYm94WzNdID0gcG9zaXRpb25zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbnNbaSArIDFdID4gYmJveFs0XSlcbiAgICAgICAgICAgICAgICAgICAgYmJveFs0XSA9IHBvc2l0aW9uc1tpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uc1tpICsgMl0gPiBiYm94WzVdKVxuICAgICAgICAgICAgICAgICAgICBiYm94WzVdID0gcG9zaXRpb25zW2kgKyAyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm94O1xuICAgIH1cbn07XG4iLCJ2YXIgRHJhd2FibGVDbG9zdXJlID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3NjZW5lL2RyYXdhYmxlY2xvc3VyZS5qc1wiKTtcbnZhciBHTE1lc2ggPSByZXF1aXJlKFwiLi4vYmFzZS9tZXNoLmpzXCIpO1xudmFyIFhmbG93VXRpbHMgPSByZXF1aXJlKFwiLi91dGlscy5qc1wiKTtcbnZhciBFVkVOVF9UWVBFID0gcmVxdWlyZShcIi4uLy4uL3JlbmRlcmVyL3NjZW5lL2NvbnN0YW50cy5qc1wiKS5FVkVOVF9UWVBFO1xudmFyIE1hdGVyaWFsRXZlbnRzID0gcmVxdWlyZShcIi4uL21hdGVyaWFscy9ldmVudHMuanNcIik7XG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vLi4veGZsb3cvaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcbnZhciBDb21wdXRlUmVxdWVzdCA9IHJlcXVpcmUoXCIuLi8uLi8uLi94Zmxvdy9pbnRlcmZhY2UvcmVxdWVzdC5qc1wiKS5Db21wdXRlUmVxdWVzdDtcblxudmFyIENIQU5HRV9TVEFURSA9IHtcbiAgICBOT1RISU5HX0NIQU5HRUQ6IDAsXG4gICAgU1RSVUNUVVJFX0NIQU5HRUQ6IDEsXG4gICAgVFlQRV9EQVRBX0NIQU5HRUQ6IDIsXG4gICAgVlNfREFUQV9DSEFOR0VEOiA0LFxuICAgIFRZUEVfQ0hBTkdFRDogMiArIDEsXG4gICAgVlNfQ0hBTkdFRDogNCArIDEsXG4gICAgU0hBREVSX0NIQU5HRUQ6IDMyXG59O1xudmFyIFNIQURFUl9DTE9TVVJFX05FRURTX1VQREFURSA9IENIQU5HRV9TVEFURS5TVFJVQ1RVUkVfQ0hBTkdFRCB8IENIQU5HRV9TVEFURS5TSEFERVJfQ0hBTkdFRDtcblxudmFyIFJFQURZX1NUQVRFID0gRHJhd2FibGVDbG9zdXJlLlJFQURZX1NUQVRFO1xuXG5cbnZhciBNRVNIX1BBUkFNRVRFUlMgPSB7fTtcblxuTUVTSF9QQVJBTUVURVJTW1dlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVNdID0ge1xuICAgIGF0dHJpYnV0ZURhdGE6IHtcInBvc2l0aW9uXCI6IFhDLkRBVEFfVFlQRS5GTE9BVDN9LCB0eXBlRGF0YToge1xuICAgICAgICBcImluZGV4XCI6IFhDLkRBVEFfVFlQRS5JTlQsIFwic29saWRcIjogWEMuREFUQV9UWVBFLkJPT0wsIFwidmVydGV4Q291bnRcIjogWEMuREFUQV9UWVBFLklOVFxuICAgIH0sIGJib3hGaXg6IHtcbiAgICAgICAgXCJib3VuZGluZ0JveFwiOiBYQy5EQVRBX1RZUEUuRkxPQVQzXG4gICAgfSwgYmJveENvbXB1dGU6IHtcbiAgICAgICAgXCJwb3NpdGlvblwiOiBYQy5EQVRBX1RZUEUuRkxPQVQzXG4gICAgfVxufTtcbk1FU0hfUEFSQU1FVEVSU1tXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORV9TVFJJUF0gPSBNRVNIX1BBUkFNRVRFUlNbV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFU107XG5NRVNIX1BBUkFNRVRFUlNbV2ViR0xSZW5kZXJpbmdDb250ZXh0LkxJTkVTXSA9IE1FU0hfUEFSQU1FVEVSU1tXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTXTtcbk1FU0hfUEFSQU1FVEVSU1tXZWJHTFJlbmRlcmluZ0NvbnRleHQuUE9JTlRTXSA9IE1FU0hfUEFSQU1FVEVSU1tXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTXTtcbk1FU0hfUEFSQU1FVEVSU1tXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVfU1RSSVBdID0gTUVTSF9QQVJBTUVURVJTW1dlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVNdO1xuXG5cbi8qKlxuICogQ2xhc3MgdGhhdCBzeW5jaHJvbml6ZXMgZGF0YSBjaGFuZ2VzIGZyb20gWGZsb3cgd2l0aCBhIEdMTWVzaCBpbnN0YW5jZVxuICpcbiAqIEBwYXJhbSB7R0xDb250ZXh0fSBjb250ZXh0XG4gKiBAcGFyYW0ge1hmbG93LkRhdGFOb2RlfSBkYXRhTm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRcbiAqIEBleHRlbmRzIHtEcmF3YWJsZUNsb3N1cmV9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFhmbG93TWVzaCA9IGZ1bmN0aW9uIChjb250ZXh0LCBkYXRhTm9kZSwgdHlwZSwgb3B0KSB7XG4gICAgRHJhd2FibGVDbG9zdXJlLmNhbGwodGhpcywgY29udGV4dCwgRHJhd2FibGVDbG9zdXJlLlRZUEVTLk1FU0gpO1xuICAgIG9wdCA9IG9wdCB8fCB7fTtcbiAgICB0aGlzLm1lc2ggPSBuZXcgR0xNZXNoKGNvbnRleHQsIHR5cGUpO1xuXG4gICAgLyoqXG4gICAgICogRGF0YSBOb2RlIG9mIHRoZSByZW5kZXJPYmplY3RcbiAgICAgKiBAdHlwZSB7WGZsb3cuRGF0YU5vZGV9XG4gICAgICovXG4gICAgdGhpcy5kYXRhTm9kZSA9IGRhdGFOb2RlO1xuXG4gICAgLyoqXG4gICAgICogU2hhZGVyIENvbXBvc2VyIHRoYXQgd2lsbCBwcm92aWRlIFNoYWRlckNsb3N1cmUgYW5kIFByb2dyYW1cbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RTaGFkZXJDb21wb3Nlcn1cbiAgICAgKi9cbiAgICB0aGlzLnNoYWRlckNvbXBvc2VyID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFNoYWRlciBDbG9zdXJlIHVzZWQgYnkgdGhpcyBtZXNoXG4gICAgICogQHR5cGUge0Fic3RyYWN0U2hhZGVyQ2xvc3VyZX1cbiAgICAgKi9cbiAgICB0aGlzLnNoYWRlckNsb3N1cmUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQXR0cmlidXRlcyByZXF1aXJlZCB0byBjcmVhdGUgdGhlIEdMTWVzaFxuICAgICAqIEB0eXBlIHtDb21wdXRlUmVxdWVzdH1cbiAgICAgKi9cbiAgICB0aGlzLnR5cGVSZXF1ZXN0ID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEFyZSBhbGwgYXR0cmlidXRlcyByZXF1aXJlZCBieSBkcmF3YWJsZSBhdmFpbGFibGU/XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy50eXBlRGF0YVZhbGlkID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEF0dHJpYnV0ZXMgYW5kIHVuaWZvcm1zIHZhbHVlcyBmb3IgdGhlIHNoYWRlclxuICAgICAqIEB0eXBlIHtYZmxvdy5SZXF1ZXN0fVxuICAgICAqL1xuICAgIHRoaXMub2JqZWN0U2hhZGVyUmVxdWVzdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBCaXRmaWVsZCB0aGF0IHJlY29yZHMgdGhlIGNoYW5nZXMgcmVwb3J0ZWQgYnkgWGZsb3dcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2VTdGF0ZSA9IENIQU5HRV9TVEFURS5TVFJVQ1RVUkVfQ0hBTkdFRDtcblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGlmIGJvdW5kaW5nIGJveCBoYXMgY2hhbmdlZC4gR2V0cyBvbmx5IGNhbGxlZCBpZlxuICAgICAqIHRoaXMuYm91bmRpbmdCb3hSZXF1aXJlZCBpcyB0cnVlLlxuICAgICAqIEB0eXBlIHsqfGZ1bmN0aW9uKEZsb2F0MzJBcnJheSl9XG4gICAgICovXG4gICAgdGhpcy5ib3VuZGluZ0JveENoYW5nZWQgPSBvcHQuYm91bmRpbmdCb3hDaGFuZ2VkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICB9O1xuXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG59O1xuXG5YTUwzRC5jcmVhdGVDbGFzcyhYZmxvd01lc2gsIERyYXdhYmxlQ2xvc3VyZSwge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50eXBlRGF0YUNoYW5nZWQodGhpcy50eXBlUmVxdWVzdCwgWEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcbiAgICAgICAgdGhpcy5zaGFkZXJDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIHNldFNoYWRlckNvbXBvc2VyOiBmdW5jdGlvbiAoc2hhZGVyQ29tcG9zZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJpbmRlZFNoYWRlckNoYW5nZWQpIHRoaXMuYmluZGVkU2hhZGVyQ2hhbmdlZCA9IHRoaXMuc2hhZGVyQ2hhbmdlZC5iaW5kKHRoaXMpO1xuXG4gICAgICAgIGlmICh0aGlzLnNoYWRlckNvbXBvc2VyKVxuICAgICAgICAgICAgdGhpcy5zaGFkZXJDb21wb3Nlci5yZW1vdmVMaXN0ZW5lcihNYXRlcmlhbEV2ZW50cy5NQVRFUklBTF9TVFJVQ1RVUkVfQ0hBTkdFRCwgdGhpcy5iaW5kZWRTaGFkZXJDaGFuZ2VkKTtcblxuICAgICAgICB0aGlzLnNoYWRlckNvbXBvc2VyID0gc2hhZGVyQ29tcG9zZXI7XG4gICAgICAgIGlmICh0aGlzLnNoYWRlckNvbXBvc2VyKVxuICAgICAgICAgICAgdGhpcy5zaGFkZXJDb21wb3Nlci5vbihNYXRlcmlhbEV2ZW50cy5NQVRFUklBTF9TVFJVQ1RVUkVfQ0hBTkdFRCwgdGhpcy5iaW5kZWRTaGFkZXJDaGFuZ2VkKTtcblxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlIHw9IENIQU5HRV9TVEFURS5TSEFERVJfQ0hBTkdFRDtcbiAgICB9LFxuXG4gICAgdXBkYXRlOiBmdW5jdGlvbiAoc2NlbmUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hhbmdlU3RhdGUgPT09IENIQU5HRV9TVEFURS5OT1RISU5HX0NIQU5HRUQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIlVwZGF0ZSBtZXNoIGNsb3N1cmVcIiwgdGhpcy5jaGFuZ2VTdGF0ZSk7XG5cbiAgICAgICAgdmFyIG9sZFZhbGlkID0gISF0aGlzLnNoYWRlckNsb3N1cmUgJiYgdGhpcy50eXBlRGF0YVZhbGlkLCBzb21lRXJyb3IgPSBudWxsLCB0eXBlRGF0YVJlc29sdmVkID0gZmFsc2U7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5nZVN0YXRlICYgU0hBREVSX0NMT1NVUkVfTkVFRFNfVVBEQVRFKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNoLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5nZVN0YXRlICYgQ0hBTkdFX1NUQVRFLlRZUEVfQ0hBTkdFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVHlwZURhdGEoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHlwZURhdGFSZXNvbHZlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5nZVN0YXRlICYgKFNIQURFUl9DTE9TVVJFX05FRURTX1VQREFURSB8IENIQU5HRV9TVEFURS5UWVBFX0NIQU5HRUQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVJbmRleEJ1ZmZlcigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jaGFuZ2VTdGF0ZSAmIFNIQURFUl9DTE9TVVJFX05FRURTX1VQREFURSkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlT2JqZWN0U2hhZGVyUmVxdWVzdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2hhZGVyQ2xvc3VyZShzY2VuZSk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVPYmplY3RTaGFkZXJEYXRhKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hhbmdlU3RhdGUgJiBDSEFOR0VfU1RBVEUuVlNfQ0hBTkdFRCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlT2JqZWN0U2hhZGVyRGF0YSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhTm9kZS5pc1N1YnRyZWVMb2FkaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlckNsb3N1cmUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZURhdGFWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBzb21lRXJyb3IgPSBlO1xuICAgICAgICAgICAgaWYgKCF0eXBlRGF0YVJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHRoaXMudHlwZURhdGFWYWxpZCA9IGZhbHNlOyBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkZXJDbG9zdXJlID0gbnVsbDtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgdmFyIG5ld1ZhbGlkID0gISF0aGlzLnNoYWRlckNsb3N1cmUgJiYgdGhpcy50eXBlRGF0YVZhbGlkO1xuXG4gICAgICAgIGlmIChvbGRWYWxpZCAhPSBuZXdWYWxpZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KEVWRU5UX1RZUEUuRFJBV0FCTEVfU1RBVEVfQ0hBTkdFRCxcbiAgICAgICAgICAgICAgICBuZXdWYWxpZCA/IFJFQURZX1NUQVRFLkNPTVBMRVRFIDogUkVBRFlfU1RBVEUuSU5DT01QTEVURSxcbiAgICAgICAgICAgICAgICBvbGRWYWxpZCA/IFJFQURZX1NUQVRFLkNPTVBMRVRFIDogUkVBRFlfU1RBVEUuSU5DT01QTEVURVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlID0gQ0hBTkdFX1NUQVRFLk5PVEhJTkdfQ0hBTkdFRDtcblxuICAgICAgICBpZiAoc29tZUVycm9yKSB0aHJvdyBzb21lRXJyb3I7XG4gICAgfSxcblxuICAgIGNhbGN1bGF0ZUJvdW5kaW5nQm94OiAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY19lbXB0eSA9IG5ldyBYTUwzRC5Cb3goKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gY29tcHV0ZSBib3VuZGluZyBib3ggZnJvbSBwb3NpdGlvbnMgYW5kIGluZGljZXMsIGlmIHByZXNlbnRcbiAgICAgICAgICAgIHZhciBkYXRhUmVzdWx0ID0gdGhpcy50eXBlUmVxdWVzdC5nZXRSZXN1bHQoKTtcbiAgICAgICAgICAgIHZhciBib3VuZGluZ0JveEVudHJ5ID0gZGF0YVJlc3VsdC5nZXRPdXRwdXREYXRhKFwiYm91bmRpbmdCb3hcIik7XG4gICAgICAgICAgICBpZiAoYm91bmRpbmdCb3hFbnRyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hDaGFuZ2VkKFhmbG93VXRpbHMuY2FsY3VsYXRlQm91bmRpbmdCb3goYm91bmRpbmdCb3hFbnRyeS5nZXRWYWx1ZSgpLCBudWxsKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBvc2l0aW9uRW50cnkgPSBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEoXCJwb3NpdGlvblwiKTtcbiAgICAgICAgICAgIGlmICghcG9zaXRpb25FbnRyeSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYm91bmRpbmdCb3hDaGFuZ2VkKGNfZW1wdHkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpbmRleEVudHJ5ID0gZGF0YVJlc3VsdC5nZXRPdXRwdXREYXRhKFwiaW5kZXhcIik7XG4gICAgICAgICAgICB0aGlzLmJvdW5kaW5nQm94Q2hhbmdlZChYZmxvd1V0aWxzLmNhbGN1bGF0ZUJvdW5kaW5nQm94KHBvc2l0aW9uRW50cnkuZ2V0VmFsdWUoKSwgaW5kZXhFbnRyeSA/IGluZGV4RW50cnkuZ2V0VmFsdWUoKSA6IG51bGwpKTtcbiAgICAgICAgfVxuICAgIH0oKSksIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb21wdXRlUmVxdWVzdH0gcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7WEMuUkVTVUxUX1NUQVRFfSBzdGF0ZVxuICAgICAqL1xuICAgIHR5cGVEYXRhQ2hhbmdlZDogZnVuY3Rpb24gKHJlcXVlc3QsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUgfD0gc3RhdGUgPT0gWEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFID8gQ0hBTkdFX1NUQVRFLlNUUlVDVFVSRV9DSEFOR0VEIDogQ0hBTkdFX1NUQVRFLlRZUEVfREFUQV9DSEFOR0VEO1xuICAgICAgICB0aGlzLmVtaXQoRVZFTlRfVFlQRS5TQ0VORV9TSEFQRV9DSEFOR0VEKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RSZWRyYXcoXCJNZXNoIFR5cGUgRGF0YSBDaGFuZ2VcIik7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiWGZsb3dNZXNoOiBUeXBlIGRhdGEgY2hhbmdlZFwiLCByZXF1ZXN0LCBzdGF0ZSwgdGhpcy5jaGFuZ2VTdGF0ZSk7XG4gICAgfSxcblxuICAgIGdldE1lc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzaDtcbiAgICB9LFxuXG4gICAgZ2V0TWVzaFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzaC5nbFR5cGU7XG4gICAgfSxcblxuICAgIHVwZGF0ZU9iamVjdFNoYWRlclJlcXVlc3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JqZWN0U2hhZGVyUmVxdWVzdCkgdGhpcy5vYmplY3RTaGFkZXJSZXF1ZXN0LmNsZWFyKCk7XG4gICAgICAgIHRoaXMub2JqZWN0U2hhZGVyUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzLmRhdGFOb2RlLmlzU3VidHJlZUxvYWRpbmcoKSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QgPSB0aGlzLnNoYWRlckNvbXBvc2VyLmNyZWF0ZU9iamVjdERhdGFSZXF1ZXN0KHRoaXMuZGF0YU5vZGUsIHRoaXMuc2hhZGVySW5wdXREYXRhQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlU2hhZGVyQ2xvc3VyZTogZnVuY3Rpb24gKHNjZW5lKSB7XG4gICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZSA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5kYXRhTm9kZS5pc1N1YnRyZWVMb2FkaW5nKCkgJiYgIXRoaXMuZGF0YU5vZGUuZ2V0T3V0cHV0Q2hhbm5lbEluZm8oXCJwb3NpdGlvblwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWVzaCBkb2VzIG5vdCBoYXZlICdwb3NpdGlvbicgYXR0cmlidXRlLlwiKTtcbiAgICAgICAgICAgIC8vWE1MM0QuZGVidWcubG9nRXJyb3IoXCJNZXNoIGRvZXMgbm90IGhhdmUgJ3Bvc2l0aW9uJyBhdHRyaWJ1dGUuXCIsIHRoaXMubWVzaCwgdGhpcy5nZXRNZXNoVHlwZSgpKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5kYXRhTm9kZS5pc1N1YnRyZWVMb2FkaW5nKCkpIHtcbiAgICAgICAgICAgIHZhciBvYmplY3RTaGFkZXJSZXN1bHQgPSB0aGlzLm9iamVjdFNoYWRlclJlcXVlc3QuZ2V0UmVzdWx0KCk7XG4gICAgICAgICAgICBpZiAoIW9iamVjdFNoYWRlclJlc3VsdC5sb2FkaW5nKVxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZGVyQ2xvc3VyZSA9IHRoaXMuc2hhZGVyQ29tcG9zZXIuZ2V0U2hhZGVyQ2xvc3VyZShzY2VuZSwgdGhpcy5vYmplY3RTaGFkZXJSZXF1ZXN0KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVJbmRleEJ1ZmZlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBBZGQgSW5kZXggYnVmZmVyLCBpZiBhdmFpbGFibGVcbiAgICAgICAgdmFyIGRhdGFSZXN1bHQgPSB0aGlzLnR5cGVSZXF1ZXN0LmdldFJlc3VsdCgpO1xuICAgICAgICB2YXIgZW50cnkgPSBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEoXCJpbmRleFwiKTtcbiAgICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5LmdldFZhbHVlKCkpXG4gICAgICAgICAgICB0aGlzLmhhbmRsZUJ1ZmZlcihcImluZGV4XCIsIGVudHJ5LCB0cnVlKTtcbiAgICB9LFxuXG4gICAgdXBkYXRlT2JqZWN0U2hhZGVyRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2hhZGVyQ2xvc3VyZSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBpZiBvbmx5IHRoZSBkYXRhIGhhcyBjaGFuZ2VkLCBpdCBjYW4ndCBnZXQgdmFsaWQgYWZ0ZXIgdXBkYXRlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuYmluZGVkSGFuZGxlQnVmZmVyKSB0aGlzLmJpbmRlZEhhbmRsZUJ1ZmZlciA9IHRoaXMuaGFuZGxlQnVmZmVyLmJpbmQodGhpcyk7XG4gICAgICAgIGlmICghdGhpcy5iaW5kZWRIYW5kbGVVbmlmb3JtKSB0aGlzLmJpbmRlZEhhbmRsZVVuaWZvcm0gPSB0aGlzLmhhbmRsZVVuaWZvcm0uYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLnNoYWRlckNvbXBvc2VyLmRpc3RyaWJ1dGVPYmplY3RTaGFkZXJEYXRhKHRoaXMub2JqZWN0U2hhZGVyUmVxdWVzdCwgdGhpcy5iaW5kZWRIYW5kbGVCdWZmZXIsIHRoaXMuYmluZGVkSGFuZGxlVW5pZm9ybSk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm1lc2guaXNSZWFkeVRvUmVuZGVyKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1lc2ggaGFzIGVtcHR5IHZlcnRleCBhdHRyaWJ1dGVzLlwiKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGRhdGVUeXBlRGF0YTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMudHlwZURhdGFWYWxpZCAmJiAhKHRoaXMuY2hhbmdlU3RhdGUgJiBDSEFOR0VfU1RBVEUuU1RSVUNUVVJFX0NIQU5HRUQpKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG9ubHkgaWYgc3RydWN0dXJlIGhhcyBjaGFuZ2VkLCBpdCBjYW4ndCBnZXQgdmFsaWQgYWZ0ZXIgdXBkYXRlXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZVR5cGVSZXF1ZXN0KCk7XG5cbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIHZhciBkYXRhUmVzdWx0ID0gdGhpcy50eXBlUmVxdWVzdC5nZXRSZXN1bHQoKTtcblxuICAgICAgICB2YXIgZW50cnkgPSBkYXRhUmVzdWx0LmdldE91dHB1dERhdGEoXCJ2ZXJ0ZXhDb3VudFwiKTtcbiAgICAgICAgdGhpcy5tZXNoLnNldFZlcnRleENvdW50KGVudHJ5ICYmIGVudHJ5LmdldFZhbHVlKCkgPyBlbnRyeS5nZXRWYWx1ZSgpIDogbnVsbCk7XG4gICAgICAgIHRoaXMudHlwZURhdGFWYWxpZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtYZmxvdy5CdWZmZXJFbnRyeX0geGZsb3dEYXRhRW50cnlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc0luZGV4XG4gICAgICovXG4gICAgaGFuZGxlQnVmZmVyOiBmdW5jdGlvbiAobmFtZSwgeGZsb3dEYXRhRW50cnksIGlzSW5kZXgpIHtcbiAgICAgICAgaXNJbmRleCA9IGlzSW5kZXggfHwgZmFsc2U7XG4gICAgICAgIHZhciBtZXNoID0gdGhpcy5tZXNoO1xuXG4gICAgICAgIGlmIChuYW1lID09IFwicG9zaXRpb25cIiAmJiAheGZsb3dEYXRhRW50cnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIidwb3NpdGlvbicgYXR0cmlidXRlIG9mIG1lc2ggaXMgZW1wdHkuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF4Zmxvd0RhdGFFbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5tZXNoLnJlbW92ZUJ1ZmZlcihuYW1lKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh4Zmxvd0RhdGFFbnRyeS50eXBlID09IFhDLkRBVEFfVFlQRS5URVhUVVJFKSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIlRleHR1cmUgYXMgbWVzaCBwYXJhbWV0ZXIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYnVmZmVyID0gWGZsb3dVdGlscy5nZXRHTEJ1ZmZlckZyb21YZmxvd0RhdGFFbnRyeSh4Zmxvd0RhdGFFbnRyeSwgdGhpcy5jb250ZXh0LCBuYW1lID09IFwiaW5kZXhcIik7XG4gICAgICAgIGlmIChpc0luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUluZGV4UmFuZ2UoeGZsb3dEYXRhRW50cnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tZXNoLmNoZWNrQnVmZmVyQ29tcGF0aWJsZShuYW1lLCB4Zmxvd0RhdGFFbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gZXZlcnkgY2FzZSwgc2V0IHRoZSBidWZmZXIsIGJlY2F1c2Ugb3RoZXIgbWVzaGVzIG1pZ2h0IGhhdmUgYWxyZWFkeVxuICAgICAgICAvLyBwZXJmb3JtZWQgb25lIG9yIG1vcmUgb2YgdGhlIHRhc2tzIGFib3ZlXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJTZXQgYnVmZmVyXCIsIG5hbWUsIGJ1ZmZlci5pZCk7XG4gICAgICAgIG1lc2guc2V0QnVmZmVyKG5hbWUsIGJ1ZmZlcik7XG4gICAgfSxcblxuICAgIHVwZGF0ZUluZGV4UmFuZ2U6IGZ1bmN0aW9uICh4Zmxvd0RhdGFFbnRyeSkge1xuICAgICAgICB2YXIgd2ViZ2xEYXRhID0gdGhpcy5jb250ZXh0LmdldFhmbG93RW50cnlXZWJHbERhdGEoeGZsb3dEYXRhRW50cnkpO1xuICAgICAgICB0aGlzLm1lc2guc2V0SW5kZXhSYW5nZSh3ZWJnbERhdGEubWluSW5kZXgsIHdlYmdsRGF0YS5tYXhJbmRleCk7XG4gICAgfSxcblxuICAgIC8qY2hlY2tCdWZmZXJTaXplOiBmdW5jdGlvbihuYW1lLCB4Zmxvd0RhdGFFbnRyeSl7XG4gICAgIGlmKHhmbG93RGF0YUVudHJ5LmdldEl0ZXJhdGVDb3VudCl7XG4gICAgIHZhciBjbnQgPSB4Zmxvd0RhdGFFbnRyeS5nZXRJdGVyYXRlQ291bnQoKTtcbiAgICAgaWYoY250ID49IHRoaXMubWVzaC5tYXhJbmRleClcbiAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW5kZXggcmFuZ2Ugb2YgW1wiICsgdGhpcy5tZXNoLm1pbkluZGV4ICsgXCIsIFwiICsgdGhpcy5tZXNoLm1heEluZGV4ICsgXCJdIFwiICtcbiAgICAgXCIgZ29lcyBiZXlvbmQgZWxlbWVudCBjb3VudCBcIiArIGNudCArIFwiIG9mIGF0dHJpYnV0ZSAnXCIgKyBuYW1lICsgXCInXCIpO1xuICAgICB9XG4gICAgIH0sKi9cblxuICAgIGhhbmRsZVVuaWZvcm06IGZ1bmN0aW9uIChuYW1lLCB4Zmxvd0RhdGFFbnRyeSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBYZmxvd1V0aWxzLmdldEdMVW5pZm9ybVZhbHVlRnJvbVhmbG93RGF0YUVudHJ5KHhmbG93RGF0YUVudHJ5LCB0aGlzLmNvbnRleHQpO1xuICAgICAgICB0aGlzLm1lc2guc2V0VW5pZm9ybU92ZXJyaWRlKG5hbWUsIHZhbHVlKTtcbiAgICB9LCAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHVwZGF0ZVR5cGVSZXF1ZXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtZXNoQ29uZmlnID0gTUVTSF9QQVJBTUVURVJTW3RoaXMuZ2V0TWVzaFR5cGUoKV07XG4gICAgICAgIGlmICghbWVzaENvbmZpZykge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJVbnN1cHBvcnRlZCBNZXNoIHJlcXVlc3Q6IFwiLCB0aGlzLm1lc2gsIHRoaXMuZ2V0TWVzaFR5cGUoKSk7XG4gICAgICAgICAgICB0aGlzLnR5cGVEYXRhVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVxdWVzdE5hbWVzID0gdGhpcy5nZXRUeXBlUmVxdWVzdE5hbWVzKG1lc2hDb25maWcpO1xuXG4gICAgICAgIGlmICghdGhpcy50eXBlUmVxdWVzdCB8fCB0aGlzLnR5cGVSZXF1ZXN0LmZpbHRlciAhPSByZXF1ZXN0TmFtZXMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGVSZXF1ZXN0KSB0aGlzLnR5cGVSZXF1ZXN0LmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLnR5cGVSZXF1ZXN0ID0gbmV3IENvbXB1dGVSZXF1ZXN0KHRoaXMuZGF0YU5vZGUsIHJlcXVlc3ROYW1lcywgdGhpcy50eXBlRGF0YUNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VHlwZVJlcXVlc3ROYW1lczogZnVuY3Rpb24gKG1lc2hDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcXVlc3ROYW1lcyA9IFtdO1xuICAgICAgICByZXF1ZXN0TmFtZXMucHVzaC5hcHBseShyZXF1ZXN0TmFtZXMsIE9iamVjdC5rZXlzKG1lc2hDb25maWcudHlwZURhdGEpKTtcbiAgICAgICAgLy8gV2UgYWx3YXlzIHJlcXVlc3QgZml4ZWQgYm91bmRpbmcgYm94IHZhbHVlczogdGhhdCB3YXkgd2UgY2FuIHJlYWN0LCB3aGVuIHRob3NlIHZhbHVlcyBnZXQgYXZhaWxhYmxlXG4gICAgICAgIHJlcXVlc3ROYW1lcy5wdXNoLmFwcGx5KHJlcXVlc3ROYW1lcywgT2JqZWN0LmtleXMobWVzaENvbmZpZy5iYm94Rml4KSk7XG4gICAgICAgIHZhciBjb21wdXRlQkJveCA9ICF0aGlzLmNoZWNrWGZsb3dUeXBlcyh0aGlzLmRhdGFOb2RlLCBtZXNoQ29uZmlnLmJib3hGaXgpO1xuXG4gICAgICAgIGlmIChjb21wdXRlQkJveCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNoZWNrWGZsb3dUeXBlcyh0aGlzLmRhdGFOb2RlLCBtZXNoQ29uZmlnLmJib3hDb21wdXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHlwZURhdGFWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdE5hbWVzLnB1c2guYXBwbHkocmVxdWVzdE5hbWVzLCBPYmplY3Qua2V5cyhtZXNoQ29uZmlnLmJib3hDb21wdXRlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcXVlc3ROYW1lcztcbiAgICB9LFxuXG4gICAgY2hlY2tYZmxvd1R5cGVzOiBmdW5jdGlvbiAoZGF0YU5vZGUsIHJlcXVpcmVtZW50cykge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHJlcXVpcmVtZW50cykge1xuICAgICAgICAgICAgdmFyIGluZm8gPSBkYXRhTm9kZS5nZXRPdXRwdXRDaGFubmVsSW5mbyhuYW1lKTtcbiAgICAgICAgICAgIGlmICghaW5mbykgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGluZm8udHlwZSAhPSByZXF1aXJlbWVudHNbbmFtZV0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0NvbXB1dGVSZXF1ZXN0fSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtYQy5SRVNVTFRfU1RBVEV9IHN0YXRlXG4gICAgICovXG4gICAgc2hhZGVySW5wdXREYXRhQ2hhbmdlZDogZnVuY3Rpb24gKHJlcXVlc3QsIHN0YXRlKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlU3RhdGUgfD0gc3RhdGUgIT0gWEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9WQUxVRSA/IENIQU5HRV9TVEFURS5TVFJVQ1RVUkVfQ0hBTkdFRCA6IENIQU5HRV9TVEFURS5WU19EQVRBX0NIQU5HRUQ7XG4gICAgICAgIC8vIFRPRE86IFdlIGRvbid0IGtub3cgaWYgdGhlIGNoYW5nZSBvZiBkYXRhIG9ubHkgaW5mbHVlbmNlcyB0aGUgc3VyZmFjZSBzaGFkaW5nIG9yIHRoZSBhY3R1YWwgbWVzaCBzaGFwZVxuICAgICAgICB0aGlzLmVtaXQoRVZFTlRfVFlQRS5TQ0VORV9TSEFQRV9DSEFOR0VEKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlcXVlc3RSZWRyYXcoXCJNZXNoIEF0dHJpYnV0ZSBEYXRhIENoYW5nZWRcIik7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiWGZsb3dNZXNoOiBBdHRyaWJ1dGUgZGF0YSBjaGFuZ2VkXCIsIHJlcXVlc3QsIHN0YXRlLCB0aGlzLmNoYW5nZVN0YXRlKTtcbiAgICB9LFxuXG4gICAgc2hhZGVyQ2hhbmdlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNoYW5nZVN0YXRlIHw9IENIQU5HRV9TVEFURS5TSEFERVJfQ0hBTkdFRDtcbiAgICB9LFxuXG4gICAgZ2V0UHJvZ3JhbTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXJDbG9zdXJlO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gWGZsb3dNZXNoO1xuXG4iLCJ2YXIgdmVjNCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjNDtcbnZhciBWZWMzID0gcmVxdWlyZShcIi4vdmVjMy5qc1wiKTtcblxudmFyIEF4aXNBbmdsZSA9IGZ1bmN0aW9uKHZlYykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgQXhpc0FuZ2xlKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZlYzQuY3JlYXRlKCk7XG4gICAgICAgIGlmICh2ZWMpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQodmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYyk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgcmV0dXJuIG5ldyBBeGlzQW5nbGUodmVjKTtcbn07XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEF4aXNBbmdsZS5wcm90b3R5cGUsIFwiYXhpc1wiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih2ZWMpe1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB2ZWMuZGF0YSA/IHZlYy5kYXRhWzBdIDogdmVjWzBdO1xuICAgICAgICB0aGlzLmRhdGFbMV0gPSB2ZWMuZGF0YSA/IHZlYy5kYXRhWzFdIDogdmVjWzFdO1xuICAgICAgICB0aGlzLmRhdGFbMl0gPSB2ZWMuZGF0YSA/IHZlYy5kYXRhWzJdIDogdmVjWzJdO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gVmVjMy53cmFwKHRoaXMuZGF0YSkgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXhpc0FuZ2xlLnByb3RvdHlwZSwgXCJhbmdsZVwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbihhKXtcbiAgICAgICAgdGhpcy5kYXRhWzNdID0gYTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVszXTsgfVxufSk7XG5cbkF4aXNBbmdsZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgQXhpc0FuZ2xlKHRoaXMpO1xufTtcblxuQXhpc0FuZ2xlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6LCBhbmdsZSkge1xuICAgIHJldHVybiBuZXcgQXhpc0FuZ2xlKHZlYzQuZnJvbVZhbHVlcyh4LHkseixhbmdsZSkpO1xufTtcblxuQXhpc0FuZ2xlLmZyb21RdWF0ID0gZnVuY3Rpb24ocSkge1xuICAgIHZhciBvdXQgPSBuZXcgQXhpc0FuZ2xlKCk7XG4gICAgb3V0LmRhdGEuc2V0KFhNTDNELm1hdGgudmVjNC5mcm9tUXVhdChxLmRhdGEgPyBxLmRhdGEgOiBxKSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbkF4aXNBbmdsZS5wcm90b3R5cGUudG9ET01TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmVjNC50b0RPTVN0cmluZyh0aGlzLmRhdGEpO1xufTtcblxuQXhpc0FuZ2xlLmZyb21ET01TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEF4aXNBbmdsZSgpO1xuICAgIG91dC5kYXRhLnNldCggdmVjNC5mcm9tRE9NU3RyaW5nKHN0cikgKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuQXhpc0FuZ2xlLnByb3RvdHlwZS50b1F1YXQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcbiAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQuZGF0YSwgdGhpcy5kYXRhLCB0aGlzLmRhdGFbM10pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5BeGlzQW5nbGUud3JhcCA9IGZ1bmN0aW9uKHZlYykge1xuICAgIHZhciB2ID0gQXhpc0FuZ2xlKCk7XG4gICAgdi5kYXRhID0gdmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYztcbiAgICByZXR1cm4gdjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpc0FuZ2xlO1xuIiwidmFyIFZlYzMgPSByZXF1aXJlKFwiLi92ZWMzLmpzXCIpO1xudmFyIHZlYzMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzM7XG5cbnZhciBCb3ggPSBmdW5jdGlvbihib3gpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIEJveCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDYpO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc2V0KGJveC5kYXRhID8gYm94LmRhdGEgOiBib3gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRFbXB0eSgpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHJldHVybiBuZXcgQm94KGJveCk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQm94LnByb3RvdHlwZSwgXCJtaW5cIiwge1xuICAgIHNldDogZnVuY3Rpb24odil7XG4gICAgICAgIHZhciB2YWwgPSB2LmRhdGEgPyB2LmRhdGEgOiB2O1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB2YWxbMF07XG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IHZhbFsxXTtcbiAgICAgICAgdGhpcy5kYXRhWzJdID0gdmFsWzJdO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gVmVjMy53cmFwKHRoaXMuZGF0YS5zdWJhcnJheSgwLDMpKTtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJveC5wcm90b3R5cGUsIFwibWF4XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xuICAgICAgICB2YXIgdmFsID0gdi5kYXRhID8gdi5kYXRhIDogdjtcbiAgICAgICAgdGhpcy5kYXRhWzNdID0gdmFsWzBdO1xuICAgICAgICB0aGlzLmRhdGFbNF0gPSB2YWxbMV07XG4gICAgICAgIHRoaXMuZGF0YVs1XSA9IHZhbFsyXTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0dXJuIFZlYzMud3JhcCh0aGlzLmRhdGEuc3ViYXJyYXkoMyw2KSk7XG4gICAgfVxufSk7XG5cbkJveC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IEJveCh0aGlzKTtcbn07XG5cbkJveC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdGhpcy5jb3B5TWluKG90aGVyKTtcbiAgICB0aGlzLmNvcHlNYXgob3RoZXIpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuQm94LnByb3RvdHlwZS5jb3B5TWluID0gZnVuY3Rpb24ob3RoZXIpIHtcbiAgICB2ZWMzLmNvcHkodGhpcy5kYXRhLCBvdGhlci5kYXRhID8gb3RoZXIuZGF0YSA6IG90aGVyKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkJveC5wcm90b3R5cGUuY29weU1heCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdmVjMy5jb3B5KHRoaXMuZGF0YS5zdWJhcnJheSgzLDYpLCBvdGhlci5kYXRhID8gb3RoZXIuZGF0YS5zdWJhcnJheSgzLDYpIDogb3RoZXIuc3ViYXJyYXkoMyw2KSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Cb3gucHJvdG90eXBlLmV4dGVuZCA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdmFyIGJveCA9IG90aGVyLmRhdGEgPyBvdGhlci5kYXRhIDogb3RoZXI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgdGhpcy5kYXRhW2ldID0gTWF0aC5taW4oYm94W2ldLCB0aGlzLmRhdGFbaV0pO1xuICAgICAgICB0aGlzLmRhdGFbaSArIDNdID0gTWF0aC5tYXgoYm94W2kgKyAzXSwgdGhpcy5kYXRhW2kgKyAzXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuQm94LnByb3RvdHlwZS5zZXRFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZGF0YVswXSA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgdGhpcy5kYXRhWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLmRhdGFbMl0gPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHRoaXMuZGF0YVszXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHRoaXMuZGF0YVs0XSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHRoaXMuZGF0YVs1XSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuQm94LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLmRhdGFbMF0gPiB0aGlzLmRhdGFbM10gfHwgdGhpcy5kYXRhWzFdID4gdGhpcy5kYXRhWzRdIHx8IHRoaXMuZGF0YVsyXSA+IHRoaXMuZGF0YVs1XSk7XG59O1xuXG5Cb3gucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHZhciBjZW4gPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICBjZW4ueCA9ICh0aGlzLmRhdGFbMF0gKyB0aGlzLmRhdGFbM10pICogMC41O1xuICAgIGNlbi55ID0gKHRoaXMuZGF0YVsxXSArIHRoaXMuZGF0YVs0XSkgKiAwLjU7XG4gICAgY2VuLnogPSAodGhpcy5kYXRhWzJdICsgdGhpcy5kYXRhWzVdKSAqIDAuNTtcbiAgICByZXR1cm4gY2VuO1xufTtcblxuQm94LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIHNpemUgPSB0YXJnZXQgfHwgbmV3IFZlYzMoKTtcbiAgICBzaXplLnggPSBNYXRoLm1heCh0aGlzLmRhdGFbM10gLSB0aGlzLmRhdGFbMF0sIDApO1xuICAgIHNpemUueSA9IE1hdGgubWF4KHRoaXMuZGF0YVs0XSAtIHRoaXMuZGF0YVsxXSwgMCk7XG4gICAgc2l6ZS56ID0gTWF0aC5tYXgodGhpcy5kYXRhWzVdIC0gdGhpcy5kYXRhWzJdLCAwKTtcbiAgICByZXR1cm4gc2l6ZTtcbn07XG5cbkJveC5wcm90b3R5cGUuZXh0ZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2l6ZSgpLnNjYWxlKDAuNSk7XG59O1xuXG5Cb3gucHJvdG90eXBlLnRyYW5zZm9ybUF4aXNBbGlnbmVkID0gZnVuY3Rpb24obWF0KSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSg2KTtcbiAgICB2YXIgbSA9IG1hdC5kYXRhID8gbWF0LmRhdGEgOiBtYXQ7XG4gICAgaWYgKG1bM10gPT0gMCAmJiBtWzddID09IDAgJiYgbVsxMV0gPT0gMCAmJiBtWzE1XSA9PSAxKSB7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IG91dFtpICsgM10gPSBtWzEyICsgaV07XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEsIGI7XG5cbiAgICAgICAgICAgICAgICBhID0gbVtqICogNCArIGldICogdGhpcy5kYXRhW2pdO1xuICAgICAgICAgICAgICAgIGIgPSBtW2ogKiA0ICsgaV0gKiB0aGlzLmRhdGFbaiArIDNdO1xuXG4gICAgICAgICAgICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dFtpXSArPSBhO1xuICAgICAgICAgICAgICAgICAgICBvdXRbaSArIDNdICs9IGI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRbaV0gKz0gYjtcbiAgICAgICAgICAgICAgICAgICAgb3V0W2kgKyAzXSArPSBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEuc2V0KG91dCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXRyaXggaXMgbm90IGFmZmluZVwiKTtcbn07XG5cbkJveC5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24obWF0KSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQodGhpcy5taW4uZGF0YSwgdGhpcy5taW4uZGF0YSwgbWF0LmRhdGEgPyBtYXQuZGF0YSA6IG1hdCk7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQ0KHRoaXMubWF4LmRhdGEsIHRoaXMubWF4LmRhdGEsIG1hdC5kYXRhID8gbWF0LmRhdGEgOiBtYXQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuQm94LnByb3RvdHlwZS5sb25nZXN0U2lkZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIHggPSBNYXRoLmFicyh0aGlzLmRhdGFbM10gLSB0aGlzLmRhdGFbMF0pO1xuICAgIHZhciB5ID0gTWF0aC5hYnModGhpcy5kYXRhWzRdIC0gdGhpcy5kYXRhWzFdKTtcbiAgICB2YXIgeiA9IE1hdGguYWJzKHRoaXMuZGF0YVs1XSAtIHRoaXMuZGF0YVsyXSk7XG4gICAgcmV0dXJuIE1hdGgubWF4KHgsIE1hdGgubWF4KHksIHopKTtcbn07XG5cbkJveC5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uKHJheSwgb3B0KSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIGlmIChvcHQgIT09IHVuZGVmaW5lZCAmJiBvcHQuZGlzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHQuZGlzdCA9IEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIG9yaWdpbiA9IHJheS5vcmlnaW47XG4gICAgdmFyIGRpcmVjdGlvbiA9IHJheS5kaXJlY3Rpb247XG4gICAgdmFyIGludmVyc2VEaXJYID0gMSAvIGRpcmVjdGlvbi54O1xuICAgIHZhciBpbnZlcnNlRGlyWSA9IDEgLyBkaXJlY3Rpb24ueTtcbiAgICB2YXIgaW52ZXJzZURpclogPSAxIC8gZGlyZWN0aW9uLno7XG5cbiAgICB2YXIgdDEgPSAodGhpcy5kYXRhWzBdIC0gb3JpZ2luLngpICogaW52ZXJzZURpclg7XG4gICAgdmFyIHQyID0gKHRoaXMuZGF0YVszXSAtIG9yaWdpbi54KSAqIGludmVyc2VEaXJYO1xuICAgIHZhciB0MyA9ICh0aGlzLmRhdGFbMV0gLSBvcmlnaW4ueSkgKiBpbnZlcnNlRGlyWTtcbiAgICB2YXIgdDQgPSAodGhpcy5kYXRhWzRdIC0gb3JpZ2luLnkpICogaW52ZXJzZURpclk7XG4gICAgdmFyIHQ1ID0gKHRoaXMuZGF0YVsyXSAtIG9yaWdpbi56KSAqIGludmVyc2VEaXJaO1xuICAgIHZhciB0NiA9ICh0aGlzLmRhdGFbNV0gLSBvcmlnaW4ueikgKiBpbnZlcnNlRGlyWjtcblxuICAgIHZhciB0bWluID0gTWF0aC5tYXgoTWF0aC5tYXgoTWF0aC5taW4odDEsIHQyKSwgTWF0aC5taW4odDMsIHQ0KSksIE1hdGgubWluKHQ1LCB0NikpO1xuICAgIHZhciB0bWF4ID0gTWF0aC5taW4oTWF0aC5taW4oTWF0aC5tYXgodDEsIHQyKSwgTWF0aC5tYXgodDMsIHQ0KSksIE1hdGgubWF4KHQ1LCB0NikpO1xuXG4gICAgaWYgKG9wdCA9PT0gdW5kZWZpbmVkIHx8IG9wdC5kaXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRtYXggPiAwICYmIHRtaW4gPD0gdG1heDtcbiAgICB9XG5cbiAgICBpZiAodG1heCA8IDAgfHwgdG1pbiA+IHRtYXgpIHtcbiAgICAgICAgb3B0LmRpc3QgPSBJbmZpbml0eTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIG9wdC5kaXN0ID0gdG1pbjtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkJveC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ1hNTDNELkJveCgnICsgdGhpcy5kYXRhWzBdICsgJywgJyArIHRoaXMuZGF0YVsxXSArICcsICcgKyB0aGlzLmRhdGFbMl0gKyAnLCAnICsgdGhpcy5kYXRhWzNdICsgJywgJyArXG4gICAgICAgIHRoaXMuZGF0YVs0XSArICcsICcgKyB0aGlzLmRhdGFbNV0gKyAnKSc7XG59O1xuXG5Cb3guRU1QVFlfQk9YID0gbmV3IEJveCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJveDtcbiIsInZhciBYQyA9IHJlcXVpcmUoXCIuLi94Zmxvdy9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xudmFyIFJlc291cmNlID0gcmVxdWlyZShcIi4uL2Jhc2UvcmVzb3VyY2VtYW5hZ2VyLmpzXCIpLlJlc291cmNlO1xuXG52YXIgY19YZmxvd09ic2VydmVyTGlzdCA9IFtdO1xuXG52YXIgWE1MM0REYXRhT2JzZXJ2ZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMub2JzZXJ2ZWQgPSBbXTtcbn07XG5cblhNTDNERGF0YU9ic2VydmVyLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24obm9kZSwgb3B0aW9ucyl7XG4gICAgaWYoIW5vZGUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBub2RlIHRvIG9ic2VydmUgaXMgbnVsbC5cIik7XG5cblxuICAgIGlmKCFub2RlLl9jb25maWd1cmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3RlIHRvIG9ic2VydmUgaXMgbm90ICAgKHlldCkuIE1ha2Ugc3VyZSB0byBwYXNzIGFuIFhNTDNEIG5vZGUgYW5kIHRvIGV4ZWN1dGUgXCIgK1xuICAgICAgICAgICAgXCJ0aGlzIGZ1bmN0aW9uIGFmdGVyIFhNTDNEIGhhcyBiZWVuIGNvbmZpZ3VyZWQgZS5nLiBpbnNpZGUgYSBET01Db250ZW50TG9hZGVkIGxpc3RlbmVyLlwiKTtcblxuXG4gICAgdmFyIGRhdGFBZGFwdGVyID0gUmVzb3VyY2UuZ2V0QWRhcHRlcihub2RlLCBcImRhdGFcIik7XG4gICAgaWYoIWRhdGFBZGFwdGVyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBvYnNlcnZlIG5vZGUuIFhNTDNEYXRhT2JzZXJ2ZXIgY2FuIG9ubHkgb2JzZXJ2ZSBkYXRhIGNvbnRhaW5lcnMgc3VjaCBhcyA8ZGF0YT4sIDxtZXNoPiBvciA8c2hhZGVyPlwiKTtcblxuICAgIGlmKHRoaXMub2JzZXJ2ZWQubGVuZ3RoID09IDApXG4gICAgICAgIGNfWGZsb3dPYnNlcnZlckxpc3QucHVzaCh0aGlzKTtcblxuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgY2hhbmdlZDogZmFsc2UsXG4gICAgICAgIHJlcXVlc3Q6IG51bGxcbiAgICB9O1xuXG4gICAgdmFyIG5hbWVzID0gb3B0aW9ucyAmJiBvcHRpb25zWyduYW1lcyddO1xuICAgIHZhciB0eXBlT2ZOYW1lcyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuYW1lcykuc2xpY2UoOCwgLTEpO1xuICAgIGlmICh0eXBlT2ZOYW1lcyA9PT0gXCJTdHJpbmdcIikge1xuICAgICAgICBuYW1lcyA9IFtuYW1lc107XG4gICAgfVxuXG4gICAgZW50cnkucmVxdWVzdCA9IGRhdGFBZGFwdGVyLmdldENvbXB1dGVSZXF1ZXN0KG5hbWVzLCBmdW5jdGlvbihyZXF1ZXN0LCBjaGFuZ2VUeXBlKXtcbiAgICAgICAgZW50cnkuY2hhbmdlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgLy8gRmV0Y2ggcmVzdWx0IHRvIHN5bmNocm9uaXplIFhmbG93IHN0cnVjdHVyZXMgYW5kIGNvbm5lY3QgdG8gY2FsbGJhY2tzXG4gICAgLy8gVE9ETzogRmluZCBhbiBvcHRpb24gdG8gY29ubmVjdCByZXF1ZXN0IHRvIGNhbGxiYWNrIHN0cnVjdHVyZSB3aXRob3V0IGNvbXB1dGluZyByZXN1bHRcbiAgICBlbnRyeS5yZXF1ZXN0LmdldFJlc3VsdCgpO1xuXG4gICAgdGhpcy5vYnNlcnZlZC5wdXNoKGVudHJ5KTtcbn07XG5cblhNTDNERGF0YU9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5vYnNlcnZlZC5sZW5ndGg7ICsraSl7XG4gICAgICAgIHRoaXMub2JzZXJ2ZWRbaV0ucmVxdWVzdC5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLm9ic2VydmVkID0gW107XG4gICAgdmFyIGkgPSBjX1hmbG93T2JzZXJ2ZXJMaXN0Lmxlbmd0aDtcbiAgICB3aGlsZShpLS0pe1xuICAgICAgICBpZihjX1hmbG93T2JzZXJ2ZXJMaXN0W2ldID09IHRoaXMpXG4gICAgICAgICAgICBjX1hmbG93T2JzZXJ2ZXJMaXN0LnNwbGljZShpLCAxKTtcbiAgICB9XG59O1xuXG5cblhNTDNELnVwZGF0ZVhmbG93T2JzZXJ2ZXIgPSBmdW5jdGlvbigpe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjX1hmbG93T2JzZXJ2ZXJMaXN0Lmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIG9ic2VydmVyID0gY19YZmxvd09ic2VydmVyTGlzdFtpXTtcbiAgICAgICAgdmFyIHJlY29yZHMgPSBbXTtcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IG9ic2VydmVyLm9ic2VydmVkLmxlbmd0aDsgKytqKXtcbiAgICAgICAgICAgIHZhciBlbnRyeSA9IG9ic2VydmVyLm9ic2VydmVkW2pdO1xuICAgICAgICAgICAgaWYoZW50cnkuY2hhbmdlZCl7XG4gICAgICAgICAgICAgICAgZW50cnkuY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBlbnRyeS5yZXF1ZXN0LmdldFJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhUmVzdWx0ID0gbmV3IFhNTDNERGF0YVJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIHJlY29yZHMucHVzaCggbmV3IFhNTDNERGF0YVJlY29yZChlbnRyeS5ub2RlLCBkYXRhUmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYocmVjb3Jkcy5sZW5ndGggPiAwICYmIG9ic2VydmVyLmNhbGxiYWNrKXtcbiAgICAgICAgICAgIG9ic2VydmVyLmNhbGxiYWNrKHJlY29yZHMsIG9ic2VydmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciBYTUwzRERhdGFSZWNvcmQgPSBmdW5jdGlvbih0YXJnZXQsIHJlc3VsdCl7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5yZXN1bHQgPSByZXN1bHQ7XG59O1xuXG5cbnZhciBYTUwzRERhdGFSZXN1bHQgPSBmdW5jdGlvbihyZXN1bHQpe1xuICAgIHRoaXMuX2VudHJpZXMgPSB7fTtcbiAgICBjb25zdHJ1Y3REYXRhUmVzdWx0KHRoaXMsIHJlc3VsdCk7XG59O1xuXG5YTUwzRERhdGFSZXN1bHQucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmICh0aGlzLl9lbnRyaWVzW25hbWVdKVxuICAgICAgICByZXR1cm4gdGhpcy5fZW50cmllc1tuYW1lXS52YWx1ZTtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblhNTDNERGF0YVJlc3VsdC5wcm90b3R5cGUuZ2V0VHlwZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICBpZiAodGhpcy5fZW50cmllc1tuYW1lXSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudHJpZXNbbmFtZV0udHlwZTtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5cblhNTDNERGF0YVJlc3VsdC5wcm90b3R5cGUuZ2V0TmFtZXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IodmFyIG5hbWUgaW4gdGhpcy5fZW50cmllcyl7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuWE1MM0REYXRhUmVzdWx0LkZMT0FUICA9IDA7XG5YTUwzRERhdGFSZXN1bHQuRkxPQVQyID0gMTtcblhNTDNERGF0YVJlc3VsdC5GTE9BVDMgPSAyO1xuWE1MM0REYXRhUmVzdWx0LkZMT0FUNCA9IDM7XG5YTUwzRERhdGFSZXN1bHQuRkxPQVQ0WDQgPSA0O1xuWE1MM0REYXRhUmVzdWx0LklOVCA9IDEwO1xuWE1MM0REYXRhUmVzdWx0LklOVDQgPSAxMTtcblhNTDNERGF0YVJlc3VsdC5CT09MID0gMjA7XG5YTUwzRERhdGFSZXN1bHQuVEVYVFVSRSA9IDMwO1xuWE1MM0REYXRhUmVzdWx0LkJZVEUgPSA0MDtcblhNTDNERGF0YVJlc3VsdC5VQllURSA9IDUwO1xuXG5cbmZ1bmN0aW9uIGNvbnN0cnVjdERhdGFSZXN1bHQoZGF0YVJlc3VsdCwgcmVzdWx0KXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lm91dHB1dE5hbWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIG5hbWUgPSByZXN1bHQub3V0cHV0TmFtZXNbaV07XG4gICAgICAgIHZhciBlbnRyeSA9IHJlc3VsdC5nZXRPdXRwdXREYXRhKG5hbWUpO1xuICAgICAgICB2YXIgdmFsdWUgPSBlbnRyeSAmJiBlbnRyeS5nZXRWYWx1ZSgpO1xuICAgICAgICBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZ2V0WE1MM0REYXRhVHlwZShlbnRyeS50eXBlKTtcbiAgICAgICAgICAgIGRhdGFSZXN1bHQuX2VudHJpZXNbbmFtZV0gPSB7IHR5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZX07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFhNTDNERGF0YVR5cGUodHlwZSl7XG4gICAgc3dpdGNoKHR5cGUpe1xuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5GTE9BVCA6IHJldHVybiBYTUwzRERhdGFSZXN1bHQuRkxPQVQ7XG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkZMT0FUMiA6IHJldHVybiBYTUwzRERhdGFSZXN1bHQuRkxPQVQyO1xuICAgICAgICBjYXNlIFhDLkRBVEFfVFlQRS5GTE9BVDMgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LkZMT0FUMztcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuRkxPQVQ0IDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5GTE9BVDQ7XG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkZMT0FUNFg0IDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5GTE9BVDRYNDtcbiAgICAgICAgY2FzZSBYQy5EQVRBX1RZUEUuSU5UIDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5JTlQ7XG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLklOVDQgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LklOVDQ7XG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkJPT0wgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LkJPT0w7XG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLlRFWFRVUkUgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LlRFWFRVUkU7XG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLkJZVEUgOiByZXR1cm4gWE1MM0REYXRhUmVzdWx0LkJZVEU7XG4gICAgICAgIGNhc2UgWEMuREFUQV9UWVBFLlVCWVRFIDogcmV0dXJuIFhNTDNERGF0YVJlc3VsdC5VQllURTtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKFwiV0hBVCBJUyBUSElTIEkgRE9OJ1QgRVZFTi4uLlwiKTtcbiAgICB9XG59XG5cbnZhciBYTUwzRERhdGFDaGFubmVsSW5mbyA9IGZ1bmN0aW9uKHR5cGUsIG9yaWdpbiwgb3JpZ2luYWxOYW1lLCBzZXFMZW5ndGgsIHNlcU1pbktleSwgc2VxTWF4S2V5KXtcbiAgICB0aGlzLnR5cGUgPSBnZXRYTUwzRERhdGFUeXBlKHR5cGUpO1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luO1xuICAgIHRoaXMub3JpZ2luYWxOYW1lID0gb3JpZ2luYWxOYW1lO1xuICAgIHRoaXMuc2VxTGVuZ3RoID0gc2VxTGVuZ3RoO1xuICAgIHRoaXMuc2VxTWluS2V5ID0gc2VxTWluS2V5O1xuICAgIHRoaXMuc2VxTWF4S2V5ID0gc2VxTWF4S2V5O1xufTtcblxuWE1MM0REYXRhQ2hhbm5lbEluZm8uT1JJR0lOX0NISUxEID0gMTtcblhNTDNERGF0YUNoYW5uZWxJbmZvLk9SSUdJTl9DT01QVVRFID0gMjtcblhNTDNERGF0YUNoYW5uZWxJbmZvLk9SSUdJTl9QUk9UTyA9IDM7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFhNTDNERGF0YUNoYW5uZWxJbmZvOiBYTUwzRERhdGFDaGFubmVsSW5mbyxcbiAgICBYTUwzRERhdGFSZXN1bHQ6IFhNTDNERGF0YVJlc3VsdCxcbiAgICBYTUwzRERhdGFPYnNlcnZlcjogWE1MM0REYXRhT2JzZXJ2ZXJcbn07XG4iLCJ2YXIgbWF0MiA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikubWF0MjtcblxudmFyIE1hdDIgPSBmdW5jdGlvbihtYXQpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIE1hdDIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gbWF0Mi5jcmVhdGUoKTtcbiAgICAgICAgaWYgKG1hdCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNldChtYXQuZGF0YSA/IG1hdC5kYXRhIDogbWF0KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSByZXR1cm4gbmV3IE1hdDIobWF0KTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQyLnByb3RvdHlwZSwgXCJtMTFcIiwge1xuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVswXSA9IHg7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzBdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQyLnByb3RvdHlwZSwgXCJtMTJcIiwge1xuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVsxXSA9IHg7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzFdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQyLnByb3RvdHlwZSwgXCJtMjFcIiwge1xuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVsyXSA9IHg7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzJdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQyLnByb3RvdHlwZSwgXCJtMjJcIiwge1xuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVszXSA9IHg7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzNdOyB9XG59KTtcblxuTWF0Mi5wcm90b3R5cGUuYWRqb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0MigpO1xuICAgIG1hdDIuYWRqb2ludChvdXQuZGF0YSwgdGhpcy5kYXRhKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuTWF0Mi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgTWF0Mih0aGlzKTtcbn07XG5cbk1hdDIucHJvdG90eXBlLmRldGVybWluYW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1hdDIuZGV0ZXJtaW5hbnQodGhpcy5kYXRhKTtcbn07XG5cbk1hdDIucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0MigpO1xuICAgIG1hdDIuaW52ZXJ0KG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQyLnByb3RvdHlwZS5tdWwgPSBNYXQyLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDIoKTtcbiAgICBtYXQyLm11bHRpcGx5KG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQyLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihyYWQpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDIoKTtcbiAgICBtYXQyLnJvdGF0ZShvdXQuZGF0YSwgdGhpcy5kYXRhLCByYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQyLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHZlYykge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0MigpO1xuICAgIG1hdDIuc2NhbGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgdmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDIucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0MigpO1xuICAgIG1hdDIudHJhbnNwb3NlKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQyLndyYXAgPSBmdW5jdGlvbihtYXQpIHtcbiAgICB2YXIgbSA9IE1hdDIoKTtcbiAgICBtLmRhdGEgPSBtYXQuZGF0YSA/IG1hdC5kYXRhIDogbWF0O1xuICAgIHJldHVybiBtO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBNYXQyO1xuIiwidmFyIG1hdDMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLm1hdDM7XG5cbnZhciBNYXQzID0gZnVuY3Rpb24obWF0KSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBNYXQzKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG1hdDMuY3JlYXRlKCk7XG4gICAgICAgIGlmIChtYXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5zZXQobWF0LmRhdGEgPyBtYXQuZGF0YSA6IG1hdCk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgcmV0dXJuIG5ldyBNYXQzKG1hdCk7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTExXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMF0gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVswXTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTEyXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMV0gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxXTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTEzXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMl0gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsyXTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTIxXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbM10gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVszXTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTIyXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbNF0gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVs0XTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTIzXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbNV0gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVs1XTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTMxXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbNl0gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVs2XTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTMyXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbN10gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVs3XTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0My5wcm90b3R5cGUsIFwibTMzXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbOF0gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVs4XTsgfVxufSk7XG5cblxuTWF0My5wcm90b3R5cGUuYWRqb2ludCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0MygpO1xuICAgIG1hdDMuYWRqb2ludChvdXQuZGF0YSwgdGhpcy5kYXRhKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuTWF0My5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgIHJldHVybiBuZXcgTWF0Myh0aGlzKTtcbn07XG5cbk1hdDMucHJvdG90eXBlLmRldGVybWluYW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG1hdDMuZGV0ZXJtaW5hbnQodGhpcy5kYXRhKTtcbn07XG5cbk1hdDMuZnJvbU1hdDQgPSBmdW5jdGlvbihtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBNYXQzKCk7XG4gICAgbWF0My5mcm9tTWF0NChvdXQuZGF0YSwgbS5kYXRhID8gbS5kYXRhIDogbSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDMuZnJvbVF1YXQgPSBmdW5jdGlvbihxKSB7XG4gICAgdmFyIG91dCA9IG5ldyBNYXQzKCk7XG4gICAgbWF0My5mcm9tUXVhdChvdXQuZGF0YSwgcS5kYXRhID8gcS5kYXRhIDogcSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDMucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0MygpO1xuICAgIG1hdDMuaW52ZXJ0KG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQzLnByb3RvdHlwZS5tdWwgPSBNYXQzLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDMoKTtcbiAgICBtYXQzLm11bHRpcGx5KG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQzLm5vcm1hbEZyb21NYXQ0ID0gZnVuY3Rpb24obSkge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0MygpO1xuICAgIG1hdDMubm9ybWFsRnJvbU1hdDQob3V0LmRhdGEsIG0uZGF0YSA/IG0uZGF0YSA6IG0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQzLnByb3RvdHlwZS5yb3RhdGUgPSBmdW5jdGlvbihyYWQpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDMoKTtcbiAgICBtYXQzLnJvdGF0ZShvdXQuZGF0YSwgdGhpcy5kYXRhLCByYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQzLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHZlYykge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0MygpO1xuICAgIG1hdDMuc2NhbGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgdmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDMucHJvdG90eXBlLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0MygpO1xuICAgIG1hdDMudHJhbnNwb3NlKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQzLnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbih2ZWMpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDMoKTtcbiAgICBtYXQzLnRyYW5zbGF0ZShvdXQuZGF0YSwgdGhpcy5kYXRhLCB2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuTWF0My53cmFwID0gZnVuY3Rpb24obWF0KSB7XG4gICAgdmFyIG0gPSBNYXQzKCk7XG4gICAgbS5kYXRhID0gbWF0LmRhdGEgPyBtYXQuZGF0YSA6IG1hdDtcbiAgICByZXR1cm4gbTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0MztcbiIsInZhciBtYXQ0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS5tYXQ0O1xuXG52YXIgTWF0NCA9IGZ1bmN0aW9uKG1hdCkge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgTWF0NCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBtYXQ0LmNyZWF0ZSgpO1xuICAgICAgICBpZiAobWF0KSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc2V0KG1hdC5kYXRhID8gbWF0LmRhdGEgOiBtYXQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHJldHVybiBuZXcgTWF0NChtYXQpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0xMVwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzBdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMF07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0xMlwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzFdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMV07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0xM1wiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzJdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMl07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0xNFwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzNdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbM107IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0yMVwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzRdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbNF07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0yMlwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzVdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbNV07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0yM1wiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzZdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbNl07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0yNFwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzddID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbN107IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0zMVwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzhdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbOF07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0zMlwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzldID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbOV07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm0zM1wiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzEwXSA9IHg7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzEwXTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0NC5wcm90b3R5cGUsIFwibTM0XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMTFdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMTFdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQ0LnByb3RvdHlwZSwgXCJtNDFcIiwge1xuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVsxMl0gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxMl07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hdDQucHJvdG90eXBlLCBcIm00MlwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih4KXsgdGhpcy5kYXRhWzEzXSA9IHg7IH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzEzXTsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTWF0NC5wcm90b3R5cGUsIFwibTQzXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpeyB0aGlzLmRhdGFbMTRdID0geDsgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMTRdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXQ0LnByb3RvdHlwZSwgXCJtNDRcIiwge1xuICAgIHNldDogZnVuY3Rpb24oeCl7IHRoaXMuZGF0YVsxNV0gPSB4OyB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZGF0YVsxNV07IH1cbn0pO1xuXG5NYXQ0LnByb3RvdHlwZS5hZGpvaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XG4gICAgbWF0NC5hZGpvaW50KG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQ0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIG5ldyBNYXQ0KHRoaXMpO1xufTtcblxuTWF0NC5wcm90b3R5cGUuZGV0ZXJtaW5hbnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbWF0NC5kZXRlcm1pbmFudCh0aGlzLmRhdGEpO1xufTtcblxuTWF0NC5mcnVzdHVtID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcbiAgICBtYXQ0LmZydXN0dW0ob3V0LmRhdGEsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuTWF0NC5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XG4gICAgbWF0NC5pbnZlcnQob3V0LmRhdGEsIHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDQubG9va0F0ID0gZnVuY3Rpb24oZXllLCBjZW50ZXIsIHVwKSB7XG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XG4gICAgbWF0NC5sb29rQXQob3V0LmRhdGEsIGV5ZS5kYXRhID8gZXllLmRhdGEgOiBleWUsIGNlbnRlci5kYXRhID8gY2VudGVyLmRhdGEgOiBjZW50ZXIsIHVwLmRhdGEgPyB1cC5kYXRhIDogdXApO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQ0LnByb3RvdHlwZS5tdWwgPSBNYXQ0LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcbiAgICBtYXQ0Lm11bHRpcGx5KG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQ0Lm9ydGhvID0gZnVuY3Rpb24obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcbiAgICBtYXQ0Lm9ydGhvKG91dC5kYXRhLCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDQucGVyc3BlY3RpdmUgPSBmdW5jdGlvbihmb3YsIGFzcGVjdCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XG4gICAgbWF0NC5wZXJzcGVjdGl2ZShvdXQuZGF0YSwgZm92LCBhc3BlY3QsIG5lYXIsIGZhcik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDQucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHJhZCwgYXhpcykge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0NCgpO1xuICAgIG1hdDQucm90YXRlKG91dC5kYXRhLCB0aGlzLmRhdGEsIHJhZCwgYXhpcy5kYXRhID8gYXhpcy5kYXRhIDogYXhpcyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDQucHJvdG90eXBlLnJvdGF0ZVggPSBmdW5jdGlvbihyYWQpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcbiAgICBtYXQ0LnJvdGF0ZVgob3V0LmRhdGEsIHRoaXMuZGF0YSwgcmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuTWF0NC5wcm90b3R5cGUucm90YXRlWSA9IGZ1bmN0aW9uKHJhZCkge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0NCgpO1xuICAgIG1hdDQucm90YXRlWShvdXQuZGF0YSwgdGhpcy5kYXRhLCByYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQ0LnByb3RvdHlwZS5yb3RhdGVaID0gZnVuY3Rpb24ocmFkKSB7XG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XG4gICAgbWF0NC5yb3RhdGVaKG91dC5kYXRhLCB0aGlzLmRhdGEsIHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDQucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24odmVjKSB7XG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XG4gICAgbWF0NC5zY2FsZShvdXQuZGF0YSwgdGhpcy5kYXRhLCB2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuTWF0NC5mcm9tUXVhdCA9IGZ1bmN0aW9uKHEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcbiAgICBtYXQ0LmZyb21RdWF0KG91dC5kYXRhLCBxLmRhdGEgPyBxLmRhdGEgOiBxKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuTWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbiA9IGZ1bmN0aW9uKHEsIHYpIHtcbiAgICB2YXIgb3V0ID0gbmV3IE1hdDQoKTtcbiAgICBtYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKG91dC5kYXRhLCBxLmRhdGEgPyBxLmRhdGEgOiBxLCB2LmRhdGEgPyB2LmRhdGEgOiB2KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuTWF0NC5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBNYXQ0KCk7XG4gICAgbWF0NC50cmFuc3Bvc2Uob3V0LmRhdGEsIHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cbk1hdDQucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHZlYykge1xuICAgIHZhciBvdXQgPSBuZXcgTWF0NCgpO1xuICAgIG1hdDQudHJhbnNsYXRlKG91dC5kYXRhLCB0aGlzLmRhdGEsIHZlYy5kYXRhID8gdmVjLmRhdGEgOiB2ZWMpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5NYXQ0LndyYXAgPSBmdW5jdGlvbihtYXQpIHtcbiAgICB2YXIgbSA9IE1hdDQoKTtcbiAgICBtLmRhdGEgPSBtYXQuZGF0YSA/IG1hdC5kYXRhIDogbWF0O1xuICAgIHJldHVybiBtO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hdDQ7XG4iLCJ2YXIgcXVhdCA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikucXVhdDtcblxudmFyIFF1YXQgPSBmdW5jdGlvbih2ZWMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFF1YXQpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gcXVhdC5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHZlYykge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNldCh2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSByZXR1cm4gbmV3IFF1YXQodmVjKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWF0LnByb3RvdHlwZSwgXCJ4XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpe1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB4O1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzBdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWF0LnByb3RvdHlwZSwgXCJ5XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHkpe1xuICAgICAgICB0aGlzLmRhdGFbMV0gPSB5O1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzFdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWF0LnByb3RvdHlwZSwgXCJ6XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHope1xuICAgICAgICB0aGlzLmRhdGFbMl0gPSB6O1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzJdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShRdWF0LnByb3RvdHlwZSwgXCJ3XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHcpe1xuICAgICAgICB0aGlzLmRhdGFbM10gPSB3O1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzNdOyB9XG59KTtcblxuUXVhdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYikge1xuICAgIHZhciBvdXQgPSBuZXcgUXVhdCgpO1xuICAgIHF1YXQuYWRkKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5RdWF0LnByb3RvdHlwZS5jYWxjdWxhdGVXID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XG4gICAgcXVhdC5jYWxjdWxhdGVXKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5RdWF0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIG5ldyBRdWF0KHRoaXMpO1xufTtcblxuUXVhdC5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XG4gICAgcXVhdC5jb25qdWdhdGUob3V0LmRhdGEsIHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblF1YXQucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGIpIHtcbiAgICByZXR1cm4gcXVhdC5kb3QodGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcbn07XG5cblF1YXQucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgUXVhdCgpO1xuICAgIHF1YXQuaW52ZXJ0KG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5RdWF0LnByb3RvdHlwZS5sZW4gPSBRdWF0LnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhdC5sZW5ndGgodGhpcy5kYXRhKTtcbn07XG5cblF1YXQucHJvdG90eXBlLmxlcnAgPSBmdW5jdGlvbihiLCB0KSB7XG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XG4gICAgcXVhdC5sZXJwKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIsIHQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5RdWF0LnByb3RvdHlwZS5tdWwgPSBRdWF0LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcbiAgICBxdWF0Lm11bChvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuUXVhdC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XG4gICAgcXVhdC5ub3JtYWxpemUob3V0LmRhdGEsIHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblF1YXQucHJvdG90eXBlLnJvdGF0ZVggPSBmdW5jdGlvbihyYWQpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcbiAgICBxdWF0LnJvdGF0ZVgob3V0LmRhdGEsIHRoaXMuZGF0YSwgcmFkKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuUXVhdC5wcm90b3R5cGUucm90YXRlWSA9IGZ1bmN0aW9uKHJhZCkge1xuICAgIHZhciBvdXQgPSBuZXcgUXVhdCgpO1xuICAgIHF1YXQucm90YXRlWShvdXQuZGF0YSwgdGhpcy5kYXRhLCByYWQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5RdWF0LnByb3RvdHlwZS5yb3RhdGVaID0gZnVuY3Rpb24ocmFkKSB7XG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XG4gICAgcXVhdC5yb3RhdGVaKG91dC5kYXRhLCB0aGlzLmRhdGEsIHJhZCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblF1YXQucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBvdXQgPSBuZXcgUXVhdCgpO1xuICAgIHF1YXQuc2NhbGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgcyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblF1YXQuZnJvbUF4aXNBbmdsZSA9IGZ1bmN0aW9uKGF4aXMsIHJhZCkge1xuICAgIHZhciBvdXQgPSBuZXcgUXVhdCgpO1xuICAgIGlmIChyYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBxdWF0LnNldEF4aXNBbmdsZShvdXQuZGF0YSwgYXhpcy5kYXRhID8gYXhpcy5kYXRhIDogYXhpcywgYXhpcy5kYXRhID8gYXhpcy5kYXRhWzNdIDogYXhpc1szXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVhdC5zZXRBeGlzQW5nbGUob3V0LmRhdGEsIGF4aXMuZGF0YSA/IGF4aXMuZGF0YSA6IGF4aXMsIHJhZCk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59O1xuXG5RdWF0LmZyb21CYXNpcyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcbiAgICBYTUwzRC5tYXRoLnF1YXQuc2V0RnJvbUJhc2lzKG91dC5kYXRhLCB4LmRhdGEgPyB4LmRhdGEgOiB4LCB5LmRhdGEgPyB5LmRhdGEgOiB5LCB6LmRhdGEgPyB6LmRhdGEgOiB6KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuUXVhdC5mcm9tTWF0MyA9IGZ1bmN0aW9uKG0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IFF1YXQoKTtcbiAgICBxdWF0LmZyb21NYXQzKG91dC5kYXRhLCBtLmRhdGEgPyBtLmRhdGEgOiBtKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuUXVhdC5mcm9tUm90YXRpb25UbyA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XG4gICAgcXVhdC5yb3RhdGlvblRvKG91dC5kYXRhLCBmcm9tLmRhdGEgPyBmcm9tLmRhdGEgOiBmcm9tLCB0by5kYXRhID8gdG8uZGF0YSA6IHRvKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuUXVhdC5wcm90b3R5cGUuc2xlcnAgPSBmdW5jdGlvbihiLCB0KSB7XG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XG4gICAgcXVhdC5zbGVycChvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiLCB0KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuUXVhdC5wcm90b3R5cGUudG9ET01TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gcXVhdC50b0RPTVN0cmluZyh0aGlzLmRhdGEpO1xufTtcblxuUXVhdC5mcm9tRE9NU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG4gICAgdmFyIG91dCA9IG5ldyBRdWF0KCk7XG4gICAgb3V0LmRhdGEuc2V0KCBxdWF0LmZyb21ET01TdHJpbmcoc3RyKSApO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5RdWF0LndyYXAgPSBmdW5jdGlvbih2ZWMpIHtcbiAgICB2YXIgdiA9IFF1YXQoKTtcbiAgICB2LmRhdGEgPSB2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjO1xuICAgIHJldHVybiB2O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBRdWF0O1xuIiwidmFyIFZlYzMgPSByZXF1aXJlKFwiLi92ZWMzLmpzXCIpO1xudmFyIHZlYzMgPSByZXF1aXJlKFwiZ2wtbWF0cml4XCIpLnZlYzM7XG5cbnZhciBSYXkgPSBmdW5jdGlvbihyYXkpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFJheSkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KDYpO1xuICAgICAgICB0aGlzLmRhdGFbNV0gPSAtMTtcbiAgICAgICAgaWYgKHJheSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNldCggcmF5LmRhdGEgPyByYXkuZGF0YSA6IHJheSApO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSYXkocmF5KTtcbiAgICB9XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmF5LnByb3RvdHlwZSwgXCJvcmlnaW5cIiwge1xuICAgIHNldDogZnVuY3Rpb24odil7XG4gICAgICAgIHZhciB2YWwgPSB2LmRhdGEgPyB2LmRhdGEgOiB2O1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB2YWxbMF07XG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IHZhbFsxXTtcbiAgICAgICAgdGhpcy5kYXRhWzJdID0gdmFsWzJdO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gVmVjMy53cmFwKHRoaXMuZGF0YS5zdWJhcnJheSgwLDMpKTtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJheS5wcm90b3R5cGUsIFwiZGlyZWN0aW9uXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xuICAgICAgICB2YXIgdmFsID0gdi5kYXRhID8gdi5kYXRhIDogdjtcbiAgICAgICAgdmVjMy5ub3JtYWxpemUodmFsLCB2YWwpO1xuICAgICAgICB0aGlzLmRhdGFbM10gPSB2YWxbMF07XG4gICAgICAgIHRoaXMuZGF0YVs0XSA9IHZhbFsxXTtcbiAgICAgICAgdGhpcy5kYXRhWzVdID0gdmFsWzJdO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICByZXR1cm4gVmVjMy53cmFwKHRoaXMuZGF0YS5zdWJhcnJheSgzLDYpKTtcbiAgICB9XG59KTtcblxuUmF5LnByb3RvdHlwZS5zZXRGcm9tT3JpZ2luRGlyZWN0aW9uID0gZnVuY3Rpb24ob3JpZ2luLCBkaXJlY3Rpb24pIHtcbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpbjtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJheS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJheSgpLmNvcHkodGhpcyk7XG59O1xuXG5SYXkucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHRoaXMuY29weU9yaWdpbihvdGhlcik7XG4gICAgdGhpcy5jb3B5RGlyZWN0aW9uKG90aGVyKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblJheS5wcm90b3R5cGUuY29weU9yaWdpbiA9IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgdmVjMy5jb3B5KHRoaXMuZGF0YSwgb3RoZXIuZGF0YSA/IG90aGVyLmRhdGEgOiBvdGhlcik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5SYXkucHJvdG90eXBlLmNvcHlEaXJlY3Rpb24gPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHZlYzMuY29weSh0aGlzLmRhdGEuc3ViYXJyYXkoMyw2KSwgb3RoZXIuZGF0YSA/IG90aGVyLmRhdGEuc3ViYXJyYXkoMyw2KSA6IG90aGVyLnN1YmFycmF5KDMsNikpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuUmF5LnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24oYm94LCBvcHQpIHtcbiAgICByZXR1cm4gYm94LmludGVyc2VjdHModGhpcywgb3B0KTtcbn07XG5cblJheS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJ1hNTDNELlJheShvcmlnaW46ICcgKyB0aGlzLmRhdGFbMF0gKyAnLCAnICsgdGhpcy5kYXRhWzFdICsgJywgJyArIHRoaXMuZGF0YVsyXSArICcsIGRpcmVjdGlvbjogJyArIHRoaXMuZGF0YVszXSArICcsICcgK1xuICAgICAgICB0aGlzLmRhdGFbNF0gKyAnLCAnICsgdGhpcy5kYXRhWzVdICsgJyknO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXk7XG4iLCJ2YXIgdmVjMiA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjMjtcblxudmFyIFZlYzIgPSBmdW5jdGlvbih2ZWMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFZlYzIpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdmVjMi5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHZlYykge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNldCh2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjKTtcbiAgICAgICAgfVxuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH0gZWxzZSByZXR1cm4gbmV3IFZlYzIodmVjKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZWMyLnByb3RvdHlwZSwgXCJ4XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpe1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB4O1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzBdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZWMyLnByb3RvdHlwZSwgXCJ5XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHkpe1xuICAgICAgICB0aGlzLmRhdGFbMV0gPSB5O1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzFdOyB9XG59KTtcblxuVmVjMi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYikge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMigpO1xuICAgIHZlYzIuYWRkKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgVmVjMih0aGlzKTtcbn07XG5cblZlYzIucHJvdG90eXBlLmRpc3QgPSBWZWMyLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2ZWMyLmRpc3QodGhpcy5kYXRhKTtcbn07XG5cblZlYzIucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzIoKTtcbiAgICB2ZWMyLmRpdmlkZShvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjMi5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24oYikge1xuICAgIHJldHVybiB2ZWMyLmRvdCh0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xufTtcblxuVmVjMi5mcm9tVmFsdWVzID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiBuZXcgVmVjMih2ZWMyLmZyb21WYWx1ZXMoeCx5KSk7XG59O1xuXG5WZWMyLnByb3RvdHlwZS5sZW4gPSBWZWMyLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmVjMi5sZW5ndGgodGhpcy5kYXRhKTtcbn07XG5cblZlYzIucHJvdG90eXBlLmxlcnAgPSBmdW5jdGlvbihiLCB0KSB7XG4gICAgdmFyIG91dCA9IG5ldyBWZWMyKCk7XG4gICAgdmVjMi5sZXJwKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIsIHQpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbihiKSB7XG4gICAgdmFyIG0gPSBuZXcgVmVjMigpO1xuICAgIHZlYzIubWF4KG0uZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcbiAgICByZXR1cm4gbTtcbn07XG5cblZlYzIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgbSA9IG5ldyBWZWMyKCk7XG4gICAgdmVjMi5tYXgobS5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBtO1xufTtcblxuVmVjMi5wcm90b3R5cGUubXVsID0gVmVjMi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbihiKSB7XG4gICAgdmFyIG91dCA9IG5ldyBWZWMyKCk7XG4gICAgdmVjMi5tdWwob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMigpO1xuICAgIHZlYzIubmVnYXRlKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMyLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzIoKTtcbiAgICB2ZWMyLm5vcm1hbGl6ZShvdXQuZGF0YSwgdGhpcy5kYXRhKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjMi5yYW5kb20gPSBmdW5jdGlvbihzY2FsZSkge1xuICAgIHZhciBtID0gbmV3IFZlYzIoKTtcbiAgICB2ZWMyLnJhbmRvbShtLmRhdGEsIHNjYWxlKTtcbiAgICByZXR1cm4gbTtcbn07XG5cblZlYzIucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMigpO1xuICAgIHZlYzIuc2NhbGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgcyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzIucHJvdG90eXBlLnN1YiA9IFZlYzIucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24oYikge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMigpO1xuICAgIHZlYzIuc3ViKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMyLnByb3RvdHlwZS50cmFuc2Zvcm1NYXQyID0gZnVuY3Rpb24obSkge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMigpO1xuICAgIHZlYzIudHJhbnNmb3JtTWF0MihvdXQuZGF0YSwgdGhpcy5kYXRhLCBtLmRhdGEgPyBtLmRhdGEgOiBtKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjMi5wcm90b3R5cGUudHJhbnNmb3JtTWF0MyA9IGZ1bmN0aW9uKG0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzIoKTtcbiAgICB2ZWMyLnRyYW5zZm9ybU1hdDMob3V0LmRhdGEsIHRoaXMuZGF0YSwgbS5kYXRhID8gbS5kYXRhIDogbSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzIucHJvdG90eXBlLnRyYW5zZm9ybU1hdDQgPSBmdW5jdGlvbihtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBWZWMyKCk7XG4gICAgdmVjMi50cmFuc2Zvcm1NYXQ0KG91dC5kYXRhLCB0aGlzLmRhdGEsIG0uZGF0YSA/IG0uZGF0YSA6IG0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMyLnByb3RvdHlwZS50b0RPTVN0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2ZWMyLnRvRE9NU3RyaW5nKHRoaXMuZGF0YSk7XG59O1xuXG5WZWMyLmZyb21ET01TdHJpbmcgPSBmdW5jdGlvbihzdHIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzIoKTtcbiAgICBvdXQuZGF0YS5zZXQoIHZlYzIuZnJvbURPTVN0cmluZyhzdHIpICk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzIud3JhcCA9IGZ1bmN0aW9uKHZlYykge1xuICAgIHZhciB2ID0gVmVjMigpO1xuICAgIHYuZGF0YSA9IHZlYy5kYXRhID8gdmVjLmRhdGEgOiB2ZWM7XG4gICAgcmV0dXJuIHY7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZlYzI7XG4iLCJ2YXIgdmVjMyA9IHJlcXVpcmUoXCJnbC1tYXRyaXhcIikudmVjMztcblxudmFyIFZlYzMgPSBmdW5jdGlvbih2ZWMpIHtcbiAgICBpZiAodGhpcyBpbnN0YW5jZW9mIFZlYzMpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gdmVjMy5jcmVhdGUoKTtcbiAgICAgICAgaWYgKHZlYykge1xuICAgICAgICAgICAgdGhpcy5kYXRhLnNldCh2ZWMuZGF0YSA/IHZlYy5kYXRhIDogdmVjKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSByZXR1cm4gbmV3IFZlYzModmVjKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZWMzLnByb3RvdHlwZSwgXCJ4XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHgpe1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB4O1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzBdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZWMzLnByb3RvdHlwZSwgXCJ5XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHkpe1xuICAgICAgICB0aGlzLmRhdGFbMV0gPSB5O1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzFdOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZWMzLnByb3RvdHlwZSwgXCJ6XCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHope1xuICAgICAgICB0aGlzLmRhdGFbMl0gPSB6O1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5kYXRhWzJdOyB9XG59KTtcblxuVmVjMy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oYikge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xuICAgIHZlYzMuYWRkKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIG5ldyBWZWMzKHRoaXMpO1xufTtcblxuVmVjMy5wcm90b3R5cGUuY3Jvc3MgPSBmdW5jdGlvbihiKSB7XG4gICAgdmFyIG91dCA9IG5ldyBWZWMzKCk7XG4gICAgdmVjMy5jcm9zcyhvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjMy5wcm90b3R5cGUuZGlzdCA9IFZlYzMucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZlYzMuZGlzdCh0aGlzLmRhdGEpO1xufTtcblxuVmVjMy5wcm90b3R5cGUuZGl2aWRlID0gZnVuY3Rpb24oYikge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xuICAgIHZlYzMuZGl2aWRlKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMzLnByb3RvdHlwZS5kb3QgPSBmdW5jdGlvbihiKSB7XG4gICAgcmV0dXJuIHZlYzMuZG90KHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XG59O1xuXG5WZWMzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gICAgcmV0dXJuIG5ldyBWZWMzKHZlYzMuZnJvbVZhbHVlcyh4LHkseikpO1xufTtcblxuVmVjMy5wcm90b3R5cGUubGVuID0gVmVjMy5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZlYzMubGVuZ3RoKHRoaXMuZGF0YSk7XG59O1xuXG5WZWMzLnByb3RvdHlwZS5sZXJwID0gZnVuY3Rpb24oYiwgdCkge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xuICAgIHZlYzMubGVycChvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiLCB0KTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjMy5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24oYikge1xuICAgIHZhciBtID0gbmV3IFZlYzMoKTtcbiAgICB2ZWMzLm1heChtLmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XG4gICAgcmV0dXJuIG07XG59O1xuXG5WZWMzLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbihiKSB7XG4gICAgdmFyIG0gPSBuZXcgVmVjMygpO1xuICAgIHZlYzMubWF4KG0uZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcbiAgICByZXR1cm4gbTtcbn07XG5cblZlYzMucHJvdG90eXBlLm11bCA9IFZlYzMucHJvdG90eXBlLm11bHRpcGx5ID0gZnVuY3Rpb24oYikge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xuICAgIHZlYzMubXVsKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMzLnByb3RvdHlwZS5uZWdhdGUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzMoKTtcbiAgICB2ZWMzLm5lZ2F0ZShvdXQuZGF0YSwgdGhpcy5kYXRhKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjMy5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBWZWMzKCk7XG4gICAgdmVjMy5ub3JtYWxpemUob3V0LmRhdGEsIHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzMucHJvdG90eXBlLnJhbmRvbSA9IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgdmFyIG0gPSBuZXcgVmVjMygpO1xuICAgIHZlYzMucmFuZG9tKG0uZGF0YSwgc2NhbGUpO1xuICAgIHJldHVybiBtO1xufTtcblxuVmVjMy5wcm90b3R5cGUucmVjaXByb2NhbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xuICAgIFhNTDNELm1hdGgudmVjMy5yZWNpcHJvY2FsKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMzLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHMpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzMoKTtcbiAgICB2ZWMzLnNjYWxlKG91dC5kYXRhLCB0aGlzLmRhdGEsIHMpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMzLnByb3RvdHlwZS5zdWIgPSBWZWMzLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzMoKTtcbiAgICB2ZWMzLnN1YihvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjMy5wcm90b3R5cGUudHJhbnNmb3JtRGlyZWN0aW9uID0gZnVuY3Rpb24obSkge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xuICAgIFhNTDNELm1hdGgudmVjMy50cmFuc2Zvcm1EaXJlY3Rpb24ob3V0LmRhdGEsIHRoaXMuZGF0YSwgbS5kYXRhID8gbS5kYXRhIDogbSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzMucHJvdG90eXBlLnRyYW5zZm9ybU1hdDMgPSBmdW5jdGlvbihtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBWZWMzKCk7XG4gICAgdmVjMy50cmFuc2Zvcm1NYXQzKG91dC5kYXRhLCB0aGlzLmRhdGEsIG0uZGF0YSA/IG0uZGF0YSA6IG0pO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWMzLnByb3RvdHlwZS50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24obSkge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xuICAgIHZlYzMudHJhbnNmb3JtTWF0NChvdXQuZGF0YSwgdGhpcy5kYXRhLCBtLmRhdGEgPyBtLmRhdGEgOiBtKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjMy5wcm90b3R5cGUudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKHEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzMoKTtcbiAgICB2ZWMzLnRyYW5zZm9ybVF1YXQob3V0LmRhdGEsIHRoaXMuZGF0YSwgcS5kYXRhID8gcS5kYXRhIDogcSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzMucHJvdG90eXBlLnRvRE9NU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZlYzMudG9ET01TdHJpbmcodGhpcy5kYXRhKTtcbn07XG5cblZlYzMuZnJvbURPTVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjMygpO1xuICAgIG91dC5kYXRhLnNldCggdmVjMy5mcm9tRE9NU3RyaW5nKHN0cikgKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjMy53cmFwID0gZnVuY3Rpb24odmVjKSB7XG4gICAgdmFyIHYgPSBWZWMzKCk7XG4gICAgdi5kYXRhID0gdmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYztcbiAgICByZXR1cm4gdjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjMztcbiIsInZhciB2ZWM0ID0gcmVxdWlyZShcImdsLW1hdHJpeFwiKS52ZWM0O1xudmFyIFZlYzMgPSByZXF1aXJlKFwiLi92ZWMzLmpzXCIpO1xuXG52YXIgVmVjNCA9IGZ1bmN0aW9uKHZlYykge1xuICAgIGlmICh0aGlzIGluc3RhbmNlb2YgVmVjNCkge1xuICAgICAgICB0aGlzLmRhdGEgPSB2ZWM0LmNyZWF0ZSgpO1xuICAgICAgICBpZiAodmVjKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEuc2V0KHZlYy5kYXRhID8gdmVjLmRhdGEgOiB2ZWMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHJldHVybiBuZXcgVmVjNCh2ZWMpO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzQucHJvdG90eXBlLCBcInhcIiwge1xuICAgIHNldDogZnVuY3Rpb24oeCl7XG4gICAgICAgIHRoaXMuZGF0YVswXSA9IHg7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMF07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzQucHJvdG90eXBlLCBcInlcIiwge1xuICAgIHNldDogZnVuY3Rpb24oeSl7XG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IHk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMV07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzQucHJvdG90eXBlLCBcInpcIiwge1xuICAgIHNldDogZnVuY3Rpb24oeil7XG4gICAgICAgIHRoaXMuZGF0YVsyXSA9IHo7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbMl07IH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZlYzQucHJvdG90eXBlLCBcIndcIiwge1xuICAgIHNldDogZnVuY3Rpb24odyl7XG4gICAgICAgIHRoaXMuZGF0YVszXSA9IHc7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmRhdGFbM107IH1cbn0pO1xuXG5WZWM0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihiKSB7XG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XG4gICAgdmVjNC5hZGQob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICByZXR1cm4gbmV3IFZlYzQodGhpcyk7XG59O1xuXG5WZWM0LnByb3RvdHlwZS5kaXN0ID0gVmVjNC5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmVjNC5kaXN0KHRoaXMuZGF0YSk7XG59O1xuXG5WZWM0LnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbihiKSB7XG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XG4gICAgdmVjNC5kaXZpZGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzQucHJvdG90eXBlLmRvdCA9IGZ1bmN0aW9uKGIpIHtcbiAgICByZXR1cm4gdmVjNC5kb3QodGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcbn07XG5cblZlYzQuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHgsIHksIHosIHcpIHtcbiAgICByZXR1cm4gbmV3IFZlYzQodmVjNC5mcm9tVmFsdWVzKHgseSx6LHcpKTtcbn07XG5cblZlYzQucHJvdG90eXBlLmxlbiA9IFZlYzQucHJvdG90eXBlLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2ZWM0Lmxlbmd0aCh0aGlzLmRhdGEpO1xufTtcblxuVmVjNC5wcm90b3R5cGUubGVycCA9IGZ1bmN0aW9uKGIsIHQpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzQoKTtcbiAgICB2ZWM0LmxlcnAob3V0LmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYiwgdCk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzQucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgbSA9IG5ldyBWZWM0KCk7XG4gICAgdmVjNC5tYXgobS5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBtO1xufTtcblxuVmVjNC5wcm90b3R5cGUubWluID0gZnVuY3Rpb24oYikge1xuICAgIHZhciBtID0gbmV3IFZlYzQoKTtcbiAgICB2ZWM0Lm1heChtLmRhdGEsIHRoaXMuZGF0YSwgYi5kYXRhID8gYi5kYXRhIDogYik7XG4gICAgcmV0dXJuIG07XG59O1xuXG5WZWM0LnByb3RvdHlwZS5tdWwgPSBWZWM0LnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKGIpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzQoKTtcbiAgICB2ZWM0Lm11bChvdXQuZGF0YSwgdGhpcy5kYXRhLCBiLmRhdGEgPyBiLmRhdGEgOiBiKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjNC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG91dCA9IG5ldyBWZWM0KCk7XG4gICAgdmVjNC5uZWdhdGUob3V0LmRhdGEsIHRoaXMuZGF0YSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjNCgpO1xuICAgIHZlYzQubm9ybWFsaXplKG91dC5kYXRhLCB0aGlzLmRhdGEpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWM0LnByb3RvdHlwZS5yYW5kb20gPSBmdW5jdGlvbihzY2FsZSkge1xuICAgIHZhciBtID0gbmV3IFZlYzQoKTtcbiAgICB2ZWM0LnJhbmRvbShtLmRhdGEsIHNjYWxlKTtcbiAgICByZXR1cm4gbTtcbn07XG5cblZlYzQucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24ocykge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjNCgpO1xuICAgIHZlYzQuc2NhbGUob3V0LmRhdGEsIHRoaXMuZGF0YSwgcyk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzQucHJvdG90eXBlLnN1YiA9IFZlYzQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24oYikge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjNCgpO1xuICAgIHZlYzQuc3ViKG91dC5kYXRhLCB0aGlzLmRhdGEsIGIuZGF0YSA/IGIuZGF0YSA6IGIpO1xuICAgIHJldHVybiBvdXQ7XG59O1xuXG5WZWM0LnByb3RvdHlwZS50cmFuc2Zvcm1NYXQ0ID0gZnVuY3Rpb24obSkge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjNCgpO1xuICAgIHZlYzQudHJhbnNmb3JtTWF0NChvdXQuZGF0YSwgdGhpcy5kYXRhLCBtLmRhdGEgPyBtLmRhdGEgOiBtKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjNC5wcm90b3R5cGUudHJhbnNmb3JtUXVhdCA9IGZ1bmN0aW9uKHEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IFZlYzQoKTtcbiAgICB2ZWM0LnRyYW5zZm9ybVF1YXQob3V0LmRhdGEsIHRoaXMuZGF0YSwgcS5kYXRhID8gcS5kYXRhIDogcSk7XG4gICAgcmV0dXJuIG91dDtcbn07XG5cblZlYzQucHJvdG90eXBlLnRvRE9NU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZlYzQudG9ET01TdHJpbmcodGhpcy5kYXRhKTtcbn07XG5cblZlYzQuZnJvbURPTVN0cmluZyA9IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBvdXQgPSBuZXcgVmVjNCgpO1xuICAgIG91dC5kYXRhLnNldCggdmVjNC5mcm9tRE9NU3RyaW5nKHN0cikgKTtcbiAgICByZXR1cm4gb3V0O1xufTtcblxuVmVjNC53cmFwID0gZnVuY3Rpb24odmVjKSB7XG4gICAgdmFyIHYgPSBWZWM0KCk7XG4gICAgdi5kYXRhID0gdmVjLmRhdGEgPyB2ZWMuZGF0YSA6IHZlYztcbiAgICByZXR1cm4gdjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmVjNDtcbiIsIi8vIEFkZCBjb252aWVuZW50IGFycmF5IG1ldGhvZHMgaWYgbm9uLWV4aXN0YW50XG5pZiAoIUFycmF5LmZvckVhY2gpIHtcbiAgICBBcnJheS5mb3JFYWNoID0gZnVuY3Rpb24oYXJyYXksIGZ1biwgdGhpc3ApIHtcbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgZm9yICggdmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIGFycmF5W2ldLCBpLCBhcnJheSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuaWYgKCFBcnJheS5tYXApIHtcbiAgICBBcnJheS5tYXAgPSBmdW5jdGlvbihhcnJheSwgZnVuLCB0aGlzcCkge1xuICAgICAgICB2YXIgbGVuID0gYXJyYXkubGVuZ3RoO1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAoIHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBhcnJheSkge1xuICAgICAgICAgICAgICAgIHJlc1tpXSA9IGZ1bi5jYWxsKHRoaXNwLCBhcnJheVtpXSwgaSwgYXJyYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbmlmICghQXJyYXkuZmlsdGVyKSB7XG4gICAgQXJyYXkuZmlsdGVyID0gZnVuY3Rpb24oYXJyYXksIGZ1biwgdGhpc3ApIHtcbiAgICAgICAgdmFyIGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICBmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gYXJyYXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gYXJyYXlbaV07XG4gICAgICAgICAgICAgICAgaWYgKGZ1bi5jYWxsKHRoaXNwLCB2YWwsIGksIGFycmF5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXMucHVzaCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5cbmlmICghQXJyYXkuZXJhc2UpIHtcbiAgICBBcnJheS5lcmFzZSA9IGZ1bmN0aW9uKGFycmF5LCBvYmplY3QpIHtcbiAgICAgICAgdmFyIGVyYXNlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgaWR4ID0gLTE7XG4gICAgICAgIHdoaWxlKCAoaWR4ID0gYXJyYXkuaW5kZXhPZihvYmplY3QpICkgIT0gLTEpe1xuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgICBlcmFzZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcmFzZWQ7XG4gICAgfTtcbn1cblxuaWYgKCFBcnJheS5zZXQpIHtcbiAgICBBcnJheS5zZXQgPSBmdW5jdGlvbihhcnJheSwgb2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGFycmF5W29mZnNldCtpXSA9IHZhbHVlW2ldO1xuICAgIH07XG59XG5cbmlmICghQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmcpID09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbn1cbiIsInZhciBDU1NNYXRyaXggPSByZXF1aXJlKFwiLi9jc3NNYXRyaXguanNcIik7XHJcblxyXG52YXIgY3NzID0ge307XHJcblxyXG5jc3MuVFJBTlNGT1JNX1BST1BFUlRZID0gbnVsbDtcclxuXHJcbmNzcy5pbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCd0cmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpIHtcclxuICAgICAgICBjc3MuVFJBTlNGT1JNX1BST1BFUlRZID0gJ3RyYW5zZm9ybSdcclxuICAgIH0gZWxzZSBpZiAoJ1dlYmtpdFRyYW5zZm9ybScgaW4gZG9jdW1lbnQuYm9keS5zdHlsZSkge1xyXG4gICAgICAgIGNzcy5UUkFOU0ZPUk1fUFJPUEVSVFkgPSAnLXdlYmtpdC10cmFuc2Zvcm0nXHJcbiAgICB9IGVsc2UgaWYgKCdNb3pUcmFuc2Zvcm0nIGluIGRvY3VtZW50LmJvZHkuc3R5bGUpIHtcclxuICAgICAgICBjc3MuVFJBTlNGT1JNX1BST1BFUlRZID0gJy1tb3otdHJhbnNmb3JtJ1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiTm8gc3VwcG9ydGVkIHRyYW5zZm9ybSBjc3MgcHJvcGVydHkgZm91bmRcIik7XHJcbiAgICB9XHJcbn07XHJcblxyXG5jc3MuZ2V0SW5saW5lUHJvcGVydHlWYWx1ZSA9IGZ1bmN0aW9uIChub2RlLCBwcm9wZXJ0eSkge1xyXG4gICAgdmFyIHN0eWxlVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcclxuICAgIGlmIChzdHlsZVZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHBhdHRlcm4gPSBuZXcgUmVnRXhwKHByb3BlcnR5ICsgXCJcXHMqOihbXjtdKylcIiwgXCJpXCIpO1xyXG4gICAgICAgIHZhciByZXN1bHQgPSBwYXR0ZXJuLmV4ZWMoc3R5bGVWYWx1ZSk7XHJcbiAgICAgICAgaWYgKHJlc3VsdClcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFsxXS50cmltKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufTtcclxuXHJcbmNzcy5nZXRQcm9wZXJ0eVZhbHVlID0gZnVuY3Rpb24gKG5vZGUsIHByb3BlcnR5KSB7XHJcbiAgICB2YXIgdmFsdWUgPSB0aGlzLmdldElubGluZVByb3BlcnR5VmFsdWUobm9kZSwgcHJvcGVydHkpO1xyXG4gICAgaWYgKHZhbHVlKVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuXHJcbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcclxuICAgIHJldHVybiBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcclxufTtcclxuXHJcbmNzcy5nZXRDU1NNYXRyaXggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgaWYgKCFjc3MuVFJBTlNGT1JNX1BST1BFUlRZIHx8ICFDU1NNYXRyaXgpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgdmFyIHN0eWxlID0gbnVsbDtcclxuXHJcbiAgICBpZiAoY3NzLlRSQU5TRk9STV9QUk9QRVJUWSAhPSBcInRyYW5zZm9ybVwiKVxyXG4gICAgICAgIHN0eWxlID0gY3NzLmdldElubGluZVByb3BlcnR5VmFsdWUobm9kZSwgXCJ0cmFuc2Zvcm1cIik7XHJcblxyXG4gICAgaWYgKCFzdHlsZSlcclxuICAgICAgICBzdHlsZSA9IGNzcy5nZXRQcm9wZXJ0eVZhbHVlKG5vZGUsIGNzcy5UUkFOU0ZPUk1fUFJPUEVSVFkpO1xyXG5cclxuICAgIGlmICghc3R5bGUgfHwgc3R5bGUgPT0gXCJub25lXCIpXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBDU1NNYXRyaXgoc3R5bGUpO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiRXJyb3IgcGFyc2luZyB0cmFuc2Zvcm0gcHJvcGVydHk6IFwiICsgc3R5bGUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbn07XHJcblxyXG5cclxuY3NzLmNvbnZlcnRDc3NUb01hdDQgPSBmdW5jdGlvbiAoY3NzTWF0cml4LCBtKSB7XHJcbiAgICB2YXIgbWF0cml4ID0gbSB8fCBuZXcgWE1MM0QuTWF0NCgpO1xyXG4gICAgbWF0cml4Lm0xMSA9IGNzc01hdHJpeC5tMTE7XHJcbiAgICBtYXRyaXgubTEyID0gY3NzTWF0cml4Lm0xMjtcclxuICAgIG1hdHJpeC5tMTMgPSBjc3NNYXRyaXgubTEzO1xyXG4gICAgbWF0cml4Lm0xNCA9IGNzc01hdHJpeC5tMTQ7XHJcbiAgICBtYXRyaXgubTIxID0gY3NzTWF0cml4Lm0yMTtcclxuICAgIG1hdHJpeC5tMjIgPSBjc3NNYXRyaXgubTIyO1xyXG4gICAgbWF0cml4Lm0yMyA9IGNzc01hdHJpeC5tMjM7XHJcbiAgICBtYXRyaXgubTI0ID0gY3NzTWF0cml4Lm0yNDtcclxuICAgIG1hdHJpeC5tMzEgPSBjc3NNYXRyaXgubTMxO1xyXG4gICAgbWF0cml4Lm0zMiA9IGNzc01hdHJpeC5tMzI7XHJcbiAgICBtYXRyaXgubTMzID0gY3NzTWF0cml4Lm0zMztcclxuICAgIG1hdHJpeC5tMzQgPSBjc3NNYXRyaXgubTM0O1xyXG4gICAgbWF0cml4Lm00MSA9IGNzc01hdHJpeC5tNDE7XHJcbiAgICBtYXRyaXgubTQyID0gY3NzTWF0cml4Lm00MjtcclxuICAgIG1hdHJpeC5tNDMgPSBjc3NNYXRyaXgubTQzO1xyXG4gICAgbWF0cml4Lm00NCA9IGNzc01hdHJpeC5tNDQ7XHJcbiAgICByZXR1cm4gbWF0cml4O1xyXG59O1xyXG5cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XHJcbiAgICBzdHlsZUVsZW1lbnQudGV4dENvbnRlbnQgPSBcInhtbDNkICogeyBkaXNwbGF5OiBpbmhlcml0OyB9XCIgKyBcImZsb2F0LGZsb2F0MixmbG9hdDMsZmxvYXQ0LGZsb2F0NHg0LGludCxpbnQ0LGJvb2wsdGV4dHVyZSxjb21wdXRlIHsgZGlzcGxheTogbm9uZTsgfVwiO1xyXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG59KCkpO1xyXG5cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gY3NzO1xyXG5cclxuIiwiXG4vKipcbiAqICBjbGFzcyBGaXJtaW5DU1NNYXRyaXhcbiAqXG4gKiAgVGhlIFtbRmlybWluQ1NTTWF0cml4XV0gY2xhc3MgaXMgYSBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGVcbiAqICBgQ1NTTWF0cml4YCBpbnRlcmZhY2UgZGVmaW5lZCBpbiB0aGUgW0NTUyAyRCBUcmFuc2Zvcm1zXVsyZF0gYW5kXG4gKiAgW0NTUyAzRCBUcmFuc2Zvcm1zXVszZF0gTW9kdWxlIHNwZWNpZmljYXRpb25zLlxuICpcbiAqICBbMmRdOiBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLTJkLXRyYW5zZm9ybXMvXG4gKiAgWzNkXTogaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy0zZC10cmFuc2Zvcm1zL1xuICpcbiAqICBUaGUgaW1wbGVtZW50YXRpb24gd2FzIGxhcmdlbHkgY29waWVkIGZyb20gdGhlIGBXZWJLaXRDU1NNYXRyaXhgIGNsYXNzLCBhbmRcbiAqICB0aGUgc3VwcGFydGluZyBtYXRocyBsaWJyYXJpZXMgaW4gdGhlIFtXZWJLaXRdW3dlYmtpdF0gcHJvamVjdC4gVGhpcyBpcyBvbmVcbiAqICByZWFzb24gd2h5IG11Y2ggb2YgdGhlIGNvZGUgbG9va3MgbW9yZSBsaWtlIEMrKyB0aGFuIEphdmFTY3JpcHQuXG4gKlxuICogIFt3ZWJraXRdOiBodHRwOi8vd2Via2l0Lm9yZy9cbiAqXG4gKiAgSXRzIEFQSSBpcyBhIHN1cGVyc2V0IG9mIHRoYXQgcHJvdmlkZWQgYnkgYFdlYktpdENTU01hdHJpeGAsIGxhcmdlbHlcbiAqICBiZWNhdXNlIHZhcmlvdXMgcGllY2VzIG9mIHN1cHBvcnRpbmcgY29kZSBoYXZlIGJlZW4gYWRkZWQgYXMgaW5zdGFuY2VcbiAqICBtZXRob2RzIHJhdGhlciB0aGFuIHBvbGx1dGUgdGhlIGdsb2JhbCBuYW1lc3BhY2UuIEV4YW1wbGVzIG9mIHRoZXNlIGluY2x1ZGVcbiAqICBbW0Zpcm1pbkNTU01hdHJpeCNpc0FmZmluZV1dLCBbW0Zpcm1pbkNTU01hdHJpeCNpc0lkZW50aXR5T3JUcmFuc2xhdGlvbl1dXG4gKiAgYW5kIFtbRmlybWluQ1NTTWF0cml4I2Fkam9pbnRdXS5cbiAqKi9cblxuLyoqXG4gKiAgbmV3IEZpcm1pbkNTU01hdHJpeChkb21zdHIpXG4gKiAgLSBkb21zdHIgKFN0cmluZyk6IGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgMkQgb3IgM0QgdHJhbnNmb3JtIG1hdHJpeFxuICogICAgaW4gdGhlIGZvcm0gZ2l2ZW4gYnkgdGhlIENTUyB0cmFuc2Zvcm0gcHJvcGVydHksIGkuZS4ganVzdCBsaWtlIHRoZVxuICogICAgb3V0cHV0IGZyb20gW1tGaXJtaW5DU1NNYXRyaXgjdG9TdHJpbmddXS5cbiAqXG4gKiAgQGNvbnN0cnVjdG9yXG4gKiovXG52YXIgRmlybWluQ1NTTWF0cml4ID0gZnVuY3Rpb24oZG9tc3RyKSB7XG4gICAgdGhpcy5tMTEgPSB0aGlzLm0yMiA9IHRoaXMubTMzID0gdGhpcy5tNDQgPSAxO1xuXG4gICAgdGhpcy5tMTIgPSB0aGlzLm0xMyA9IHRoaXMubTE0ID1cbiAgICB0aGlzLm0yMSA9ICAgICAgICAgICAgdGhpcy5tMjMgPSB0aGlzLm0yNCA9XG4gICAgdGhpcy5tMzEgPSB0aGlzLm0zMiA9ICAgICAgICAgICAgdGhpcy5tMzQgPVxuICAgIHRoaXMubTQxID0gdGhpcy5tNDIgPSB0aGlzLm00MyAgICAgICAgICAgID0gMDtcblxuICAgIGlmICh0eXBlb2YgZG9tc3RyID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhpcy5zZXRNYXRyaXhWYWx1ZShkb21zdHIpO1xuICAgIH1cbn07XG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeC5kaXNwbGF5TmFtZSA9IFwiRmlybWluQ1NTTWF0cml4XCJcbiAqKi9cbkZpcm1pbkNTU01hdHJpeC5kaXNwbGF5TmFtZSA9IFwiRmlybWluQ1NTTWF0cml4XCI7XG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeC5kZWdyZWVzVG9SYWRpYW5zKGFuZ2xlKSAtPiBOdW1iZXJcbiAqICAtIGFuZ2xlIChOdW1iZXIpOiBhbiBhbmdsZSBpbiBkZWdyZWVzLlxuICpcbiAqICBDb252ZXJ0cyBhbmdsZXMgaW4gZGVncmVlcywgd2hpY2ggYXJlIHVzZWQgYnkgdGhlIGV4dGVybmFsIEFQSSwgdG8gYW5nbGVzXG4gKiAgaW4gcmFkaWFucyB1c2VkIGluIGludGVybmFsIGNhbGN1bGF0aW9ucy5cbiAqKi9cbkZpcm1pbkNTU01hdHJpeC5kZWdyZWVzVG9SYWRpYW5zID0gZnVuY3Rpb24oYW5nbGUpIHtcbiAgICByZXR1cm4gYW5nbGUgKiBNYXRoLlBJIC8gMTgwO1xufTtcblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50MngyKGEsIGIsIGMsIGQpIC0+IE51bWJlclxuICogIC0gYSAoTnVtYmVyKTogdG9wLWxlZnQgdmFsdWUgb2YgdGhlIG1hdHJpeC5cbiAqICAtIGIgKE51bWJlcik6IHRvcC1yaWdodCB2YWx1ZSBvZiB0aGUgbWF0cml4LlxuICogIC0gYyAoTnVtYmVyKTogYm90dG9tLWxlZnQgdmFsdWUgb2YgdGhlIG1hdHJpeC5cbiAqICAtIGQgKE51bWJlcik6IGJvdHRvbS1yaWdodCB2YWx1ZSBvZiB0aGUgbWF0cml4LlxuICpcbiAqICBDYWxjdWxhdGVzIHRoZSBkZXRlcm1pbmFudCBvZiBhIDJ4MiBtYXRyaXguXG4gKiovXG5GaXJtaW5DU1NNYXRyaXguZGV0ZXJtaW5hbnQyeDIgPSBmdW5jdGlvbihhLCBiLCBjLCBkKSB7XG4gICAgcmV0dXJuIGEgKiBkIC0gYiAqIGM7XG59O1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXguZGV0ZXJtaW5hbnQzeDMobWF0cml4KSAtPiBOdW1iZXJcbiAqICAtIGExIChOdW1iZXIpOiBtYXRyaXggdmFsdWUgaW4gcG9zaXRpb24gWzEsIDFdLlxuICogIC0gYTIgKE51bWJlcik6IG1hdHJpeCB2YWx1ZSBpbiBwb3NpdGlvbiBbMSwgMl0uXG4gKiAgLSBhMyAoTnVtYmVyKTogbWF0cml4IHZhbHVlIGluIHBvc2l0aW9uIFsxLCAzXS5cbiAqICAtIGIxIChOdW1iZXIpOiBtYXRyaXggdmFsdWUgaW4gcG9zaXRpb24gWzIsIDFdLlxuICogIC0gYjIgKE51bWJlcik6IG1hdHJpeCB2YWx1ZSBpbiBwb3NpdGlvbiBbMiwgMl0uXG4gKiAgLSBiMyAoTnVtYmVyKTogbWF0cml4IHZhbHVlIGluIHBvc2l0aW9uIFsyLCAzXS5cbiAqICAtIGMxIChOdW1iZXIpOiBtYXRyaXggdmFsdWUgaW4gcG9zaXRpb24gWzMsIDFdLlxuICogIC0gYzIgKE51bWJlcik6IG1hdHJpeCB2YWx1ZSBpbiBwb3NpdGlvbiBbMywgMl0uXG4gKiAgLSBjMyAoTnVtYmVyKTogbWF0cml4IHZhbHVlIGluIHBvc2l0aW9uIFszLCAzXS5cbiAqXG4gKiAgQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSAzeDMgbWF0cml4LlxuICoqL1xuRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50M3gzID0gZnVuY3Rpb24oYTEsIGEyLCBhMywgYjEsIGIyLCBiMywgYzEsIGMyLCBjMykge1xuICAgIHZhciBkZXRlcm1pbmFudDJ4MiA9IEZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDJ4MjtcbiAgICByZXR1cm4gYTEgKiBkZXRlcm1pbmFudDJ4MihiMiwgYjMsIGMyLCBjMykgLVxuICAgIGIxICogZGV0ZXJtaW5hbnQyeDIoYTIsIGEzLCBjMiwgYzMpICtcbiAgICBjMSAqIGRldGVybWluYW50MngyKGEyLCBhMywgYjIsIGIzKTtcbn07XG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDR4NChtYXRyaXgpIC0+IE51bWJlclxuICogIC0gbWF0cml4IChGaXJtaW5DU1NNYXRyaXgpOiB0aGUgbWF0cml4IHRvIGNhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnQgb2YuXG4gKlxuICogIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgNHg0IG1hdHJpeC5cbiAqKi9cbkZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDR4NCA9IGZ1bmN0aW9uKG0pIHtcbiAgICB2YXIgZGV0ZXJtaW5hbnQzeDMgPSBGaXJtaW5DU1NNYXRyaXguZGV0ZXJtaW5hbnQzeDMsXG5cbiAgICAgICAgLy8gQXNzaWduIHRvIGluZGl2aWR1YWwgdmFyaWFibGUgbmFtZXMgdG8gYWlkIHNlbGVjdGluZyBjb3JyZWN0IGVsZW1lbnRzXG4gICAgYTEgPSBtLm0xMSwgYjEgPSBtLm0yMSwgYzEgPSBtLm0zMSwgZDEgPSBtLm00MSxcbiAgICBhMiA9IG0ubTEyLCBiMiA9IG0ubTIyLCBjMiA9IG0ubTMyLCBkMiA9IG0ubTQyLFxuICAgIGEzID0gbS5tMTMsIGIzID0gbS5tMjMsIGMzID0gbS5tMzMsIGQzID0gbS5tNDMsXG4gICAgYTQgPSBtLm0xNCwgYjQgPSBtLm0yNCwgYzQgPSBtLm0zNCwgZDQgPSBtLm00NDtcblxuICAgIHJldHVybiBhMSAqIGRldGVybWluYW50M3gzKGIyLCBiMywgYjQsIGMyLCBjMywgYzQsIGQyLCBkMywgZDQpIC1cbiAgICBiMSAqIGRldGVybWluYW50M3gzKGEyLCBhMywgYTQsIGMyLCBjMywgYzQsIGQyLCBkMywgZDQpICtcbiAgICBjMSAqIGRldGVybWluYW50M3gzKGEyLCBhMywgYTQsIGIyLCBiMywgYjQsIGQyLCBkMywgZDQpIC1cbiAgICBkMSAqIGRldGVybWluYW50M3gzKGEyLCBhMywgYTQsIGIyLCBiMywgYjQsIGMyLCBjMywgYzQpO1xufTtcblxuLyoqXG4gKiBGaXJtaW5DU1NNYXRyaXgudG9NYXRyaXhTdHJpbmcodHJhbnNmb3JtVmFsdWUpIC0+IFN0cmluZ1xuICogLSB0cmFuc2Zvcm1WYWx1ZSAoU3RyaW5nKTogYGVsLnN0eWxlLldlYmtpdFRyYW5zZm9ybWAtc3R5bGUgc3RyaW5nIChsaWtlIGByb3RhdGUoMThyYWQpIHRyYW5zbGF0ZTNkKDUwcHgsIDEwMHB4LCAxMHB4KWApXG4gKlxuICogVHJhbmZvcm1zIGEgYGVsLnN0eWxlLldlYmtpdFRyYW5zZm9ybWAtc3R5bGUgc3RyaW5nXG4gKiAobGlrZSBgcm90YXRlKDE4cmFkKSB0cmFuc2xhdGUzZCg1MHB4LCAxMDBweCwgMTBweClgKVxuICogaW50byBhIGBnZXRDb21wdXRlZFN0eWxlKGVsKWAtc3R5bGUgbWF0cml4IHN0cmluZ1xuICogKGxpa2UgYG1hdHJpeDNkKDAuNjYwMzE2NzA4MjQ0MDgyOCwgLTAuNzUwOTg3MjQ2NzcxNjczNywgMCwgMCwgMC43NTA5ODcyNDY3NzE2NzM3LCAwLjY2MDMxNjcwODI0NDA4MjgsIDAsIDAsIDAsIDAsIDEsIDAsIDEwOC4xMTQ1NjAwODkzNzE1MSwgMjguNDgyMzA4NDg1ODI0NTk2LCAxMCwgMSlgKVxuICoqL1xuRmlybWluQ1NTTWF0cml4LnRvTWF0cml4U3RyaW5nID0gZnVuY3Rpb24gKHRyYW5zZm9ybVZhbHVlKSB7XG4gICAgdmFyIHJneCA9IHtcbiAgICAgICAgZnVuY3Rpb25TaWduYXR1cmU6IC8oXFx3KylcXChbXlxcKV0rXFwpL2lnLFxuICAgICAgICBuYW1lQW5kQXJndW1lbnRzOiAvKFxcdyspXFwoKFteXFwpXSspXFwpL2ksXG4gICAgICAgIHVuaXRzOiAvKFstXFwrXT9bMC05XStbXFwuMC05XSopKGRlZ3xyYWR8Z3JhZHxweHwlKSovXG4gICAgfTtcbiAgICB2YXIgdHJhbnNmb3JtU3RhdGVtZW50cyA9IHRyYW5zZm9ybVZhbHVlLm1hdGNoKC8oXFx3KylcXChbXlxcKV0rXFwpL2lnKTtcbiAgICB2YXIgb25seU1hdHJpY2VzID0gdHJhbnNmb3JtU3RhdGVtZW50cyAmJiB0cmFuc2Zvcm1TdGF0ZW1lbnRzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7IHJldHVybiAoL15tYXRyaXgvKS50ZXN0KHQpIH0pO1xuICAgIGlmICghdHJhbnNmb3JtU3RhdGVtZW50cyB8fCBvbmx5TWF0cmljZXMpIHJldHVybiB0cmFuc2Zvcm1WYWx1ZTtcblxuICAgIHZhciB2YWx1ZXMgPSBmdW5jdGlvbiAobykgeyByZXR1cm4gby52YWx1ZSB9O1xuICAgIHZhciBjc3NGdW5jdGlvblRvSnNGdW5jdGlvbiA9IHtcbiAgICAgICAgbWF0cml4OiBmdW5jdGlvbiAobSwgbykge1xuICAgICAgICAgICAgdmFyIG0yID0gbmV3IEZpcm1pbkNTU01hdHJpeChvLnVucGFyc2VkKTtcblxuICAgICAgICAgICAgcmV0dXJuIG0ubXVsdGlwbHkobTIpXG4gICAgICAgIH0sXG4gICAgICAgIG1hdHJpeDNkOiBmdW5jdGlvbiAobSwgbykge1xuICAgICAgICAgICAgdmFyIG0yID0gbmV3IEZpcm1pbkNTU01hdHJpeChvLnVucGFyc2VkKTtcblxuICAgICAgICAgICAgcmV0dXJuIG0ubXVsdGlwbHkobTIpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyc3BlY3RpdmU6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICB2YXIgbTIgPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XG4gICAgICAgICAgICBtMi5tMzQgLT0gMSAvIG8udmFsdWVbMF0udmFsdWU7XG5cbiAgICAgICAgICAgIHJldHVybiBtLm11bHRpcGx5KG0yKTtcbiAgICAgICAgfSxcblxuICAgICAgICByb3RhdGU6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5yb3RhdGUuYXBwbHkobSwgby52YWx1ZS5tYXAodmFsdWVzKSlcbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRlM2Q6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5yb3RhdGVBeGlzQW5nbGUuYXBwbHkobSwgby52YWx1ZS5tYXAodmFsdWVzKSlcbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRlWDogZnVuY3Rpb24gKG0sIG8pIHtcbiAgICAgICAgICAgIHJldHVybiBtLnJvdGF0ZS5hcHBseShtLCBbby52YWx1ZVswXS52YWx1ZSwgMCwgMF0pO1xuICAgICAgICB9LFxuICAgICAgICByb3RhdGVZOiBmdW5jdGlvbiAobSwgbykge1xuICAgICAgICAgICAgcmV0dXJuIG0ucm90YXRlLmFwcGx5KG0sIFswLCBvLnZhbHVlWzBdLnZhbHVlLCAwXSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0ZVo6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5yb3RhdGUuYXBwbHkobSwgWzAsIDAsIG8udmFsdWVbMF0udmFsdWVdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBzY2FsZTogZnVuY3Rpb24gKG0sIG8pIHtcbiAgICAgICAgICAgIHJldHVybiBtLnNjYWxlLmFwcGx5KG0sIG8udmFsdWUubWFwKHZhbHVlcykpO1xuICAgICAgICB9LFxuICAgICAgICBzY2FsZTNkOiBmdW5jdGlvbiAobSwgbykge1xuICAgICAgICAgICAgcmV0dXJuIG0uc2NhbGUuYXBwbHkobSwgby52YWx1ZS5tYXAodmFsdWVzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlWDogZnVuY3Rpb24gKG0sIG8pIHtcbiAgICAgICAgICAgIHJldHVybiBtLnNjYWxlLmFwcGx5KG0sIG8udmFsdWUubWFwKHZhbHVlcykpO1xuICAgICAgICB9LFxuICAgICAgICBzY2FsZVk6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5zY2FsZS5hcHBseShtLCBbMCwgby52YWx1ZVswXS52YWx1ZSwgMF0pO1xuICAgICAgICB9LFxuICAgICAgICBzY2FsZVo6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5zY2FsZS5hcHBseShtLCBbMCwgMCwgby52YWx1ZVswXS52YWx1ZV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHNrZXc6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICB2YXIgbVggPSBuZXcgRmlybWluQ1NTTWF0cml4KCdza2V3WCgnICsgby52YWx1ZVswXS51bnBhcnNlZCArICcpJyk7XG4gICAgICAgICAgICB2YXIgbVkgPSBuZXcgRmlybWluQ1NTTWF0cml4KCdza2V3WSgnICsgby52YWx1ZVsxXS51bnBhcnNlZCArICcpJyk7XG4gICAgICAgICAgICB2YXIgc00gPSAnbWF0cml4KDEuMDAwMDAsICcrIG1ZLmIgKycsICcrIG1YLmMgKycsIDEuMDAwMDAwLCAwLjAwMDAwMCwgMC4wMDAwMDApJztcbiAgICAgICAgICAgIHZhciBtMiA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoc00pO1xuXG4gICAgICAgICAgICByZXR1cm4gbS5tdWx0aXBseShtMik7XG4gICAgICAgIH0sXG4gICAgICAgIHNrZXdYOiBmdW5jdGlvbiAobSwgbykge1xuICAgICAgICAgICAgcmV0dXJuIG0uc2tld1guYXBwbHkobSwgW28udmFsdWVbMF0udmFsdWVdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2tld1k6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gbS5za2V3WS5hcHBseShtLCBbby52YWx1ZVswXS52YWx1ZV0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIHRyYW5zbGF0ZTogZnVuY3Rpb24gKG0sIG8pIHtcbiAgICAgICAgICAgIHJldHVybiBtLnRyYW5zbGF0ZS5hcHBseShtLCBvLnZhbHVlLm1hcCh2YWx1ZXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNsYXRlM2Q6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gbS50cmFuc2xhdGUuYXBwbHkobSwgby52YWx1ZS5tYXAodmFsdWVzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zbGF0ZVg6IGZ1bmN0aW9uIChtLCBvKSB7XG4gICAgICAgICAgICByZXR1cm4gbS50cmFuc2xhdGUuYXBwbHkobSwgW28udmFsdWVbMF0udmFsdWUsIDAsIDBdKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnNsYXRlWTogZnVuY3Rpb24gKG0sIG8pIHtcbiAgICAgICAgICAgIHJldHVybiBtLnRyYW5zbGF0ZS5hcHBseShtLCBbMCwgby52YWx1ZVswXS52YWx1ZSwgMF0pO1xuICAgICAgICB9LFxuICAgICAgICB0cmFuc2xhdGVaOiBmdW5jdGlvbiAobSwgbykge1xuICAgICAgICAgICAgcmV0dXJuIG0udHJhbnNsYXRlLmFwcGx5KG0sIFswLCAwLCBvLnZhbHVlWzBdLnZhbHVlXSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwYXJzZVRyYW5zZm9ybVN0YXRlbWVudCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIHBhaXIgPSBzdHIubWF0Y2gocmd4Lm5hbWVBbmRBcmd1bWVudHMpLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHBhaXJbMF0sXG4gICAgICAgICAgICB2YWx1ZTogcGFpclsxXS5zcGxpdCgvLCA/LykubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IHZhbHVlLm1hdGNoKC8oWy1cXCtdP1swLTldK1tcXC4wLTldKikoZGVnfHJhZHxncmFkfHB4fCUpKi8pIHx8IFtdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHBhcnNlRmxvYXQocGFydHNbMV0pLFxuICAgICAgICAgICAgICAgICAgICB1bml0czogcGFydHNbMl0sXG4gICAgICAgICAgICAgICAgICAgIHVucGFyc2VkOiB2YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHVucGFyc2VkOiBzdHJcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgdmFyIHRyYW5zZm9ybU9wZXJhdGlvbnMgPSB0cmFuc2Zvcm1TdGF0ZW1lbnRzLm1hcChwYXJzZVRyYW5zZm9ybVN0YXRlbWVudCk7XG4gICAgdmFyIHN0YXJ0aW5nTWF0cml4ID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpO1xuICAgIHZhciB0cmFuc2Zvcm1lZE1hdHJpeCA9IHRyYW5zZm9ybU9wZXJhdGlvbnMucmVkdWNlKGZ1bmN0aW9uIChtYXRyaXgsIG9wZXJhdGlvbikge1xuICAgICAgICAvLyBjb252ZXJ0IHRvIGRlZ3JlZXMgYi9jIGFsbCBDU1NNYXRyaXggbWV0aG9kcyBleHBlY3QgZGVncmVlc1xuICAgICAgICBvcGVyYXRpb24udmFsdWUgPSBvcGVyYXRpb24udmFsdWUubWFwKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb24udW5pdHMgPT0gJ3JhZCcpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb24udmFsdWUgPSBvcGVyYXRpb24udmFsdWUgKiAoMTgwIC8gTWF0aC5QSSk7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnVuaXRzID0gJ2RlZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcGVyYXRpb24udW5pdHMgPT0gJ2dyYWQnKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uLnZhbHVlID0gb3BlcmF0aW9uLnZhbHVlIC8gKDQwMCAvIDM2MCk7IC8vIDQwMCBncmFkaWFucyBpbiAzNjAgZGVncmVlc1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi51bml0cyA9ICdkZWcnXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb247XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBqc0Z1bmN0aW9uID0gY3NzRnVuY3Rpb25Ub0pzRnVuY3Rpb25bb3BlcmF0aW9uLmtleV07XG4gICAgICAgIHZhciByZXN1bHQgPSBqc0Z1bmN0aW9uKG1hdHJpeCwgb3BlcmF0aW9uKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0IHx8IG1hdHJpeDtcbiAgICB9LCBzdGFydGluZ01hdHJpeCk7XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtZWRNYXRyaXgudG9TdHJpbmcoKTtcbn07XG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNhIC0+IE51bWJlclxuICogIFRoZSBmaXJzdCAyRCB2ZWN0b3IgdmFsdWUuXG4gKiovXG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNiIC0+IE51bWJlclxuICogIFRoZSBzZWNvbmQgMkQgdmVjdG9yIHZhbHVlLlxuICoqL1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjYyAtPiBOdW1iZXJcbiAqICBUaGUgdGhpcmQgMkQgdmVjdG9yIHZhbHVlLlxuICoqL1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjZCAtPiBOdW1iZXJcbiAqICBUaGUgZm91cnRoIDJEIHZlY3RvciB2YWx1ZS5cbiAqKi9cblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I2UgLT4gTnVtYmVyXG4gKiAgVGhlIGZpZnRoIDJEIHZlY3RvciB2YWx1ZS5cbiAqKi9cblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I2YgLT4gTnVtYmVyXG4gKiAgVGhlIHNpeHRoIDJEIHZlY3RvciB2YWx1ZS5cbiAqKi9cblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I20xMSAtPiBOdW1iZXJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBmaXJzdCByb3cgYW5kIGZpcnN0IGNvbHVtbi5cbiAqKi9cblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I20xMiAtPiBOdW1iZXJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBmaXJzdCByb3cgYW5kIHNlY29uZCBjb2x1bW4uXG4gKiovXG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNtMTMgLT4gTnVtYmVyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgZmlyc3Qgcm93IGFuZCB0aGlyZCBjb2x1bW4uXG4gKiovXG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNtMTQgLT4gTnVtYmVyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgZmlyc3Qgcm93IGFuZCBmb3VydGggY29sdW1uLlxuICoqL1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTIxIC0+IE51bWJlclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIHNlY29uZCByb3cgYW5kIGZpcnN0IGNvbHVtbi5cbiAqKi9cblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I20yMiAtPiBOdW1iZXJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBzZWNvbmQgcm93IGFuZCBzZWNvbmQgY29sdW1uLlxuICoqL1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTIzIC0+IE51bWJlclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIHNlY29uZCByb3cgYW5kIHRoaXJkIGNvbHVtbi5cbiAqKi9cblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I20yNCAtPiBOdW1iZXJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSBzZWNvbmQgcm93IGFuZCBmb3VydGggY29sdW1uLlxuICoqL1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTMxIC0+IE51bWJlclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIHRoaXJkIHJvdyBhbmQgZmlyc3QgY29sdW1uLlxuICoqL1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTMyIC0+IE51bWJlclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIHRoaXJkIHJvdyBhbmQgc2Vjb25kIGNvbHVtbi5cbiAqKi9cblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I20zMyAtPiBOdW1iZXJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSB0aGlyZCByb3cgYW5kIHRoaXJkIGNvbHVtbi5cbiAqKi9cblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I20zNCAtPiBOdW1iZXJcbiAqICBUaGUgM0QgbWF0cml4IHZhbHVlIGluIHRoZSB0aGlyZCByb3cgYW5kIGZvdXJ0aCBjb2x1bW4uXG4gKiovXG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNtNDEgLT4gTnVtYmVyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgZm91cnRoIHJvdyBhbmQgZmlyc3QgY29sdW1uLlxuICoqL1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTQyIC0+IE51bWJlclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIGZvdXJ0aCByb3cgYW5kIHNlY29uZCBjb2x1bW4uXG4gKiovXG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNtNDMgLT4gTnVtYmVyXG4gKiAgVGhlIDNEIG1hdHJpeCB2YWx1ZSBpbiB0aGUgZm91cnRoIHJvdyBhbmQgdGhpcmQgY29sdW1uLlxuICoqL1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjbTQ0IC0+IE51bWJlclxuICogIFRoZSAzRCBtYXRyaXggdmFsdWUgaW4gdGhlIGZvdXJ0aCByb3cgYW5kIGZvdXJ0aCBjb2x1bW4uXG4gKiovXG5cbltbXCJtMTFcIiwgXCJhXCJdLFxuICAgIFtcIm0xMlwiLCBcImJcIl0sXG4gICAgW1wibTIxXCIsIFwiY1wiXSxcbiAgICBbXCJtMjJcIiwgXCJkXCJdLFxuICAgIFtcIm00MVwiLCBcImVcIl0sXG4gICAgW1wibTQyXCIsIFwiZlwiXV0uZm9yRWFjaChmdW5jdGlvbihwYWlyKSB7XG4gICAgdmFyIGtleTNkID0gcGFpclswXSwga2V5MmQgPSBwYWlyWzFdO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUsIGtleTJkLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICB0aGlzW2tleTNkXSA9IHZhbDtcbiAgICAgICAgfSxcblxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNba2V5M2RdO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlIDogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlIDogdHJ1ZVxuICAgIH0pO1xufSk7XG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNpc0FmZmluZSgpIC0+IEJvb2xlYW5cbiAqXG4gKiAgRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBtYXRyaXggaXMgYWZmaW5lLlxuICoqL1xuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5pc0FmZmluZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLm0xMyA9PT0gMCAmJiB0aGlzLm0xNCA9PT0gMCAmJlxuICAgIHRoaXMubTIzID09PSAwICYmIHRoaXMubTI0ID09PSAwICYmXG4gICAgdGhpcy5tMzEgPT09IDAgJiYgdGhpcy5tMzIgPT09IDAgJiZcbiAgICB0aGlzLm0zMyA9PT0gMSAmJiB0aGlzLm0zNCA9PT0gMCAmJlxuICAgIHRoaXMubTQzID09PSAwICYmIHRoaXMubTQ0ID09PSAxO1xufTtcblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I211bHRpcGx5KG90aGVyTWF0cml4KSAtPiBGaXJtaW5DU1NNYXRyaXhcbiAqICAtIG90aGVyTWF0cml4IChGaXJtaW5DU1NNYXRyaXgpOiB0aGUgbWF0cml4IHRvIG11bHRpcGx5IHRoaXMgb25lIGJ5LlxuICpcbiAqICBNdWx0aXBsaWVzIHRoZSBtYXRyaXggYnkgYSBnaXZlbiBtYXRyaXggYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAqKi9cbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbihvdGhlck1hdHJpeCkge1xuICAgIGlmICghb3RoZXJNYXRyaXgpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIGEgPSBvdGhlck1hdHJpeCxcbiAgICBiID0gdGhpcyxcbiAgICBjID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpO1xuXG4gICAgYy5tMTEgPSBhLm0xMSAqIGIubTExICsgYS5tMTIgKiBiLm0yMSArIGEubTEzICogYi5tMzEgKyBhLm0xNCAqIGIubTQxO1xuICAgIGMubTEyID0gYS5tMTEgKiBiLm0xMiArIGEubTEyICogYi5tMjIgKyBhLm0xMyAqIGIubTMyICsgYS5tMTQgKiBiLm00MjtcbiAgICBjLm0xMyA9IGEubTExICogYi5tMTMgKyBhLm0xMiAqIGIubTIzICsgYS5tMTMgKiBiLm0zMyArIGEubTE0ICogYi5tNDM7XG4gICAgYy5tMTQgPSBhLm0xMSAqIGIubTE0ICsgYS5tMTIgKiBiLm0yNCArIGEubTEzICogYi5tMzQgKyBhLm0xNCAqIGIubTQ0O1xuXG4gICAgYy5tMjEgPSBhLm0yMSAqIGIubTExICsgYS5tMjIgKiBiLm0yMSArIGEubTIzICogYi5tMzEgKyBhLm0yNCAqIGIubTQxO1xuICAgIGMubTIyID0gYS5tMjEgKiBiLm0xMiArIGEubTIyICogYi5tMjIgKyBhLm0yMyAqIGIubTMyICsgYS5tMjQgKiBiLm00MjtcbiAgICBjLm0yMyA9IGEubTIxICogYi5tMTMgKyBhLm0yMiAqIGIubTIzICsgYS5tMjMgKiBiLm0zMyArIGEubTI0ICogYi5tNDM7XG4gICAgYy5tMjQgPSBhLm0yMSAqIGIubTE0ICsgYS5tMjIgKiBiLm0yNCArIGEubTIzICogYi5tMzQgKyBhLm0yNCAqIGIubTQ0O1xuXG4gICAgYy5tMzEgPSBhLm0zMSAqIGIubTExICsgYS5tMzIgKiBiLm0yMSArIGEubTMzICogYi5tMzEgKyBhLm0zNCAqIGIubTQxO1xuICAgIGMubTMyID0gYS5tMzEgKiBiLm0xMiArIGEubTMyICogYi5tMjIgKyBhLm0zMyAqIGIubTMyICsgYS5tMzQgKiBiLm00MjtcbiAgICBjLm0zMyA9IGEubTMxICogYi5tMTMgKyBhLm0zMiAqIGIubTIzICsgYS5tMzMgKiBiLm0zMyArIGEubTM0ICogYi5tNDM7XG4gICAgYy5tMzQgPSBhLm0zMSAqIGIubTE0ICsgYS5tMzIgKiBiLm0yNCArIGEubTMzICogYi5tMzQgKyBhLm0zNCAqIGIubTQ0O1xuXG4gICAgYy5tNDEgPSBhLm00MSAqIGIubTExICsgYS5tNDIgKiBiLm0yMSArIGEubTQzICogYi5tMzEgKyBhLm00NCAqIGIubTQxO1xuICAgIGMubTQyID0gYS5tNDEgKiBiLm0xMiArIGEubTQyICogYi5tMjIgKyBhLm00MyAqIGIubTMyICsgYS5tNDQgKiBiLm00MjtcbiAgICBjLm00MyA9IGEubTQxICogYi5tMTMgKyBhLm00MiAqIGIubTIzICsgYS5tNDMgKiBiLm0zMyArIGEubTQ0ICogYi5tNDM7XG4gICAgYy5tNDQgPSBhLm00MSAqIGIubTE0ICsgYS5tNDIgKiBiLm0yNCArIGEubTQzICogYi5tMzQgKyBhLm00NCAqIGIubTQ0O1xuXG4gICAgcmV0dXJuIGM7XG59O1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjaXNJZGVudGl0eU9yVHJhbnNsYXRpb24oKSAtPiBCb29sZWFuXG4gKlxuICogIFJldHVybnMgd2hldGhlciB0aGUgbWF0cml4IGlzIHRoZSBpZGVudGl0eSBtYXRyaXggb3IgYSB0cmFuc2xhdGlvbiBtYXRyaXguXG4gKiovXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLmlzSWRlbnRpdHlPclRyYW5zbGF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSB0aGlzO1xuICAgIHJldHVybiB0Lm0xMSA9PT0gMSAmJiB0Lm0xMiA9PT0gMCAmJiB0Lm0xMyA9PT0gMCAmJiB0Lm0xNCA9PT0gMCAmJlxuICAgIHQubTIxID09PSAwICYmIHQubTIyID09PSAxICYmIHQubTIzID09PSAwICYmIHQubTI0ID09PSAwICYmXG4gICAgdC5tMzEgPT09IDAgJiYgdC5tMzEgPT09IDAgJiYgdC5tMzMgPT09IDEgJiYgdC5tMzQgPT09IDAgJiZcbiAgICAgICAgLyogbTQxLCBtNDIgYW5kIG00MyBhcmUgdGhlIHRyYW5zbGF0aW9uIHBvaW50cyAqLyAgIHQubTQ0ID09PSAxO1xufTtcblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I2Fkam9pbnQoKSAtPiBGaXJtaW5DU1NNYXRyaXhcbiAqXG4gKiAgUmV0dXJucyB0aGUgYWRqb2ludCBtYXRyaXguXG4gKiovXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLmFkam9pbnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpLCB0ID0gdGhpcyxcbiAgICBkZXRlcm1pbmFudDN4MyA9IEZpcm1pbkNTU01hdHJpeC5kZXRlcm1pbmFudDN4MyxcblxuICAgIGExID0gdC5tMTEsIGIxID0gdC5tMTIsIGMxID0gdC5tMTMsIGQxID0gdC5tMTQsXG4gICAgYTIgPSB0Lm0yMSwgYjIgPSB0Lm0yMiwgYzIgPSB0Lm0yMywgZDIgPSB0Lm0yNCxcbiAgICBhMyA9IHQubTMxLCBiMyA9IHQubTMyLCBjMyA9IHQubTMzLCBkMyA9IHQubTM0LFxuICAgIGE0ID0gdC5tNDEsIGI0ID0gdC5tNDIsIGM0ID0gdC5tNDMsIGQ0ID0gdC5tNDQ7XG5cbiAgICAvLyBSb3cgY29sdW1uIGxhYmVsaW5nIHJldmVyc2VkIHNpbmNlIHdlIHRyYW5zcG9zZSByb3dzICYgY29sdW1uc1xuICAgIHJlc3VsdC5tMTEgPSAgZGV0ZXJtaW5hbnQzeDMoYjIsIGIzLCBiNCwgYzIsIGMzLCBjNCwgZDIsIGQzLCBkNCk7XG4gICAgcmVzdWx0Lm0yMSA9IC1kZXRlcm1pbmFudDN4MyhhMiwgYTMsIGE0LCBjMiwgYzMsIGM0LCBkMiwgZDMsIGQ0KTtcbiAgICByZXN1bHQubTMxID0gIGRldGVybWluYW50M3gzKGEyLCBhMywgYTQsIGIyLCBiMywgYjQsIGQyLCBkMywgZDQpO1xuICAgIHJlc3VsdC5tNDEgPSAtZGV0ZXJtaW5hbnQzeDMoYTIsIGEzLCBhNCwgYjIsIGIzLCBiNCwgYzIsIGMzLCBjNCk7XG5cbiAgICByZXN1bHQubTEyID0gLWRldGVybWluYW50M3gzKGIxLCBiMywgYjQsIGMxLCBjMywgYzQsIGQxLCBkMywgZDQpO1xuICAgIHJlc3VsdC5tMjIgPSAgZGV0ZXJtaW5hbnQzeDMoYTEsIGEzLCBhNCwgYzEsIGMzLCBjNCwgZDEsIGQzLCBkNCk7XG4gICAgcmVzdWx0Lm0zMiA9IC1kZXRlcm1pbmFudDN4MyhhMSwgYTMsIGE0LCBiMSwgYjMsIGI0LCBkMSwgZDMsIGQ0KTtcbiAgICByZXN1bHQubTQyID0gIGRldGVybWluYW50M3gzKGExLCBhMywgYTQsIGIxLCBiMywgYjQsIGMxLCBjMywgYzQpO1xuXG4gICAgcmVzdWx0Lm0xMyA9ICBkZXRlcm1pbmFudDN4MyhiMSwgYjIsIGI0LCBjMSwgYzIsIGM0LCBkMSwgZDIsIGQ0KTtcbiAgICByZXN1bHQubTIzID0gLWRldGVybWluYW50M3gzKGExLCBhMiwgYTQsIGMxLCBjMiwgYzQsIGQxLCBkMiwgZDQpO1xuICAgIHJlc3VsdC5tMzMgPSAgZGV0ZXJtaW5hbnQzeDMoYTEsIGEyLCBhNCwgYjEsIGIyLCBiNCwgZDEsIGQyLCBkNCk7XG4gICAgcmVzdWx0Lm00MyA9IC1kZXRlcm1pbmFudDN4MyhhMSwgYTIsIGE0LCBiMSwgYjIsIGI0LCBjMSwgYzIsIGM0KTtcblxuICAgIHJlc3VsdC5tMTQgPSAtZGV0ZXJtaW5hbnQzeDMoYjEsIGIyLCBiMywgYzEsIGMyLCBjMywgZDEsIGQyLCBkMyk7XG4gICAgcmVzdWx0Lm0yNCA9ICBkZXRlcm1pbmFudDN4MyhhMSwgYTIsIGEzLCBjMSwgYzIsIGMzLCBkMSwgZDIsIGQzKTtcbiAgICByZXN1bHQubTM0ID0gLWRldGVybWluYW50M3gzKGExLCBhMiwgYTMsIGIxLCBiMiwgYjMsIGQxLCBkMiwgZDMpO1xuICAgIHJlc3VsdC5tNDQgPSAgZGV0ZXJtaW5hbnQzeDMoYTEsIGEyLCBhMywgYjEsIGIyLCBiMywgYzEsIGMyLCBjMyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I2ludmVyc2UoKSAtPiBGaXJtaW5DU1NNYXRyaXggfCBudWxsXG4gKlxuICogIElmIHRoZSBtYXRyaXggaXMgaW52ZXJ0aWJsZSwgcmV0dXJucyBpdHMgaW52ZXJzZSwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbC5cbiAqKi9cbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUuaW52ZXJzZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbnYsIGRldCwgcmVzdWx0LCBpLCBqO1xuXG4gICAgaWYgKHRoaXMuaXNJZGVudGl0eU9yVHJhbnNsYXRpb24oKSkge1xuICAgICAgICBpbnYgPSBuZXcgRmlybWluQ1NTTWF0cml4KCk7XG5cbiAgICAgICAgaWYgKCEodGhpcy5tNDEgPT09IDAgJiYgdGhpcy5tNDIgPT09IDAgJiYgdGhpcy5tNDMgPT09IDApKSB7XG4gICAgICAgICAgICBpbnYubTQxID0gLXRoaXMubTQxO1xuICAgICAgICAgICAgaW52Lm00MiA9IC10aGlzLm00MjtcbiAgICAgICAgICAgIGludi5tNDMgPSAtdGhpcy5tNDM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW52O1xuICAgIH1cblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgYWRqb2ludCBtYXRyaXhcbiAgICByZXN1bHQgPSB0aGlzLmFkam9pbnQoKTtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgNHg0IGRldGVybWluYW50XG4gICAgZGV0ID0gRmlybWluQ1NTTWF0cml4LmRldGVybWluYW50NHg0KHRoaXMpO1xuXG4gICAgLy8gSWYgdGhlIGRldGVybWluYW50IGlzIHplcm8sIHRoZW4gdGhlIGludmVyc2UgbWF0cml4IGlzIG5vdCB1bmlxdWVcbiAgICBpZiAoTWF0aC5hYnMoZGV0KSA8IDFlLTgpIHJldHVybiBudWxsO1xuXG4gICAgLy8gU2NhbGUgdGhlIGFkam9pbnQgbWF0cml4IHRvIGdldCB0aGUgaW52ZXJzZVxuICAgIGZvciAoaSA9IDE7IGkgPCA1OyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IDU7IGorKykge1xuICAgICAgICAgICAgcmVzdWx0WyhcIm1cIiArIGkpICsgal0gLz0gZGV0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNyb3RhdGUocm90WCwgcm90WSwgcm90WikgLT4gRmlybWluQ1NTTWF0cml4XG4gKiAgLSByb3RYIChOdW1iZXIpOiB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB4IGF4aXMuXG4gKiAgLSByb3RZIChOdW1iZXIpOiB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB5IGF4aXMuIElmIHVuZGVmaW5lZCwgdGhlIHhcbiAqICAgIGNvbXBvbmVudCBpcyB1c2VkLlxuICogIC0gcm90WiAoTnVtYmVyKTogdGhlIHJvdGF0aW9uIGFyb3VuZCB0aGUgeiBheGlzLiBJZiB1bmRlZmluZWQsIHRoZSB4XG4gKiAgICBjb21wb25lbnQgaXMgdXNlZC5cbiAqXG4gKiAgUmV0dXJucyB0aGUgcmVzdWx0IG9mIHJvdGF0aW5nIHRoZSBtYXRyaXggYnkgYSBnaXZlbiB2ZWN0b3IuXG4gKlxuICogIElmIG9ubHkgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIHByb3ZpZGVkLCB0aGUgbWF0cml4IGlzIG9ubHkgcm90YXRlZCBhYm91dFxuICogIHRoZSB6IGF4aXMuXG4gKiovXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLnJvdGF0ZSA9IGZ1bmN0aW9uKHJ4LCByeSwgcnopIHtcbiAgICB2YXIgZGVncmVlc1RvUmFkaWFucyA9IEZpcm1pbkNTU01hdHJpeC5kZWdyZWVzVG9SYWRpYW5zO1xuXG4gICAgaWYgKHR5cGVvZiByeCAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHJ4KSkgcnggPSAwO1xuXG4gICAgaWYgKCh0eXBlb2YgcnkgIT0gXCJudW1iZXJcIiB8fCBpc05hTihyeSkpICYmXG4gICAgKHR5cGVvZiByeiAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHJ6KSkpIHtcbiAgICAgICAgcnogPSByeDtcbiAgICAgICAgcnggPSAwO1xuICAgICAgICByeSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiByeSAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHJ5KSkgcnkgPSAwO1xuICAgIGlmICh0eXBlb2YgcnogIT0gXCJudW1iZXJcIiB8fCBpc05hTihyeikpIHJ6ID0gMDtcblxuICAgIHJ4ID0gZGVncmVlc1RvUmFkaWFucyhyeCk7XG4gICAgcnkgPSBkZWdyZWVzVG9SYWRpYW5zKHJ5KTtcbiAgICByeiA9IGRlZ3JlZXNUb1JhZGlhbnMocnopO1xuXG4gICAgdmFyIHR4ID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpLFxuICAgIHR5ID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpLFxuICAgIHR6ID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpLFxuICAgIHNpbkEsIGNvc0EsIHNpbkEyO1xuXG4gICAgcnogLz0gMjtcbiAgICBzaW5BID0gTWF0aC5zaW4ocnopO1xuICAgIGNvc0EgPSBNYXRoLmNvcyhyeik7XG4gICAgc2luQTIgPSBzaW5BICogc2luQTtcblxuICAgIC8vIE1hdHJpY2VzIGFyZSBpZGVudGl0eSBvdXRzaWRlIHRoZSBhc3NpZ25lZCB2YWx1ZXNcbiAgICB0ei5tMTEgPSB0ei5tMjIgPSAxIC0gMiAqIHNpbkEyO1xuICAgIHR6Lm0xMiA9IHR6Lm0yMSA9IDIgKiBzaW5BICogY29zQTtcbiAgICB0ei5tMjEgKj0gLTE7XG5cbiAgICByeSAvPSAyO1xuICAgIHNpbkEgID0gTWF0aC5zaW4ocnkpO1xuICAgIGNvc0EgID0gTWF0aC5jb3MocnkpO1xuICAgIHNpbkEyID0gc2luQSAqIHNpbkE7XG5cbiAgICB0eS5tMTEgPSB0eS5tMzMgPSAxIC0gMiAqIHNpbkEyO1xuICAgIHR5Lm0xMyA9IHR5Lm0zMSA9IDIgKiBzaW5BICogY29zQTtcbiAgICB0eS5tMTMgKj0gLTE7XG5cbiAgICByeCAvPSAyO1xuICAgIHNpbkEgPSBNYXRoLnNpbihyeCk7XG4gICAgY29zQSA9IE1hdGguY29zKHJ4KTtcbiAgICBzaW5BMiA9IHNpbkEgKiBzaW5BO1xuXG4gICAgdHgubTIyID0gdHgubTMzID0gMSAtIDIgKiBzaW5BMjtcbiAgICB0eC5tMjMgPSB0eC5tMzIgPSAyICogc2luQSAqIGNvc0E7XG4gICAgdHgubTMyICo9IC0xO1xuXG4gICAgdmFyIGlzSWRlbnRpdHkgPSAodGhpcy50b1N0cmluZygpID09PSAobmV3IEZpcm1pbkNTU01hdHJpeCkudG9TdHJpbmcoKSk7XG5cbiAgICByZXR1cm4gKGlzSWRlbnRpdHkpXG4gICAgPyB0ei5tdWx0aXBseSh0eSkubXVsdGlwbHkodHgpXG4gICAgOiB0aGlzLm11bHRpcGx5KHR4KS5tdWx0aXBseSh0eSkubXVsdGlwbHkodHopO1xufTtcblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I3JvdGF0ZUF4aXNBbmdsZShyb3RYLCByb3RZLCByb3RaLCBhbmdsZSkgLT4gRmlybWluQ1NTTWF0cml4XG4gKiAgLSByb3RYIChOdW1iZXIpOiB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB4IGF4aXMuXG4gKiAgLSByb3RZIChOdW1iZXIpOiB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB5IGF4aXMuIElmIHVuZGVmaW5lZCwgdGhlIHhcbiAqICAgIGNvbXBvbmVudCBpcyB1c2VkLlxuICogIC0gcm90WiAoTnVtYmVyKTogdGhlIHJvdGF0aW9uIGFyb3VuZCB0aGUgeiBheGlzLiBJZiB1bmRlZmluZWQsIHRoZSB4XG4gKiAgICBjb21wb25lbnQgaXMgdXNlZC5cbiAqICAtIGFuZ2xlIChOdW1iZXIpOiB0aGUgYW5nbGUgb2Ygcm90YXRpb24gYWJvdXQgdGhlIGF4aXMgdmVjdG9yLCBpbiBkZWdyZWVzLlxuICpcbiAqICBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygcm90YXRpbmcgdGhlIG1hdHJpeCBhcm91bmQgYSBnaXZlbiB2ZWN0b3IgYnkgYSBnaXZlblxuICogIGFuZ2xlLlxuICpcbiAqICBJZiB0aGUgZ2l2ZW4gdmVjdG9yIGlzIHRoZSBvcmlnaW4gdmVjdG9yIHRoZW4gdGhlIG1hdHJpeCBpcyByb3RhdGVkIGJ5IHRoZVxuICogIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgeiBheGlzLlxuICoqL1xuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5yb3RhdGVBeGlzQW5nbGUgPSBmdW5jdGlvbih4LCB5LCB6LCBhKSB7XG4gICAgaWYgKHR5cGVvZiB4ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oeCkpIHggPSAwO1xuICAgIGlmICh0eXBlb2YgeSAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHkpKSB5ID0gMDtcbiAgICBpZiAodHlwZW9mIHogIT0gXCJudW1iZXJcIiB8fCBpc05hTih6KSkgeiA9IDA7XG4gICAgaWYgKHR5cGVvZiBhICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oYSkpIGEgPSAwO1xuICAgIGlmICh4ID09PSAwICYmIHkgPT09IDAgJiYgeiA9PT0gMCkgeiA9IDE7XG5cbiAgICB2YXIgdCAgID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpLFxuICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgIGNvc0EsIHNpbkEsIHNpbkEyLCBjc0EsIHgyLCB5MiwgejI7XG5cbiAgICBhICAgICA9IChGaXJtaW5DU1NNYXRyaXguZGVncmVlc1RvUmFkaWFucyhhKSB8fCAwKSAvIDI7XG4gICAgY29zQSAgPSBNYXRoLmNvcyhhKTtcbiAgICBzaW5BICA9IE1hdGguc2luKGEpO1xuICAgIHNpbkEyID0gc2luQSAqIHNpbkE7XG5cbiAgICAvLyBCYWQgdmVjdG9yLCB1c2Ugc29tZXRoaW5nIHNlbnNpYmxlXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICB4ID0gMDtcbiAgICAgICAgeSA9IDA7XG4gICAgICAgIHogPSAxO1xuICAgIH0gZWxzZSBpZiAobGVuICE9PSAxKSB7XG4gICAgICAgIHggLz0gbGVuO1xuICAgICAgICB5IC89IGxlbjtcbiAgICAgICAgeiAvPSBsZW47XG4gICAgfVxuXG4gICAgLy8gT3B0aW1pc2UgY2FzZXMgd2hlcmUgYXhpcyBpcyBhbG9uZyBtYWpvciBheGlzXG4gICAgaWYgKHggPT09IDEgJiYgeSA9PT0gMCAmJiB6ID09PSAwKSB7XG4gICAgICAgIHQubTIyID0gdC5tMzMgPSAxIC0gMiAqIHNpbkEyO1xuICAgICAgICB0Lm0yMyA9IHQubTMyID0gMiAqIGNvc0EgKiBzaW5BO1xuICAgICAgICB0Lm0zMiAqPSAtMTtcbiAgICB9IGVsc2UgaWYgKHggPT09IDAgJiYgeSA9PT0gMSAmJiB6ID09PSAwKSB7XG4gICAgICAgIHQubTExID0gdC5tMzMgPSAxIC0gMiAqIHNpbkEyO1xuICAgICAgICB0Lm0xMyA9IHQubTMxID0gMiAqIGNvc0EgKiBzaW5BO1xuICAgICAgICB0Lm0xMyAqPSAtMTtcbiAgICB9IGVsc2UgaWYgKHggPT09IDAgJiYgeSA9PT0gMCAmJiB6ID09PSAxKSB7XG4gICAgICAgIHQubTExID0gdC5tMjIgPSAxIC0gMiAqIHNpbkEyO1xuICAgICAgICB0Lm0xMiA9IHQubTIxID0gMiAqIGNvc0EgKiBzaW5BO1xuICAgICAgICB0Lm0yMSAqPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjc0EgPSBzaW5BICogY29zQTtcbiAgICAgICAgeDIgID0geCAqIHg7XG4gICAgICAgIHkyICA9IHkgKiB5O1xuICAgICAgICB6MiAgPSB6ICogejtcblxuICAgICAgICB0Lm0xMSA9IDEgLSAyICogKHkyICsgejIpICogc2luQTI7XG4gICAgICAgIHQubTEyID0gMiAqICh4ICogeSAqIHNpbkEyICsgeiAqIGNzQSk7XG4gICAgICAgIHQubTEzID0gMiAqICh4ICogeiAqIHNpbkEyIC0geSAqIGNzQSk7XG4gICAgICAgIHQubTIxID0gMiAqICh5ICogeCAqIHNpbkEyIC0geiAqIGNzQSk7XG4gICAgICAgIHQubTIyID0gMSAtIDIgKiAoejIgKyB4MikgKiBzaW5BMjtcbiAgICAgICAgdC5tMjMgPSAyICogKHkgKiB6ICogc2luQTIgKyB4ICogY3NBKTtcbiAgICAgICAgdC5tMzEgPSAyICogKHogKiB4ICogc2luQTIgKyB5ICogY3NBKTtcbiAgICAgICAgdC5tMzIgPSAyICogKHogKiB5ICogc2luQTIgLSB4ICogY3NBKTtcbiAgICAgICAgdC5tMzMgPSAxIC0gMiAqICh4MiArIHkyKSAqIHNpbkEyO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHQpO1xufTtcblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I3NjYWxlKHNjYWxlWCwgc2NhbGVZLCBzY2FsZVopIC0+IEZpcm1pbkNTU01hdHJpeFxuICogIC0gc2NhbGVYIChOdW1iZXIpOiB0aGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHggYXhpcy5cbiAqICAtIHNjYWxlWSAoTnVtYmVyKTogdGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB5IGF4aXMuIElmIHVuZGVmaW5lZCwgdGhlIHhcbiAqICAgIGNvbXBvbmVudCBpcyB1c2VkLlxuICogIC0gc2NhbGVaIChOdW1iZXIpOiB0aGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHogYXhpcy4gSWYgdW5kZWZpbmVkLCAxIGlzXG4gKiAgICB1c2VkLlxuICpcbiAqICBSZXR1cm5zIHRoZSByZXN1bHQgb2Ygc2NhbGluZyB0aGUgbWF0cml4IGJ5IGEgZ2l2ZW4gdmVjdG9yLlxuICoqL1xuRmlybWluQ1NTTWF0cml4LnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHNjYWxlWCwgc2NhbGVZLCBzY2FsZVopIHtcbiAgICB2YXIgdHJhbnNmb3JtID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpO1xuXG4gICAgaWYgKHR5cGVvZiBzY2FsZVggIT0gXCJudW1iZXJcIiB8fCBpc05hTihzY2FsZVgpKSBzY2FsZVggPSAxO1xuICAgIGlmICh0eXBlb2Ygc2NhbGVZICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oc2NhbGVZKSkgc2NhbGVZID0gc2NhbGVYO1xuICAgIGlmICh0eXBlb2Ygc2NhbGVaICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oc2NhbGVaKSkgc2NhbGVaID0gMTtcblxuICAgIHRyYW5zZm9ybS5tMTEgPSBzY2FsZVg7XG4gICAgdHJhbnNmb3JtLm0yMiA9IHNjYWxlWTtcbiAgICB0cmFuc2Zvcm0ubTMzID0gc2NhbGVaO1xuXG4gICAgcmV0dXJuIHRoaXMubXVsdGlwbHkodHJhbnNmb3JtKTtcbn07XG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNza2V3WChza2V3WCkgLT4gRmlybWluQ1NTTWF0cml4XG4gKiAgLSBza2V3WCAoTnVtYmVyKTogdGhlIHNjYWxpbmcgZmFjdG9yIGluIHRoZSB4IGF4aXMuXG4gKlxuICogIFJldHVybnMgdGhlIHJlc3VsdCBvZiBza2V3aW5nIHRoZSBtYXRyaXggYnkgYSBnaXZlbiB2ZWN0b3IuXG4gKiovXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLnNrZXdYID0gZnVuY3Rpb24oZGVncmVlcykge1xuICAgIHZhciByYWRpYW5zID0gRmlybWluQ1NTTWF0cml4LmRlZ3JlZXNUb1JhZGlhbnMoZGVncmVlcyk7XG4gICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKTtcblxuICAgIHRyYW5zZm9ybS5jID0gTWF0aC50YW4ocmFkaWFucyk7XG5cbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseSh0cmFuc2Zvcm0pO1xufTtcblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I3NrZXdZKHNrZXdZKSAtPiBGaXJtaW5DU1NNYXRyaXhcbiAqICAtIHNrZXdZIChOdW1iZXIpOiB0aGUgc2NhbGluZyBmYWN0b3IgaW4gdGhlIHggYXhpcy5cbiAqXG4gKiAgUmV0dXJucyB0aGUgcmVzdWx0IG9mIHNrZXdpbmcgdGhlIG1hdHJpeCBieSBhIGdpdmVuIHZlY3Rvci5cbiAqKi9cbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUuc2tld1kgPSBmdW5jdGlvbihkZWdyZWVzKSB7XG4gICAgdmFyIHJhZGlhbnMgPSBGaXJtaW5DU1NNYXRyaXguZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKTtcbiAgICB2YXIgdHJhbnNmb3JtID0gbmV3IEZpcm1pbkNTU01hdHJpeCgpO1xuXG4gICAgdHJhbnNmb3JtLmIgPSBNYXRoLnRhbihyYWRpYW5zKTtcblxuICAgIHJldHVybiB0aGlzLm11bHRpcGx5KHRyYW5zZm9ybSk7XG59O1xuXG4vKipcbiAqICBGaXJtaW5DU1NNYXRyaXgjdHJhbnNsYXRlKHgsIHksIHopIC0+IEZpcm1pbkNTU01hdHJpeFxuICogIC0geCAoTnVtYmVyKTogdGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3IuXG4gKiAgLSB5IChOdW1iZXIpOiB0aGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3Rvci5cbiAqICAtIHogKE51bWJlcik6IHRoZSB6IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yLiBJZiB1bmRlZmluZWQsIDAgaXMgdXNlZC5cbiAqXG4gKiAgUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRyYW5zbGF0aW5nIHRoZSBtYXRyaXggYnkgYSBnaXZlbiB2ZWN0b3IuXG4gKiovXG5GaXJtaW5DU1NNYXRyaXgucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgICB2YXIgdCA9IG5ldyBGaXJtaW5DU1NNYXRyaXgoKTtcblxuICAgIGlmICh0eXBlb2YgeCAhPSBcIm51bWJlclwiIHx8IGlzTmFOKHgpKSB4ID0gMDtcbiAgICBpZiAodHlwZW9mIHkgIT0gXCJudW1iZXJcIiB8fCBpc05hTih5KSkgeSA9IDA7XG4gICAgaWYgKHR5cGVvZiB6ICE9IFwibnVtYmVyXCIgfHwgaXNOYU4oeikpIHogPSAwO1xuXG4gICAgdC5tNDEgPSB4O1xuICAgIHQubTQyID0geTtcbiAgICB0Lm00MyA9IHo7XG5cbiAgICByZXR1cm4gdGhpcy5tdWx0aXBseSh0KTtcbn07XG5cbi8qKlxuICogIEZpcm1pbkNTU01hdHJpeCNzZXRNYXRyaXhWYWx1ZShkb21zdHIpIC0+IHVuZGVmaW5lZFxuICogIC0gZG9tc3RyIChTdHJpbmcpOiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIDJEIG9yIDNEIHRyYW5zZm9ybSBtYXRyaXhcbiAqICAgIGluIHRoZSBmb3JtIGdpdmVuIGJ5IHRoZSBDU1MgdHJhbnNmb3JtIHByb3BlcnR5LCBpLmUuIGp1c3QgbGlrZSB0aGVcbiAqICAgIG91dHB1dCBmcm9tIFtbRmlybWluQ1NTTWF0cml4I3RvU3RyaW5nXV0uXG4gKlxuICogIFNldHMgdGhlIG1hdHJpeCB2YWx1ZXMgdXNpbmcgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24sIHN1Y2ggYXMgdGhhdCBwcm9kdWNlZFxuICogIGJ5IHRoZSBbW0Zpcm1pbkNTU01hdHJpeCN0b1N0cmluZ11dIG1ldGhvZC5cbiAqKi9cbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUuc2V0TWF0cml4VmFsdWUgPSBmdW5jdGlvbihkb21zdHIpIHtcbiAgICBkb21zdHIgPSBGaXJtaW5DU1NNYXRyaXgudG9NYXRyaXhTdHJpbmcoZG9tc3RyLnRyaW0oKSk7XG4gICAgdmFyIG1zdHIgICA9IGRvbXN0ci5tYXRjaCgvXm1hdHJpeCgzZCk/XFwoXFxzKiguKylcXHMqXFwpJC8pLFxuICAgIGlzM2QsIGNodW5rcywgbGVuLCBwb2ludHMsIGksIGNodW5rO1xuXG4gICAgaWYgKCFtc3RyKSByZXR1cm47XG5cbiAgICBpczNkICAgPSAhIW1zdHJbMV07XG4gICAgY2h1bmtzID0gbXN0clsyXS5zcGxpdCgvXFxzKixcXHMqLyk7XG4gICAgbGVuICAgID0gY2h1bmtzLmxlbmd0aDtcbiAgICBwb2ludHMgPSBuZXcgQXJyYXkobGVuKTtcblxuICAgIGlmICgoaXMzZCAmJiBsZW4gIT09IDE2KSB8fCAhKGlzM2QgfHwgbGVuID09PSA2KSkge1xuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIkludmFsaWQgQ1NTIE1hdHJpeDogXCIsIGRvbXN0cik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgICAgIGlmIChjaHVuay5tYXRjaCgvXi0/XFxkKyhcXC5cXGQrKT8kLykpIHtcbiAgICAgICAgICAgIHBvaW50c1tpXSA9IHBhcnNlRmxvYXQoY2h1bmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJJbnZhbGlkIENTUyBNYXRyaXg6IFwiLCBkb21zdHIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBwb2ludCA9IGlzM2QgP1xuICAgICAgICAoXCJtXCIgKyAoTWF0aC5mbG9vcihpIC8gNCkgKyAxKSkgKyAoaSAlIDQgKyAxKSA6XG4gICAgICAgIFN0cmluZy5mcm9tQ2hhckNvZGUoaSArIDk3KTsgLy8gQVNDSUkgY2hhciA5NyA9PSAnYSdcbiAgICAgICAgdGhpc1twb2ludF0gPSBwb2ludHNbaV07XG4gICAgfVxufTtcblxuLyoqXG4gKiAgRmlybWluQ1NTTWF0cml4I3RvU3RyaW5nKCkgLT4gU3RyaW5nXG4gKlxuICogIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1hdHJpeC5cbiAqKi9cbkZpcm1pbkNTU01hdHJpeC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHBvaW50cywgcHJlZml4O1xuXG4gICAgaWYgKHRoaXMuaXNBZmZpbmUoKSkge1xuICAgICAgICBwcmVmaXggPSBcIm1hdHJpeChcIjtcbiAgICAgICAgcG9pbnRzID0gW1wiYVwiLCBcImJcIiwgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCJdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeCA9IFwibWF0cml4M2QoXCI7XG4gICAgICAgIHBvaW50cyA9IFtcIm0xMVwiLCBcIm0xMlwiLCBcIm0xM1wiLCBcIm0xNFwiLFxuICAgICAgICAgICAgXCJtMjFcIiwgXCJtMjJcIiwgXCJtMjNcIiwgXCJtMjRcIixcbiAgICAgICAgICAgIFwibTMxXCIsIFwibTMyXCIsIFwibTMzXCIsIFwibTM0XCIsXG4gICAgICAgICAgICBcIm00MVwiLCBcIm00MlwiLCBcIm00M1wiLCBcIm00NFwiXTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJlZml4ICsgcG9pbnRzLm1hcChmdW5jdGlvbihwKSB7XG4gICAgICAgIHJldHVybiBzZWxmW3BdLnRvRml4ZWQoNik7XG4gICAgfSkuam9pbihcIiwgXCIpICsgXCIpXCI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZpcm1pbkNTU01hdHJpeDtcblxuIiwidmFyIHByaW50U3RhY2tUcmFjZSA9IHJlcXVpcmUoXCIuLi9jb250cmliL3N0YWNrdHJhY2UtMC40LmpzXCIpO1xudmFyIE9wdGlvbnMgPSByZXF1aXJlKFwiLi9vcHRpb25zLmpzXCIpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoXCJhc3NlcnRcIik7XG5cbihmdW5jdGlvbiAobnMpIHtcblxuICAgIHZhciBPUFRJT05fTE9HTEVWRUwgPSBcImxvZ2xldmVsXCI7XG4gICAgT3B0aW9ucy5yZWdpc3RlcihPUFRJT05fTE9HTEVWRUwsIFwid2FybmluZ1wiKTtcblxuICAgIG5zLmV4cG9ydHMgPSB7XG4gICAgICAgIEFMTDogMCxcbiAgICAgICAgREVCVUc6IDEsXG4gICAgICAgIElORk86IDIsXG4gICAgICAgIFdBUk5JTkc6IDMsXG4gICAgICAgIEVSUk9SOiA0LFxuICAgICAgICBFWENFUFRJT046IDUsXG4gICAgICAgIHBhcmFtczoge30sXG4gICAgICAgIGlzU2V0dXA6IGZhbHNlLFxuICAgICAgICBsb2dsZXZlbDogNCxcbiAgICAgICAgbG9nbGV2ZWxzOiB7XG4gICAgICAgICAgICBhbGw6IDAsXG4gICAgICAgICAgICBkZWJ1ZzogMSxcbiAgICAgICAgICAgIGluZm86IDIsXG4gICAgICAgICAgICB3YXJuaW5nOiAzLFxuICAgICAgICAgICAgZXJyb3I6IDQsXG4gICAgICAgICAgICBleGNlcHRpb246IDVcbiAgICAgICAgfSxcblxuICAgICAgICBzZXR1cDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGRlYnVnID0gWE1MM0QuZGVidWc7XG4gICAgICAgICAgICBpZiAoIWRlYnVnLmlzU2V0dXApIHtcbiAgICAgICAgICAgICAgICBkZWJ1Zy5pc1NldHVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkZWJ1Zy5sb2dsZXZlbCA9IGRlYnVnLmxvZ2xldmVsc1tPcHRpb25zLmdldFZhbHVlKE9QVElPTl9MT0dMRVZFTCldIHx8IDM7XG4gICAgICAgICAgICAgICAgT3B0aW9ucy5hZGRPYnNlcnZlcihmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGtleSA9PSBPUFRJT05fTE9HTEVWRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnLmxvZ2xldmVsID0gZGVidWcubG9nbGV2ZWxzW3ZhbHVlXSB8fCAzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBfc2V0TG9nTGV2ZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB9LFxuICAgICAgICBkb0xvZzogZnVuY3Rpb24gKGxvZ1R5cGUsIGFyZ3MpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBYTUwzRC5kZWJ1Zy5wYXJhbXM7XG4gICAgICAgICAgICBpZiAocGFyYW1zLnhtbDNkX25vbG9nIHx8IGxvZ1R5cGUgPCBYTUwzRC5kZWJ1Zy5sb2dsZXZlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAobG9nVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLklORk86XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS5pbmZvLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLldBUk5JTkc6XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY29uc29sZS53YXJuLmFwcGx5KHdpbmRvdy5jb25zb2xlLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLkVSUk9SOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3IuYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgWE1MM0QuZGVidWcuRVhDRVBUSU9OOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3IocHJpbnRTdGFja1RyYWNlKHtlOiBhcmdzWzBdLCBndWVzczogdHJ1ZX0pLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFhNTDNELmRlYnVnLkRFQlVHOlxuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUuZGVidWcuYXBwbHkod2luZG93LmNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxvZ0RlYnVnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5kb0xvZyhYTUwzRC5kZWJ1Zy5ERUJVRywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9nSW5mbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2coWE1MM0QuZGVidWcuSU5GTywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9nV2FybmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcuZG9Mb2coWE1MM0QuZGVidWcuV0FSTklORywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9nRXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmRvTG9nKFhNTDNELmRlYnVnLkVSUk9SLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuICAgICAgICBsb2dFeGNlcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmRvTG9nKFhNTDNELmRlYnVnLkVYQ0VQVElPTiwgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXNzZXJ0OiBhc3NlcnQsXG4gICAgICAgIHRyYWNlOiBmdW5jdGlvbiAobXNnLCBsb2dUeXBlKSB7XG4gICAgICAgICAgICBsb2dUeXBlID0gbG9nVHlwZSAhPT0gdW5kZWZpbmVkID8gbG9nVHlwZSA6IFhNTDNELmRlYnVnLkVSUk9SO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlLnRyYWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1zZykge1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5kb0xvZyhsb2dUeXBlLCBbbXNnXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLnRyYWNlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IHByaW50U3RhY2tUcmFjZSgpO1xuICAgICAgICAgICAgICAgIG1zZyAmJiBzdGFjay5zcGxpY2UoMCwgMCwgbXNnKTtcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5kb0xvZyhsb2dUeXBlLCBzdGFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldE51bWJlcldpdGhQYWRkaW5nOiBmdW5jdGlvbiAobnVtYmVyLCB3aWR0aCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9IFwiXCIgKyBudW1iZXI7XG4gICAgICAgICAgICB3aGlsZSAocmVzLmxlbmd0aCA8IHdpZHRoKSByZXMgPSBcIiBcIiArIHJlcztcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdFNvdXJjZUNvZGU6IGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgICAgICAgICAgdmFyIHNvdXJjZUxpbmVzID0gc291cmNlLnNwbGl0KFwiXFxuXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2VMaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLmdldE51bWJlcldpdGhQYWRkaW5nKGkgKyAxLCAzKSArIFwiICBcIiArIHNvdXJjZUxpbmVzW2ldICsgXCJcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9O1xuXG59KG1vZHVsZSkpO1xuIiwiLy8gdXRpbHMvbWlzYy5qc1xuXG4oZnVuY3Rpb24oZXhwb3J0cykge1xuXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNlbmRzIHNpbmdsZSBvciBtdWx0aXBsZSBhZGFwdGVyIGZ1bmN0aW9ucyBieSBjYWxsaW5nIGZ1bmN0aW9uc1xuICAgICAqIHNwZWNpZmllZCBpbiBmdW5jcyBwYXJhbWV0ZXIgZm9yIGVhY2ggYWRhcHRlciBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBmdW5jcyBwYXJhbWV0ZXIgaXMgdXNlZCBhcyBhIGRpY3Rpb25hcnkgd2hlcmUgZWFjaCBrZXkgaXMgdXNlZCBhcyBuYW1lIG9mIGFcbiAgICAgKiBhZGFwdGVyIGZ1bmN0aW9uIHRvIGNhbGwsIGFuZCBjb3JyZXNwb25kaW5nIHZhbHVlIGlzIGEgbGlzdCBvZiBhcmd1bWVudHNcbiAgICAgKiAoaS5lLiBtdXN0IGJlIGFuIGFycmF5KS4gRm9yIGV4YW1wbGUgc2VuZEFkYXB0ZXJFdmVudChub2RlLCB7bWV0aG9kIDogWzEsMiwzXX0pXG4gICAgICogd2lsbCBjYWxsIGZ1bmN0aW9uICdtZXRob2QnIHdpdGggYXJndW1lbnRzIDEsMiwzIGZvciBlYWNoIGFkYXB0ZXIgb2YgdGhlIG5vZGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbm9kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmdW5jc1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiBhbGwgcmV0dXJuZWQgdmFsdWVzXG4gICAgICovXG4gICAgZXhwb3J0cy5jYWxsQWRhcHRlckZ1bmMgPSBmdW5jdGlvbihub2RlLCBmdW5jcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLl9jb25maWd1cmVkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB2YXIgYWRhcHRlcnMgPSBub2RlLl9jb25maWd1cmVkLmFkYXB0ZXJzO1xuICAgICAgICBmb3IgKHZhciBhZGFwdGVyIGluIGFkYXB0ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBmdW5jIGluIGZ1bmNzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFkYXB0ZXJPYmplY3QgPSBhZGFwdGVyc1thZGFwdGVyXTtcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRIYW5kbGVyID0gYWRhcHRlck9iamVjdFtmdW5jXTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV2ZW50SGFuZGxlci5hcHBseShhZGFwdGVyT2JqZWN0LCBmdW5jc1tmdW5jXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHNlbmRzIHNpbmdsZSBvciBtdWx0aXBsZSBhZGFwdGVyIGV2ZW50cyBieSBjYWxsaW5nIGZ1bmN0aW9uc1xuICAgICAqIHNwZWNpZmllZCBpbiBldmVudHMgcGFyYW1ldGVyIGZvciBlYWNoIGFkYXB0ZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlLlxuICAgICAqXG4gICAgICogZXZlbnRzIHBhcmFtZXRlciBpcyB1c2VkIGFzIGEgZGljdGlvbmFyeSB3aGVyZSBlYWNoIGtleSBpcyB1c2VkIGFzIG5hbWUgb2YgYVxuICAgICAqIGFkYXB0ZXIgZnVuY3Rpb24gdG8gY2FsbCwgYW5kIGNvcnJlc3BvbmRpbmcgdmFsdWUgaXMgYSBsaXN0IG9mIGFyZ3VtZW50c1xuICAgICAqIChpLmUuIG11c3QgYmUgYW4gYXJyYXkpLiBGb3IgZXhhbXBsZSBzZW5kQWRhcHRlckV2ZW50KG5vZGUsIHttZXRob2QgOiBbMSwyLDNdfSlcbiAgICAgKiB3aWxsIGNhbGwgZnVuY3Rpb24gJ21ldGhvZCcgd2l0aCBhcmd1bWVudHMgMSwyLDMgZm9yIGVhY2ggYWRhcHRlciBvZiB0aGUgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50c1xuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGZhbHNlIGlmIG5vZGUgaXMgbm90IGNvbmZpZ3VyZWQuXG4gICAgICovXG4gICAgZXhwb3J0cy5zZW5kQWRhcHRlckV2ZW50ID0gZnVuY3Rpb24obm9kZSwgZXZlbnRzKSB7XG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLl9jb25maWd1cmVkID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBhZGFwdGVycyA9IG5vZGUuX2NvbmZpZ3VyZWQuYWRhcHRlcnM7XG4gICAgICAgIGZvciAodmFyIGFkYXB0ZXIgaW4gYWRhcHRlcnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50IGluIGV2ZW50cykge1xuICAgICAgICAgICAgICAgIHZhciBldmVudEhhbmRsZXIgPSBhZGFwdGVyc1thZGFwdGVyXVtldmVudF07XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50SGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIuYXBwbHkoYWRhcHRlcnNbYWRhcHRlcl0sIGV2ZW50c1tldmVudF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBEaXNwYXRjaCBjdXN0b20gSFRNTCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBlbGVtZW50IG9yIGRvY3VtZW50LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgY3VzdG9tIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBjYW5CdWJibGUgV2hldGhlciB0aGUgZXZlbnQgcHJvcGFnYXRlcyB1cHdhcmQuIFNldHMgdGhlIHZhbHVlIGZvciB0aGUgYnViYmxlcyBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbmNlbGFibGUgV2hldGhlciB0aGUgZXZlbnQgaXMgY2FuY2VsYWJsZSBhbmQgc28gcHJldmVudERlZmF1bHQgY2FuIGJlIGNhbGxlZC4gU2V0cyB0aGUgdmFsdWVcbiAgICAgKiAgICAgICAgICAgICAgICAgIGZvciB0aGUgY2FuY2VsYWJsZSBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGV0YWlsIEEgdXNlci1kZWZpbmVkIG9iamVjdCB0aGF0IGNhbiBjb250YWluIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGV2ZW50LlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIG9mIGFueSB0eXBlLCBvciBudWxsLiBUaGlzIHZhbHVlIGlzIHJldHVybmVkIGluIHRoZSBkZXRhaWwgcHJvcGVydHkgb2YgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGV4cG9ydHMuZGlzcGF0Y2hDdXN0b21FdmVudCA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnRUeXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUsIGRldGFpbCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgZXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlLCBkZXRhaWwpO1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG5cbiAgICAvKiogRGlzcGF0Y2ggSFRNTCBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCAgICBlbGVtZW50IG9yIGRvY3VtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBzdGFuZGFyZCBldmVudCB0eXBlIGUuZy4gbG9hZCwgY2xpY2tcbiAgICAgKi9cbiAgICBleHBvcnRzLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbih0YXJnZXQsIGV2ZW50VHlwZSkge1xuICAgICAgICB2YXIgZXZ0ID0gbnVsbDtcbiAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudHNcIik7XG4gICAgICAgICAgICAgICAgZXZ0LmluaXRFdmVudChldmVudFR5cGUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCkge1xuICAgICAgICAgICAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5maXJlRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgZXZ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIHZhciBfX2F1dG9DcmVhdGVkVmlld0lkID0gMDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhY3RpdmUgdmlldyBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIHhtbDNkIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IHhtbDNkXG4gICAgICogQHJldHVybiB7T2JqZWN0fSB0aGUgYWN0aXZlIHZpZXcgZWxlbWVudFxuICAgICAqL1xuICAgIGV4cG9ydHMuZ2V0T3JDcmVhdGVBY3RpdmVWaWV3ID0gZnVuY3Rpb24oeG1sM2QpXG4gICAge1xuICAgICAgICAvLyB0cnkgdG8gcmVzb2x2ZSByZWZlcmVuY2VcbiAgICAgICAgdmFyIHJlZiA9IHhtbDNkLmFjdGl2ZVZpZXc7XG4gICAgICAgIGlmKHJlZilcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHYgPSB3aW5kb3cuWE1MM0QuVVJJUmVzb2x2ZXIucmVzb2x2ZUxvY2FsKHJlZik7XG4gICAgICAgICAgICBpZighdilcbiAgICAgICAgICAgICAgICB0aHJvdyBcIlhNTDNEIEVycm9yOiB4bWwzZCByZWZlcmVuY2VzIHZpZXcgdGhhdCBpcyBub3QgZGVmaW5lZDogJ1wiICsgcmVmICsgXCInLlwiO1xuXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRpZG4ndCBzdWNjZWVkLCBzbyBub3cgdHJ5IHRvIGp1c3QgdGFrZSB0aGUgZmlyc3Qgdmlld1xuICAgICAgICB2YXIgZmlyc3RWaWV3ID0geG1sM2QucXVlcnlTZWxlY3RvcihcInZpZXdcIik7XG4gICAgICAgIGlmKGZpcnN0VmlldylcbiAgICAgICAge1xuICAgICAgICAgICAgLy8gaWYgaXQgaGFzIGFuIGlkLCBzZXQgaXQgYXMgYWN0aXZlXG4gICAgICAgICAgICBpZihmaXJzdFZpZXcuaWQgJiYgZmlyc3RWaWV3LmlkLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgeG1sM2QuYWN0aXZlVmlldyA9IFwiI1wiICsgZmlyc3RWaWV3LmlkO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlyc3RWaWV3O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlkbid0IGZpbmQgYW55OiBjcmVhdGUgbmV3IG9uZVxuICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwieG1sM2QgZWxlbWVudCBoYXMgbm8gdmlldyBkZWZpbmVkOiBjcmVhdGluZyBvbmUuXCIpO1xuXG4gICAgICAgIHZhciB2aWQgPSBcInhtbDNkLmF1dG9jcmVhdGVkdmlld19cIiArIF9fYXV0b0NyZWF0ZWRWaWV3SWQrKztcbiAgICAgICAgdmFyIHYgPSBYTUwzRC5jcmVhdGVFbGVtZW50KFwidmlld1wiKTtcbiAgICAgICAgdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB2aWQpO1xuXG4gICAgICAgIHhtbDNkLmFwcGVuZENoaWxkKHYpO1xuICAgICAgICB4bWwzZC5hY3RpdmVWaWV3ID0gXCIjXCIgKyB2aWQ7XG5cbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfTtcblxuICAgIHZhciB0bXBDYW52YXMsIHRtcENvbnRleHQ7XG5cbiAgICBleHBvcnRzLnRvSW1hZ2VEYXRhID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgICAgIGlmKGltYWdlRGF0YSBpbnN0YW5jZW9mIEltYWdlRGF0YSlcbiAgICAgICAgICAgIHJldHVybiBpbWFnZURhdGE7XG4gICAgICAgIGlmKCFpbWFnZURhdGEuZGF0YSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGRhdGEgcHJvcGVydHlcIik7XG4gICAgICAgIGlmKCFpbWFnZURhdGEud2lkdGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyB3aWR0aCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgaWYoIWltYWdlRGF0YS5oZWlnaHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBoZWlnaHQgcHJvcGVydHlcIik7XG4gICAgICAgIGlmKCF0bXBDb250ZXh0KSB7XG4gICAgICAgICAgICB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIHRtcENvbnRleHQgPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3SW1hZ2VEYXRhID0gdG1wQ29udGV4dC5jcmVhdGVJbWFnZURhdGEoaW1hZ2VEYXRhLndpZHRoLCBpbWFnZURhdGEuaGVpZ2h0KTtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGltYWdlRGF0YS5kYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IGltYWdlRGF0YS5kYXRhW2ldO1xuICAgICAgICAgICAgaWYodiA+IDI1NSlcbiAgICAgICAgICAgICAgICB2ID0gMjU1O1xuICAgICAgICAgICAgaWYodiA8IDApXG4gICAgICAgICAgICAgICAgdiA9IDA7XG4gICAgICAgICAgICBuZXdJbWFnZURhdGEuZGF0YVtpXSA9IHY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0ltYWdlRGF0YTtcbiAgICB9O1xuXG59KG1vZHVsZS5leHBvcnRzKSk7XG4iLCIoZnVuY3Rpb24gKG5zKSB7XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyB0byBoYW5kbGUgb3B0aW9ucy4gQ3VycmVudGx5IG9ubHkgdXNlZCBmb3IgZ2xvYmFsIG9wdGlvbnMsIGNvdWxkXG4gICAgICogYmUgZXh0ZW5kZWQgdG8gd29yayBoaWVyYXJjaGljYWxseSB0byBjb25maWd1cmUgb3RoZXIgZWxlbWVudHMuXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgdmFyIE9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0geyBcIipcIjogW10gfTtcbiAgICB9O1xuXG4gICAgT3B0aW9ucy5wcm90b3R5cGUgPSB7XG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uIGFscmVhZHkgcmVnaXN0ZXJlZCAnXCIgKyBrZXkgKyBcIidcIik7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zW2tleV0gPSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFZhbHVlOiBkZWZhdWx0VmFsdWUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0VmFsdWU6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBrZXkgJ1wiICsga2V5ICsgXCInXCIpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1trZXldLmN1cnJlbnRWYWx1ZSA9IHRoaXMuX29wdGlvbnNba2V5XS5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeU9ic2VydmVycyhrZXksIHRoaXMuX29wdGlvbnNba2V5XS5jdXJyZW50VmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBrZXkgJ1wiICsga2V5ICsgXCInXCIpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9uc1trZXldLmN1cnJlbnRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlPYnNlcnZlcnMoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29uZmlndXJhdGlvbiBrZXkgJ1wiICsga2V5ICsgXCInXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnNba2V5XS5jdXJyZW50VmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldEtleXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9vcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgbm90aWZ5T2JzZXJ2ZXJzOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gTm90aWZ5IHNwZWNpZmljIG9ic2VydmVyc1xuICAgICAgICAgICAgaWYodGhpcy5fbGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICAgICAgICAgICBsKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90aWZ5IGdlbmVyaWMgb2JzZXJ2ZXJzXG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbXCIqXCJdLmZvckVhY2goZnVuY3Rpb24obCkge1xuICAgICAgICAgICAgICAgbChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBhZGRPYnNlcnZlcjogZnVuY3Rpb24gKGtleSwgb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmKHR5cGVvZiBrZXkgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG9ic2VydmVyID0ga2V5O1xuICAgICAgICAgICAgICAgIGtleSA9IFwiKlwiXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighdGhpcy5fb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGtleSAhPT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCByZWdpc3RlciB0byB1bmtub3duIG9wdGlvbiAnXCIgKyBrZXkgKyBcIidcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighdGhpcy5fbGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNba2V5XSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2tleV0ucHVzaChvYnNlcnZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZU9ic2VydmVyOiBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGZvcih2YXIgZmlsdGVyIGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZmlsdGVyXTtcbiAgICAgICAgICAgICAgICB2YXIgaWR4ID0gbGlzdGVuZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChpZHggIT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBHbG9iYWxPcHRpb25zID0gbmV3IE9wdGlvbnMoKTtcblxuICAgIEdsb2JhbE9wdGlvbnMuc2V0T3B0aW9uc0Zyb21RdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cigxKS5zcGxpdCgnJicpO1xuXG4gICAgICAgIHAuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGtleVZhbCA9IGUuc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGtleVZhbFswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuaW5kZXhPZihcInhtbDNkLVwiKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoa2V5VmFsWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5vcHRpb25zLnNldFZhbHVlKGtleS5zdWJzdHIoNiksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgWE1MM0QuZGVidWcgJiYgWE1MM0QuZGVidWcubG9nRXJyb3IoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5zLmV4cG9ydHMgPSBHbG9iYWxPcHRpb25zO1xuXG59KG1vZHVsZSkpO1xuIiwiKGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiAgICAvKipcbiAgICAgKiBDbGFzcyBVUklcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBVUkkgYXMgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIFVSSSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgc3RyID0gc3RyIHx8IFwiXCI7XG4gICAgICAgIGlmIChzdHIuaW5kZXhPZihcImJsb2I6XCIpID09IDApIHtcbiAgICAgICAgICAgIC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cudzMub3JnL1RSL0ZpbGVBUEkvI3VybFxuICAgICAgICAgICAgdmFyIHBhcnNlciA9IC9eKD86KFteOlxcLz9cXCNdKyk6KT8oW15cXCNdKikoPzpcXCMoLiopKT8vO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHN0ci5tYXRjaChwYXJzZXIpO1xuICAgICAgICAgICAgLyoqICBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgICAgIHRoaXMudmFsaWQgPSByZXN1bHQgIT0gbnVsbDtcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgICAgICB0aGlzLnNjaGVtZSA9IHJlc3VsdFsxXSB8fCBudWxsO1xuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICAgIHRoaXMuYXV0aG9yaXR5ID0gbnVsbDtcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBudWxsO1xuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSBudWxsO1xuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICAgIHRoaXMub3BhcXVlU3RyaW5nID0gcmVzdWx0WzJdIHx8IG51bGw7XG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHJlc3VsdFszXSB8fCBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQmFzZWQgb24gdGhlIHJlZ2V4IGluIFJGQzIzOTYgQXBwZW5kaXggQi5cbiAgICAgICAgICAgIHZhciBwYXJzZXIgPSAvXig/OihbXjpcXC8/XFwjXSspOik/KD86XFwvXFwvKFteXFwvP1xcI10qKSk/KFteP1xcI10qKSg/OlxcPyhbXlxcI10qKSk/KD86XFwjKC4qKSk/LztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBzdHIubWF0Y2gocGFyc2VyKTtcbiAgICAgICAgICAgIC8qKiAgQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgICAgICB0aGlzLnZhbGlkID0gcmVzdWx0ICE9IG51bGw7XG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgICAgICAgICAgdGhpcy5zY2hlbWUgPSByZXN1bHRbMV0gfHwgbnVsbDtcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgICAgICB0aGlzLmF1dGhvcml0eSA9IHJlc3VsdFsyXSB8fCBudWxsO1xuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICAgIHRoaXMucGF0aCA9IHJlc3VsdFszXSB8fCBudWxsO1xuICAgICAgICAgICAgLyoqICBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICAgIHRoaXMucXVlcnkgPSByZXN1bHRbNF0gfHwgbnVsbDtcbiAgICAgICAgICAgIC8qKiAgQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgICAgICB0aGlzLm9wYXF1ZVN0cmluZyA9IG51bGw7XG4gICAgICAgICAgICAvKiogIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgICAgICAgICAgdGhpcy5mcmFnbWVudCA9IHJlc3VsdFs1XSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgVVJJIGlzIHJlbGF0aXZlIHRvIGN1cnJlbnQgZG9jdW1lbnRcbiAgICAgKi9cbiAgICBVUkkucHJvdG90eXBlLmlzTG9jYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtZSAhPSBcImJsb2JcIiAmJiAhdGhpcy5hdXRob3JpdHkgJiYgIXRoaXMucGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIFVSSSBpcyBhYnNvbHV0ZVxuICAgICAqL1xuICAgIFVSSS5wcm90b3R5cGUuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1lICE9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFic29sdXRlIFVSSSByZWxhdGl2ZSB0byB0aGUgcHJvdmlkZWQgZG9jdW1lbnQgdXJpXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRvY1VyaSB1cmkgb2YgZG9jdW1lbnQgZnJvbSB3aGljaCB0aGlzIHVyaSBvcmlnaW5hdGVzXG4gICAgICogQHJldHVybnMge1VSSX1cbiAgICAgKi9cbiAgICBVUkkucHJvdG90eXBlLmdldEFic29sdXRlVVJJID0gZnVuY3Rpb24gKGRvY1VyaSkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWQgfHwgdGhpcy5pc0Fic29sdXRlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRvY1VyaU9iaiA9IG5ldyBVUkkoZG9jVXJpKTtcblxuICAgICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXRoLmluZGV4T2YoXCIvXCIpID09IDApIHtcbiAgICAgICAgICAgICAgICBkb2NVcmlPYmoucGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jVXJpT2JqLnBhdGggPSBkb2NVcmlPYmoucGF0aC5zdWJzdHIoMCwgZG9jVXJpT2JqLnBhdGgubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyB0aGlzLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb2NVcmlPYmoucXVlcnkgPSB0aGlzLnF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgICAgICAgIGRvY1VyaU9iai5xdWVyeSA9IHRoaXMucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgZG9jVXJpT2JqLmZyYWdtZW50ID0gdGhpcy5mcmFnbWVudDtcblxuICAgICAgICByZXR1cm4gZG9jVXJpT2JqO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhpcyBVUkkgaGFzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgcHJvdmlkZWQgcmVmZXJlbmNlXG4gICAgICogQHBhcmFtIHtVUkl8c3RyaW5nfSBvdGhlclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIFVSSS5wcm90b3R5cGUuaGFzU2FtZU9yaWdpbiA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICBpZiAodHlwZW9mIG90aGVyID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgb3RoZXIgPSBuZXcgVVJJKG90aGVyKTtcblxuICAgICAgICBpZiAodGhpcy5zY2hlbWUgPT0gXCJibG9iXCIgfHwgdGhpcy5zY2hlbWUgPT0gXCJkYXRhXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1lID09IG90aGVyLnNjaGVtZSAmJiB0aGlzLmF1dGhvcml0eSA9PSBvdGhlci5hdXRob3JpdHk7XG4gICAgfTtcblxuXG4vLyBSZXN0b3JlIHRoZSBVUkkgdG8gaXQncyBzdHJpbmd5IGdsb3J5LlxuICAgIFVSSS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5zY2hlbWUgPT0gXCJibG9iXCIpIHtcbiAgICAgICAgICAgIHN0ciA9IFwiYmxvYjpcIiArIHRoaXMub3BhcXVlU3RyaW5nO1xuICAgICAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBzdHIgKz0gXCIjXCIgKyB0aGlzLmZyYWdtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2hlbWUpIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnNjaGVtZSArIFwiOlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dGhvcml0eSkge1xuICAgICAgICAgICAgc3RyICs9IFwiLy9cIiArIHRoaXMuYXV0aG9yaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgICAgICAgIHN0ciArPSBcIj9cIiArIHRoaXMucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHN0ciArPSBcIiNcIiArIHRoaXMuZnJhZ21lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4vLyBSZXN0b3JlIHRoZSBVUkkgdG8gaXQncyBzdHJpbmd5IGdsb3J5IG1pbnVzIHRoZSBmcmFnbWVudFxuICAgIFVSSS5wcm90b3R5cGUudG9TdHJpbmdXaXRob3V0RnJhZ21lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdHIgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5zY2hlbWUgPT0gXCJibG9iXCIpIHtcbiAgICAgICAgICAgIHN0ciA9IFwiYmxvYjpcIiArIHRoaXMub3BhcXVlU3RyaW5nO1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zY2hlbWUpIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnNjaGVtZSArIFwiOlwiO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmF1dGhvcml0eSkge1xuICAgICAgICAgICAgc3RyICs9IFwiLy9cIiArIHRoaXMuYXV0aG9yaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnBhdGgpIHtcbiAgICAgICAgICAgIHN0ciArPSB0aGlzLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucXVlcnkpIHtcbiAgICAgICAgICAgIHN0ciArPSBcIj9cIiArIHRoaXMucXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2xhc3MgVVJJUmVzb2x2ZXJcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgVVJJUmVzb2x2ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgYSBsb2NhbCBVUkkgdG8gYW4gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3xVUkkpfSB1cmkgRWxlbWVudCB0byByZXNvbHZlXG4gICAgICogQHBhcmFtIHtEb2N1bWVudD19IGRvY3VtZW50IEJhc2UgZG9jdW1lbnQgdG8gdXNlXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHJlc29sdmVkIGVsZW1lbnQgb3IgbnVsbCBpZiBpdCBjb3VsZCBub3QgYmUgcmVzb2x2ZWRcbiAgICAgKi9cbiAgICBVUklSZXNvbHZlci5yZXNvbHZlTG9jYWwgPSBmdW5jdGlvbiAodXJpLCBkb2N1bWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIHVyaSA9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHVyaSA9IG5ldyBVUkkodXJpKTtcbiAgICAgICAgZG9jdW1lbnQgPSBkb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG5cbiAgICAgICAgaWYgKHVyaS5zY2hlbWUgPT0gJ3VybicgfHwgdXJpLnNjaGVtZSA9PSBcImJsb2JcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVyaS5wYXRoICYmIHVyaS5mcmFnbWVudCkgeyAvLyBsb2NhbCB1cmlcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh1cmkuZnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG5cblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgVVJJUmVzb2x2ZXIucmVzb2x2ZSA9IGZ1bmN0aW9uICh1cmksIGRvY3VtZW50KSB7XG4gICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJZb3UgYXJlIHVzaW5nIGRlcHJlY2F0ZWQgWE1MM0QuVVJJUmVzb2x2ZXIucmVzb2x2ZS4gVXNlIFhNTDNELlVSSVJlc29sdmVyLnJlc29sdmVMb2NhbCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgcmV0dXJuIFVSSVJlc29sdmVyLnJlc29sdmVMb2NhbCh1cmksIGRvY3VtZW50KTtcbiAgICB9O1xuXG4gICAgZXhwb3J0cy5VUkkgPSBVUkk7XG4gICAgZXhwb3J0cy5VUklSZXNvbHZlciA9IFVSSVJlc29sdmVyO1xuXG4gICAgd2luZG93LlhNTDNELlVSSVJlc29sdmVyID0gVVJJUmVzb2x2ZXI7XG5cbn0obW9kdWxlLmV4cG9ydHMpKTtcbiIsIi8vVE9ETzogSGVscGZ1bCBBUEkgbWV0aG9kcyBjb25jZXJuaW5nIFdlYkNMIHdpbGwgYmUgYWRkZWQgd2hlbiBuZWVkZWQuIFBsZWFzZSBwcm92aWRlIGZlZWRiYWNrIVxuXG4vKipcbiAqIEBmaWxlIFdlYkNMIEFQSS4gUHJvdmlkZXMgdXNlZnVsIG1ldGhvZHMgZm9yIGluaXRpYWxpc2luZyBhbmQgdXRpbGlzaW5nIHRoZSBXZWJDTCBwbGF0Zm9ybS5cbiAqIEB2ZXJzaW9uIDAuMlxuICogQGF1dGhvciBUb25pIERhaGxcbiAqL1xuXG4oZnVuY3Rpb24gKG5hbWVzcGFjZSwgdW5kZWZpbmVkKSB7XG5cbiAgICB2YXIgcGxhdGZvcm1zID0gW10sXG4gICAgICAgIGRldmljZXMgPSBbXSxcbiAgICAgICAgY3R4ID0gbnVsbCxcblxuICAgICAgICBXZWJDTE5hbWVzcGFjZUF2YWlsYWJsZSA9IGZhbHNlLFxuICAgICAgICBPcGVuQ0xEcml2ZXJzQXZhaWxhYmxlID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiAgICAgQGNvbnN0YW50IHtzdHJpbmd9IERFRkFVTFRfREVWSUNFXG4gICAgICogICAgIEBkZWZhdWx0IFwiQ1BVXCJcbiAgICAgKi9cbiAgICB2YXIgREVGQVVMVF9ERVZJQ0UgPSBcIkNQVVwiLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAgICAgQHJlYWRvbmx5XG4gICAgICAgICAqICAgICBAbmFtZSBDTF9FUlJPUl9DT0RFU1xuICAgICAgICAgKiAgICAgQGVudW0ge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgICAgICBDTF9FUlJPUl9DT0RFUyA9IHtcbiAgICAgICAgICAgIFwiU1VDQ0VTU1wiOiAwLFxuICAgICAgICAgICAgXCJERVZJQ0VfTk9UX0ZPVU5EXCI6IC0xLFxuICAgICAgICAgICAgXCJERVZJQ0VfTk9UX0FWQUlMQUJMRVwiOiAtMixcbiAgICAgICAgICAgIFwiQ09NUElMRVJfTk9UX0FWQUlMQUJMRVwiOiAtMyxcbiAgICAgICAgICAgIFwiTUVNX09CSkVDVF9BTExPQ0FUSU9OX0ZBSUxVUkVcIjogLTQsXG4gICAgICAgICAgICBcIk9VVF9PRl9SRVNPVVJDRVNcIjogLTUsXG4gICAgICAgICAgICBcIk9VVF9PRl9IT1NUX01FTU9SWVwiOiAtNixcbiAgICAgICAgICAgIFwiUFJPRklMSU5HX0lORk9fTk9UX0FWQUlMQUJMRVwiOiAtNyxcbiAgICAgICAgICAgIFwiTUVNX0NPUFlfT1ZFUkxBUFwiOiAtOCxcbiAgICAgICAgICAgIFwiSU1BR0VfRk9STUFUX01JU01BVENIXCI6IC05LFxuICAgICAgICAgICAgXCJJTUFHRV9GT1JNQVRfTk9UX1NVUFBPUlRFRFwiOiAtMTAsXG4gICAgICAgICAgICBcIkJVSUxEX1BST0dSQU1fRkFJTFVSRVwiOiAtMTEsXG4gICAgICAgICAgICBcIk1BUF9GQUlMVVJFXCI6IC0xMixcbiAgICAgICAgICAgIFwiSU5WQUxJRF9WQUxVRVwiOiAtMzAsXG4gICAgICAgICAgICBcIklOVkFMSURfREVWSUNFX1RZUEVcIjogLTMxLFxuICAgICAgICAgICAgXCJJTlZBTElEX1BMQVRGT1JNXCI6IC0zMixcbiAgICAgICAgICAgIFwiSU5WQUxJRF9ERVZJQ0VcIjogLTMzLFxuICAgICAgICAgICAgXCJJTlZBTElEX0NPTlRFWFRcIjogLTM0LFxuICAgICAgICAgICAgXCJJTlZBTElEX1FVRVVFX1BST1BFUlRJRVNcIjogLTM1LFxuICAgICAgICAgICAgXCJJTlZBTElEX0NPTU1BTkRfUVVFVUVcIjogLTM2LFxuICAgICAgICAgICAgXCJJTlZBTElEX0hPU1RfUFRSXCI6IC0zNyxcbiAgICAgICAgICAgIFwiSU5WQUxJRF9NRU1fT0JKRUNUXCI6IC0zOCxcbiAgICAgICAgICAgIFwiSU5WQUxJRF9JTUFHRV9GT1JNQVRfREVTQ1JJUFRPUlwiOiAtMzksXG4gICAgICAgICAgICBcIklOVkFMSURfSU1BR0VfU0laRVwiOiAtNDAsXG4gICAgICAgICAgICBcIklOVkFMSURfU0FNUExFUlwiOiAtNDEsXG4gICAgICAgICAgICBcIklOVkFMSURfQklOQVJZXCI6IC00MixcbiAgICAgICAgICAgIFwiSU5WQUxJRF9CVUlMRF9PUFRJT05TXCI6IC00MyxcbiAgICAgICAgICAgIFwiSU5WQUxJRF9QUk9HUkFNXCI6IC00NCxcbiAgICAgICAgICAgIFwiSU5WQUxJRF9QUk9HUkFNX0VYRUNVVEFCTEVcIjogLTQ1LFxuICAgICAgICAgICAgXCJJTlZBTElEX0tFUk5FTF9OQU1FXCI6IC00NixcbiAgICAgICAgICAgIFwiSU5WQUxJRF9LRVJORUxfREVGSU5JVElPTlwiOiAtNDcsXG4gICAgICAgICAgICBcIklOVkFMSURfS0VSTkVMXCI6IC00OCxcbiAgICAgICAgICAgIFwiSU5WQUxJRF9BUkdfSU5ERVhcIjogLTQ5LFxuICAgICAgICAgICAgXCJJTlZBTElEX0FSR19WQUxVRVwiOiAtNTAsXG4gICAgICAgICAgICBcIklOVkFMSURfQVJHX1NJWkVcIjogLTUxLFxuICAgICAgICAgICAgXCJJTlZBTElEX0tFUk5FTF9BUkdTXCI6IC01MixcbiAgICAgICAgICAgIFwiSU5WQUxJRF9XT1JLX0RJTUVOU0lPTlwiOiAtNTMsXG4gICAgICAgICAgICBcIklOVkFMSURfV09SS19HUk9VUF9TSVpFXCI6IC01NCxcbiAgICAgICAgICAgIFwiSU5WQUxJRF9XT1JLX0lURU1fU0laRVwiOiAtNTUsXG4gICAgICAgICAgICBcIklOVkFMSURfR0xPQkFMX09GRlNFVFwiOiAtNTYsXG4gICAgICAgICAgICBcIklOVkFMSURfRVZFTlRfV0FJVF9MSVNUXCI6IC01NyxcbiAgICAgICAgICAgIFwiSU5WQUxJRF9FVkVOVFwiOiAtNTgsXG4gICAgICAgICAgICBcIklOVkFMSURfT1BFUkFUSU9OXCI6IC01OSxcbiAgICAgICAgICAgIFwiSU5WQUxJRF9HTF9PQkpFQ1RcIjogLTYwLFxuICAgICAgICAgICAgXCJJTlZBTElEX0JVRkZFUl9TSVpFXCI6IC02MSxcbiAgICAgICAgICAgIFwiSU5WQUxJRF9NSVBfTEVWRUxcIjogLTYyLFxuICAgICAgICAgICAgXCJJTlZBTElEX0dMT0JBTF9XT1JLX1NJWkVcIjogLTYzXG4gICAgICAgIH07XG4gICAgT2JqZWN0LmZyZWV6ZShDTF9FUlJPUl9DT0RFUyk7XG5cblxuICAgIGZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgQ0wgZXJyb3IgbmFtZSBjb3JyZXNwb25kaW5nIHRvIGEgQ0wgZXJyb3IgY29kZVxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmdldENMRXJyb3JOYW1lXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVycm9yQ29kZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXRDTEVycm9yTmFtZShlcnJvckNvZGUpIHtcbiAgICAgICAgdmFyIHByb3A7XG5cbiAgICAgICAgaWYgKGlzTnVtYmVyKGVycm9yQ29kZSkpIHtcbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBDTF9FUlJPUl9DT0RFUykge1xuICAgICAgICAgICAgICAgIGlmIChDTF9FUlJPUl9DT0RFU1twcm9wXSA9PT0gZXJyb3JDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiR290IHVua25vd24gT3BlbkNMIEVycm9yIENvZGU6XCIsIGVycm9yQ29kZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJVTktOT1dOX0VSUk9SXCI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbiBlcnJvciBjb2RlIGZyb20gYSBDTCBlcnJvciBtZXNzYWdlICh0aHJvd24gYnkgTm9raWEgV2ViQ0wgUGx1Z2luKVxuICAgICAqXG4gICAgICogQHBhcmFtIGVcbiAgICAgKiBAcmV0dXJucyB7SW50ZWdlcnxCb29sZWFufVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSkge1xuICAgICAgICB2YXIgY29kZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGUubmFtZSAmJiB0eXBlb2YgZS5uYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoQ0xfRVJST1JfQ09ERVNbZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDTF9FUlJPUl9DT0RFU1tlLm5hbWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlLm1lc3NhZ2UgJiYgdHlwZW9mIGUubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29kZSA9IGUubWVzc2FnZS5tYXRjaCgvLT9cXGQrL2cpO1xuXG4gICAgICAgICAgICBpZiAoY29kZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvZGVbY29kZS5sZW5ndGggLSAxXSwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgaW5zdGFuY2Ugb2YgV2ViQ0xFcnJvclxuICAgICAqXG4gICAgICogQGNvbnN0cnVjdG9yIFhNTDNELndlYmNsfldlYkNMRXJyb3JcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWU9XCJXZWJDTEVycm9yXCJdIEVycm9yIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21zZz1cIkdlbmVyaWMgV2ViQ0wgZXJyb3IuXCJdIFRoZSBkZXNpcmVkIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIFdlYkNMRXJyb3IobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChuYW1lICYmIHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dEZWJ1ZyhcIldlYkNMIEFQSTogV2ViQ0xFcnJvcjogRXJyb3IgbmFtZSBub3QgdHlwZSBvZiBTdHJpbmdcIik7XG4gICAgICAgICAgICBuYW1lID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtc2cgJiYgdHlwZW9mIG1zZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJXZWJDTCBBUEk6IFdlYkNMRXJyb3I6IEVycm9yIG1lc3NhZ2Ugbm90IHR5cGUgb2YgU3RyaW5nXCIpO1xuICAgICAgICAgICAgbXNnID0gXCJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJXZWJDTEVycm9yXCI7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1zZyB8fCBcIkdlbmVyaWMgV2ViQ0wgZXJyb3IuXCI7XG4gICAgICAgIHRoaXMuc3RhY2sgPSAobmV3IEVycm9yKCkpLnN0YWNrO1xuICAgIH1cblxuICAgIFdlYkNMRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICAgIFdlYkNMRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gV2ViQ0xFcnJvcjtcblxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIFdlYkNMIG5hbWVzcGFjZSBpcyBhdmFpbGFibGUuIFRoZSBuYW1lc3BhY2UgY2FuIGJlIHByb3ZpZGVkIGJ5IGEgV2ViQ0wgcGx1Z2luIG9yIG5hdGl2ZSBpbXBsZW1lbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5oYXNXZWJDTE5hbWVzcGFjZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gaGFzV2ViQ0xOYW1lc3BhY2UoKSB7XG4gICAgICAgIFdlYkNMTmFtZXNwYWNlQXZhaWxhYmxlID0gd2luZG93LndlYmNsICYmIHdlYmNsLmdldFBsYXRmb3JtcztcblxuICAgICAgICByZXR1cm4gV2ViQ0xOYW1lc3BhY2VBdmFpbGFibGU7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUZXN0cyBhIGJhc2ljIFdlYkNMIG1ldGhvZCB0byBzZWUgaWYgdGhlIE9wZW5DTCBkcml2ZXJzIGFyZSB3b3JraW5nIG9uIHVzZXJzIGRldmljZS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5oYXNPcGVuQ0xEcml2ZXJzXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBoYXNPcGVuQ0xEcml2ZXJzKCkge1xuICAgICAgICB2YXIgcGxhdEFycjtcbiAgICAgICAgT3BlbkNMRHJpdmVyc0F2YWlsYWJsZSA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBsYXRBcnIgPSB3ZWJjbC5nZXRQbGF0Zm9ybXMoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgT3BlbkNMRHJpdmVyc0F2YWlsYWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwbGF0QXJyIHx8IHBsYXRBcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBPcGVuQ0xEcml2ZXJzQXZhaWxhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gT3BlbkNMRHJpdmVyc0F2YWlsYWJsZTtcblxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbWJpbmVzIFdlYkNMIG5hbWVzcGFjZSBhbmQgZHJpdmVyIHRlc3QuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+aXNBdmFpbGFibGVcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGlzQXZhaWxhYmxlKCkge1xuICAgICAgICByZXR1cm4gaGFzV2ViQ0xOYW1lc3BhY2UoKSAmJiBoYXNPcGVuQ0xEcml2ZXJzKCk7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlcyB0aGUgV2ViQ0wgQVBJIHdpdGggZGVmYXVsdCB2YWx1ZXMgdXNpbmcgYSBwcmVkZWZpbmVkIGRldmljZSB0eXBlIG9yIGEgZGVmYXVsdCBkZXZpY2UgdHlwZS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5pbml0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlPVwiQ1BVXCJdIERldmljZSB0eXBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGluaXQodHlwZSkge1xuICAgICAgICAvLyBDaGVja2luZyBpZiBXZWJDTCBpcyBhdmFpbGFibGUgaW4gdGhlIHVzZXJzIHN5c3RlbVxuICAgICAgICBpZiAoIWhhc1dlYkNMTmFtZXNwYWNlKCkpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJXZWJDTCBBUEk6IFVuZm9ydHVuYXRlbHkgeW91ciBzeXN0ZW0gZG9lcyBub3Qgc3VwcG9ydCBXZWJDTC4gXCIgK1xuICAgICAgICAgICAgICAgIFwiV2ViQ0wgbmFtZXNwYWNlIGlzIG5vdCBhdmFpbGFibGUuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFoYXNPcGVuQ0xEcml2ZXJzKCkpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJXZWJDTCBBUEk6IFVuZm9ydHVuYXRlbHkgeW91ciBzeXN0ZW0gZG9lcyBub3Qgc3VwcG9ydCBXZWJDTC4gXCIgK1xuICAgICAgICAgICAgICAgIFwiT3BlbkNMIGRyaXZlcnMgYXJlIG5vdCB3b3JraW5nIHByb3Blcmx5LlwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBsYXRmb3JtcygpO1xuXG4gICAgICAgIGRldmljZXMgPSBnZXREZXZpY2VzQnlUeXBlKHR5cGUgfHwgREVGQVVMVF9ERVZJQ0UpO1xuXG4gICAgICAgIC8vIENyZWF0aW5nIGRlZmF1bHQgY29udGV4dFxuICAgICAgICBjdHggPSBjcmVhdGVDb250ZXh0KGRldmljZXMpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGF2YWlsYWJsZSBXZWJDTCBkZXZpY2UgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmdldFBsYXRmb3Jtc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldFBsYXRmb3JtcygpIHtcbiAgICAgICAgaWYocGxhdGZvcm1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcGxhdGZvcm1zID0gd2ViY2wuZ2V0UGxhdGZvcm1zKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGxhdGZvcm1zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGRldmljZXMgb2YgYSBjaG9zZW4gdHlwZSBmcm9tIGEgc2VsZWN0ZWQgcGxhdGZvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGU9XCJDUFVcIl0gRGV2aWNlIHR5cGVcbiAgICAgKiBAcGFyYW0ge0lXZWJDTFBsYXRmb3JtfSBwbGF0Zm9ybVxuICAgICAqIEByZXR1cm5zIHtBcnJheXxCb29sZWFufVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0UGxhdGZvcm1EZXZpY2VzQnlUeXBlKHR5cGUsIHBsYXRmb3JtKSB7XG4gICAgICAgIHZhciBkZXZpY2VBcnIgPSBbXSwgZXJyQ29kZTtcblxuICAgICAgICBpZiAoIXBsYXRmb3JtKSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogZ2V0UGxhdGZvcm1EZXZpY2VzQnlUeXBlKCk6IHBsYXRmb3JtIHdhcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0eXBlID0gdHlwZSB8fCBERUZBVUxUX0RFVklDRTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiQ1BVXCIpIHtcbiAgICAgICAgICAgICAgICBkZXZpY2VBcnIgPSBwbGF0Zm9ybS5nZXREZXZpY2VzKHdlYmNsLkRFVklDRV9UWVBFX0NQVSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiR1BVXCIpIHtcbiAgICAgICAgICAgICAgICBkZXZpY2VBcnIgPSBwbGF0Zm9ybS5nZXREZXZpY2VzKHdlYmNsLkRFVklDRV9UWVBFX0dQVSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiQUxMXCIpIHtcbiAgICAgICAgICAgICAgICBkZXZpY2VBcnIgPSBwbGF0Zm9ybS5nZXREZXZpY2VzKHdlYmNsLkRFVklDRV9UWVBFX0FMTCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xuXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJDb2RlICE9PSBDTF9FUlJPUl9DT0RFUy5ERVZJQ0VfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiQ291bGQgbm90IGdldCBkZXZpY2VzLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRldmljZUFycjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBkZXZpY2VzIG9mIGEgc2VsZWN0ZWQgdHlwZSBmcm9tIGFsbCBhdmFpbGFibGUgcGxhdGZvcm1zLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmdldERldmljZXNCeVR5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBEZXZpY2UgdHlwZVxuICAgICAqIEByZXR1cm5zIHtBcnJheXxCb29sZWFufVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0RGV2aWNlc0J5VHlwZSh0eXBlKSB7XG4gICAgICAgIHZhciByZXN1bHRBcnIgPSBbXSwgZGV2aWNlQXJyLCBpO1xuXG4gICAgICAgIGdldFBsYXRmb3JtcygpO1xuXG4gICAgICAgIGZvciAoaSA9IHBsYXRmb3Jtcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIGRldmljZUFyciA9IGdldFBsYXRmb3JtRGV2aWNlc0J5VHlwZSh0eXBlLCBwbGF0Zm9ybXNbaV0pO1xuXG4gICAgICAgICAgICBpZiAoZGV2aWNlQXJyKSB7XG4gICAgICAgICAgICAgICAgZGV2aWNlQXJyLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0QXJyLnB1c2godik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdEFyci5sZW5ndGggPT09IDAgPyBmYWxzZSA6IHJlc3VsdEFycjtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBsYXRmb3JtIG9uIHdoZXJlIHRoZSBkZXZpY2UgaXMuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+Z2V0RGV2aWNlUGxhdGZvcm1cbiAgICAgKiBAcGFyYW0ge0lXZWJDTERldmljZX0gZGV2aWNlXG4gICAgICogQHJldHVybnMge0lXZWJDTFBsYXRmb3JtfEJvb2xlYW59XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBnZXREZXZpY2VQbGF0Zm9ybShkZXZpY2UpIHtcbiAgICAgICAgdmFyIHBsYXRmb3JtO1xuXG4gICAgICAgIGlmICghZGV2aWNlKSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogZ2V0RGV2aWNlUGxhdGZvcm0oKTogZGV2aWNlIHdhcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGxhdGZvcm0gPSBkZXZpY2UuZ2V0SW5mbyh3ZWJjbC5ERVZJQ0VfUExBVEZPUk0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xuXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJDb3VsZCBub3QgZ2V0IHRoZSBwbGF0Zm9ybSBvZiB0aGUgZGV2aWNlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbGF0Zm9ybTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbEN0eFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gZ2V0Q29udGV4dERldmljZXMoY2xDdHgpIHtcbiAgICAgICAgdmFyIGRldmljZUFyciA9IFtdLCBlcnJDb2RlO1xuXG4gICAgICAgIGlmKCFjbEN0eCkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGdldENvbnRleHREZXZpY2VzKCk6IGNsQ3R4IHdhcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZGV2aWNlQXJyID0gY2xDdHguZ2V0SW5mbyh3ZWJjbC5DT05URVhUX0RFVklDRVMpO1xuICAgICAgICB9Y2F0Y2goZSkge1xuICAgICAgICAgICAgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xuXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJDb3VsZCBub3QgZ2V0IGRldmljZXMuXCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGV2aWNlQXJyLmxlbmd0aCA9PT0gMCA/IGZhbHNlIDogZGV2aWNlQXJyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBXZWJDTCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+Y3JlYXRlQ29udGV4dFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcGVydGllc11cbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMQ29udGV4dH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQocHJvcGVydGllcykge1xuICAgICAgLypcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgZGV2aWNlczogZ2V0RGV2aWNlc0J5VHlwZShERUZBVUxUX0RFVklDRSlcbiAgICAgICAgICAgIH0sIGNvbnRleHQ7XG5cbiAgICAgICAgWE1MM0QuZXh0ZW5kKHByb3BzLCBwcm9wZXJ0aWVzKTsqL1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgY29udGV4dCA9IHdlYmNsLmNyZWF0ZUNvbnRleHQocHJvcGVydGllcyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XG5cbiAgICAgICAgICAgIGlmICghZXJyQ29kZSkge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJGYWlsZWQgdG8gY3JlYXRlIGEgV2ViQ0wgY29udGV4dC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBkZWZhdWx0IFdlYkNMIGNvbnRleHQuXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+Z2V0RGVmYXVsdENvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMQ29udGV4dH1cbiAgICAgKi9cblxuICAgIGZ1bmN0aW9uIGdldERlZmF1bHRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gY3R4O1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFdlYkNMIHByb2dyYW0gZnJvbSBhIHN0cmluZyBvZiBXZWJDTCBjb2RlLlxuICAgICAqXG4gICAgICogQGZ1bmN0aW9uIFhNTDNELndlYmNsfmNyZWF0ZVByb2dyYW1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29kZVN0clxuICAgICAqIEBwYXJhbSB7SVdlYkNMQ29udGV4dH0gY2xDdHhcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMUHJvZ3JhbSB8IEJvb2xlYW59XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKGNvZGVTdHIsIGNsQ3R4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtO1xuXG4gICAgICAgIGNsQ3R4ID0gY2xDdHggfHwgY3R4O1xuXG4gICAgICAgIGlmICghY29kZVN0cikge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZVByb2dyYW0oKTogY29kZVN0ciB3YXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjbEN0eCkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZVByb2dyYW0oKTogY2xDdHggd2FzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBwcm9ncmFtID0gY2xDdHguY3JlYXRlUHJvZ3JhbShjb2RlU3RyKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcblxuICAgICAgICAgICAgaWYgKCFlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiRmFpbGVkIHRvIGNyZWF0ZSBhIFdlYkNMIHByb2dyYW0uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHByb2dyYW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIGEgV2ViQ0wgcHJvZ3JhbS5cbiAgICAgKlxuICAgICAqIEBmdW5jdGlvbiBYTUwzRC53ZWJjbH5idWlsZFByb2dyYW1cbiAgICAgKiBAcGFyYW0ge0lXZWJDTFByb2dyYW19IHByb2dyYW1cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBkZXZpY2VBcnJcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMUHJvZ3JhbXxCb29sZWFufVxuICAgICAqL1xuXG4gICAgZnVuY3Rpb24gYnVpbGRQcm9ncmFtKHByb2dyYW0sIGRldmljZUFycikge1xuICAgICAgICBkZXZpY2VBcnIgPSBkZXZpY2VBcnIgfHwgZGV2aWNlcztcblxuICAgICAgICBpZiAoIXByb2dyYW0pIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBidWlsZFByb2dyYW0oKTogcHJvZ3JhbSB3YXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHByb2dyYW0uYnVpbGQoZGV2aWNlQXJyLCBcIlwiKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcblxuICAgICAgICAgICAgaWYgKCFlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGVyckNvZGUpLFxuICAgICAgICAgICAgICAgIHByb2dyYW0uZ2V0QnVpbGRJbmZvKGRldmljZUFyclswXSwgV2ViQ0wuUFJPR1JBTV9CVUlMRF9MT0cpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBXZWJDTCBLZXJuZWwgdXNpbmcgYSBkZWZpbmVkIHByb2dyYW0uXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+Y3JlYXRlS2VybmVsXG4gICAgICogQHBhcmFtIHtJV2ViQ0xQcm9ncmFtfSBwcm9ncmFtXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMS2VybmVsfEJvb2xlYW59XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVLZXJuZWwocHJvZ3JhbSwgbmFtZSkge1xuICAgICAgICB2YXIga2VybmVsO1xuXG4gICAgICAgIGlmICghcHJvZ3JhbSkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZUtlcm5lbCgpOiBwcm9ncmFtIHdhcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVLZXJuZWwoKTogbmFtZSB3YXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtlcm5lbCA9IHByb2dyYW0uY3JlYXRlS2VybmVsKG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xuXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZXJyQ29kZSksIFwiRmFpbGVkIHRvIGNyZWF0ZSBhIFdlYkNMIGtlcm5lbC5cIik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ga2VybmVsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBXZWJDTCBDb21tYW5kIFF1ZXVlIGZvciBxdWV1ZWluZyBrZXJuZWxzIGZvciBleGVjdXRpb24uXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+Y3JlYXRlQ29tbWFuZFF1ZXVlXG4gICAgICogQHBhcmFtIHtJV2ViQ0xEZXZpY2V9IGRldmljZVxuICAgICAqIEBwYXJhbSB7SVdlYkNMQ29udGV4dH0gY2xDdHhcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMQ29tbWFuZFF1ZXVlfEJvb2xlYW59XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21tYW5kUXVldWUoZGV2aWNlLCBjbEN0eCkge1xuICAgICAgICB2YXIgY21kUXVldWU7XG5cbiAgICAgICAgY2xDdHggPSBjbEN0eCB8fCBjdHg7XG5cbiAgICAgICAgaWYoIWNsQ3R4KSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogY3JlYXRlQ29tbWFuZFF1ZXVlOiBjbEN0eCB3YXMgbm90IGRlZmluZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY21kUXVldWUgPSBjbEN0eC5jcmVhdGVDb21tYW5kUXVldWUoZGV2aWNlIHx8IGRldmljZXNbMF0sIDApO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xuXG4gICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdlYkNMRXJyb3IoZ2V0Q0xFcnJvck5hbWUoZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSkpLCBcIkNvdWxkIG5vdCBjcmVhdGUgQ29tbWFuZFF1ZXVlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbWRRdWV1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGlucHV0L291dHB1dCBidWZmZXIgdG8gYmUgdXNlZCB3aXRoIGEgV2ViQ0wga2VybmVsXG4gICAgICpcbiAgICAgKiBAZnVuY3Rpb24gWE1MM0Qud2ViY2x+Y3JlYXRlQnVmZmVyXG4gICAgICogQHBhcmFtIHtpbnR9IHNpemVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgICAqIEBwYXJhbSB7SVdlYkNMQ29udGV4dH0gY2xDdHhcbiAgICAgKiBAcmV0dXJucyB7SVdlYkNMTWVtb3J5T2JqZWN0fEJvb2xlYW59XG4gICAgICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVCdWZmZXIoc2l6ZSwgdHlwZSwgY2xDdHgpIHtcbiAgICAgICAgY2xDdHggPSBjbEN0eCB8fCBjdHg7XG5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogY3JlYXRlQnVmZmVyKCk6IEJ1ZmZlciBzaXplIHdhcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1lbHNlIGlmICghaXNOdW1iZXIoc2l6ZSkgfHwgc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVCdWZmZXIoKTogQnVmZmVyIHNpemUgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlci5cIik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBjcmVhdGVCdWZmZXIoKTogQnVmZmVyIHR5cGUgd2FzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFjbEN0eCkge1xuICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGNyZWF0ZUJ1ZmZlcigpOiBjbEN0eCB3YXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcInJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbEN0eC5jcmVhdGVCdWZmZXIod2ViY2wuTUVNX1JFQURfT05MWSwgc2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwid1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsQ3R4LmNyZWF0ZUJ1ZmZlcih3ZWJjbC5NRU1fV1JJVEVfT05MWSwgc2l6ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwicndcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbEN0eC5jcmVhdGVCdWZmZXIod2ViY2wuTUVNX1JFQURfV1JJVEUsIHNpemUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dFcnJvcihcIldlYkNMIEFQSTogY3JlYXRlQnVmZmVyKCk6IFVua25vd24gYnVmZmVyIHR5cGU6XCIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdmFyIGVyckNvZGUgPSBnZXRFcnJvckNvZGVGcm9tQ0xFcnJvcihlKTtcblxuICAgICAgICAgICAgaWYgKCFlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGVyckNvZGUpLCBcIkNvdWxkIG5vdCBjcmVhdGUgYSBXZWJDTCBidWZmZXIuXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBLZXJuZWxNYW5hZ2VyLlxuICAgICAqXG4gICAgICogQG5hbWUgS2VybmVsTWFuYWdlclxuICAgICAqIEBjb25zdHJ1Y3RvciBYTUwzRC53ZWJjbH5LZXJuZWxNYW5hZ2VyXG4gICAgICovXG5cbiAgICB2YXIgS2VybmVsTWFuYWdlciA9IGZ1bmN0aW9uIChjbEN0eCwgZGV2aWNlQXJyKSB7XG4gICAgICAgIHZhciBrZXJuZWxzID0ge307XG5cbiAgICAgICAgcmV0dXJuIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGFuZCBidWlsZHMgYSBXZWJDTCBwcm9ncmFtIGZyb20gYSBjb2RlIHN0cmluZyBhbmQgY3JlYXRlcyBhIFdlYkNMIGtlcm5lbCBmcm9tIHRoZSBwcm9ncmFtLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBmdW5jdGlvbiBLZXJuZWxNYW5hZ2VyfnJlZ2lzdGVyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVTdHJcbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICByZWdpc3RlcjogZnVuY3Rpb24gKG5hbWUsIGNvZGVTdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2VybmVscy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC5kZWJ1Zy5sb2dXYXJuaW5nKFwiV2ViQ0wgQVBJOiBrZXJuZWxzLnJlZ2lzdGVyKCk6IEtlcm5lbCB3aXRoIGEgc2FtZSBuYW1lIGlzIGFscmVhZHkgZGVmaW5lZC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRXJyb3IoXCJXZWJDTCBBUEk6IGtlcm5lbHMucmVnaXN0ZXIoKTogS2VybmVsIG5hbWUgd2FzIG5vdCBkZWZpbmVkIG9yIHdhcyBub3QgdHlwZSBvZiBTdHJpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2RlU3RyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0wgQVBJOiBrZXJuZWxzLnJlZ2lzdGVyKCk6IEtlcm5lbCBjb2RlIHdhcyBub3QgZGVmaW5lZCBvciB3YXMgbm90IHR5cGUgb2YgU3RyaW5nLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmFtLCBrZXJuZWw7XG5cbiAgICAgICAgICAgICAgICBwcm9ncmFtID0gY3JlYXRlUHJvZ3JhbShjb2RlU3RyLCBjbEN0eCk7XG5cbiAgICAgICAgICAgICAgICBidWlsZFByb2dyYW0ocHJvZ3JhbSwgZGV2aWNlQXJyKTtcblxuICAgICAgICAgICAgICAgIGlmIChwcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGtlcm5lbCA9IGNyZWF0ZUtlcm5lbChwcm9ncmFtLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2VybmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGtlcm5lbHNbbmFtZV0gPSBrZXJuZWw7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERlYWxsb2NhdGVzIGFuZCB1bnJlZ2lzdGVycyBhIGtlcm5lbC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gS2VybmVsTWFuYWdlcn51blJlZ2lzdGVyXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIHVuUmVnaXN0ZXI6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtlcm5lbHMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtlcm5lbHNbbmFtZV0ucmVsZWFzZSgpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyQ29kZSA9IGdldEVycm9yQ29kZUZyb21DTEVycm9yKGUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVyckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2ViQ0xFcnJvcihnZXRDTEVycm9yTmFtZShlcnJDb2RlKSwgXCJDb3VsZCBub3QgcmVsZWFzZSBrZXJuZWwgcmVzb3VyY2VzLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUga2VybmVsc1tuYW1lXTtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldHMgYSBrZXJuZWwgb2YgYSBzcGVjaWZpZWQgbmFtZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb24gS2VybmVsTWFuYWdlcn5nZXRLZXJuZWxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7SVdlYkNMS2VybmVsIHwgQm9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBnZXRLZXJuZWw6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoa2VybmVscy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VybmVsc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldHMgYXJndW1lbnRzIG9mIGEgc3BlY2lmaWVkIGtlcm5lbC5cbiAgICAgICAgICAgICAqIFRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGlzIGZ1bmN0aW9uIGlzIGEgcmVnaXN0ZXJlZCBrZXJuZWwgbmFtZSwgb3RoZXIgYXJndW1lbnRzIGFyZSB0aGUga2VybmVsIGFyZ3VtZW50cyByZXNwZWN0aXZlbHkuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uIEtlcm5lbE1hbmFnZXJ+c2V0QXJnc1xuICAgICAgICAgICAgICogQHBhcmFtIHtJV2ViQ0xLZXJuZWx9IGtlcm5lbCBXZWJDTCBrZXJuZWxcbiAgICAgICAgICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBLZXJuZWwgYXJndW1lbnRzIGluIHRoZSBzYW1lIG9yZGVyIGFzIGRlZmluZWQgaW4gdGhlIGtlcm5lbCBjb2RlXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICBzZXRBcmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgICAgICBrZXJuZWwsIGlucHV0QXJncywgbktlcm5lbEFyZ3MsIGk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ1dhcm5pbmcoXCJXZWJDTCBBUEk6IHNldEFyZ3MoKTogTm8ga2VybmVsIGFyZ3VtZW50cyB3ZXJlIGRlZmluZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAga2VybmVsID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBpbnB1dEFyZ3MgPSBhcmdzLnNsaWNlKDEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFrZXJuZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIldlYkNMIEFQSTogc2V0QXJncygpOiBXZWJDTCBrZXJuZWwgd2FzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5LZXJuZWxBcmdzID0ga2VybmVsLmdldEluZm8od2ViY2wuS0VSTkVMX05VTV9BUkdTKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbnB1dEFyZ3MubGVuZ3RoID4gbktlcm5lbEFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIldlYkNMOiBzZXRBcmdzOiBJbnB1dCBhcmdzIGFtb3VudCA+IGtlcm5lbCBwcm9ncmFtIGFyZ3MgYW1vdW50ISBJZ25vcmluZyBleHRyYSBhcmd1bWVudHMuXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5wdXRBcmdzLmxlbmd0aCA8IG5LZXJuZWxBcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiV2ViQ0w6IHNldEFyZ3M6IE5vdCBlbm91Z2ggYXJndW1lbnRzIHdlcmUgZ2l2ZW4gdG8gV2ViQ0wga2VybmVsLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiQXJncyBmb3Iga2VybmVsOlwiLCBrZXJuZWwuZ2V0SW5mbyh3ZWJjbC5LRVJORUxfRlVOQ1RJT05fTkFNRSkpO1xuXG4gICAgICAgICAgICAgICAgaSA9IG5LZXJuZWxBcmdzO1xuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGktLSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nRGVidWcoXCJBcmc6XCIsIGksIGlucHV0QXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXJuZWwuc2V0QXJnKGksIGlucHV0QXJnc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlcnJDb2RlID0gZ2V0RXJyb3JDb2RlRnJvbUNMRXJyb3IoZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXZWJDTEVycm9yKGdldENMRXJyb3JOYW1lKGVyckNvZGUpLCBcIkNvdWxkIG5vdCBzZXQga2VybmVsIGFyZ3VtZW50cy5cIik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIFdlYkNMIGlzIGF2YWlsYWJsZSBhbmQgYXR0YWNoZXMgYSBjb250ZXh0IHRvIHRoZSBnaXZlbiBvYmplY3RcbiAgICAgKiBAcGFyYW0gd2ViY2xPYmplY3QgdGhlIG9iamVjdCB0aGF0IHRoZSBjb250ZXh0IHdpbGwgYmUgYXR0YWNoZWQgdG9cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbml0V2ViQ0xQbGF0Zm9ybSh3ZWJjbE9iamVjdCkge1xuICAgICAgICBpZiAoIWlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbFBsYXRmb3JtcyA9IGdldFBsYXRmb3JtcygpO1xuICAgICAgICBpZiAoIWNsUGxhdGZvcm1zIHx8IGNsUGxhdGZvcm1zLmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5aW5nIGluaXRpYWxseSB0byB1c2UgR1BVIChmb3IgdGhlIGJlc3QgcGVyZm9ybWFuY2UpLiBVc2luZyBDUFUgYXMgYSBmYWxsYmFjay5cbiAgICAgICAgICAgIHZhciBjbERldmljZXMgPSBnZXREZXZpY2VzQnlUeXBlKFwiR1BVXCIpIHx8IGdldERldmljZXNCeVR5cGUoXCJDUFVcIik7XG4gICAgICAgICAgICBpZiAoIWNsRGV2aWNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbEN0eCA9IGNyZWF0ZUNvbnRleHQoY2xEZXZpY2VzKTtcbiAgICAgICAgICAgIHZhciBjbWRRdWV1ZSA9IGNyZWF0ZUNvbW1hbmRRdWV1ZShjbERldmljZXNbMF0sIGNsQ3R4KTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgVE9ETzogTWF5YmUgd2Ugc2hvdWxkIGp1c3Qgc3RvcmUgdGhlIGNsLXBsYXRmb3JtIG9iamVjdHMgaW4gQy5jbCBzbyB0aGV5IGFyZSBtb3JlIGVhc2lseSBhdmFpbGFibGUgYW5kXG4gICAgICAgICAgICAgKiAgdG8gYXZvaWQgbG9uZyBwcm90b3R5cGUgY2hhaW5zLiBPciB3ZSBjb3VsZCBwYXNzIHRoZSBncmFwaCBjb250ZXh0IHRvIGVhY2ggbm9kZSBvZiB0aGUgZ3JhcGguXG4gICAgICAgICAgICAgKiAgSG93ZXZlciwgaXQgd291bGQgYmUgZ29vZCB0byBhbGxvdyBlYWNoIEdyYXBoIG9iamVjdCB0byBoYXZlIGF0IGxlYXN0IG93biBjb250ZXh0LCBjbWRRdWV1ZSBhbmQga2VybmVsTWFuYWdlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgd2ViY2xPYmplY3QuY2wgPSB7XG4gICAgICAgICAgICAgICAgQVBJOiB3ZWJjbCxcbiAgICAgICAgICAgICAgICBrZXJuZWxNYW5hZ2VyOiBuZXcgS2VybmVsTWFuYWdlcihjbEN0eCwgY2xEZXZpY2VzKSxcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybXM6IGNsUGxhdGZvcm1zLFxuICAgICAgICAgICAgICAgIGRldmljZXM6IGNsRGV2aWNlcyxcbiAgICAgICAgICAgICAgICBjdHg6IGNsQ3R4LFxuICAgICAgICAgICAgICAgIGNtZFF1ZXVlOiBjbWRRdWV1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFhNTDNELmRlYnVnLmxvZ0RlYnVnKFwiU3VjY2Vzc2Z1bGx5IGluaXRpYWxpemVkIFdlYkNMIHBsYXRmb3JtLlwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBUElcbiAgICAgKlxuICAgICAqIEBuYW1lc3BhY2Ugd2ViY2xcbiAgICAgKiBAbWVtYmVyT2YgWE1MM0RcbiAgICAgKi9cblxuICAgIG5hbWVzcGFjZVsnd2ViY2wnXSA9IHtcbiAgICAgICAgXCJpbml0XCI6IGluaXQsXG4gICAgICAgIFwiY3JlYXRlQ29udGV4dFwiOiBjcmVhdGVDb250ZXh0LFxuICAgICAgICBcImNyZWF0ZVByb2dyYW1cIjogY3JlYXRlUHJvZ3JhbSxcbiAgICAgICAgXCJidWlsZFByb2dyYW1cIjogYnVpbGRQcm9ncmFtLFxuICAgICAgICBcImNyZWF0ZUtlcm5lbFwiOiBjcmVhdGVLZXJuZWwsXG4gICAgICAgIFwiY3JlYXRlQ29tbWFuZFF1ZXVlXCI6IGNyZWF0ZUNvbW1hbmRRdWV1ZSxcbiAgICAgICAgXCJjcmVhdGVCdWZmZXJcIjogY3JlYXRlQnVmZmVyLFxuICAgICAgICBcImdldERlZmF1bHRDb250ZXh0XCI6IGdldERlZmF1bHRDb250ZXh0LFxuICAgICAgICBcImdldFBsYXRmb3Jtc1wiOiBnZXRQbGF0Zm9ybXMsXG4gICAgICAgIFwiZ2V0RGV2aWNlc0J5VHlwZVwiOiBnZXREZXZpY2VzQnlUeXBlLFxuICAgICAgICBcImdldENvbnRleHREZXZpY2VzXCI6IGdldENvbnRleHREZXZpY2VzLFxuICAgICAgICBcImdldERldmljZVBsYXRmb3JtXCI6IGdldERldmljZVBsYXRmb3JtLFxuXG4gICAgICAgIC8qKiBAbmFtZSBYTUwzRC53ZWJjbH5rZXJuZWxzICovXG4gICAgICAgIFwia2VybmVsc1wiOiBuZXcgS2VybmVsTWFuYWdlcigpLFxuICAgICAgICBcIktlcm5lbE1hbmFnZXJcIjogS2VybmVsTWFuYWdlcixcblxuICAgICAgICBcImhhc1dlYkNMTmFtZXNwYWNlXCI6IGhhc1dlYkNMTmFtZXNwYWNlLFxuICAgICAgICBcImhhc09wZW5DTERyaXZlcnNcIjogaGFzT3BlbkNMRHJpdmVycyxcbiAgICAgICAgXCJpc0F2YWlsYWJsZVwiOiBpc0F2YWlsYWJsZSxcbiAgICAgICAgXCJXZWJDTEVycm9yXCI6IFdlYkNMRXJyb3IsXG4gICAgICAgIFwiZ2V0Q0xFcnJvck5hbWVcIjogZ2V0Q0xFcnJvck5hbWVcbiAgICB9O1xuXG4gICAgaW5pdFdlYkNMUGxhdGZvcm0obmFtZXNwYWNlLndlYmNsKTtcbiAgICB3aW5kb3cuWE1MM0Qud2ViY2wgPSBuYW1lc3BhY2Uud2ViY2w7XG5cbn0obW9kdWxlLmV4cG9ydHMpKTtcbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xuXG4vLyBFcnJvciBDYWxsYmFja3M6XG52YXIgY19lcnJvckNhbGxiYWNrcyA9IFtdO1xuXG52YXIgY19saXN0ZWRDYWxsYmFja3MgPSBbXTtcbnZhciBjX2xpc3RlZENhbGxiYWNrc0RhdGEgPSBbXTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgICByZWdpc3RlckVycm9yQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBjX2Vycm9yQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICBub3RpZnlFcnJvcjogZnVuY3Rpb24gKG1lc3NhZ2UsIG5vZGUpIHtcbiAgICAgICAgaWYgKGNfZXJyb3JDYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY19lcnJvckNhbGxiYWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNfZXJyb3JDYWxsYmFja3NbaV0obWVzc2FnZSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBEbyBEZWZhdWx0IGVycm9yIHByaW50aW5nXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY3RvciBDb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJlbnQgUGFyZW50IGNsYXNzXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBtZXRob2RzIE1ldGhvZHMgdG8gYWRkIHRvIHRoZSBjbGFzc1xuICAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgICovXG4gICAgY3JlYXRlQ2xhc3M6IGZ1bmN0aW9uIChjdG9yLCBwYXJlbnQsIG1ldGhvZHMpIHtcbiAgICAgICAgbWV0aG9kcyA9IG1ldGhvZHMgfHwge307XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIC8qKiBAY29uc3RydWN0b3IgKi9cbiAgICAgICAgICAgIHZhciBGID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEYucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IEYoKTtcbiAgICAgICAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvcjtcbiAgICAgICAgICAgIGN0b3Iuc3VwZXJjbGFzcyA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgbSBpbiBtZXRob2RzKSB7XG4gICAgICAgICAgICBjdG9yLnByb3RvdHlwZVttXSA9IG1ldGhvZHNbbV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0b3I7XG4gICAgfSxcblxuICAgIGV4dGVuZDogZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgZm9yICh2YXIgaSBpbiBiKSB7XG4gICAgICAgICAgICBpZiAoYi5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIGFbaV0gPSBiW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsdXN0ZXIgaW50ZXJuYWwgbm90aWZpY2F0aW9ucyB0byBhdm9pZCBtdWx0aXBsZSBub3RpZmljYXRpb25zXG4gICAgICogb2Ygc2FtZSB0eXBlLiBNYWlubHkgZm9yIFJlcXVlc3RzIGFuZCBSZXN1bHRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxdWVzdE9yUmVzdWx0IFJlcXVlc3Qgb3IgUmVzdWx0XG4gICAgICogQHBhcmFtIHtSRVNVTFRfU1RBVEV9IHJlc3VsdFN0YXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcXVldWVSZXN1bHRDYWxsYmFjazogZnVuY3Rpb24gKHJlcXVlc3RPclJlc3VsdCwgcmVzdWx0U3RhdGUpIHtcbiAgICAgICAgYXNzZXJ0KHJlc3VsdFN0YXRlICE9PSB1bmRlZmluZWQpO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIGlmICgoIGluZGV4ID0gY19saXN0ZWRDYWxsYmFja3MuaW5kZXhPZihyZXF1ZXN0T3JSZXN1bHQpKSA9PSAtMSkge1xuICAgICAgICAgICAgaW5kZXggPSBjX2xpc3RlZENhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICBjX2xpc3RlZENhbGxiYWNrcy5wdXNoKHJlcXVlc3RPclJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZEYXRhID0gY19saXN0ZWRDYWxsYmFja3NEYXRhW2luZGV4XTtcblxuICAgICAgICBpZiAoIXByZXZEYXRhIHx8IHByZXZEYXRhIDwgcmVzdWx0U3RhdGUpIHtcbiAgICAgICAgICAgIGNfbGlzdGVkQ2FsbGJhY2tzRGF0YVtpbmRleF0gPSByZXN1bHRTdGF0ZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfZmx1c2hSZXN1bHRDYWxsYmFja3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNfbGlzdGVkQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY19saXN0ZWRDYWxsYmFja3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjX2xpc3RlZENhbGxiYWNrc1tpXS5fb25Qb3N0cG9uZWRSZXN1bHRDaGFuZ2VkKGNfbGlzdGVkQ2FsbGJhY2tzRGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjX2xpc3RlZENhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgY19saXN0ZWRDYWxsYmFja3NEYXRhID0gW107XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cblxuXG5cblxuIiwidmFyIEMgPSB7fTtcblxuQy5FUFNJTE9OID0gMC4wMDAwMDE7XG5cbi8qKlxuICogVHlwZSBvZiBEYXRhRW50cnlcbiAqIEBlbnVtXG4gKi9cbkMuREFUQV9UWVBFID0ge1xuICAgIFVOS05PV046IDAsXG4gICAgRkxPQVQ6IDEsXG4gICAgRkxPQVQyOiAyLFxuICAgIEZMT0FUMzogMyxcbiAgICBGTE9BVDQ6IDQsXG4gICAgRkxPQVQzWDM6IDUsXG4gICAgRkxPQVQ0WDQ6IDEwLFxuICAgIElOVDogMjAsXG4gICAgSU5UNDogMjEsXG4gICAgQk9PTDogMzAsXG4gICAgVEVYVFVSRTogNDAsXG4gICAgQllURTogNTAsXG4gICAgVUJZVEU6IDYwLFxuICAgIGZyb21TdHJpbmc6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBpZiAoIXN0ciB8fCAhc3RyLnRvVXBwZXJDYXNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNbc3RyLnRvVXBwZXJDYXNlKCldO1xuICAgIH1cbn07XG5cbkMuREFUQV9UWVBFX01BUCA9IHtcbiAgICAnZmxvYXQnOiBDLkRBVEFfVFlQRS5GTE9BVCxcbiAgICAnZmxvYXQyJzogQy5EQVRBX1RZUEUuRkxPQVQyLFxuICAgICdmbG9hdDMnOiBDLkRBVEFfVFlQRS5GTE9BVDMsXG4gICAgJ2Zsb2F0NCc6IEMuREFUQV9UWVBFLkZMT0FUNCxcbiAgICAnZmxvYXQzeDMnOiBDLkRBVEFfVFlQRS5GTE9BVDNYMyxcbiAgICAnZmxvYXQ0eDQnOiBDLkRBVEFfVFlQRS5GTE9BVDRYNCxcbiAgICAnaW50JzogQy5EQVRBX1RZUEUuSU5ULFxuICAgICdpbnQ0JzogQy5EQVRBX1RZUEUuSU5UNCxcbiAgICAnYm9vbCc6IEMuREFUQV9UWVBFLkJPT0wsXG4gICAgJ3RleHR1cmUnOiBDLkRBVEFfVFlQRS5URVhUVVJFLFxuICAgICdieXRlJzogQy5EQVRBX1RZUEUuQllURSxcbiAgICAndWJ5dGUnOiBDLkRBVEFfVFlQRS5VQllURVxufTtcblxuLy8gVmFsdWVzIGFyZSBjaG9zZW4gdG8gYmUgaW4gbGluZSB3aXRoIERBVEFfVFlQRVxuQy5URVhUVVJFX1RZUEUgPSB7XG4gICAgVU5LTk9XTjogMCwgRkxPQVQ6IDEsIFVCWVRFOiA2MCwgVVNIT1JUXzVfNl81OiA3MCwgVVNIT1JUXzRfNF80XzQ6IDcxLCBVU0hPUlRfNV81XzVfMTogNzJcbn07XG5cbkMuVEVYVFVSRV9GT1JNQVQgPSB7XG4gICAgVU5LTk9XTjogMCwgQUxQSEE6IDEwMCwgUkdCOiAxMDEsIFJHQkE6IDEwMiwgTFVNSU5BTkNFOiAxMDMsIExVTUlOQU5DRV9BTFBIQTogMTA0XG59O1xuXG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFID0ge307XG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkZMT0FUXSA9IDE7XG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkZMT0FUMl0gPSAyO1xuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5GTE9BVDNdID0gMztcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuRkxPQVQ0XSA9IDQ7XG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkZMT0FUM1gzXSA9IDk7XG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLkZMT0FUNFg0XSA9IDE2O1xuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5JTlRdID0gMTtcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuSU5UNF0gPSA0O1xuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5CT09MXSA9IDE7XG5DLkRBVEFfVFlQRV9UVVBMRV9TSVpFW0MuREFUQV9UWVBFLlRFWFRVUkVdID0gMTtcbkMuREFUQV9UWVBFX1RVUExFX1NJWkVbQy5EQVRBX1RZUEUuQllURV0gPSAxO1xuQy5EQVRBX1RZUEVfVFVQTEVfU0laRVtDLkRBVEFfVFlQRS5VQllURV0gPSAxO1xuXG5DLlRZUEVEX0FSUkFZX01BUCA9IHt9O1xuQy5UWVBFRF9BUlJBWV9NQVBbQy5EQVRBX1RZUEUuRkxPQVRdID0gRmxvYXQzMkFycmF5O1xuQy5UWVBFRF9BUlJBWV9NQVBbQy5EQVRBX1RZUEUuRkxPQVQyXSA9IEZsb2F0MzJBcnJheTtcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLkZMT0FUM10gPSBGbG9hdDMyQXJyYXk7XG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5GTE9BVDRdID0gRmxvYXQzMkFycmF5O1xuQy5UWVBFRF9BUlJBWV9NQVBbQy5EQVRBX1RZUEUuRkxPQVQ0WDRdID0gRmxvYXQzMkFycmF5O1xuQy5UWVBFRF9BUlJBWV9NQVBbQy5EQVRBX1RZUEUuSU5UXSA9IEludDMyQXJyYXk7XG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5JTlQ0XSA9IEludDMyQXJyYXk7XG5DLlRZUEVEX0FSUkFZX01BUFtDLkRBVEFfVFlQRS5CT09MXSA9IEludDhBcnJheTtcbkMuVFlQRURfQVJSQVlfTUFQW0MuREFUQV9UWVBFLkJZVEVdID0gSW50OEFycmF5O1xuQy5UWVBFRF9BUlJBWV9NQVBbQy5EQVRBX1RZUEUuVUJZVEVdID0gVWludDhBcnJheTtcblxuLy8gdGV4dHVyZSBmb3JtYXRzXG4vLyBmbG9hdCBhbmQgdWJ5dGUgYXJlIG1hcHBlZCB0byBEQVRBX1RZUEUgdmFsdWVzIGFib3ZlXG5DLlRZUEVEX0FSUkFZX01BUFtDLlRFWFRVUkVfVFlQRS5VU0hPUlRfNF80XzRfNF0gPSBVaW50MTZBcnJheTtcbkMuVFlQRURfQVJSQVlfTUFQW0MuVEVYVFVSRV9UWVBFLlVTSE9SVF81XzZfNV0gPSBVaW50MTZBcnJheTtcbkMuVFlQRURfQVJSQVlfTUFQW0MuVEVYVFVSRV9UWVBFLlVTSE9SVF81XzVfNV8xXSA9IFVpbnQxNkFycmF5O1xuXG5DLlRFWFRVUkVfRk9STUFUX1RVUExFX1NJWkUgPSB7fTtcbkMuVEVYVFVSRV9GT1JNQVRfVFVQTEVfU0laRVtDLlRFWFRVUkVfRk9STUFULkFMUEhBXSA9IDE7XG5DLlRFWFRVUkVfRk9STUFUX1RVUExFX1NJWkVbQy5URVhUVVJFX0ZPUk1BVC5SR0JdID0gMztcbkMuVEVYVFVSRV9GT1JNQVRfVFVQTEVfU0laRVtDLlRFWFRVUkVfRk9STUFULlJHQkFdID0gNDtcbkMuVEVYVFVSRV9GT1JNQVRfVFVQTEVfU0laRVtDLlRFWFRVUkVfRk9STUFULkxVTUlOQU5DRV0gPSAxO1xuQy5URVhUVVJFX0ZPUk1BVF9UVVBMRV9TSVpFW0MuVEVYVFVSRV9GT1JNQVQuTFVNSU5BTkNFX0FMUEhBXSA9IDI7XG5cbkMuZ2V0VHlwZU5hbWUgPSBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciBpO1xuICAgIGZvciAoaSBpbiBDLkRBVEFfVFlQRV9NQVApIHtcbiAgICAgICAgaWYgKEMuREFUQV9UWVBFX01BUFtpXSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbkMuVEVYX0ZJTFRFUl9UWVBFID0ge1xuICAgIE5FQVJFU1Q6IDB4MjYwMCwgTElORUFSOiAweDI2MDEsIE1JUE1BUF9ORUFSRVNUOiAweDI3MDAsIE1JUE1BUF9MSU5FQVI6IDB4MjcwMVxuXG59O1xuLyoqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5DLlRFWF9XUkFQX1RZUEUgPSB7XG4gICAgQ0xBTVA6IDB4ODEyRiwgUkVQRUFUOiAweDI5MDFcbn07XG4vKipcbiAqIEBlbnVtIHtudW1iZXJ9XG4gKi9cbkMuVEVYX1RZUEUgPSB7XG4gICAgVEVYVFVSRV8yRDogMHgwREUxXG59O1xuXG5DLlNIQURFUl9DT05TVEFOVF9LRVkgPSB7XG4gICAgV09STERfVFJBTlNGT1JNOiAxLFxuICAgIFZJRVdfVFJBTlNGT1JNOiAyLFxuICAgIFNDUkVFTl9UUkFOU0ZPUk06IDMsXG4gICAgV09STERfVFJBTlNGT1JNX05PUk1BTDogNCxcbiAgICBWSUVXX1RSQU5TRk9STV9OT1JNQUw6IDUsXG4gICAgU0NSRUVOX1RSQU5TRk9STV9OT1JNQUw6IDYsXG4gICAgT0JKRUNUX0lEOiA3XG59O1xuXG5DLlZTX0FUVFJJQl9UUkFOU0ZPUk0gPSB7XG4gICAgTk9ORTogMCwgVklFV19QT0lOVDogMSwgV09STERfUE9JTlQ6IDIsIFZJRVdfTk9STUFMOiAzLCBXT1JMRF9OT1JNQUw6IDRcbn07XG5cblxuLyoqXG4gKiBGaWx0ZXIgVHlwZSBvZiBEYXRhTm9kZVxuICogS0VFUCAtIEtlZXAgb25seSB0aGUgcHJvdmlkZWQgbmFtZXNcbiAqIFJFTU9WRSAtIFJlbW92ZSBwcm92aWRlZCBuYW1lcyAoaWdub3JlcyBuYW1lIG1hcHBpbmcpXG4gKiBSRU5BTUUgLSBPbmx5IGFwcGx5IG5hbWUgbWFwcGluZ1xuICogQGVudW1cbiAqL1xuQy5EQVRBX0ZJTFRFUl9UWVBFID0ge1xuICAgIE5PTkU6IDAsIFJFTkFNRTogMSwgS0VFUDogMiwgUkVNT1ZFOiAzXG59O1xuXG5cbi8qKlxuICogVE9ETzogTWF5YmUgbWVyZ2UgdGhpcyBzdHJ1Y3R1cmUgd2l0aCBSRVNVTFRfU1RBVEUgdG8gYXZvaWQgYmFjayBhbmQgZm9ydGggY29udmVyc2lvbiB3aXRoaW4gbm90aWZpY2F0aW9uIGNoYWluXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5DLkRBVEFfRU5UUllfU1RBVEUgPSB7XG4gICAgQ0hBTkdFRF9WQUxVRTogMSxcbiAgICBDSEFOR0VEX05FVzogMixcbiAgICBMT0FEX1NUQVJUOiAzLFxuICAgIExPQURfRU5EOiA0LFxuICAgIENIQU5HRURfU0laRTogNSxcbiAgICBDSEFOR0VEX1JFTU9WRUQ6IDYsIC8vIE5vdCBqdXN0IHRoZSBzaXplIGNoYW5nZWQsIGJ1dCBhbHNvIHF1YWxpZmllclxuICAgIC8vIGlmIHdlIGhhdmUgMCwgMSBvciBtYW55IHR1cGxlcyBpbiB2YWx1ZVxuICAgIENIQU5HRURfU0laRV9UWVBFOiA3XG59O1xuXG4vKiogVE9ETzogTWVyZ2Ugd2l0aCBDLlBMQVRGT1JNPyAqKi9cbkMuUkVTVUxUX1RZUEUgPSB7XG4gICAgQ09NUFVURTogMCwgVlM6IDFcbn07XG5cblxuLyoqXG4gKiBUeXBlIG9mIE1vZGlmaWNhdGlvbiwgdXNlZCBpbnRlcm5hbGx5IG9ubHlcbiAqIE9yZGVyZWQgYnkgaW1wb3J0YW5jZS5cbiAqIEBlbnVtXG4gKi9cbkMuUkVTVUxUX1NUQVRFID0ge1xuICAgIE5PTkU6IDAsIENIQU5HRURfREFUQV9WQUxVRTogMSwgQ0hBTkdFRF9EQVRBX1NJWkU6IDIsIENIQU5HRURfU1RSVUNUVVJFOiAzLCAvLyBUT0RPOiBGZWxpeDogU3RpbGwgcmVxdWlyZWQ/XG4gICAgSU1BR0VfTE9BRF9TVEFSVDogNCwgSU1BR0VfTE9BRF9FTkQ6IDVcbn07XG5cblxuLyoqXG4gKiBUeXBlIG9mIFNlcXVlbmNlIGFjY2VzcyAtIHVzZWQgYnkgb3BlcmF0b3JzXG4gKiBAZW51bVxuICovXG5DLlNFUVVFTkNFID0ge1xuICAgIE5PX0FDQ0VTUzogMCwgUFJFVl9CVUZGRVI6IDEsIE5FWFRfQlVGRkVSOiAyLCBMSU5FQVJfV0VJR0hUOiAzXG59O1xuXG5cbkMuSVRFUkFUSU9OX1RZUEUgPSB7XG4gICAgTlVMTDogMCwgT05FOiAxLCBNQU5ZOiAyXG59O1xuXG4vKipcbiAqIFR5cGUgb2YgSW5mb3JtYXRpb24gRXh0cmFjdGlvbiAtIHVzZWQgYnkgb3BlcmF0b3JzXG4gKiBAcHJpdmF0ZVxuICogQGVudW1cbiAqL1xuLy9UT0RPOiBUaGlzIHNlZW1zIHRvIGJlIHVudXNlZCwgaXMgaXQgc3RpbGwgbmVlZGVkP1xuQy5FWFRSQUNUID0ge1xuICAgIE5PX0VYVFJBQzogMCwgVEVYX1dJRFRIOiAxLCBURVhfSEVJR0hUOiAyXG59O1xuXG5DLk9SSUdJTiA9IHtcbiAgICBDSElMRDogMSwgQ09NUFVURTogMiwgUFJPVE86IDNcbn07XG5cbi8qKlxuICogVHlwZXMgb2YgcGxhdGZvcm1zIHRvIHBlcmZvcm0gY29tcHV0YXRpb24gb25cbiAqIEB0eXBlIHtlbnVtfVxuICovXG5DLlBMQVRGT1JNID0ge1xuICAgIEpBVkFTQ1JJUFQ6IDAsIEdMU0w6IDEsIENMOiAyLCBBU1lOQzogM1xufTtcblxuLyoqXG4gKiBQb3NzaWJsZSBzdGF0ZXMgb2YgYSBQcm9jZXNzTm9kZVxuICogQHR5cGUge2VudW19XG4gKi9cbkMuUFJPQ0VTU19TVEFURSA9IHtcbiAgICBNT0RJRklFRDogMCwgLy8gV2UgZG9uJ3Qga25vdyAoVE9ETyBGZWxpeDogRmluZCBvdXQhKVxuICAgIExPQURJTkc6IDEsIC8vIFNvbWV0aGluZyBzdGlsbCBsb2FkaW5nIChibG9ja2VkKVxuICAgIElOVkFMSUQ6IDMsIC8vIElucHV0IGlzIGludmFsaWQgKG1pZ2h0IGhhcHBlbiBldmVuIGFmdGVyIG9wZXJhdG9yIHNlbGVjdGlvbiAtIGUuZy4gYmVjYXVzZSBvZiBlbXB0eSBhcnJheSBvdXRwdXQgZXRjLilcbiAgICBVTlBST0NFU1NFRDogNCwgLy8gUHJvY2VzcyBub2RlIGlzIGRpcnR5XG4gICAgUFJPQ0VTU0VEOiA1IC8vIEFsbCBkYXRhIGlzIHVwLXRvLWRhdGVcbn07XG5cbi8vd2luZG93LlhmbG93LlBMQVRGT1JNID0gQy5QTEFURk9STTtcblxubW9kdWxlLmV4cG9ydHMgPSBDO1xuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcbnZhciBDID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xucmVxdWlyZShcIi4uLy4uL3V0aWxzL2FycmF5LmpzXCIpO1xuXG4vKipcbiAqIENvbnRlbnQgb2YgdGhpcyBmaWxlOlxuICogQWxsIENvZGUgZm9yIGhhbmRsaW5nIGRhdGEgZW50cmllcyBjb25uZWN0ZWQgdG8gWGZsb3cgaW5jbHVkaW5nOlxuICogIC0gQnVmZmVyRW50cmllczogVHlwZWQgdmFsdWUgYnVmZmVycyAoZS5nIGZsb2F0MyBidWZmZXIsIHdpdGhvdXQgbmFtZSlcbiAqICAtIFRleHR1cmVFbnRyaWVzOiBlLmcuIGltYWdlc1xuICpcbiAqICBUaGlzIGZpbGUgYWxzbyBpbmNsdWRlcyB0aGUgRGF0YUNoYW5nZU5vdGlmaWVyIHVzZWQgdG8gcmVhY3QgdG8gY2hhbmdlcyBvbiBYZmxvdyBkYXRhIHN0cnVjdHVyZXNcbiAqL1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNhbXBsZXJDb25maWdcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8qKlxuICogU2FtcGxlckNvbmZpZyBpcyB1c2VkIHRvIGRlZmluZSBzYW1wbGVyIHByb3BlcnRpZXMgb2YgYSBUZXh0dXJlRW50cnkgb3IgSW1hZ2VEYXRhVGV4dHVyZUVudHJ5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNhbXBsZXJDb25maWcgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMubWluRmlsdGVyID0gMDtcbiAgICB0aGlzLm1hZ0ZpbHRlciA9IDA7XG4gICAgdGhpcy5taXBGaWx0ZXIgPSAwO1xuICAgIHRoaXMud3JhcFMgPSAwO1xuICAgIHRoaXMud3JhcFQgPSAwO1xuICAgIHRoaXMud3JhcFUgPSAwO1xuICAgIHRoaXMudGV4dHVyZVR5cGUgPSAwO1xuICAgIHRoaXMuY29sb3JSID0gMDtcbiAgICB0aGlzLmNvbG9yRyA9IDA7XG4gICAgdGhpcy5jb2xvckIgPSAwO1xuICAgIHRoaXMuYW5pc290cm9weSA9IDA7IC8vIG51bWJlciBvZiBtYXggc2FtcGxlcyBmb3IgYW5pc290cm9waWMgZmlsdGVyaW5nXG4gICAgdGhpcy5nZW5lcmF0ZU1pcE1hcCA9IDA7XG59O1xuXG5TYW1wbGVyQ29uZmlnLnByb3RvdHlwZS5zZXREZWZhdWx0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWluRmlsdGVyID0gQy5URVhfRklMVEVSX1RZUEUuTElORUFSO1xuICAgIHRoaXMubWFnRmlsdGVyID0gQy5URVhfRklMVEVSX1RZUEUuTElORUFSO1xuICAgIHRoaXMubWlwRmlsdGVyID0gQy5URVhfRklMVEVSX1RZUEUuTkVBUkVTVDtcbiAgICB0aGlzLndyYXBTID0gQy5URVhfV1JBUF9UWVBFLkNMQU1QO1xuICAgIHRoaXMud3JhcFQgPSBDLlRFWF9XUkFQX1RZUEUuQ0xBTVA7XG4gICAgdGhpcy53cmFwVSA9IEMuVEVYX1dSQVBfVFlQRS5DTEFNUDtcbiAgICB0aGlzLnRleHR1cmVUeXBlID0gQy5URVhfVFlQRS5URVhUVVJFXzJEO1xuICAgIHRoaXMuY29sb3JSID0gMDtcbiAgICB0aGlzLmNvbG9yRyA9IDA7XG4gICAgdGhpcy5jb2xvckIgPSAwO1xuICAgIHRoaXMuYW5pc290cm9weSA9IDE7IC8vIG51bWJlciBvZiBtYXggc2FtcGxlcyBmb3IgYW5pc290cm9waWMgZmlsdGVyaW5nXG4gICAgdGhpcy5nZW5lcmF0ZU1pcE1hcCA9IDA7XG59O1xuXG5TYW1wbGVyQ29uZmlnLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihvdGhlcikge1xuICAgIHRoaXMubWluRmlsdGVyID0gb3RoZXIubWluRmlsdGVyO1xuICAgIHRoaXMubWFnRmlsdGVyID0gb3RoZXIubWFnRmlsdGVyO1xuICAgIHRoaXMubWlwRmlsdGVyID0gb3RoZXIubWlwRmlsdGVyO1xuICAgIHRoaXMud3JhcFMgPSBvdGhlci53cmFwUztcbiAgICB0aGlzLndyYXBUID0gb3RoZXIud3JhcFQ7XG4gICAgdGhpcy53cmFwVSA9IG90aGVyLndyYXBVO1xuICAgIHRoaXMudGV4dHVyZVR5cGUgPSBvdGhlci50ZXh0dXJlVHlwZTtcbiAgICB0aGlzLmNvbG9yUiA9IG90aGVyLmNvbG9yUjtcbiAgICB0aGlzLmNvbG9yRyA9IG90aGVyLmNvbG9yRztcbiAgICB0aGlzLmNvbG9yQiA9IG90aGVyLmNvbG9yQjtcbiAgICB0aGlzLmdlbmVyYXRlTWlwTWFwID0gb3RoZXIuZ2VuZXJhdGVNaXBNYXA7XG59O1xuXG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gRGF0YUVudHJ5XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vKipcbiAqIFRoZSBhYnN0cmFjdCBiYXNlIGNsYXNzIGZvciBhbGwgRGF0YUVudHJpZXMgY29ubmVjdGVkIHRvIGFuIHhmbG93IGdyYXBoLlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge0MuREFUQV9UWVBFfSB0eXBlIFR5cGUgb2YgRGF0YUVudHJ5XG4gKi9cbnZhciBEYXRhRW50cnkgPSBmdW5jdGlvbih0eXBlKXtcbiAgICB0aGlzLl90eXBlID0gdHlwZTtcbiAgICAvKiogQHR5cGUge0FycmF5LjxGdW5jdGlvbihEYXRhRW50cnksIEMuREFUQV9FTlRSWV9TVEFURSk+fSAqKi9cbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICAvKiogQWRkIHJlbGF0ZWQgY3VzdG9tIGRhdGEgKGUuZy4gV2ViR0wgYnVmZmVycykgKiovXG4gICAgdGhpcy51c2VyRGF0YSA9IHt9O1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFFbnRyeS5wcm90b3R5cGUsIFwidHlwZVwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIGlzIHJlYWQtb25seVwiKTtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIHtDLkRBVEFfVFlQRX0gKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl90eXBlOyB9XG59KTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFFbnRyeSwgQy5EQVRBX0VOVFJZX1NUQVRFKX0gY2FsbGJhY2tcbiAqL1xuRGF0YUVudHJ5LnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRGF0YUVudHJ5LCBDLkRBVEFfRU5UUllfU1RBVEUpfSBjYWxsYmFja1xuICovXG5EYXRhRW50cnkucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24oY2FsbGJhY2spe1xuICAgIEFycmF5LmVyYXNlKHRoaXMuX2xpc3RlbmVycywgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKi9cbkRhdGFFbnRyeS5wcm90b3R5cGUuX25vdGlmeUNoYW5nZWQgPSBmdW5jdGlvbigpe1xuICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRSk7XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEJ1ZmZlckVudHJ5XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBIHR5cGVkIHZhbHVlIGJ1ZmZlciBiYXNpY2FsbHkgbGlua2luZyB0byBhIHR5cGVkIGFycmF5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RGF0YUVudHJ5fVxuICogQHBhcmFtIHtDLkRBVEFfVFlQRX0gdHlwZVxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIEEgdHlwZWQgYXJyYXlcbiAqL1xudmFyIEJ1ZmZlckVudHJ5ID0gZnVuY3Rpb24odHlwZSwgdmFsdWUpe1xuICAgIERhdGFFbnRyeS5jYWxsKHRoaXMsIHR5cGUpO1xuICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX05FVyk7XG59O1xuQmFzZS5jcmVhdGVDbGFzcyhCdWZmZXJFbnRyeSwgRGF0YUVudHJ5KTtcblxuXG4vKipcbiAqICBTZXQgdmFsdWUgb2YgZW50cnkuIFRyaWdnZXJzIG5vdGlmaWNhdGlvbiBjaGFpblxuICogIEBwYXJhbSB7T2JqZWN0fSB2IFZhbHVlIHRvIHNldCAoaGFzIHRvIGJlIGEgVHlwZWRBcnJheSlcbiAqL1xuQnVmZmVyRW50cnkucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24odil7XG4gICAgdGhpcy5fc2V0VmFsdWUodik7XG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcbn07XG5cbi8qKlxuICogQXJlIHRoZXJlIG5vLCBvbmUgb3IgbWFueSB2YWx1ZXM/XG4gKiBAcGFyYW0gc2l6ZVxuICogQHBhcmFtIHR1cGxlU2l6ZVxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZ2V0U2l6ZVR5cGUoc2l6ZSwgdHVwbGVTaXplKXtcbiAgICBpZihzaXplID49IHR1cGxlU2l6ZSoyKVxuICAgICAgICByZXR1cm4gMjtcbiAgICBlbHNlIGlmKHNpemUgPj0gdHVwbGVTaXplKVxuICAgICAgICByZXR1cm4gMTtcbiAgICBlbHNlXG4gICAgICAgIHJldHVybiAwO1xufVxuXG5CdWZmZXJFbnRyeS5wcm90b3R5cGUuX3NldFZhbHVlID0gZnVuY3Rpb24odil7XG4gICAgdmFyIG9sZFNpemUgPSAodGhpcy5fdmFsdWUgPyB0aGlzLl92YWx1ZS5sZW5ndGggOiAwKSwgbmV3U2l6ZSA9ICh2ID8gdi5sZW5ndGggOiAwKSwgdHVwbGVTaXplID0gdGhpcy5nZXRUdXBsZVNpemUoKTtcbiAgICB2YXIgbm90aWZpY2F0aW9uO1xuICAgIGlmKGdldFNpemVUeXBlKG9sZFNpemUsIHR1cGxlU2l6ZSkgIT0gZ2V0U2l6ZVR5cGUobmV3U2l6ZSwgdHVwbGVTaXplKSlcbiAgICAgICAgbm90aWZpY2F0aW9uID0gQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfU0laRV9UWVBFO1xuICAgIGVsc2UgaWYob2xkU2l6ZSAhPSBuZXdTaXplKXtcbiAgICAgICAgbm90aWZpY2F0aW9uID0gQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfU0laRTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgbm90aWZpY2F0aW9uID0gQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfVkFMVUU7XG4gICAgfVxuICAgIHRoaXMuX3ZhbHVlID0gdjtcbiAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgbm90aWZpY2F0aW9uKTtcbn07XG5cbi8qKiBAcmV0dXJuIHtPYmplY3R9ICovXG5CdWZmZXJFbnRyeS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYnVmZmVyIGxlbmd0aFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5CdWZmZXJFbnRyeS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUgPyB0aGlzLl92YWx1ZS5sZW5ndGggOiAwO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHR1cGxlIHNpemUgKGUuZyAxLCAyLCAzLCA0LCAxNilcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkJ1ZmZlckVudHJ5LnByb3RvdHlwZS5nZXRUdXBsZVNpemUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQy5EQVRBX1RZUEVfVFVQTEVfU0laRVt0aGlzLl90eXBlXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHR1cGxlIGNvdW50XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbkJ1ZmZlckVudHJ5LnByb3RvdHlwZS5nZXRJdGVyYXRlQ291bnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmdldExlbmd0aCgpIC8gdGhpcy5nZXRUdXBsZVNpemUoKTtcbn07XG5cbi8qKlxuICogSXMgdmFsdWUgbm90IHNldCBvciB0aGUgbGVuZ3RoIG9mIHRoZSBidWZmZXIgMFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkJ1ZmZlckVudHJ5LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gIXRoaXMuX3ZhbHVlIHx8ICF0aGlzLmdldExlbmd0aCgpO1xufTtcblxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRleHR1cmVFbnRyeVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIFRleGVsU291cmNlKHNvdXJjZU9yV2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VPcldpZHRoID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChzb3VyY2VPcldpZHRoLm5vZGVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgbm9kZU5hbWUgPSBzb3VyY2VPcldpZHRoLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT09IFwidmlkZW9cIiAmJiAodHlwZW9mIHNvdXJjZU9yV2lkdGguY29tcGxldGUgPT09IFwidW5kZWZpbmVkXCIpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc291cmNlT3JXaWR0aCwge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlkZW9XaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWRlb0hlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKHRoaXMucmVhZHlTdGF0ZSA9PSAwIHx8IHRoaXMudmlkZW9XaWR0aCA8PSAwIHx8IHRoaXMudmlkZW9IZWlnaHQgPD0gMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZU9yV2lkdGgudGV4ZWxGb3JtYXQgPSBDLlRFWFRVUkVfRk9STUFULlJHQkE7XG4gICAgICAgICAgICBzb3VyY2VPcldpZHRoLnRleGVsVHlwZSA9IEMuVEVYVFVSRV9UWVBFLlVCWVRFO1xuICAgICAgICB9XG4gICAgICAgIC8vYXNzdW1lIHNvdXJjZSBpcyBhIGltYWdlIGRhdGEgbGlrZSBvYmplY3RcbiAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlT3JXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgQy5URVhUVVJFX0ZPUk1BVC5SR0JBO1xuICAgICAgICB0eXBlID0gIHR5cGUgfHwgQy5URVhUVVJFX1RZUEUuVUJZVEU7XG4gICAgICAgIC8vY3JlYXRlIGEgbmV3IHRleGVsIHNvdXJjZSBiYWNrZWQgYnkgdHlwZSBhcnJheVxuICAgICAgICB0aGlzLl9zb3VyY2UgPSB7XG4gICAgICAgICAgICB3aWR0aDogc291cmNlT3JXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgdGV4ZWxGb3JtYXQ6IGZvcm1hdCxcbiAgICAgICAgICAgIHRleGVsVHlwZTogdHlwZSxcbiAgICAgICAgICAgIGRhdGE6IG5ldyBDLlRZUEVEX0FSUkFZX01BUFt0eXBlXShzb3VyY2VPcldpZHRoICogaGVpZ2h0ICogQy5URVhUVVJFX0ZPUk1BVF9UVVBMRV9TSVpFW2Zvcm1hdF0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRleGVsU291cmNlLnByb3RvdHlwZSwge1xuICAgIGltYWdlRGF0YToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zb3VyY2UgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuX3NvdXJjZS53aWR0aDtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5fc291cmNlLmhlaWdodDtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3NvdXJjZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5fc291cmNlLndpZHRoLCB0aGlzLl9zb3VyY2UuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBzb3VyY2UudGV4ZWxGb3JtYXQgPSB0aGlzLl9zb3VyY2UudGV4ZWxGb3JtYXQ7XG4gICAgICAgICAgICAgICAgc291cmNlLnRleGVsVHlwZSA9IHRoaXMuX3NvdXJjZS50ZXhlbFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc291cmNlID0gc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLy8gVE9ETyB0aGlzIGlzIHZlcnkgY29uZnVzaW5nLiBhc0dMVGV4dHVyZURhdGEgaXMgdGV4ZWxzb3VyY2Uuc291cmNlXG4gICAgZ2xUZXh0dXJlRGF0YToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2U7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBsZXRlOiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9zb3VyY2UuY29tcGxldGUgPT09IFwidW5kZWZpbmVkXCIgPyB0cnVlIDogdGhpcy5fc291cmNlLmNvbXBsZXRlO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2Uud2lkdGggOiAtMTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS5oZWlnaHQgOiAtMTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGV4ZWxGb3JtYXQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlID8gdGhpcy5fc291cmNlLnRleGVsRm9ybWF0OiBDLlRFWFRVUkVfRk9STUFULlVOS05PV047XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRleGVsVHlwZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2UudGV4ZWxUeXBlOiBDLlRFWFRVUkVfVFlQRS5VTktOT1dOO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbi8qKlxuICogQSBkYXRhIGVudHJ5IGZvciBhIHRleHR1cmUuXG4gKiBOb3RlOiBlYWNoIFRleHR1cmVFbnRyeSBpbmNsdWRlcyBhIHNhbXBsZXJDb25maWcuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtEYXRhRW50cnl9XG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTFZpZGVvRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudH0gc291cmNlIC8vVE9ETzogV2hpY2gga2luZHMgYXJlIHN1cHBvcnRlZD9cbiAqL1xudmFyIFRleHR1cmVFbnRyeSA9IGZ1bmN0aW9uKHNvdXJjZSl7XG4gICAgRGF0YUVudHJ5LmNhbGwodGhpcywgQy5EQVRBX1RZUEUuVEVYVFVSRSk7XG4gICAgdGhpcy5fc2FtcGxlckNvbmZpZyA9IG5ldyBTYW1wbGVyQ29uZmlnKCk7XG4gICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuc2V0SW1hZ2Uoc291cmNlKTtcblxuICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9ORVcpO1xufTtcblxuQmFzZS5jcmVhdGVDbGFzcyhUZXh0dXJlRW50cnksIERhdGFFbnRyeSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRleHR1cmVFbnRyeS5wcm90b3R5cGUsIHtcbiAgICB3aWR0aDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2Uud2lkdGggOiAtMTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NvdXJjZSA/IHRoaXMuX3NvdXJjZS5oZWlnaHQgOiAtMTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdGV4ZWxGb3JtYXQ6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc291cmNlID8gdGhpcy5fc291cmNlLnRleGVsRm9ybWF0OiBDLlRFWFRVUkVfRk9STUFULlVOS05PV047XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRleGVsVHlwZToge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UgPyB0aGlzLl9zb3VyY2UudGV4ZWxUeXBlOiBDLlRFWFRVUkVfVFlQRS5VTktOT1dOO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblRleHR1cmVFbnRyeS5wcm90b3R5cGUuaXNMb2FkaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9zb3VyY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiAhdGhpcy5fc291cmNlLmNvbXBsZXRlO1xufTtcblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5UZXh0dXJlRW50cnkucHJvdG90eXBlLl9jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgc2FtcGxlckNvbmZpZykge1xuICAgIGlmICghdGhpcy5fc291cmNlIHx8IHRoaXMud2lkdGggIT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT0gaGVpZ2h0IHx8IHRoaXMuZm9ybWF0ICE9IGZvcm1hdCB8fCB0aGlzLnR5cGUgIT0gdHlwZSkge1xuICAgICAgICB2YXIgc291cmNlID0gbmV3IFRleGVsU291cmNlKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSk7XG5cbiAgICAgICAgaWYgKCFzYW1wbGVyQ29uZmlnKSB7XG4gICAgICAgICAgICBzYW1wbGVyQ29uZmlnID0gbmV3IFNhbXBsZXJDb25maWcoKTtcbiAgICAgICAgICAgIHNhbXBsZXJDb25maWcuc2V0RGVmYXVsdHMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NhbXBsZXJDb25maWcuc2V0KHNhbXBsZXJDb25maWcpO1xuICAgICAgICB0aGlzLl9zZXRJbWFnZShzb3VyY2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX25vdGlmeUNoYW5nZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc291cmNlO1xufTtcblxuLyoqXG4gKiBTZXQgaW1hZ2Ugc291cmNlIG9mIGEgVGV4dHVyZSBFbnRyeVxuICogVE9ETzogVGhpcyBpcyBjYWxsZWQgZXZlbiBpZiBpbWFnZSBpcyBqdXN0IGxvYWRlZCAob24gWE1MM0Qgc2lkZSkuIEFkZCBhIG5vdGlmeUltYWdlTG9hZGVkIG1ldGhvZCBjb3VsZFxuICogYmUgaGVscGZ1bFxuICpcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MVmlkZW9FbGVtZW50fFRleGVsU291cmNlfG51bGx9IGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbj99IGZvcmNlTG9hZENhbGxiYWNrIHRyaWdnZXIgbG9hZCBjYWxsYmFjayBpZiBkYXRhIGNoYW5nZXNcbiAqL1xuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5zZXRJbWFnZSA9IGZ1bmN0aW9uIChlbGVtZW50LCBmb3JjZUxvYWRDYWxsYmFjaykge1xuICAgIHRoaXMuX3NldEltYWdlKGVsZW1lbnQsIGZvcmNlTG9hZENhbGxiYWNrKTtcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xufTtcblxuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5fc2V0SW1hZ2UgPSBmdW5jdGlvbiAoZWxlbWVudCwgZm9yY2VMb2FkQ2FsbGJhY2spIHtcbiAgICBpZiAoIWVsZW1lbnQpXG4gICAgICAgIHRoaXMuX3NldFNvdXJjZShudWxsLCBmb3JjZUxvYWRDYWxsYmFjayk7XG4gICAgZWxzZSBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFRleGVsU291cmNlKVxuICAgICAgICB0aGlzLl9zZXRTb3VyY2UoZWxlbWVudCwgZm9yY2VMb2FkQ2FsbGJhY2spO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fc2V0U291cmNlKG5ldyBUZXhlbFNvdXJjZShlbGVtZW50KSwgZm9yY2VMb2FkQ2FsbGJhY2spO1xufTtcblxuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5fc2V0U291cmNlID0gZnVuY3Rpb24ocywgZm9yY2VMb2FkQ2FsbGJhY2spIHtcbiAgICB2YXIgcHJldkxvYWRpbmcgPSB0aGlzLmlzTG9hZGluZygpO1xuICAgIHRoaXMuX3NvdXJjZSA9IHM7XG4gICAgdmFyIGxvYWRpbmcgPSB0aGlzLmlzTG9hZGluZygpO1xuICAgIGlmKGZvcmNlTG9hZENhbGxiYWNrICYmICFsb2FkaW5nICYmICFwcmV2TG9hZGluZyl7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuTE9BRF9TVEFSVCk7XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBDLkRBVEFfRU5UUllfU1RBVEUuTE9BRF9FTkQpO1xuICAgIH1cbiAgICBlbHNlIGlmKGxvYWRpbmcpe1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5MT0FEX1NUQVJUKTtcbiAgICB9XG4gICAgZWxzZSBpZih0aGlzLl9sb2FkaW5nKXtcbiAgICAgICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgQy5EQVRBX0VOVFJZX1NUQVRFLkxPQURfRU5EKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfVkFMVUUpO1xufTtcblxuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5hc0dMVGV4dHVyZVZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zb3VyY2UgJiYgdGhpcy5fc291cmNlLmdsVGV4dHVyZURhdGE7XG59O1xuXG4vKiogQHJldHVybiB7SW1hZ2VEYXRhfSAqL1xuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fc291cmNlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoIXRoaXMuaXNMb2FkaW5nKCkpXG4gICAgICAgIHJldHVybiB0aGlzLl9zb3VyY2UuaW1hZ2VEYXRhO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKiogQHJldHVybiB7U2FtcGxlckNvbmZpZ30gKi9cblRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0U2FtcGxlckNvbmZpZyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3NhbXBsZXJDb25maWc7XG59O1xuXG4vKiogQHJldHVybiB7bnVtYmVyfSAqL1xuVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiAxO1xufTtcblRleHR1cmVFbnRyeS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cblRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0SXRlcmF0ZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEltYWdlRGF0YVRleHR1cmVFbnRyeVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogU2FtZSBhcyBUZXh0dXJlRW50cnksIG9ubHkgYmFzZWQgb24gaW1hZ2VEYXRhLlxuICogVGhpcyBjbGFzcyBpcyB1c2VkIGZvciB4ZmxvdyBydW5uaW5nIGluc2lkZSBXZWIgV29ya2VycyAod2hpY2ggZG9uJ3Qgc3VwcG9ydCBIVE1MIGltYWdlcylcbiAqIEBwYXJhbSBpbWFnZURhdGFcbiAqIEBleHRlbmRze0RhdGFFbnRyeX1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSW1hZ2VEYXRhVGV4dHVyZUVudHJ5ID0gZnVuY3Rpb24oaW1hZ2VEYXRhKXtcbiAgICBEYXRhRW50cnkuY2FsbCh0aGlzLCBDLkRBVEFfVFlQRS5URVhUVVJFKTtcbiAgICB0aGlzLl9zYW1wbGVyQ29uZmlnID0gbmV3IFNhbXBsZXJDb25maWcoKTtcbiAgICB0aGlzLl9pbWFnZURhdGEgPSBudWxsO1xuICAgIHRoaXMuX3RleGVsRm9ybWF0ID0gQy5URVhUVVJFX0ZPUk1BVC5SR0JBO1xuICAgIHRoaXMuX3RleGVsVHlwZSA9IEMuVEVYVFVSRV9UWVBFLlVCWVRFO1xuXG4gICAgdGhpcy5fdXBkYXRlSW1hZ2VEYXRhKGltYWdlRGF0YSk7XG5cbiAgICBub3RpZnlMaXN0ZW5lcnModGhpcywgQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfTkVXKTtcbn07XG5cbkJhc2UuY3JlYXRlQ2xhc3MoSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LCBEYXRhRW50cnkpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhJbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLCB7XG4gICAgd2lkdGg6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VEYXRhID8gdGhpcy5faW1hZ2VEYXRhLndpZHRoIDogLTE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbWFnZURhdGEgPyB0aGlzLl9pbWFnZURhdGEuaGVpZ2h0IDogLTE7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRleGVsRm9ybWF0OiB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RleGVsRm9ybWF0O1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0ZXhlbFR5cGU6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdGV4ZWxUeXBlO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cblxuXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLmlzTG9hZGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5faW1hZ2VEYXRhO1xufTtcblxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5fdXBkYXRlSW1hZ2VEYXRhID0gZnVuY3Rpb24oaW1hZ2VEYXRhKSB7XG4gICAgdGhpcy5fdGV4ZWxGb3JtYXQgPSBDLlRFWFRVUkVfRk9STUFULlJHQkE7XG4gICAgdGhpcy5fdGV4ZWxUeXBlID0gQy5URVhUVVJFX1RZUEUuVUJZVEU7XG4gICAgdGhpcy5faW1hZ2VEYXRhID0gaW1hZ2VEYXRhO1xufTtcblxuLyoqIENyZWF0ZSBuZXcgaW1hZ2VcbiAqIFRPRE86IEphbjogV3JpdGUgc291cmNlIGRvY3VtZW50YXRpb25cbiAqIEBwYXJhbSB3aWR0aFxuICogQHBhcmFtIGhlaWdodFxuICogQHBhcmFtIGZvcm1hdFxuICogQHBhcmFtIHR5cGVcbiAqIEBwYXJhbSBzYW1wbGVyQ29uZmlnXG4gKiBAcmV0dXJuIHtIVE1MSW1hZ2VFbGVtZW50fEhUTUxDYW52YXNFbGVtZW50fVxuICovXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLl9jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSwgc2FtcGxlckNvbmZpZykge1xuICAgIGlmICghdGhpcy5faW1hZ2VEYXRhIHx8IHRoaXMuZ2V0V2lkdGgoKSAhPSB3aWR0aCB8fCB0aGlzLmdldEhlaWdodCgpICE9IGhlaWdodCB8fCB0aGlzLl9mb3JtYXQgIT0gZm9ybWF0IHx8IHRoaXMuX3R5cGUgIT0gdHlwZSkge1xuICAgICAgICBpZiAoIXdpZHRoIHx8ICFoZWlnaHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aCBvciBoZWlnaHQgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgICAgdGhpcy5fdGV4ZWxGb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHRoaXMuX3RleGVsVHlwZSA9IHR5cGU7XG4gICAgICAgIGlmICghc2FtcGxlckNvbmZpZykge1xuICAgICAgICAgICAgc2FtcGxlckNvbmZpZyA9IG5ldyBTYW1wbGVyQ29uZmlnKCk7XG4gICAgICAgICAgICBzYW1wbGVyQ29uZmlnLnNldERlZmF1bHRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2FtcGxlckNvbmZpZy5zZXQoc2FtcGxlckNvbmZpZyk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHt7d2lkdGg6ICosIGhlaWdodDogKiwgZGF0YTogbnVsbHxBcnJheUJ1ZmZlclZpZXd9fVxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGltYWdlRGF0YSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZih0eXBlID09IEMuVEVYVFVSRV9UWVBFLkZMT0FUKXtcbiAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCpoZWlnaHQqNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogV2Ugc2hvdWxkIGFsbG9jYXRlIFVpbnQ4Q2xhbXBlZEFycmF5IGhlcmUgaW5zdGVhZFxuICAgICAgICAgICAgLy8gQnV0IFVpbnQ4Q2xhbXBlZEFycmF5IGNhbid0IGJlIGFsbG9jYXRlZCBpbiBDaHJvbWUgaW5zaWRlIGEgV2ViIFdvcmtlclxuICAgICAgICAgICAgLy8gU2VlIGJ1ZzogaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTc2NDc5XG4gICAgICAgICAgICAvLyBBcyBhIHdvcmsgYXJvdW5kLCB3ZSBhbGxvY2F0ZSBJbnQxNkFycmF5IHdoaWNoIHJlc3VsdHMgaW4gY29ycmVjdCBjbGFtcGluZyBvdXRzaWRlIG9mIHdlYiB3b3JrZXJcbiAgICAgICAgICAgIGlmKFVpbnQ4QXJyYXkgPT0gVWludDhDbGFtcGVkQXJyYXkpXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGEgPSBuZXcgSW50MTZBcnJheSh3aWR0aCpoZWlnaHQqNCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGEgPSBuZXcgVWludDhDbGFtcGVkQXJyYXkod2lkdGgqaGVpZ2h0KjQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ltYWdlRGF0YSA9IGltYWdlRGF0YTtcbiAgICB9XG4gICAgdGhpcy5fbm90aWZ5Q2hhbmdlZCgpO1xufTtcblxuLyoqIEBwYXJhbSB7T2JqZWN0fSB2ICovXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLnNldEltYWdlRGF0YSA9IGZ1bmN0aW9uKHYpIHtcbiAgICB0aGlzLl91cGRhdGVJbWFnZURhdGEodik7XG4gICAgbm90aWZ5TGlzdGVuZXJzKHRoaXMsIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1ZBTFVFKTtcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xufTtcblxuSW1hZ2VEYXRhVGV4dHVyZUVudHJ5LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pbWFnZURhdGEgJiYgdGhpcy5faW1hZ2VEYXRhLndpZHRoIHx8IDA7XG59O1xuXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLmdldEhlaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9pbWFnZURhdGEgJiYgdGhpcy5faW1hZ2VEYXRhLmhlaWdodCB8fCAwO1xufTtcblxuLyoqIEByZXR1cm4ge0ltYWdlRGF0YX0gKi9cbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5faW1hZ2VEYXRhO1xufTtcblxuLyoqIEByZXR1cm4ge1NhbXBsZXJDb25maWd9ICovXG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLmdldFNhbXBsZXJDb25maWcgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9zYW1wbGVyQ29uZmlnO1xufTtcblxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gMTtcbn07XG5JbWFnZURhdGFUZXh0dXJlRW50cnkucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cblxuLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbkltYWdlRGF0YVRleHR1cmVFbnRyeS5wcm90b3R5cGUuZ2V0SXRlcmF0ZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERhdGFDaGFuZ2VOb3RpZmllclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLyoqXG4gKiBVc2VkIHRvIGxpc3RlbiB0byBtb2RpZmljYXRpb25zIG9mIGFueSBEYXRhRW50cnkgY29ubmVjdGVkIHRvIGFuIFhmbG93IGdyYXBoLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBEYXRhQ2hhbmdlTm90aWZpZXIgPSB7XG4gICAgX2xpc3RlbmVyczogW11cbn07XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihEYXRhRW50cnksIEMuREFUQV9FTlRSWV9TVEFURSl9IGNhbGxiYWNrXG4gKi9cbkRhdGFDaGFuZ2VOb3RpZmllci5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRGF0YUVudHJ5LCBDLkRBVEFfRU5UUllfU1RBVEUpfSBjYWxsYmFja1xuICovXG5EYXRhQ2hhbmdlTm90aWZpZXIucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgQXJyYXkuZXJhc2UodGhpcy5fbGlzdGVuZXJzLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7RGF0YUVudHJ5fSBkYXRhRW50cnlcbiAqIEBwYXJhbSB7Qy5EQVRBX0VOVFJZX1NUQVRFfSBub3RpZmljYXRpb25cbiAqL1xuZnVuY3Rpb24gbm90aWZ5TGlzdGVuZXJzKGRhdGFFbnRyeSwgbm90aWZpY2F0aW9uKXtcbiAgICB2YXIgaTtcbiAgICAvLyBHbG9iYWwgbm90aWZpY2F0aW9uc1xuICAgIGZvcihpID0gMDsgaSA8IERhdGFDaGFuZ2VOb3RpZmllci5fbGlzdGVuZXJzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgRGF0YUNoYW5nZU5vdGlmaWVyLl9saXN0ZW5lcnNbaV0oZGF0YUVudHJ5LCBub3RpZmljYXRpb24pO1xuICAgIH1cbiAgICAvLyBJbnRlcm5hbCBhbmQgZXh0ZXJuYWwgbGlzdGVuZXJzXG4gICAgZm9yKGkgPSAwOyBpIDwgZGF0YUVudHJ5Ll9saXN0ZW5lcnMubGVuZ3RoOyArK2kpe1xuICAgICAgICBkYXRhRW50cnkuX2xpc3RlbmVyc1tpXShkYXRhRW50cnksIG5vdGlmaWNhdGlvbik7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBEYXRhRW50cnk6IERhdGFFbnRyeSxcbiAgICBCdWZmZXJFbnRyeTogQnVmZmVyRW50cnksXG4gICAgVGV4dHVyZUVudHJ5OiBUZXh0dXJlRW50cnksXG4gICAgSW1hZ2VEYXRhVGV4dHVyZUVudHJ5OiBJbWFnZURhdGFUZXh0dXJlRW50cnksXG4gICAgU2FtcGxlckNvbmZpZzogU2FtcGxlckNvbmZpZyxcbiAgICBEYXRhQ2hhbmdlTm90aWZpZXI6IERhdGFDaGFuZ2VOb3RpZmllclxufTtcbiIsInZhciBDID0gcmVxdWlyZShcIi4vY29uc3RhbnRzLmpzXCIpO1xudmFyIE1hcHBpbmcgPSByZXF1aXJlKFwiLi8uLi9wcm9jZXNzaW5nL21hcHBpbmcuanNcIik7XG5yZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXJyYXkuanNcIik7XG5cbnZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XG52YXIgQ2hhbm5lbE5vZGUgPSByZXF1aXJlKFwiLi4vcHJvY2Vzc2luZy9jaGFubmVsLW5vZGUuanNcIikuQ2hhbm5lbE5vZGU7XG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXRpbHMuanNcIik7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gR3JhcGhOb2RlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBvdGhlciBncmFwaCBub2Rlc1xuICogQGNvbnN0cnVjdG9yXG4gKiBAYWJzdHJhY3RcbiAqIEBwYXJhbSB7R3JhcGh9IGdyYXBoIFJlZmVyZW5jZSB0byBwYXJlbnQgZ3JhcGhcbiAqL1xudmFyIEdyYXBoTm9kZSA9IGZ1bmN0aW9uKCl7XG4gICAgLyoqXG4gICAgICogQWxsIG5vZGVzIHRoYXQgYWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIG5vZGVcbiAgICAgKiBAdHlwZSBhcnJheTxHcmFwaE5vZGU+XG4gICAgICoqL1xuICAgIHRoaXMuX3BhcmVudHMgPSBbXTtcbn07XG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBJbnB1dE5vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFuIElucHV0Tm9kZSBpbmNsdWRlIGFuIERhdGFFbnRyeSwgYSBuYW1lIGFuZCBvdGhlciBpbmZvcm1hdGlvblxuICogVGhpcyBjbGFzcyBtaXJyb3JzIFhNTDNEIGVsZW1lbnRzIHN1Y2ggYXMgPGZsb2F0Mz4sIDxpbnQ+IG9yIDx0ZXh0dXJlPlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtHcmFwaH0gZ3JhcGhcbiAqIEBleHRlbmRzIHtHcmFwaE5vZGV9XG4gKi9cbnZhciBJbnB1dE5vZGUgPSBmdW5jdGlvbigpe1xuICAgIEdyYXBoTm9kZS5jYWxsKHRoaXMpO1xuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIGlucHV0IG5vZGVcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbmFtZSA9IFwiXCI7XG4gICAgLyoqXG4gICAgICogU2VxdWVuY2Uga2V5XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2tleSA9IDA7XG4gICAgLyoqXG4gICAgICogRGF0YUVudHJ5IG5vZGUgdGhhdCBob2xkcyB0aGUgdmFsdWVcbiAgICAgKiBAdHlwZSB7RGF0YUVudHJ5fVxuICAgICAqL1xuICAgIHRoaXMuX2RhdGEgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgbm9kZXMgaXMgYSBwYXJhbWV0ZXIgd2l0aGluIGEgPGRhdGFmbG93PlxuICAgICAqIHRoaXMgaXMgc2V0IHRvIHRoZSBuYW1lIG9mIHRoZSBwYXJhbWV0ZXIsIG90aGVyd2lzZSBudWxsXG4gICAgICogQHR5cGUge251bGx8U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFyYW1OYW1lID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEV4cGVyaW1lbnRhbCEgQXBwbHkgZGlmZmVyZW50IG92ZXJyaWRlIGxvZ2ljIGluIG9yZGVyXG4gICAgICogdG8gcHJvcGFnYXRlIGdsb2JhbCBwYXJhbWV0ZXJzIHRvIHRoZSBzb3VyY2Ugb2YgdGhlIGdyYXBoXG4gICAgICogQ291bGQgYmUgdXNlZCBmb3IgaW5zdGFuY2UgZm9yIExPRCBjb25jZXB0cywgd2hlcmUgdGhlXG4gICAgICogcmVuZGVyZXIgcHJvcGFnYXRlcyB0aGUgZGlzdGFuY2UgYWxvbmcgdGhlIGdyYXBoXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYXJhbUdsb2JhbCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogIENhY2hlIGxpc3RlbmVyIGZvciBEYXRhRW50cnlcbiAgICAgKiAgQHNlZSB7SW5wdXROb2RlLm9uRGF0YUNoYW5nZX1cbiAgICAgKi9cbiAgICB0aGlzLl9kYXRhTGlzdGVuZXIgPSB0aGlzLm9uRGF0YUNoYW5nZS5iaW5kKHRoaXMpO1xufTtcbkJhc2UuY3JlYXRlQ2xhc3MoSW5wdXROb2RlLCBHcmFwaE5vZGUpO1xuXG4vKipcbiAqIFByb3BhZ2F0ZSBldmVudHMgZnJvbSBEYXRhRW50cnkgdG8gcGFyZW50IG5vZGVzXG4gKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWVcbiAqIEBwYXJhbSB7Qy5EQVRBX0VOVFJZX1NUQVRFfSBub3RpZmljYXRpb25cbiAqL1xuSW5wdXROb2RlLnByb3RvdHlwZS5vbkRhdGFDaGFuZ2UgPSBmdW5jdGlvbihuZXdWYWx1ZSwgbm90aWZpY2F0aW9uKSB7XG4gICAgdmFyIGRvd25Ob3RlO1xuICAgIHN3aXRjaChub3RpZmljYXRpb24pe1xuICAgICAgICBjYXNlIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1ZBTFVFOiBkb3duTm90ZSA9IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9WQUxVRTsgYnJlYWs7XG4gICAgICAgIGNhc2UgQy5EQVRBX0VOVFJZX1NUQVRFLkxPQURfU1RBUlQ6IGRvd25Ob3RlID0gQy5SRVNVTFRfU1RBVEUuSU1BR0VfTE9BRF9TVEFSVDsgYnJlYWs7XG4gICAgICAgIGNhc2UgQy5EQVRBX0VOVFJZX1NUQVRFLkxPQURfRU5EOiBkb3duTm90ZSA9IEMuUkVTVUxUX1NUQVRFLklNQUdFX0xPQURfRU5EOyBicmVhaztcbiAgICAgICAgY2FzZSBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFX1RZUEU6IGRvd25Ob3RlID0gQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkU7IGJyZWFrO1xuICAgICAgICBjYXNlIEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1NJWkU6IGRvd25Ob3RlID0gQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9EQVRBX1NJWkU7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiBkb3duTm90ZSA9IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9TSVpFOyBicmVhaztcbiAgICB9XG4gICAgbm90aWZ5UGFyZW50c09uQ2hhbmdlZCh0aGlzLGRvd25Ob3RlKTtcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dE5vZGUucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgIC8qKiBAcGFyYW0ge3N0cmluZ30gdiAqL1xuICAgIHNldDogZnVuY3Rpb24odil7XG4gICAgICAgIHRoaXMuX25hbWUgPSB2O1xuICAgICAgICBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKHRoaXMsIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fbmFtZTsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dE5vZGUucHJvdG90eXBlLCBcImtleVwiLCB7XG4gICAgLyoqIEBwYXJhbSB7bnVtYmVyfSB2ICovXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcbiAgICAgICAgdGhpcy5fa2V5ID0gdjtcbiAgICAgICAgbm90aWZ5UGFyZW50c09uQ2hhbmdlZCh0aGlzLCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2tleTsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dE5vZGUucHJvdG90eXBlLCBcInBhcmFtTmFtZVwiLCB7XG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSB2ICovXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcbiAgICAgICAgdGhpcy5fcGFyYW1OYW1lID0gdjtcbiAgICAgICAgbm90aWZ5UGFyZW50c09uQ2hhbmdlZCh0aGlzLCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3BhcmFtTmFtZTsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShJbnB1dE5vZGUucHJvdG90eXBlLCBcInBhcmFtR2xvYmFsXCIsIHtcbiAgICAvKiogQHBhcmFtIHtib29sZWFufSB2ICovXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcbiAgICAgICAgdGhpcy5fcGFyYW1HbG9iYWwgPSB2O1xuICAgICAgICBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKHRoaXMsIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3BhcmFtR2xvYmFsOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KElucHV0Tm9kZS5wcm90b3R5cGUsIFwiZGF0YVwiLCB7XG4gICAgLyoqIEBwYXJhbSB7RGF0YUVudHJ5fSBkYXRhRW50cnkgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGRhdGFFbnRyeSl7XG4gICAgICAgIHZhciBwcmV2RGF0YUxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYodGhpcy5fZGF0YSkge1xuICAgICAgICAgICAgcHJldkRhdGFMb2FkaW5nID0gdGhpcy5fZGF0YS5fbG9hZGluZztcbiAgICAgICAgICAgIHRoaXMuX2RhdGEucmVtb3ZlTGlzdGVuZXIodGhpcy5fZGF0YUxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YUVudHJ5O1xuICAgICAgICBpZih0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhLmFkZExpc3RlbmVyKHRoaXMuX2RhdGFMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYocHJldkRhdGFMb2FkaW5nICE9IHRoaXMuX2RhdGEuX2xvYWRpbmcpe1xuICAgICAgICAgICAgbm90aWZ5UGFyZW50c09uQ2hhbmdlZCh0aGlzLCB0aGlzLl9kYXRhLl9sb2FkaW5nID8gQy5SRVNVTFRfU1RBVEUuSU1BR0VfTE9BRF9TVEFSVCA6XG4gICAgICAgICAgICAgICAgQy5SRVNVTFRfU1RBVEUuSU1BR0VfTE9BRF9FTkQpO1xuICAgICAgICB9XG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiB7RGF0YUVudHJ5fSAqL1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2RhdGE7IH1cbn0pO1xuXG4vKipcbiAqIEdldHRlciBmb3IgbG9jYWwgcGFyYW1ldGVyIG5hbWUsIHJldHVybnMgbnVsbCBpZiB0aGlzIGlzIGEgZ2xvYmFsXG4gKiBwYXJhbWV0ZXJcbiAqXG4gKiBAcmV0dXJucyB7bnVsbHxTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5JbnB1dE5vZGUucHJvdG90eXBlLl9nZXRQYXJhbU5hbWVzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1HbG9iYWwgPyBudWxsIDogdGhpcy5fcGFyYW1OYW1lO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgZm9yIGdsb2JhbCBwYXJhbWV0ZXIgbmFtZSwgcmV0dXJucyBudWxsIGlmIHRoaXMgaXMgbm90IGEgZ2xvYmFsXG4gKiBwYXJhbWV0ZXJcbiAqXG4gKiBAcmV0dXJucyB7bnVsbHxTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5JbnB1dE5vZGUucHJvdG90eXBlLl9nZXRHbG9iYWxQYXJhbU5hbWVzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcGFyYW1HbG9iYWwgPyB0aGlzLl9wYXJhbU5hbWUgOiBudWxsO1xufTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBEYXRhTm9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgY194Zmxvd05vZGVJZCA9IDA7XG5mdW5jdGlvbiBnZXRYZmxvd05vZGVJZCgpe1xuICAgIHJldHVybiArK2NfeGZsb3dOb2RlSWQ7XG59XG5cbi8qKlxuICogVGhlIERhdGFOb2RlIGlzIHRoZSBjZW50cmFsIHN0cnVjdHVyZSBvZiBhbiBYZmxvdyBHcmFwaC5cbiAqIEl0IGlzIHVzZWQgdG8gYnVpbGQgYSBkYXRhIGNvbXBvc2l0aW9uIGdyYXBoIGFzIHdlbGwgYXMgYSBkYXRhIGZsb3cuXG4gKiBJdCBtaXJyb3IgdGhlIDxkYXRhPiBlbGVtZW50IG9mIFhNTDNEXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0dyYXBofSBncmFwaCBDb250ZXh0IGdyYXBoXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGF0YUZsb3cgaXMgdGhpcyBub2RlIGEgZGF0YWZsb3dcbiAqIEBleHRlbmRzIHtHcmFwaE5vZGV9XG4gKi9cbnZhciBEYXRhTm9kZSA9IGZ1bmN0aW9uKGlzRGF0YUZsb3cpe1xuICAgIEdyYXBoTm9kZS5jYWxsKHRoaXMpO1xuXG4gICAgLyoqXG4gICAgICogTWFya2VyLCBpZiB0aGlzIGRhdGEgbm9kZSBpcyBleHBlY3RpbmcgZGF0YS4gWGZsb3dcbiAgICAgKiBpcyBub3QgbW9uaXRvcmluZyBhbnkgbG9hZCBldmVudHMuIFRoaXMgbXVzdCBiZSBzZXRcbiAgICAgKiBmcm9tIGV4dGVybmFsXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fbG9hZGluZyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRXhwZXJpbWVudGFsISBQcmlvcml0eS4gSG93IGltcG9ydGFudCBpcyB0aGlzIGRhdGE/XG4gICAgICogMDogVmVyeSBpbXBvcnRhbnRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuX2xvYWRMZXZlbCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBsb2FkaW5nIGV2ZW50czogSWYgcHJvZ3Jlc3MgbGV2ZWxcbiAgICAgKiByZWFjaGVzIGluZmluaXR5LCBsb2FkaW5nIGV2ZW50cyBhcmUgdHJpZ2dlcmVkXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLl9wcm9ncmVzc0xldmVsID0gSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBHbG9iYWxseSB1bmlxdWUgaWRcbiAgICAgKi9cbiAgICB0aGlzLmlkID0gZ2V0WGZsb3dOb2RlSWQoKTtcblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgbm9kZSBhIHByb3RvIG5vZGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9pc1Byb3RvTm9kZSA9IGlzRGF0YUZsb3c7XG5cbiAgICAvKipcbiAgICAgKiBDaGlsZHJlbi4gSW5wdXROb2RlcyBhbmQgRGF0YU5vZGVzIChhcyBmb3VuZCBpbiBET00pXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG5cbiAgICAvKipcbiAgICAgKiBUaGUgRGF0YU5vZGUgdGhhdCBoYXMgYmVlbiByZWZlcmVuY2UgdmlhIHNyY1xuICAgICAqIEB0eXBlIHtEYXRhTm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLl9zb3VyY2VOb2RlID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEZpZWxkIHRvIGF0dGFjaCBjdXN0b20gZGF0YVxuICAgICAqIEB0eXBlIHtudWxsfE9iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl91c2VyRGF0YSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsdGVyIHR5cGUgb2YgdGhpcyBub2RlIChrZWVwLCByZW5hbWUsIHJlbW92ZSAuLi4pXG4gICAgICogQHR5cGUge0RBVEFfRklMVEVSX1RZUEV9XG4gICAgICovXG4gICAgdGhpcy5fZmlsdGVyVHlwZSA9IEMuREFUQV9GSUxURVJfVFlQRS5OT05FO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5lIHRoZSBtYXBwaW5nXG4gICAgICogQHR5cGUge01hcHBpbmcuTWFwcGluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9maWx0ZXJNYXBwaW5nID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFN0cmluZyBpZGVudGlmaWVyIGZvciBvcGVyYXRvclxuICAgICAqIFRPRE86IE9wZXJhdG9yIGNsYXNzXG4gICAgICogQHR5cGUge3N0cmluZ3xPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5fY29tcHV0ZU9wZXJhdG9yID0gXCJcIjtcblxuICAgIC8qKlxuICAgICAqIFRydWUsIGlmIGNvbXB1dGUgaXMgYSBkYXRhZmxvdyByZWZlcmVuY2VcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9jb21wdXRlVXNlc0RhdGFmbG93ID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBNYXBwaW5nIGZvciBpbnB1dCBvZiBvcGVyYXRvcixcbiAgICAgKiBlLmcuIChwb3NpdGlvbiwgdGV4Y29vcmQpIG9yICh7cG9zaXRpb246IHBvcywgdGV4Y29vcmQ6IHV2fSlcbiAgICAgKiBAdHlwZSB7TWFwcGluZ31cbiAgICAgKi9cbiAgICB0aGlzLl9jb21wdXRlSW5wdXRNYXBwaW5nID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIE1hcHBpbmcgZm9yIG91dHB1dCBvZiBvcGVyYXRvcixcbiAgICAgKiBlLmcuIChwb3NpdGlvbiwgdGV4Y29vcmQpID0gLi4uIG9yIHtwb3NpdGlvbjogcG9zLCB0ZXhjb29yZDogdXZ9ID0gLi4uXG4gICAgICogQHR5cGUge01hcHBpbmd9XG4gICAgICovXG4gICAgdGhpcy5fY29tcHV0ZU91dHB1dE1hcHBpbmcgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSWYgZGF0YWZsb3cgbm9kZSBoYXMgYmVlbiByZXNvbHZlZCwgdGhpc1xuICAgICAqIGVudHJ5IGlzIHNldFxuICAgICAqIEB0eXBlIHtEYXRhTm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLl9kYXRhZmxvd05vZGUgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgKG9wdGltaXplZCkgdmVyc2lvbiBvZiB0aGlzIGRhdGEgbm9kZVxuICAgICAqIEB0eXBlIHtDaGFubmVsTm9kZX1cbiAgICAgKi9cbiAgICB0aGlzLl9jaGFubmVsTm9kZSA9IG5ldyBDaGFubmVsTm9kZSh0aGlzKTtcblxuICAgIC8qKlxuICAgICAqIE1hcCBvZiBjYWNoZWQgY2hhbm5lbCBub2RlcyBmb3IgZGF0YWZsb3cgaW5zdGFuY2VzIHdpdGggdmFyeWluZ1xuICAgICAqIGlucHV0IGFyZ3VtZW50cyAoc3BlY2lhbGl6ZWQgbm9kZXMpXG4gICAgICogVE9ETzogVXNlIFdlYWtNYXA/XG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBDaGFubmVsTm9kZT59XG4gICAgICovXG4gICAgdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIENhY2hlZCB2ZXJzaW9uIG9mIGxvY2FsIHBhcmFtIG5hbWVzIGNvbGxlY3RlZCBmcm9tXG4gICAgICogY2hpbGRyZW5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5fcGFyYW1OYW1lcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgdmVyc2lvbiBvZiBnbG9iYWwgcGFyYW0gbmFtZXMgY29sbGVjdGVkIGZyb21cbiAgICAgKiBjaGlsZHJlblxuICAgICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLl9nbG9iYWxQYXJhbU5hbWVzID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFBsYXRmb3JtLCB0aGlzIGRhdGEgbm9kZSBzaG91bGQgYmUgZXhlY3V0ZWQgb25cbiAgICAgKiBUT0RPOiBUaGlzIHNob3VsZCBiZSBpbXBsaWNpdCwgbm90IGV4cGxpY2l0XG4gICAgICogQHR5cGUge251bGx9XG4gICAgICovXG4gICAgdGhpcy5fcGxhdGZvcm0gPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogT2JzZXJ2ZXJzIG9mIHRoZSBub2RlJ3MgQy5SRVNVTFRfU1RBVEVcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBPYnNlcnZlcnMgb2YgdGhlIG5vZGUncyBwcm9ncmVzcyBsZXZlbFxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cbiAgICB0aGlzLl9sb2FkTGlzdGVuZXJzID0gW107XG5cbn07XG5CYXNlLmNyZWF0ZUNsYXNzKERhdGFOb2RlLCBHcmFwaE5vZGUpO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwic291cmNlTm9kZVwiLCB7XG4gICAgLyoqIEBwYXJhbSB7P0RhdGFOb2RlfSBuZXdTb3VyY2VOb2RlICovXG4gICAgc2V0OiBmdW5jdGlvbihuZXdTb3VyY2VOb2RlKXtcbiAgICAgICAgcmVwbGFjZU5vZGVJbkhpZXJhcmNoeSh0aGlzLCBcIl9zb3VyY2VOb2RlXCIsIG5ld1NvdXJjZU5vZGUpO1xuICAgICAgICB1cGRhdGVQcm9ncmVzc0xldmVsKHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGlmeShDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiB7P0RhdGFOb2RlfSAqL1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3NvdXJjZU5vZGU7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcImRhdGFmbG93Tm9kZVwiLCB7XG4gICAgLyoqIEBwYXJhbSB7P0RhdGFOb2RlfSBuZXdEYXRhZmxvd05vZGUgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG5ld0RhdGFmbG93Tm9kZSl7XG4gICAgICAgIGlmKG5ld0RhdGFmbG93Tm9kZSAmJiAhdGhpcy5fY29tcHV0ZVVzZXNEYXRhZmxvdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNldCBkYXRhZmxvd05vZGUgd2hlbiBjb21wdXRlIGRvZXNuJ3QgdXNlIGRhdGFmbG93LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlTm9kZUluSGllcmFyY2h5KHRoaXMsIFwiX2RhdGFmbG93Tm9kZVwiLCBuZXdEYXRhZmxvd05vZGUpO1xuICAgICAgICB1cGRhdGVQcm9ncmVzc0xldmVsKHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGlmeShDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiB7P0RhdGFOb2RlfSAqL1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2RhdGFmbG93Tm9kZTsgfVxufSk7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlLnByb3RvdHlwZSwgXCJ1c2VyRGF0YVwiLCB7XG4gICAgLyoqIEBwYXJhbSB7P0RhdGFOb2RlfSB2ICovXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcbiAgICAgICAgdGhpcy5fdXNlckRhdGEgPSB2O1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4gez9EYXRhTm9kZX0gKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl91c2VyRGF0YTsgfVxufSk7XG5cbi8qKlxuICogU2V0IChmcm9tIGV4dGVybmFsKSBpZiBtb3JlIGRhdGEgaXMgZXhwZWN0ZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvYWRpbmdcbiAqL1xuRGF0YU5vZGUucHJvdG90eXBlLnNldExvYWRpbmcgPSBmdW5jdGlvbihsb2FkaW5nKXtcbiAgICBpZih0aGlzLl9sb2FkaW5nICE9IGxvYWRpbmcpe1xuICAgICAgICB0aGlzLl9sb2FkaW5nID0gbG9hZGluZztcbiAgICAgICAgdGhpcy5fY2hhbm5lbE5vZGUuc2V0U3RydWN0dXJlT3V0T2ZTeW5jKCk7XG4gICAgICAgIHRoaXMuX2NoYW5uZWxOb2RlLmxvYWRpbmcgPSBsb2FkaW5nO1xuICAgICAgICBmb3IgKHZhciBzdWIgaW4gdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXMpIHtcbiAgICAgICAgICAgIHZhciBzdWJOb2RlID0gdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXNbc3ViXTtcbiAgICAgICAgICAgIHN1Yk5vZGUuc2V0U3RydWN0dXJlT3V0T2ZTeW5jKCk7XG4gICAgICAgICAgICBzdWJOb2RlLmxvYWRpbmcgPSBsb2FkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGlmIHRoaXMgb3IgYW55IGNoaWxkIG5vZGUgaXMgbG9hZGluZ1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkRhdGFOb2RlLnByb3RvdHlwZS5pc1N1YnRyZWVMb2FkaW5nID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3Jlc3NMZXZlbCA9PSAwO1xufTtcblxuLyoqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5EYXRhTm9kZS5wcm90b3R5cGUuZ2V0UHJvZ3Jlc3NMZXZlbCA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyZXNzTGV2ZWw7XG59O1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwiZmlsdGVyVHlwZVwiLCB7XG4gICAgLyoqIEBwYXJhbSB7Qy5EQVRBX0ZJTFRFUl9UWVBFfSB2ICovXG4gICAgc2V0OiBmdW5jdGlvbih2KXtcbiAgICAgICAgdGhpcy5fZmlsdGVyVHlwZSA9IHY7XG4gICAgICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiB7Qy5EQVRBX0ZJTFRFUl9UWVBFfSAqL1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2ZpbHRlclR5cGU7IH1cbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRGF0YU5vZGUucHJvdG90eXBlLCBcImZpbHRlck1hcHBpbmdcIiwge1xuICAgIC8qKiBAcGFyYW0ge01hcHBpbmd9IHYgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xuICAgICAgICBzd2FwTWFwcGluZyh0aGlzLCBcIl9maWx0ZXJNYXBwaW5nXCIsIHYpO1xuICAgICAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4ge01hcHBpbmd9ICovXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZmlsdGVyTWFwcGluZzsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwiY29tcHV0ZU9wZXJhdG9yXCIsIHtcbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHYgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xuICAgICAgICB0aGlzLl9jb21wdXRlT3BlcmF0b3IgPSB2O1xuICAgICAgICB0aGlzLl9jb21wdXRlVXNlc0RhdGFmbG93ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiB7c3RyaW5nfSAqL1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2NvbXB1dGVVc2VzRGF0YWZsb3cgPyBudWxsIDogdGhpcy5fY29tcHV0ZU9wZXJhdG9yOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFOb2RlLnByb3RvdHlwZSwgXCJjb21wdXRlRGF0YWZsb3dVcmxcIiwge1xuICAgIC8qKiBAcGFyYW0ge3N0cmluZ30gdiAqL1xuICAgIHNldDogZnVuY3Rpb24odil7XG4gICAgICAgIHRoaXMuX2NvbXB1dGVPcGVyYXRvciA9IHY7XG4gICAgICAgIHRoaXMuX2NvbXB1dGVVc2VzRGF0YWZsb3cgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xuICAgICAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xuICAgIH0sXG4gICAgLyoqIEByZXR1cm4ge3N0cmluZ30gKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9jb21wdXRlVXNlc0RhdGFmbG93ID8gdGhpcy5fY29tcHV0ZU9wZXJhdG9yIDogbnVsbDsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwiY29tcHV0ZUlucHV0TWFwcGluZ1wiLCB7XG4gICAgLyoqIEBwYXJhbSB7TWFwcGluZ30gdiAqL1xuICAgIHNldDogZnVuY3Rpb24odil7XG4gICAgICAgIHN3YXBNYXBwaW5nKHRoaXMsIFwiX2NvbXB1dGVJbnB1dE1hcHBpbmdcIiwgdik7XG4gICAgICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG4gICAgfSxcbiAgICAvKiogQHJldHVybiB7TWFwcGluZ30gKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9jb21wdXRlSW5wdXRNYXBwaW5nOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEYXRhTm9kZS5wcm90b3R5cGUsIFwiY29tcHV0ZU91dHB1dE1hcHBpbmdcIiwge1xuICAgIC8qKiBAcGFyYW0ge01hcHBpbmd9IHYgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xuICAgICAgICBzd2FwTWFwcGluZyh0aGlzLCBcIl9jb21wdXRlT3V0cHV0TWFwcGluZ1wiLCB2KTtcbiAgICAgICAgdGhpcy5ub3RpZnkoIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcbiAgICAgICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcbiAgICB9LFxuICAgIC8qKiBAcmV0dXJuIHtNYXBwaW5nfSAqL1xuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2NvbXB1dGVPdXRwdXRNYXBwaW5nOyB9XG59KTtcblxuLy9ub2luc3BlY3Rpb24gSlNVbnVzZWRHbG9iYWxTeW1ib2xzXG5EYXRhTm9kZS5wcm90b3R5cGUuaXNQcm90b05vZGUgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9pc1Byb3RvTm9kZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtHcmFwaE5vZGV9IGNoaWxkXG4gKi9cbkRhdGFOb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKXtcbiAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICBhZGRQYXJlbnQodGhpcywgY2hpbGQpO1xuICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XG4gICAgdGhpcy5ub3RpZnkoIEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcbiAgICBCYXNlLl9mbHVzaFJlc3VsdENhbGxiYWNrcygpO1xufTtcbi8qKlxuICogQHBhcmFtIHtHcmFwaE5vZGV9IGNoaWxkXG4gKi9cbkRhdGFOb2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uKGNoaWxkKXtcbiAgICBBcnJheS5lcmFzZSh0aGlzLl9jaGlsZHJlbiwgY2hpbGQpO1xuICAgIHJlbW92ZVBhcmVudCh0aGlzLCBjaGlsZCk7XG4gICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbCh0aGlzKTtcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7R3JhcGhOb2RlfSBjaGlsZFxuICogQHBhcmFtIHtHcmFwaE5vZGV9IGJlZm9yZU5vZGVcbiAqL1xuRGF0YU5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZSA9IGZ1bmN0aW9uKGNoaWxkLCBiZWZvcmVOb2RlKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihiZWZvcmVOb2RlKTtcbiAgICBpZihpZHggPT0gLTEpXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIGVsc2VcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4uc3BsaWNlKGlkeCwgMCwgY2hpbGQpO1xuICAgIGFkZFBhcmVudCh0aGlzLCBjaGlsZCk7XG4gICAgLy8gVE9ETzogTmV4dCB0aHJlZSBjYWxscyBvbiBhbGwgc3RydWN0dXJhbCBjaGFuZ2VzLiBBZGQgTWV0aG9kXG4gICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbCh0aGlzKTtcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG59O1xuXG4vKipcbiAqIHJlbW92ZSBhbGwgY2hpbGRyZW4gb2YgdGhlIERhdGFOb2RlXG4gKi9cbkRhdGFOb2RlLnByb3RvdHlwZS5jbGVhckNoaWxkcmVuID0gZnVuY3Rpb24oKXtcbiAgICBmb3IodmFyIGkgPTA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7ICsraSl7XG4gICAgICAgIHJlbW92ZVBhcmVudCh0aGlzLCB0aGlzLl9jaGlsZHJlbltpXSk7XG4gICAgfVxuICAgIHRoaXMuX2NoaWxkcmVuID0gW107XG4gICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbCh0aGlzKTtcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG59O1xuXG4vL25vaW5zcGVjdGlvbiBKU1VudXNlZEdsb2JhbFN5bWJvbHNcbi8qKlxuICogRGV0YWNoIHRoaXMgRGF0YU5vZGUgZnJvbSBhbGwgY29ubmVjdGlvbnMsIGluY2x1ZGluZyBzb3VyY2UtIGFuZCBwcm90by1ub2RlIHJlZmVyZW5jZXNcbiAqL1xuRGF0YU5vZGUucHJvdG90eXBlLmRldGFjaEZyb21QYXJlbnRzID0gZnVuY3Rpb24oKXtcbiAgICBmb3IodmFyIGkgPTA7IGkgPCB0aGlzLl9wYXJlbnRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudHNbaV07XG4gICAgICAgIGlmKHBhcmVudC5fc291cmNlTm9kZSA9PSB0aGlzKVxuICAgICAgICAgICAgcGFyZW50LnNvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICBlbHNlIGlmKHBhcmVudC5fZGF0YWZsb3dOb2RlID09IHRoaXMpe1xuICAgICAgICAgICAgcGFyZW50LmRhdGFmbG93Tm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xufTtcblxuLyoqXG4gKiBTZXRzIHBsYXRmb3JtIG9mIGEgRGF0YU5vZGUuIElmIF9wbGF0Zm9ybSBpcyBkZWZpbmVkLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHBsYXRmb3JtIHNldHRpbmcgb2ZcbiAqIGFuIFhmbG93IGdyYXBoLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEMuUExBVEZPUk18bnVsbH0gcGxhdGZvcm1TcmNcbiAqL1xuRGF0YU5vZGUucHJvdG90eXBlLnNldFBsYXRmb3JtID0gZnVuY3Rpb24ocGxhdGZvcm1TcmMpIHtcbiAgICBpZiAodHlwZW9mIHBsYXRmb3JtU3JjID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAocGxhdGZvcm1TcmMgPT09IFwiY2xcIikge1xuICAgICAgICAgICAgdGhpcy5fcGxhdGZvcm0gPSBDLlBMQVRGT1JNLkNMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtU3JjID09PSBcImdsXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtID0gQy5QTEFURk9STS5HTFNMO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtU3JjID09PSBcImpzXCIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BsYXRmb3JtID0gQy5QTEFURk9STS5KQVZBU0NSSVBUO1xuICAgICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNOYU4ocGFyc2VGbG9hdChwbGF0Zm9ybVNyYykpICYmIGlzRmluaXRlKHBsYXRmb3JtU3JjKSkge1xuICAgICAgICB0aGlzLl9wbGF0Zm9ybSA9IHBsYXRmb3JtU3JjO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3BsYXRmb3JtID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLm5vdGlmeShDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcbn07XG5cbi8qKlxuICogQGNvbnN0XG4gKi9cbnZhciBmaWx0ZXJQYXJzZXIgPSAvXihbQS1aYS16XFxzXSopXFwoKFteKCldKylcXCkkLztcblxuLyoqXG4gKiBTZXQgZmlsdGVyIGJ5IHN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IGZpbHRlclN0cmluZ1xuICovXG5EYXRhTm9kZS5wcm90b3R5cGUuc2V0RmlsdGVyID0gZnVuY3Rpb24oZmlsdGVyU3RyaW5nKXtcbiAgICBmaWx0ZXJTdHJpbmcgPSBmaWx0ZXJTdHJpbmcgfHwgXCJcIjtcbiAgICB2YXIgbmV3VHlwZSA9IEMuREFUQV9GSUxURVJfVFlQRS5SRU5BTUU7XG4gICAgdmFyIG5ld01hcHBpbmcgPSBudWxsO1xuICAgIGlmKGZpbHRlclN0cmluZyl7XG4gICAgICAgIHZhciByZXN1bHQgPSBmaWx0ZXJTdHJpbmcudHJpbSgpLm1hdGNoKGZpbHRlclBhcnNlcik7XG4gICAgICAgIGlmKHJlc3VsdCl7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHJlc3VsdFsxXS50cmltKCk7XG4gICAgICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICAgICAgY2FzZSBcImtlZXBcIjogbmV3VHlwZSA9IEMuREFUQV9GSUxURVJfVFlQRS5LRUVQOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVtb3ZlXCI6IG5ld1R5cGUgPSBDLkRBVEFfRklMVEVSX1RZUEUuUkVNT1ZFOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVuYW1lXCI6IG5ld1R5cGUgPSBDLkRBVEFfRklMVEVSX1RZUEUuUkVOQU1FOyBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBCYXNlLm5vdGlmeUVycm9yKFwiVW5rbm93biBmaWx0ZXIgdHlwZTpcIiArIHR5cGUsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3TWFwcGluZyA9IE1hcHBpbmcuTWFwcGluZy5wYXJzZShyZXN1bHRbMl0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBCYXNlLm5vdGlmeUVycm9yKFwiQ291bGQgbm90IHBhcnNlIGZpbHRlciAnXCIgKyBmaWx0ZXJTdHJpbmcgKyBcIidcIiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYoIW5ld01hcHBpbmcpe1xuICAgICAgICAvLyBUT0RPIFJlbW92ZSB0aGlzPyAoTWFwcGluZyBjYW4gYmUgbnVsbCBmcm9tIG5vdyBvbilcbiAgICAgICAgbmV3TWFwcGluZyA9IG5ldyBNYXBwaW5nLk9yZGVyTWFwcGluZygpO1xuICAgIH1cbiAgICBzd2FwTWFwcGluZyh0aGlzLCBcIl9maWx0ZXJNYXBwaW5nXCIsIG5ld01hcHBpbmcpO1xuICAgIHRoaXMuX2ZpbHRlclR5cGUgPSBuZXdUeXBlO1xuICAgIHRoaXMubm90aWZ5KCBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcbn07XG5cbnZhciBjb21wdXRlUGFyc2VyID0gL14oKFtePV0rKVxcPSk/KFteJyhdKygnW14nXSsnKT9bXicoXSspKFxcKChbXigpXSopP1xcKSk/JC87XG52YXIgYnJhY2tldHNQYXJzZXIgPSAvXlxcKChbXigpXSopXFwpJC87XG52YXIgZGF0YWZsb3dQYXJzZXIgPSAvXmRhdGFmbG93XFxbJyhbXiddKyknXFxdJC87XG5cbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuLyoqXG4gKiBJZiB0aGUgY29tcHV0ZSBzdHJpbmcgY29udGFpbnMgYSByZWZlcmVuY2UgdG8gYW4gZXh0ZXJuYWwgZGF0YWZsb3csXG4gKiB0aGUgcGFyc2VyIHJldHVybnMgaXRzIFVSTC4gTnVsbCwgb3RoZXJ3aXNlXG4gKiBAcGFyYW0gY29tcHV0ZVN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuICovXG52YXIgZ2V0Q29tcHV0ZURhdGFmbG93VXJsID0gZnVuY3Rpb24oY29tcHV0ZVN0cmluZyl7XG4gICAgY29tcHV0ZVN0cmluZyA9IGNvbXB1dGVTdHJpbmcgfHwgXCJcIjtcbiAgICB2YXIgcmVzdWx0ID0gY29tcHV0ZVN0cmluZy50cmltKCkubWF0Y2goY29tcHV0ZVBhcnNlcik7XG4gICAgaWYocmVzdWx0KXtcbiAgICAgICAgaWYocmVzdWx0ID0gcmVzdWx0WzNdLnRyaW0oKS5tYXRjaChkYXRhZmxvd1BhcnNlcikpe1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogU2V0IGNvbXB1dGUgYnkgc3RyaW5nXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcHV0ZVN0cmluZ1xuICovXG5EYXRhTm9kZS5wcm90b3R5cGUuc2V0Q29tcHV0ZSA9IGZ1bmN0aW9uKGNvbXB1dGVTdHJpbmcpe1xuICAgIGNvbXB1dGVTdHJpbmcgPSBjb21wdXRlU3RyaW5nIHx8IFwiXCI7XG4gICAgdmFyIG5ld09wZXJhdG9yID0gXCJcIjtcbiAgICB2YXIgaW5wdXRNYXBwaW5nID0gbnVsbCwgb3V0cHV0TWFwcGluZyA9IG51bGw7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXB1dGVTdHJpbmcudHJpbSgpLm1hdGNoKGNvbXB1dGVQYXJzZXIpO1xuICAgIGlmKHJlc3VsdCl7XG4gICAgICAgIHZhciBvdXRwdXQgPSByZXN1bHRbMl0gPyByZXN1bHRbMl0udHJpbSgpIDogXCJcIjtcbiAgICAgICAgbmV3T3BlcmF0b3IgPSByZXN1bHRbM10udHJpbSgpO1xuICAgICAgICB2YXIgaW5wdXQgPSByZXN1bHRbNl0gPyByZXN1bHRbNl0udHJpbSgpIDogXCJcIjtcbiAgICAgICAgaWYocmVzdWx0ID0gb3V0cHV0Lm1hdGNoKGJyYWNrZXRzUGFyc2VyKSl7XG4gICAgICAgICAgICBvdXRwdXQgPSByZXN1bHRbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYoaW5wdXQpXG4gICAgICAgICAgICBpbnB1dE1hcHBpbmcgPSBNYXBwaW5nLk1hcHBpbmcucGFyc2UoaW5wdXQsIHRoaXMpO1xuICAgICAgICBpZihvdXRwdXQpXG4gICAgICAgICAgICBvdXRwdXRNYXBwaW5nID0gTWFwcGluZy5NYXBwaW5nLnBhcnNlKG91dHB1dCwgdGhpcyk7XG5cbiAgICAgICAgaWYocmVzdWx0ID0gbmV3T3BlcmF0b3IubWF0Y2goZGF0YWZsb3dQYXJzZXIpKXtcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVVc2VzRGF0YWZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgbmV3T3BlcmF0b3IgPSByZXN1bHRbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVVc2VzRGF0YWZsb3cgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kYXRhZmxvd05vZGUgPSBudWxsO1xuICAgIH1cbiAgICBlbHNlIGlmKGNvbXB1dGVTdHJpbmcpe1xuICAgICAgICBCYXNlLm5vdGlmeUVycm9yKFwiRXJyb3IgcGFyc2luZyBDb21wdXRlIHZhbHVlICdcIiArIGNvbXB1dGVTdHJpbmcgKyBcIidcIiwgdGhpcyk7XG4gICAgfVxuICAgIHN3YXBNYXBwaW5nKHRoaXMsIFwiX2NvbXB1dGVJbnB1dE1hcHBpbmdcIiwgaW5wdXRNYXBwaW5nKTtcbiAgICBzd2FwTWFwcGluZyh0aGlzLCBcIl9jb21wdXRlT3V0cHV0TWFwcGluZ1wiLCBvdXRwdXRNYXBwaW5nKTtcbiAgICB0aGlzLl9jb21wdXRlT3BlcmF0b3IgPSBuZXdPcGVyYXRvcjtcbiAgICB0aGlzLm5vdGlmeSggQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkUpO1xuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG59O1xuXG4vKipcbiAqIE5vdGlmaWVzIERhdGFOb2RlIGFib3V0IGEgY2hhbmdlLiBOb3RpZmljYXRpb24gd2lsbCBiZSBmb3J3YXJkZWQgdG8gcGFyZW50cywgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0MuUkVTVUxUX1NUQVRFfSBjaGFuZ2VUeXBlXG4gKiBAcGFyYW0ge0dyYXBoTm9kZT99IHNlbmRlck5vZGVcbiAqL1xuRGF0YU5vZGUucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uKGNoYW5nZVR5cGUsIHNlbmRlck5vZGUpe1xuICAgIC8vbm9pbnNwZWN0aW9uIEZhbGx0aHJvdWdoSW5Td2l0Y2hTdGF0ZW1lbnRKU1xuICAgIHN3aXRjaChjaGFuZ2VUeXBlKSB7XG4gICAgICAgIGNhc2UgQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9TVFJVQ1RVUkU6XG4gICAgICAgICAgICB0aGlzLl9wYXJhbU5hbWVzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX2dsb2JhbFBhcmFtTmFtZXMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fY2hhbm5lbE5vZGUuc2V0U3RydWN0dXJlT3V0T2ZTeW5jKCk7XG4gICAgICAgICAgICBjbGVhclN1YnN0aXR1dGlvbk5vZGVzKHRoaXMpO1xuICAgICAgICAgICAgbm90aWZ5UGFyZW50c09uQ2hhbmdlZCh0aGlzLCBjaGFuZ2VUeXBlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQy5SRVNVTFRfU1RBVEUuSU1BR0VfTE9BRF9TVEFSVDpcbiAgICAgICAgY2FzZSBDLlJFU1VMVF9TVEFURS5JTUFHRV9MT0FEX0VORDpcbiAgICAgICAgICAgIHVwZGF0ZVByb2dyZXNzTGV2ZWwodGhpcyk7XG4gICAgICAgICAgICBpZihzZW5kZXJOb2RlKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFubmVsTm9kZS5ub3RpZnlEYXRhQ2hhbmdlKHNlbmRlck5vZGUsIGNoYW5nZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX0RBVEFfVkFMVUU6XG4gICAgICAgIGNhc2UgQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9EQVRBX1NJWkU6XG4gICAgICAgICAgICBpZihzZW5kZXJOb2RlKXtcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGFubmVsTm9kZS5ub3RpZnlEYXRhQ2hhbmdlKHNlbmRlck5vZGUsIGNoYW5nZVR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIEluZm9ybSBsaXN0ZW5lcnMgKGUuZy4gUmVxdWVzdHMpXG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RlbmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnNbaV0oY2hhbmdlVHlwZSk7XG4gICAgfVxufTtcblxuRGF0YU5vZGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpe1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKVxufTtcblxuRGF0YU5vZGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICBBcnJheS5lcmFzZSh0aGlzLl9saXN0ZW5lcnMsIGxpc3RlbmVyKTtcbn07XG5cbkRhdGFOb2RlLnByb3RvdHlwZS5hZGRMb2FkTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcil7XG4gICAgdGhpcy5fbG9hZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbn07XG5cbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuRGF0YU5vZGUucHJvdG90eXBlLnJlbW92ZUxvYWRMaXN0ZW5lciA9IGZ1bmN0aW9uKGxpc3RlbmVyKXtcbiAgICBBcnJheS5lcmFzZSh0aGlzLl9sb2FkTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG59O1xuXG5EYXRhTm9kZS5wcm90b3R5cGUuX2NhbGxMb2FkTGlzdGVuZXJzID0gZnVuY3Rpb24obmV3TGV2ZWwsIG9sZExldmVsKXtcbiAgICB2YXIgbGVuID0gdGhpcy5fbG9hZExpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKXtcbiAgICAgICAgdGhpcy5fbG9hZExpc3RlbmVyc1tpXSh0aGlzLCBuZXdMZXZlbCwgb2xkTGV2ZWwpO1xuICAgIH1cbn07XG5cbkRhdGFOb2RlLnByb3RvdHlwZS5nZXRPdXRwdXROYW1lcyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGdldEZvcndhcmROb2RlKHRoaXMpLl9jaGFubmVsTm9kZS5nZXRPdXRwdXROYW1lcygpO1xufTtcblxuRGF0YU5vZGUucHJvdG90eXBlLmdldE91dHB1dENoYW5uZWxJbmZvID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIGdldEZvcndhcmROb2RlKHRoaXMpLl9jaGFubmVsTm9kZS5nZXRPdXRwdXRDaGFubmVsSW5mbyhuYW1lKTtcbn07XG5cbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuRGF0YU5vZGUucHJvdG90eXBlLmdldFBhcmFtTmFtZXMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLl9nZXRQYXJhbU5hbWVzKCk7XG59O1xuXG4vKipcbiAqIERlbGVnYXRlIGNvbXB1dGF0aW9uIG9mIHRoZSByZXN1bHQgdG8gdGhlIGNoYW5uZWwgbm9kZVxuICogb2YgdGhlIGZpcnN0IGNvbnRyaWJ1dGluZyBEYXRhTm9kZS5cbiAqIEBwYXJhbSB0eXBlXG4gKiBAcGFyYW0gZmlsdGVyXG4gKiBAcmV0dXJucyB7UmVzdWx0fVxuICovXG5EYXRhTm9kZS5wcm90b3R5cGUuX2dldFJlc3VsdCA9IGZ1bmN0aW9uKHR5cGUsIGZpbHRlcil7XG4gICAgcmV0dXJuIGdldEZvcndhcmROb2RlKHRoaXMsIGZpbHRlcikuX2NoYW5uZWxOb2RlLmdldFJlc3VsdCh0eXBlLCBmaWx0ZXIpO1xufTtcblxuRGF0YU5vZGUucHJvdG90eXBlLl9nZXRGb3J3YXJkTm9kZSA9IGZ1bmN0aW9uKGZpbHRlcil7XG4gICAgcmV0dXJuIGdldEZvcndhcmROb2RlKHRoaXMsIGZpbHRlcik7XG59O1xuXG5EYXRhTm9kZS5wcm90b3R5cGUuX2dldFBhcmFtTmFtZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLl9wYXJhbU5hbWVzKXtcbiAgICAgICAgdGhpcy5fcGFyYW1OYW1lcyA9IFtdO1xuICAgICAgICBpZih0aGlzLl9zb3VyY2VOb2RlKVxuICAgICAgICAgICAgVXRpbHMubmFtZXNldC5hZGQodGhpcy5fcGFyYW1OYW1lcywgdGhpcy5fc291cmNlTm9kZS5fZ2V0UGFyYW1OYW1lcygpKTtcbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgVXRpbHMubmFtZXNldC5hZGQodGhpcy5fcGFyYW1OYW1lcywgdGhpcy5fY2hpbGRyZW5baV0uX2dldFBhcmFtTmFtZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BhcmFtTmFtZXM7XG59O1xuXG5EYXRhTm9kZS5wcm90b3R5cGUuX2dldEdsb2JhbFBhcmFtTmFtZXMgPSBmdW5jdGlvbigpe1xuICAgIGlmKCF0aGlzLl9nbG9iYWxQYXJhbU5hbWVzKXtcbiAgICAgICAgdGhpcy5fZ2xvYmFsUGFyYW1OYW1lcyA9IFtdO1xuICAgICAgICBpZih0aGlzLl9kYXRhZmxvd05vZGUpXG4gICAgICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh0aGlzLl9nbG9iYWxQYXJhbU5hbWVzLCB0aGlzLl9kYXRhZmxvd05vZGUuX2dldEdsb2JhbFBhcmFtTmFtZXMoKSk7XG5cbiAgICAgICAgaWYodGhpcy5fc291cmNlTm9kZSlcbiAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHRoaXMuX2dsb2JhbFBhcmFtTmFtZXMsIHRoaXMuX3NvdXJjZU5vZGUuX2dldEdsb2JhbFBhcmFtTmFtZXMoKSk7XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHRoaXMuX2dsb2JhbFBhcmFtTmFtZXMsIHRoaXMuX2NoaWxkcmVuW2ldLl9nZXRHbG9iYWxQYXJhbU5hbWVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9nbG9iYWxQYXJhbU5hbWVzO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge1N1YnN0aXR1dGlvbn0gc3Vic3RpdHV0aW9uXG4gKiBAcmV0dXJucyB7Q2hhbm5lbE5vZGV9XG4gKi9cbkRhdGFOb2RlLnByb3RvdHlwZS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZSA9IGZ1bmN0aW9uKHN1YnN0aXR1dGlvbil7XG4gICAgaWYoIXN1YnN0aXR1dGlvbilcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5uZWxOb2RlO1xuICAgIGVsc2V7XG4gICAgICAgIHZhciBrZXkgPSBzdWJzdGl0dXRpb24uZ2V0S2V5KHRoaXMpO1xuICAgICAgICBpZighdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXNba2V5XSkge1xuICAgICAgICAgICAgdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXNba2V5XSA9IG5ldyBDaGFubmVsTm9kZSh0aGlzLCBzdWJzdGl0dXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3Vic3RpdHV0aW9uTm9kZXNba2V5XS5pbmNyZWFzZVJlZigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdWJzdGl0dXRpb25Ob2Rlc1trZXldO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmVtb3ZlIENoYW5uZWxOb2RlIHBhc3NlZCBhcyBhcmd1bWVudCBmcm9tIGludGVybmFsIHN1YnN0aXR1dGlvbiBub2Rlc1xuICogRGVjcmVhc2VzIHJlZmVyZW5jZSBjb3VudGVyIG9mIHN1YnN0aXR1dGlvbiBub2RlIGFuZCBkZWxldGVzIGl0IGlmIG5vdFxuICogdXNlZCBieSBhbnkgb3RoZXIgbm9kZS5cbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IHN1YnN0aXR1dGlvbk5vZGVcbiAqL1xuRGF0YU5vZGUucHJvdG90eXBlLl9yZW1vdmVTdWJzdGl0dXRpb25Ob2RlID0gZnVuY3Rpb24oc3Vic3RpdHV0aW9uTm9kZSl7XG4gICAgdmFyIGtleSA9IHN1YnN0aXR1dGlvbk5vZGUuc3Vic3RpdHV0aW9uLmdldEtleSh0aGlzKTtcbiAgICBpZih0aGlzLl9zdWJzdGl0dXRpb25Ob2Rlc1trZXldICYmIHRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzW2tleV0uZGVjcmVhc2VSZWYoKSlcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnN0aXR1dGlvbk5vZGVzW2tleV07XG59O1xuXG4vKipcbiAqIENhbGxzIGNsZWFyIG9mIGFsbCBzdWJzdGl0dXRpb25Ob2RlcyBhbmQgY2xlYXJzIHRoZSBtYXBcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyU3Vic3RpdHV0aW9uTm9kZXMoZGF0YU5vZGUpe1xuICAgIGZvcih2YXIgbmFtZSBpbiBkYXRhTm9kZS5fc3Vic3RpdHV0aW9uTm9kZXMpe1xuICAgICAgICBkYXRhTm9kZS5fc3Vic3RpdHV0aW9uTm9kZXNbbmFtZV0uY2xlYXIoKTtcbiAgICB9XG4gICAgZGF0YU5vZGUuX3N1YnN0aXR1dGlvbk5vZGVzID0ge307XG59XG5cbi8qKlxuICogU2tpcHMgbm9kZXMsIGlmIGl0IGRvZXMgbm90IGNvbnRyaWJ1dGUgdG8gdGhlIHJlc3VsdCAob3B0aW1pemF0aW9uKVxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcbiAqIEBwYXJhbSB7YXJyYXkuPHN0cmluZz4/fSBmaWx0ZXJcbiAqIEByZXR1cm5zIHtEYXRhTm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0Rm9yd2FyZE5vZGUoZGF0YU5vZGUsIGZpbHRlcil7XG4gICAgdmFyIGhhc0ZpbHRlciA9IChkYXRhTm9kZS5fZmlsdGVyTWFwcGluZyAmJiAhZGF0YU5vZGUuX2ZpbHRlck1hcHBpbmcuaXNFbXB0eSgpKTtcbiAgICBpZihoYXNGaWx0ZXIpXG4gICAgICAgIHJldHVybiBkYXRhTm9kZTtcblxuICAgIGlmKCFkYXRhTm9kZS5fY29tcHV0ZU9wZXJhdG9yICl7XG4gICAgICAgIGlmKGRhdGFOb2RlLl9zb3VyY2VOb2RlICYmIGRhdGFOb2RlLl9jaGlsZHJlbi5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBnZXRGb3J3YXJkTm9kZShkYXRhTm9kZS5fc291cmNlTm9kZSk7XG4gICAgICAgIGlmKGRhdGFOb2RlLl9jaGlsZHJlbi5sZW5ndGggPT0gMSAmJiBkYXRhTm9kZS5fY2hpbGRyZW5bMF0gaW5zdGFuY2VvZiBEYXRhTm9kZSlcbiAgICAgICAgICAgIHJldHVybiBnZXRGb3J3YXJkTm9kZShkYXRhTm9kZS5fY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIHZhciBpZHggPSBkYXRhTm9kZS5fY2hhbm5lbE5vZGUuZ2V0Q2hpbGREYXRhSW5kZXgoZmlsdGVyKTtcbiAgICBpZihpZHggIT0gLTEgJiYgaWR4ICE9IHVuZGVmaW5lZCl7XG4gICAgICAgIGlmKGRhdGFOb2RlLl9zb3VyY2VOb2RlKVxuICAgICAgICAgICAgcmV0dXJuIGdldEZvcndhcmROb2RlKGRhdGFOb2RlLl9zb3VyY2VOb2RlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGdldEZvcndhcmROb2RlKGRhdGFOb2RlLl9jaGlsZHJlbltpZHhdKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFOb2RlO1xufVxuXG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIHByb2dyZXNzIGxldmVsXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtEYXRhTm9kZX0gbm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQcm9ncmVzc0xldmVsKG5vZGUpe1xuICAgIHZhciBwcm9ncmVzc0xldmVsID0gbm9kZS5fbG9hZGluZyA/IG5vZGUuX2xvYWRMZXZlbCA6IEluZmluaXR5O1xuICAgIHZhciBpO1xuXG4gICAgZm9yKGkgPSAwOyBwcm9ncmVzc0xldmVsICYmIGkgPCBub2RlLl9jaGlsZHJlbi5sZW5ndGg7ICsraSl7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGUuX2NoaWxkcmVuW2ldO1xuICAgICAgICBpZihjaGlsZCBpbnN0YW5jZW9mIERhdGFOb2RlKXtcbiAgICAgICAgICAgIHByb2dyZXNzTGV2ZWwgPSBNYXRoLm1pbihwcm9ncmVzc0xldmVsLCBNYXRoLm1heChjaGlsZC5fbG9hZExldmVsLCBjaGlsZC5fcHJvZ3Jlc3NMZXZlbCkgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmKGNoaWxkLl9kYXRhICYmIGNoaWxkLl9kYXRhLmlzTG9hZGluZyAmJiBjaGlsZC5fZGF0YS5pc0xvYWRpbmcoKSl7XG4gICAgICAgICAgICBwcm9ncmVzc0xldmVsID0gTWF0aC5taW4ocHJvZ3Jlc3NMZXZlbCwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYocHJvZ3Jlc3NMZXZlbCAmJiBub2RlLl9zb3VyY2VOb2RlKXtcbiAgICAgICAgcHJvZ3Jlc3NMZXZlbCA9IE1hdGgubWluKHByb2dyZXNzTGV2ZWwsIE1hdGgubWF4KG5vZGUuX3NvdXJjZU5vZGUuX2xvYWRMZXZlbCwgbm9kZS5fc291cmNlTm9kZS5fcHJvZ3Jlc3NMZXZlbCkpO1xuICAgIH1cbiAgICBpZihwcm9ncmVzc0xldmVsICYmIG5vZGUuX2RhdGFmbG93Tm9kZSl7XG4gICAgICAgIHByb2dyZXNzTGV2ZWwgPSBNYXRoLm1pbihwcm9ncmVzc0xldmVsLCBNYXRoLm1heChub2RlLl9kYXRhZmxvd05vZGUuX2xvYWRMZXZlbCwgbm9kZS5fZGF0YWZsb3dOb2RlLl9wcm9ncmVzc0xldmVsKSk7XG4gICAgfVxuICAgIHZhciBvbGRMZXZlbCA9IG5vZGUuX3Byb2dyZXNzTGV2ZWw7XG4gICAgbm9kZS5fcHJvZ3Jlc3NMZXZlbCA9IHByb2dyZXNzTGV2ZWw7XG5cbiAgICBpZihvbGRMZXZlbCAhPSBub2RlLl9wcm9ncmVzc0xldmVsKXtcbiAgICAgICAgbm9kZS5fY2FsbExvYWRMaXN0ZW5lcnMobm9kZS5fcHJvZ3Jlc3NMZXZlbCwgb2xkTGV2ZWwpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBub2RlLl9wYXJlbnRzLmxlbmd0aDsgKytpKVxuICAgICAgICAgICAgdXBkYXRlUHJvZ3Jlc3NMZXZlbChub2RlLl9wYXJlbnRzW2ldKTtcbiAgICB9XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gSGVscGVyc1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtEYXRhTm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge0dyYXBoTm9kZX0gY2hpbGRcbiAqL1xuZnVuY3Rpb24gYWRkUGFyZW50KHBhcmVudCwgY2hpbGQpe1xuICAgIGNoaWxkLl9wYXJlbnRzLnB1c2gocGFyZW50KTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtEYXRhTm9kZX0gcGFyZW50XG4gKiBAcGFyYW0ge0dyYXBoTm9kZX0gY2hpbGRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlUGFyZW50KHBhcmVudCwgY2hpbGQpe1xuICAgIEFycmF5LmVyYXNlKGNoaWxkLl9wYXJlbnRzLCBwYXJlbnQpO1xufVxuXG4vKipcbiAqIE5vdGlmeSBhbGwgcGFyZW50IG5vZGVzIGFib3V0IGEgY2hhbmdlXG4gKiBAcGFyYW0ge0dyYXBoTm9kZX0gbm9kZVxuICogQHBhcmFtIHtleHBvcnRzLkMuUkVTVUxUX1NUQVRFfSBjaGFuZ2VUeXBlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3RpZnlQYXJlbnRzT25DaGFuZ2VkKG5vZGUsIGNoYW5nZVR5cGUpe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBub2RlLl9wYXJlbnRzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgbm9kZS5fcGFyZW50c1tpXS5ub3RpZnkoY2hhbmdlVHlwZSwgbm9kZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgb3duZXJzIG9mIHRoZSBtYXBwaW5nc1xuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7TWFwcGluZ30gbWFwcGluZ1xuICovXG5mdW5jdGlvbiBzd2FwTWFwcGluZyhkYXRhTm9kZSwga2V5LCBtYXBwaW5nKXtcbiAgICBkYXRhTm9kZVtrZXldICYmIGRhdGFOb2RlW2tleV0uX3JlbW92ZU93bmVyKGRhdGFOb2RlKTtcbiAgICBkYXRhTm9kZVtrZXldID0gbWFwcGluZztcbiAgICBkYXRhTm9kZVtrZXldICYmIGRhdGFOb2RlW2tleV0uX2FkZE93bmVyKGRhdGFOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZU5vZGVJbkhpZXJhcmNoeShub2RlLCBmaWVsZCwgbmV3Q2hpbGQpIHtcbiAgICB2YXIgb2xkQ2hpbGQgPSBub2RlW2ZpZWxkXTtcbiAgICBpZihvbGRDaGlsZCkge1xuICAgICAgICByZW1vdmVQYXJlbnQobm9kZSwgb2xkQ2hpbGQpO1xuICAgIH1cbiAgICBub2RlW2ZpZWxkXSA9IG5ld0NoaWxkO1xuICAgIGlmKG5ld0NoaWxkKSB7XG4gICAgICAgIGFkZFBhcmVudChub2RlLCBuZXdDaGlsZCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBJbnB1dE5vZGU6IElucHV0Tm9kZSxcbiAgICBEYXRhTm9kZTogRGF0YU5vZGUsXG4gICAgZ2V0Q29tcHV0ZURhdGFmbG93VXJsOiBnZXRDb21wdXRlRGF0YWZsb3dVcmxcbn07XG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xudmFyIEMgPSByZXF1aXJlKFwiLi9jb25zdGFudHMuanNcIik7XG52YXIgRGF0YU5vZGUgPSByZXF1aXJlKFwiLi9ncmFwaC5qc1wiKS5EYXRhTm9kZTtcblxuLyoqXG4gKiBDb250ZW50IG9mIHRoaXMgZmlsZTpcbiAqIENsYXNzZXMgdG8gcmVxdWVzdCByZXN1bHRzIGZyb20gYW4gWGZsb3cgZ3JhcGguXG4gKi9cblxuLyoqXG4gKiBBYnN0cmFjdCBSZXF1ZXN0IGNsYXNzLlxuICogQW55IFJlcXVlc3QgaXMgY3JlYXRlZCBmcm9tIGEgRGF0YU5vZGUgdG8gcmVjZWl2ZSB0aGUgcmVzdWx0IG9mIHRoYXQgRGF0YU5vZGUuXG4gKiBUbyBhbGxvdyBlZmZlY3RpdmUgb3B0aW1pemF0aW9uLCBpdCBpcyByZWNvbW1lbmRlZCB0byBjcmVhdGUgb25seSBvbmUgUmVxdWVzdCBwZXIgRGF0YU5vZGUgYW5kIHJlY2VpdmUgYWxsXG4gKiByZXN1bHRzIHRocm91Z2ggdGhhdCBSZXF1ZXN0LlxuICogQGFic3RyYWN0XG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBkYXRhTm9kZSBUaGUgRGF0YU5vZGUgZnJvbSB3aGljaCB0byByZXF1ZXN0IHJlc3VsdHNcbiAqIEBwYXJhbSB7P0FycmF5LjxzdHJpbmc+fSBmaWx0ZXIgQSBsaXN0IG9mIG5hbWVzIGZpbHRlcmluZyB0aGUgdmFsdWVzIHRvIGJlIHJlY2VpdmVkIChvbmx5IHJldHVybiB2YWx1ZXMgd2l0aCBuYW1lcyBpbnNpZGUgdGhlIGZpbHRlcilcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbmV2ZXIgdGhlIHJlc3VsdCBvZiB0aGUgUmVxdWVzdCBjaGFuZ2VzXG4gKi9cbnZhciBSZXF1ZXN0ID0gZnVuY3Rpb24oZGF0YU5vZGUsIGZpbHRlciwgY2FsbGJhY2spe1xuICAgIHRoaXMuX2RhdGFOb2RlID0gZGF0YU5vZGU7XG4gICAgdGhpcy5fZmlsdGVyID0gZmlsdGVyID8gZmlsdGVyLnNsaWNlKCkuc29ydCgpIDogbnVsbDtcbiAgICB0aGlzLl9saXN0ZW5lciA9IGNhbGxiYWNrO1xuXG4gICAgLyoqXG4gICAgICogQ2FjaGVkIHJlc3VsdCBvZiB0aGlzIHJlcXVlc3RcbiAgICAgKiBAdHlwZSB7UmVzdWx0fVxuICAgICAqL1xuICAgIHRoaXMuX3Jlc3VsdCA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgY2FsbGJhY2sgZnVuY3Rpb24gYXR0YWNoZWQgdG8gZGF0YSBub2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9kYXRhTm9kZUxpc3RlbmVyID0gdGhpcy5fb25EYXRhTm9kZUNoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fZGF0YU5vZGUuYWRkTGlzdGVuZXIodGhpcy5fZGF0YU5vZGVMaXN0ZW5lcik7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVxdWVzdC5wcm90b3R5cGUsIFwiZGF0YU5vZGVcIiwge1xuICAgIHNldDogZnVuY3Rpb24oKXtcbiAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkYXRhTm9kZSBpcyByZWFkb25seVwiKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX2RhdGFOb2RlOyB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlcXVlc3QucHJvdG90eXBlLCBcImZpbHRlclwiLCB7XG4gICAgc2V0OiBmdW5jdGlvbigpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWx0ZXIgaXMgcmVhZC1vbmx5XCIpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5fZmlsdGVyOyB9XG59KTtcblxuLyoqXG4gKiBDYWxsIHRoaXMgZnVuY3Rpb24sIHdoZW5ldmVyIHRoZSByZXF1ZXN0IGlzIG5vdCByZXF1aXJlZCBhbnltb3JlLlxuICogQ2xlYW5zIHVwIGNhY2hlZCBkYXRhIGFuZCBsaXN0ZW5lcnNcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuX2xpc3RlbmVyID0gbnVsbDtcbiAgICBpZih0aGlzLl9yZXN1bHQpIHRoaXMuX3Jlc3VsdC5fcmVtb3ZlUmVxdWVzdCh0aGlzKTtcbiAgICB0aGlzLl9kYXRhTm9kZS5yZW1vdmVMaXN0ZW5lcih0aGlzLl9kYXRhTm9kZUxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtDLlJFU1VMVF9TVEFURX0gZGF0YVxuICogQHByaXZhdGVcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX29uUG9zdHBvbmVkUmVzdWx0Q2hhbmdlZCA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHRoaXMuX2xpc3RlbmVyICYmIHRoaXMuX2xpc3RlbmVyKHRoaXMsIGRhdGEpO1xufTtcblxuLyoqXG4gKiBDaGFuZ2UgdGhlIHJlc3VsdCBvZiB0aGUgcmVxdWVzdCBhbmQgdXBkYXRlIHJlcXVlc3QgbGlzdCBvZiBvbGQgYW5kIG5ld1xuICogcmVzdWx0LlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UmVxdWVzdH0gcmVxdWVzdFxuICogQHBhcmFtIHtSZXN1bHQ/fSBuZXdSZXN1bHRcbiAqIEByZXR1cm5zIHtSZXN1bHR9XG4gKi9cbmZ1bmN0aW9uIHN3YXBSZXN1bHRSZXF1ZXN0KHJlcXVlc3QsIG5ld1Jlc3VsdCl7XG4gICAgaWYocmVxdWVzdC5fcmVzdWx0KSByZXF1ZXN0Ll9yZXN1bHQuX3JlbW92ZVJlcXVlc3QocmVxdWVzdCk7XG4gICAgcmVxdWVzdC5fcmVzdWx0ID0gbmV3UmVzdWx0O1xuICAgIGlmKG5ld1Jlc3VsdCkgbmV3UmVzdWx0Ll9hZGRSZXF1ZXN0KHJlcXVlc3QpO1xuICAgIHJldHVybiBuZXdSZXN1bHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZXF1ZXN0fSByZXF1ZXN0XG4gKiBAcGFyYW0ge0MuUkVTVUxUX1NUQVRFfSBub3RpZmljYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeUxpc3RlbmVycyhyZXF1ZXN0LCBub3RpZmljYXRpb24pe1xuICAgIEJhc2UuX3F1ZXVlUmVzdWx0Q2FsbGJhY2socmVxdWVzdCwgbm90aWZpY2F0aW9uKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0MuUkVTVUxUX1NUQVRFfSBub3RpZmljYXRpb25cbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX29uRGF0YU5vZGVDaGFuZ2UgPSBmdW5jdGlvbihub3RpZmljYXRpb24pe1xuICAgIG5vdGlmeUxpc3RlbmVycyh0aGlzLCBub3RpZmljYXRpb24pO1xufTtcblxuLyoqXG4gKiBBIENvbXB1dGVSZXF1ZXN0IGlzIGEgUmVxdWVzdCBmb3IgYSBDb21wdXRlUmVzdWx0LCB3aGljaCBjb250YWlucyBhIG5hbWVkIG1hcCBvZiB0eXBlZCB2YWx1ZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtSZXF1ZXN0fVxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGUgVGhlIERhdGFOb2RlIGZyb20gd2hpY2ggdG8gcmVxdWVzdCByZXN1bHRzXG4gKiBAcGFyYW0gez9BcnJheS48c3RyaW5nPn0gZmlsdGVyIEEgbGlzdCBvZiBuYW1lcyBmaWx0ZXJpbmcgdGhlIHZhbHVlcyB0byBiZSByZWNlaXZlZCAob25seSByZXR1cm4gdmFsdWVzIHdpdGggbmFtZXMgaW5zaWRlIHRoZSBmaWx0ZXIpXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW5ldmVyIHRoZSByZXN1bHQgb2YgdGhlIFJlcXVlc3QgY2hhbmdlc1xuICovXG52YXIgQ29tcHV0ZVJlcXVlc3QgPSBmdW5jdGlvbihkYXRhTm9kZSwgZmlsdGVyLCBjYWxsYmFjayl7XG4gICAgUmVxdWVzdC5jYWxsKHRoaXMsIGRhdGFOb2RlLCBmaWx0ZXIsIGNhbGxiYWNrKTtcbn07XG5CYXNlLmNyZWF0ZUNsYXNzKENvbXB1dGVSZXF1ZXN0LCBSZXF1ZXN0KTtcblxuLyoqXG4gKiBAcmV0dXJucyB7UmVzdWx0fVxuICovXG5Db21wdXRlUmVxdWVzdC5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKXtcbiAgICAvLyBzd2FwUmVzdWx0UmVxdWVzdCBpcyBjYWxsZWQgaGVyZSBiZWNhdXNlIHRoZSByZXN1bHQgb2JqZWN0IG9mIHRoZSByZXF1ZXN0IG1heSBjaGFuZ2UsIGUuZy5cbiAgICAvLyBkaWZmZXJlbnQgZm9yd2FyZCBub2RlLlxuICAgIHJldHVybiBzd2FwUmVzdWx0UmVxdWVzdCh0aGlzLCB0aGlzLl9kYXRhTm9kZS5fZ2V0UmVzdWx0KEMuUkVTVUxUX1RZUEUuQ09NUFVURSwgdGhpcy5fZmlsdGVyKSk7XG59O1xuXG5Db21wdXRlUmVxdWVzdC5wcm90b3R5cGUuX29uUmVzdWx0Q2hhbmdlZCA9IGZ1bmN0aW9uKG5vdGlmaWNhdGlvbil7XG4gICAgdGhpcy5fb25EYXRhTm9kZUNoYW5nZShub3RpZmljYXRpb24pO1xufTtcblxuXG52YXIgY192c0Nvbm5lY3ROb2RlQ291bnQgPSB7fSxcbiAgICBjX3ZzQ29ubmVjdE5vZGVLZXkgPSB7fSxcbiAgICBjX3ZzQ29ubmVjdE5vZGVDYWNoZSA9IHt9O1xuXG4vKipcbiAqIEEgVmVydGV4U2hhZGVyUmVxdWVzdCBpcyBhIFJlcXVlc3QgZm9yIGEgVlNEYXRhUmVzdWx0LCB1c2VkIHRvIGdlbmVyYXRlIGEgVmVydGV4U2hhZGVyIHRoYXQgaW5jbHVkZXNcbiAqIGRhdGFmbG93IHByb2Nlc3NpbmcuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtSZXF1ZXN0fVxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YU5vZGVcbiAqIEBwYXJhbSB7VlNDb25maWd9IHZzQ29uZmlnIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBvdXRwdXQgb2YgdGhlIGdlbmVyYXRlZCB2ZXJ0ZXggc2hhZGVyXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQSBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW5ldmVyIHRoZSByZXN1bHQgb2YgdGhlIFJlcXVlc3QgY2hhbmdlc1xuICovXG52YXIgVmVydGV4U2hhZGVyUmVxdWVzdCA9IGZ1bmN0aW9uKGRhdGFOb2RlLCB2c0NvbmZpZywgY2FsbGJhY2spe1xuICAgIHZhciBmaWx0ZXIgPSB2c0NvbmZpZy5nZXRGaWx0ZXIoKTtcbiAgICBpZihmaWx0ZXIubGVuZ3RoID09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInZzQ29uZmlnIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSBhdHRyaWJ1dGUgZW50cnkuXCIpO1xuICAgIFJlcXVlc3QuY2FsbCh0aGlzLCBkYXRhTm9kZSwgZmlsdGVyLCBjYWxsYmFjayk7XG4gICAgdGhpcy5fdnNDb25maWcgPSB2c0NvbmZpZztcbiAgICB0aGlzLl92c0Nvbm5lY3ROb2RlID0gZ2V0VnNDb25uZWN0Tm9kZShkYXRhTm9kZSwgdnNDb25maWcpO1xufTtcbkJhc2UuY3JlYXRlQ2xhc3MoVmVydGV4U2hhZGVyUmVxdWVzdCwgUmVxdWVzdCk7XG5cblZlcnRleFNoYWRlclJlcXVlc3QucHJvdG90eXBlLmdldENvbmZpZyA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuX3ZzQ29uZmlnO1xufTtcblxuLyoqXG4gKiBAc2VlIENvbXB1dGVSZXF1ZXN0LmdldFJlc3VsdFxuICogQHJldHVybnMge1Jlc3VsdH1cbiAqL1xuVmVydGV4U2hhZGVyUmVxdWVzdC5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gc3dhcFJlc3VsdFJlcXVlc3QodGhpcywgdGhpcy5fdnNDb25uZWN0Tm9kZS5fZ2V0UmVzdWx0KEMuUkVTVUxUX1RZUEUuVlMsIHRoaXMuX2ZpbHRlcikpO1xufTtcblxuVmVydGV4U2hhZGVyUmVxdWVzdC5wcm90b3R5cGUuX29uRGF0YU5vZGVDaGFuZ2UgPSBmdW5jdGlvbihub3RpZmljYXRpb24pe1xuICAgIGlmKG5vdGlmaWNhdGlvbiA9PSBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSl7XG4gICAgICAgIHZhciBuZXdWU0Nvbm5lY3RlZE5vZGUgPSBnZXRWc0Nvbm5lY3ROb2RlKHRoaXMuX2RhdGFOb2RlLCB0aGlzLl92c0NvbmZpZywgdGhpcy5fZmlsdGVyKTtcbiAgICAgICAgaWYobmV3VlNDb25uZWN0ZWROb2RlICE9IHRoaXMuX3ZzQ29ubmVjdE5vZGUpe1xuICAgICAgICAgICAgY2xlYXJWc0Nvbm5lY3ROb2RlKHRoaXMuX3ZzQ29ubmVjdE5vZGUpO1xuICAgICAgICAgICAgdGhpcy5fdnNDb25uZWN0Tm9kZSA9IG5ld1ZTQ29ubmVjdGVkTm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5fb25EYXRhTm9kZUNoYW5nZS5jYWxsKHRoaXMsIG5vdGlmaWNhdGlvbik7XG59O1xuXG5WZXJ0ZXhTaGFkZXJSZXF1ZXN0LnByb3RvdHlwZS5nZXRWZXJ0ZXhTaGFkZXIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuZ2V0UmVzdWx0KCk7IC8vIFVwZGF0ZSB0aGUgcmVzdWx0IGZpcnN0XG4gICAgaWYoIXRoaXMuX3ZlcnRleFNoYWRlcil7XG4gICAgICAgIHRoaXMuX3ZlcnRleFNoYWRlciA9IHRoaXMuX3Jlc3VsdC5nZXRWZXJ0ZXhTaGFkZXIodGhpcy5fdnNDb25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmVydGV4U2hhZGVyO1xufTtcblxuVmVydGV4U2hhZGVyUmVxdWVzdC5wcm90b3R5cGUuX29uUmVzdWx0Q2hhbmdlZCA9IGZ1bmN0aW9uKG5vdGlmaWNhdGlvbil7XG4gICAgdGhpcy5fb25EYXRhTm9kZUNoYW5nZShub3RpZmljYXRpb24pO1xufTtcblxuZnVuY3Rpb24gZ2V0VnNDb25uZWN0Tm9kZShkYXRhTm9kZSwgdnNDb25maWcsIGZpbHRlcil7XG4gICAgdmFyIGZvcndhcmROb2RlID0gZGF0YU5vZGUuX2dldEZvcndhcmROb2RlKGZpbHRlcik7XG5cbiAgICB2YXIga2V5ID0gZ2V0RGF0YU5vZGVTaGFkZXJLZXkoZm9yd2FyZE5vZGUsIHZzQ29uZmlnKTtcbiAgICB2YXIgY29ubmVjdE5vZGU7XG4gICAgaWYoIShjb25uZWN0Tm9kZSA9IGNfdnNDb25uZWN0Tm9kZUNhY2hlW2tleV0pKXtcbiAgICAgICAgY29ubmVjdE5vZGUgPSBuZXcgRGF0YU5vZGUoZmFsc2UpO1xuICAgICAgICBjb25uZWN0Tm9kZS5hcHBlbmRDaGlsZChmb3J3YXJkTm9kZSk7XG5cbiAgICAgICAgY29ubmVjdE5vZGUuY29tcHV0ZU9wZXJhdG9yID0gdnNDb25maWcuZ2V0T3BlcmF0b3IoKTtcbiAgICAgICAgY29ubmVjdE5vZGUuY29tcHV0ZUlucHV0TWFwcGluZyA9IG51bGw7XG4gICAgICAgIGNvbm5lY3ROb2RlLmNvbXB1dGVPdXRwdXRNYXBwaW5nID0gbnVsbDtcblxuICAgICAgICBjX3ZzQ29ubmVjdE5vZGVDYWNoZVtrZXldID0gY29ubmVjdE5vZGU7XG4gICAgICAgIGNfdnNDb25uZWN0Tm9kZUNvdW50W2Nvbm5lY3ROb2RlLmlkXSA9IDE7XG4gICAgICAgIGNfdnNDb25uZWN0Tm9kZUtleVtjb25uZWN0Tm9kZS5pZF0gPSBrZXk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIGNfdnNDb25uZWN0Tm9kZUNvdW50W2Nvbm5lY3ROb2RlLmlkXSsrO1xuICAgIH1cblxuICAgIHJldHVybiBjb25uZWN0Tm9kZTtcbn1cblxuZnVuY3Rpb24gY2xlYXJWc0Nvbm5lY3ROb2RlKGNvbm5lY3ROb2RlKXtcbiAgICBjX3ZzQ29ubmVjdE5vZGVDb3VudFtjb25uZWN0Tm9kZS5pZF0tLTtcbiAgICBpZighY192c0Nvbm5lY3ROb2RlQ291bnRbY29ubmVjdE5vZGUuaWRdKXtcbiAgICAgICAgdmFyIGtleSA9IGNfdnNDb25uZWN0Tm9kZUtleVtjb25uZWN0Tm9kZS5pZF07XG4gICAgICAgIGNfdnNDb25uZWN0Tm9kZUNhY2hlW2tleV0gPSBudWxsO1xuICAgICAgICBjb25uZWN0Tm9kZS5jbGVhckNoaWxkcmVuKCk7XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIGdldERhdGFOb2RlU2hhZGVyS2V5KGRhdGFOb2RlLCB2c0NvbmZpZyl7XG4gICAgcmV0dXJuIGRhdGFOb2RlLmlkICsgXCJ8XCIgKyB2c0NvbmZpZy5nZXRLZXkoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ29tcHV0ZVJlcXVlc3Q6ICBDb21wdXRlUmVxdWVzdCxcbiAgICBWZXJ0ZXhTaGFkZXJSZXF1ZXN0OiBWZXJ0ZXhTaGFkZXJSZXF1ZXN0XG59O1xuIiwidmFyIEMgPXJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xuXG4vKipcbiAqIENMUHJvZ3JhbSBpbXBsZW1lbnRzIGF1dG9tYXRpYyBYZmxvdyBpbnB1dC9vdXRwdXQgYWRhcHRpdmUgV2ViQ0wga2VybmVsIGFuZCBhcHBsaWNhdGlvbiBjb2RlIGdlbmVyYXRpb24uXG4gKlxuICogQHBhcmFtIG9wZXJhdG9yTGlzdFxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxudmFyIENMUHJvZ3JhbSA9IGZ1bmN0aW9uIChvcGVyYXRvckxpc3QpIHtcbiAgICB0aGlzLmNsID0gWE1MM0Qud2ViY2wuY2w7IC8vIENMIHdyYXBwZXJcblxuICAgIGlmICghdGhpcy5jbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5saXN0ID0gb3BlcmF0b3JMaXN0O1xuICAgIHRoaXMuZW50cnkgPSBvcGVyYXRvckxpc3QuZW50cmllc1swXTtcbiAgICB0aGlzLm9wZXJhdG9yID0gdGhpcy5lbnRyeS5vcGVyYXRvcjtcblxuICAgIHRoaXMua2VybmVsUGFyYW1NYXAgPSB7aW5wdXRzOiBbXSwgb3V0cHV0czogW119OyAvLyBTdG9yZXMgaW5pdGlhbGlzZWQgS2VybmVsUGFyYW0gb2JqZWN0c1xuICAgIHRoaXMua2VybmVsRnVuY3Rpb25QYXJhbXMgPSBbXTsgLy8gU3RvcmVzIGdlbmVyYXRlZCBmdW5jdGlvbiBwYXJhbWV0ZXJzIGZvciBrZXJuZWwgZnVuY3Rpb24gaGVhZGVyLlxuICAgIHRoaXMua2VybmVsQ29kZSA9IG51bGw7IC8vIEdlbmVyYXRlZCBrZXJuZWwgY29kZVxuICAgIHRoaXMua2VybmVsUHJvZ3JhbSA9IG51bGw7IC8vIENvbXBpbGVkIGtlcm5lbCBwcm9ncmFtXG4gICAgdGhpcy5tYWluUHJvZ3JhbSA9IG51bGw7IC8vIE1haW4gV2ViQ0wgYXBwbGljYXRpb24gY29kZVxuXG59O1xuXG4vKipcbiAqIE1hcCBvZiBoZWxwZXIga2VybmVsIHBhcmFtZXRlcnMgcmVxdWlyZWQgZm9yIGNlcnRhaW4gaW5wdXQgZGF0YSB0eXBlcy5cbiAqXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xudmFyIGhlbHBlclBhcmFtTWFwID0ge1xuICAgICd0ZXh0dXJlJzoge3R5cGU6IFwidWludFwiLCBwYXJhbXM6IFtcIndpZHRoXCIsIFwiaGVpZ2h0XCJdfSwgJ2J1ZmZlcic6IHt0eXBlOiBcInVpbnRcIiwgcGFyYW1zOiBbXCJsZW5ndGhcIl19XG59O1xuXG4vKipcbiAqIFV0aWxpdHkgcHJvdG90eXBlIG9iamVjdCBmb3IgbWFwcGluZyBYZmxvdyBpbnB1dHMgdG8ga2VybmVsIHBhcmFtZXRlcnMgYW5kIGZvciBnZW5lcmF0aW5nIGtlcm5lbCBjb2RlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9ncmFtXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtDLkRBVEFfVFlQRX0geGZsb3dUeXBlXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xUeXBlXG4gKiBAcGFyYW0gZW50cnlWYWx1ZVxuICogQHBhcmFtIHtCb29sZWFuP30gaXNJbnB1dFxuICogQG5hbWUgS2VybmVsUGFyYW1cbiAqIEBjb25zdHJ1Y3RvciBLZXJuZWxQYXJhbVxuICovXG5cbmZ1bmN0aW9uIEtlcm5lbFBhcmFtKHByb2dyYW0sIG5hbWUsIHhmbG93VHlwZSwgY2xUeXBlLCBlbnRyeVZhbHVlLCBpc0lucHV0KSB7XG4gICAgdGhpcy5wcm9ncmFtID0gcHJvZ3JhbTtcbiAgICB0aGlzLmNsID0gcHJvZ3JhbS5jbDtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IGNsVHlwZSB8fCBudWxsO1xuICAgIHRoaXMuaXNJbnB1dCA9ICEhaXNJbnB1dDtcbiAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gZmFsc2U7XG4gICAgdGhpcy5oYXNNZW1PYmplY3QgPSBmYWxzZTtcbiAgICB0aGlzLmJ5dGVTaXplID0gbnVsbDtcbiAgICB0aGlzLm1lbU9iamVjdFNpemUgPSBudWxsO1xuICAgIHRoaXMuYXJnID0gbnVsbDtcbiAgICB0aGlzLmNsRnVuY3Rpb25QYXJhbSA9IG51bGw7XG4gICAgdGhpcy54Zmxvd1R5cGUgPSB4Zmxvd1R5cGU7XG4gICAgdGhpcy5oZWxwZXJNYXAgPSBudWxsO1xuICAgIHRoaXMuaGVscGVycyA9IFtdO1xuICAgIHRoaXMuZW50cnlWYWx1ZSA9IGVudHJ5VmFsdWUgfHwgbnVsbDtcbiAgICB0aGlzLnZhbCA9IG51bGw7XG5cbiAgICB0aGlzLnByZXBhcmVQYXJhbSgpO1xuICAgIHRoaXMuaW5pdEhlbHBlclBhcmFtcygpO1xuICAgIHRoaXMuaW5pdEtlcm5lbEFyZygpO1xuICAgIHRoaXMudXBkYXRlVmFsdWUodGhpcy5lbnRyeVZhbHVlKTtcblxufVxuXG5LZXJuZWxQYXJhbS5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgdGhlIGtlcm5lbCBwYXJhbWV0ZXIgZGF0YS5cbiAgICAgKiBNYXBzIHRoZSBpbnB1dCB4ZmxvdyBkYXRhIHR5cGUgdG8gd2ViY2wgZGF0YSB0eXBlIGFuZCBjcmVhdGVzIGEga2VybmVsIGZ1bmN0aW9uIGhlYWRlciBwYXJhbWV0ZXIgd2l0aCBwcm9wZXJcbiAgICAgKiBkZWNsYXJhdGlvbnMuXG4gICAgICovXG4gICAgcHJlcGFyZVBhcmFtOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoZWxwZXJNYXA7XG4gICAgICAgIHZhciB4Zmxvd0RhdGFUeXBlcyA9IEMuREFUQV9UWVBFO1xuICAgICAgICB2YXIga2VybmVsRnVuY1BhcmFtID0gW107XG4gICAgICAgIHZhciBhZGRyZXNzU3BhY2UgPSAnJztcbiAgICAgICAgdmFyIGRlY2xhcmF0aW9ucyA9ICcnO1xuXG4gICAgICAgIGlmICghdGhpcy50eXBlKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMueGZsb3dUeXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSB4Zmxvd0RhdGFUeXBlcy5URVhUVVJFOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyTWFwID0gaGVscGVyUGFyYW1NYXAudGV4dHVyZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJ1Y2hhcjQqXCI7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NTcGFjZSA9IFwiX19nbG9iYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc01lbU9iamVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHhmbG93RGF0YVR5cGVzLklOVDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiaW50XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHhmbG93RGF0YVR5cGVzLklOVDQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXJNYXAgPSBoZWxwZXJQYXJhbU1hcC5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiaW50NCpcIjtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1NwYWNlID0gXCJfX2dsb2JhbFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgeGZsb3dEYXRhVHlwZXMuRkxPQVQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImZsb2F0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHhmbG93RGF0YVR5cGVzLkZMT0FUMjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlck1hcCA9IGhlbHBlclBhcmFtTWFwLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJmbG9hdDIqXCI7XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3NTcGFjZSA9IFwiX19nbG9iYWxcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc01lbU9iamVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIHhmbG93RGF0YVR5cGVzLkZMT0FUMzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlck1hcCA9IGhlbHBlclBhcmFtTWFwLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50eXBlID0gXCJmbG9hdCpcIjtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1NwYWNlID0gXCJfX2dsb2JhbFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgeGZsb3dEYXRhVHlwZXMuRkxPQVQ0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyTWFwID0gaGVscGVyUGFyYW1NYXAuYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnR5cGUgPSBcImZsb2F0NCpcIjtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1NwYWNlID0gXCJfX2dsb2JhbFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgeGZsb3dEYXRhVHlwZXMuRkxPQVQ0WDQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXJNYXAgPSBoZWxwZXJQYXJhbU1hcC5idWZmZXI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHlwZSA9IFwiZmxvYXQxNipcIjtcbiAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1NwYWNlID0gXCJfX2dsb2JhbFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5lZWRzTWVtT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5oZWxwZXJNYXAgPSBoZWxwZXJNYXA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBcnJhbmdpbmcgcGFyYW1ldGVyIHBhcnRzXG4gICAgICAgIGlmIChhZGRyZXNzU3BhY2UpIHtcbiAgICAgICAgICAgIGtlcm5lbEZ1bmNQYXJhbS5wdXNoKGFkZHJlc3NTcGFjZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0lucHV0KSB7XG4gICAgICAgICAgICBkZWNsYXJhdGlvbnMgPSAnY29uc3QnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlY2xhcmF0aW9ucykge1xuICAgICAgICAgICAga2VybmVsRnVuY1BhcmFtLnB1c2goZGVjbGFyYXRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtlcm5lbEZ1bmNQYXJhbS5wdXNoKHRoaXMudHlwZSk7XG4gICAgICAgIGtlcm5lbEZ1bmNQYXJhbS5wdXNoKHRoaXMubmFtZSk7XG4gICAgICAgIHRoaXMuY2xGdW5jdGlvblBhcmFtID0ga2VybmVsRnVuY1BhcmFtLmpvaW4oJyAnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZXMgaGVscGVyIHBhcmFtZXRlcnMgZm9yIGFuIGlucHV0IHBhcmFtZXRlciBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKi9cblxuICAgIGluaXRIZWxwZXJQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhlbHBlclZhbDtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgaGVscGVyTWFwID0gdGhpcy5oZWxwZXJNYXA7XG5cbiAgICAgICAgaWYgKGhlbHBlck1hcCAmJiB0aGlzLmlzSW5wdXQpIHtcbiAgICAgICAgICAgIGhlbHBlck1hcC5wYXJhbXMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICAgICAgICAgIHZhciBwTmFtZSA9IHNlbGYubmFtZSArICdfJyArIHA7XG4gICAgICAgICAgICAgICAgaWYgKHAgPT09IFwid2lkdGhcIikge1xuICAgICAgICAgICAgICAgICAgICBoZWxwZXJWYWwgPSBzZWxmLmVudHJ5VmFsdWUud2lkdGg7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcImhlaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlclZhbCA9IHNlbGYuZW50cnlWYWx1ZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGhlbHBlclZhbCA9IHNlbGYuZW50cnlWYWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gc2VsZi54Zmxvd1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDI6XG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVscGVyVmFsID0gaGVscGVyVmFsIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQzOlxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlbHBlclZhbCA9IGhlbHBlclZhbCAvIDM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuSU5UNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJWYWwgPSBoZWxwZXJWYWwgLyA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDRYNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWxwZXJWYWwgPSBoZWxwZXJWYWwgLyAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5oZWxwZXJzLnB1c2gobmV3IEtlcm5lbFBhcmFtKHNlbGYucHJvZ3JhbSwgcE5hbWUsIG51bGwsIGhlbHBlck1hcC50eXBlLCBuZXcgVWludDMyQXJyYXkoW2hlbHBlclZhbF0pKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlcyBrZXJuZWwgYXJndW1lbnQgdGhhdCB3aWxsIGJlIHBhc3NlZCBkaXJlY3RseSBpbnRvIHRoZSBjb21waWxlZCBrZXJuZWwuXG4gICAgICogQ3JlYXRlcyBhIFdlYkNMIG1lbW9yeSBvYmplY3QgaWYgbmVlZGVkIChlLmcuIGZvciB0ZXh0dXJlKS5cbiAgICAgKi9cblxuICAgIGluaXRLZXJuZWxBcmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubmVlZHNNZW1PYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuYWxsb2NhdGVNZW1PYmplY3QoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXJnID0gdGhpcy5lbnRyeVZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGFsbG9jYXRlTWVtT2JqZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjbEFQSSA9IHRoaXMuY2wuQVBJO1xuICAgICAgICB2YXIgY2xDdHggPSB0aGlzLmNsLmN0eDtcbiAgICAgICAgdmFyIHBhcmFtVHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdmFyIGJ5dGVTaXplID0gcGFyc2VJbnQocGFyYW1UeXBlLnN1YnN0cmluZyhwYXJhbVR5cGUubGVuZ3RoIC0gMiwgcGFyYW1UeXBlLmxlbmd0aCAtIDEpLCAxMCk7XG4gICAgICAgIHZhciBtZW1PYmplY3RNb2RlID0gdGhpcy5pc0lucHV0ID8gJ3InIDogJ3cnO1xuICAgICAgICB2YXIgZW50cnlWYWx1ZSA9IHRoaXMuZW50cnlWYWx1ZTtcbiAgICAgICAgdmFyIG1lbU9iamVjdFNpemUsIG1lbU9iamVjdDtcblxuICAgICAgICBpZiAodGhpcy5oYXNNZW1PYmplY3QpIHtcbiAgICAgICAgICAgIHRoaXMuYXJnLnJlbGVhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYnl0ZVNpemUgPSBpc05hTihieXRlU2l6ZSkgPyAxIDogYnl0ZVNpemU7XG5cbiAgICAgICAgaWYgKHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5URVhUVVJFKSB7IC8vIFRleHR1cmUgaXMgYSBzcGVjaWFsIGNhc2VcbiAgICAgICAgICAgIG1lbU9iamVjdFNpemUgPSBlbnRyeVZhbHVlLndpZHRoICogZW50cnlWYWx1ZS5oZWlnaHQgKiBieXRlU2l6ZTtcbiAgICAgICAgICAgIHRoaXMuYnl0ZVNpemUgPSA0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLnhmbG93VHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuSU5UNDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG1lbU9iamVjdFNpemUgPSBlbnRyeVZhbHVlLmxlbmd0aCAqIEludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMjpcbiAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMzpcbiAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNDpcbiAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNHg0OlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtT2JqZWN0U2l6ZSA9IGVudHJ5VmFsdWUubGVuZ3RoICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgbWVtT2JqZWN0U2l6ZSA9IGVudHJ5VmFsdWUubGVuZ3RoICogNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBtZW1PYmplY3QgPSBjbEFQSS5jcmVhdGVCdWZmZXIobWVtT2JqZWN0U2l6ZSwgbWVtT2JqZWN0TW9kZSwgY2xDdHgpO1xuXG4gICAgICAgIHRoaXMubWVtT2JqZWN0U2l6ZSA9IG1lbU9iamVjdFNpemU7XG4gICAgICAgIHRoaXMuYXJnID0gbWVtT2JqZWN0O1xuXG4gICAgICAgIHRoaXMuaGFzTWVtT2JqZWN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uZWVkc01lbU9iamVjdCA9IGZhbHNlO1xuXG4gICAgfSxcblxuICAgIHVwZGF0ZVZhbHVlOiBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzTWVtT2JqZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnZhbCA9IGVudHJ5LmRhdGEgPT09IHVuZGVmaW5lZCA/IGVudHJ5IDogZW50cnkuZGF0YTtcbiAgICAgICAgICAgIHRoaXMuZW50cnlWYWx1ZSA9IGVudHJ5O1xuICAgICAgICAgICAgdGhpcy5jaGVja0VudHJ5U2l6ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hcmcgPSB0aGlzLmVudHJ5VmFsdWUgPSBlbnRyeTtcbiAgICAgICAgfVxuICAgIH0sIHVwZGF0ZUhlbHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhlbHBlcnMgPSB0aGlzLmhlbHBlcnM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICBoZWxwZXJzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICAgIHZhciBuYW1lID0gcC5uYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUuaW5kZXhPZihcIndpZHRoXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHAudXBkYXRlVmFsdWUobmV3IFVpbnQzMkFycmF5KFtzZWxmLmVudHJ5VmFsdWUud2lkdGhdKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5hbWUuaW5kZXhPZihcImhlaWdodFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBwLnVwZGF0ZVZhbHVlKG5ldyBVaW50MzJBcnJheShbc2VsZi5lbnRyeVZhbHVlLmhlaWdodF0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmFtZS5pbmRleE9mKFwibGVuZ3RoXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBzZWxmLmVudHJ5VmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmLnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuRkxPQVQ0IHx8IHNlbGYueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5JTlQ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbiA9IGxlbiAvIDQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzZWxmLnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuRkxPQVQ0WDQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gbGVuIC8gMTY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAudXBkYXRlVmFsdWUobmV3IFVpbnQzMkFycmF5KFtsZW5dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sIGNoZWNrRW50cnlTaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdTaXplO1xuICAgICAgICB2YXIgZW50cnlWYWwgPSB0aGlzLmVudHJ5VmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5URVhUVVJFKSB7XG4gICAgICAgICAgICBuZXdTaXplID0gZW50cnlWYWwud2lkdGggKiBlbnRyeVZhbC5oZWlnaHQgKiB0aGlzLmJ5dGVTaXplO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5GTE9BVDIgfHwgdGhpcy54Zmxvd1R5cGUgPT09IEMuREFUQV9UWVBFLkZMT0FUMyB8fCB0aGlzLnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuRkxPQVQ0IHx8IHRoaXMueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5GTE9BVDRYNCkge1xuICAgICAgICAgICAgbmV3U2l6ZSA9IGVudHJ5VmFsLmxlbmd0aCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVDtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnhmbG93VHlwZSA9PT0gQy5EQVRBX1RZUEUuSU5UNCkge1xuICAgICAgICAgICAgbmV3U2l6ZSA9IGVudHJ5VmFsLmxlbmd0aCAqIEludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdTaXplID0gZW50cnlWYWwubGVuZ3RoICogdGhpcy5ieXRlU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tZW1PYmplY3RTaXplICE9PSBuZXdTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmFsbG9jYXRlTWVtT2JqZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhlbHBlcnMoKTtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbS5tYWluUHJvZ3JhbSA9IG51bGw7IC8vIEZvcmNpbmcgQ0wgYXBwbGljYXRpb24gcHJvZ3JhbSB1cGRhdGVcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBSdW5zIENMUHJvZ3JhbS4gV2ViQ0wgcmVsYXRlZCBjb2RlIGluaXRpYWxpc2VkIGluIHRoZSBmaXJzdCBydW4uXG4gKlxuICogQHBhcmFtIHByb2dyYW1EYXRhXG4gKi9cblxuQ0xQcm9ncmFtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAocHJvZ3JhbURhdGEpIHtcbiAgICB2YXIgb3BlcmF0b3JEYXRhID0gcHJlcGFyZU9wZXJhdG9yRGF0YSh0aGlzLmxpc3QsIDAsIHByb2dyYW1EYXRhKTtcblxuICAgIGFwcGx5RGVmYXVsdE9wZXJhdGlvbih0aGlzLmVudHJ5LCBwcm9ncmFtRGF0YSwgb3BlcmF0b3JEYXRhLCB0aGlzKTtcblxufTtcblxuZnVuY3Rpb24gcHJlcGFyZU9wZXJhdG9yRGF0YShsaXN0LCBpZHgsIHByb2dyYW1EYXRhKSB7XG4gICAgdmFyIGRvSXRlcmF0ZSwgaTtcbiAgICB2YXIgZGF0YSA9IHByb2dyYW1EYXRhLm9wZXJhdG9yRGF0YVswXTtcbiAgICB2YXIgZW50cnkgPSBsaXN0LmVudHJpZXNbaWR4XTtcbiAgICB2YXIgbWFwcGluZyA9IGVudHJ5Lm9wZXJhdG9yLm1hcHBpbmc7XG5cbiAgICBkYXRhLml0ZXJGbGFnID0ge307XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbWFwcGluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICBkb0l0ZXJhdGUgPSAoZW50cnkuaXNUcmFuc2ZlcklucHV0KGkpIHx8IGxpc3QuaXNJbnB1dEl0ZXJhdGUoZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChpKSkpO1xuICAgICAgICBkYXRhLml0ZXJGbGFnW2ldID0gZG9JdGVyYXRlO1xuICAgIH1cblxuICAgIGRhdGEuaXRlcmF0ZUNvdW50ID0gbGlzdC5nZXRJdGVyYXRlQ291bnQocHJvZ3JhbURhdGEpO1xuXG4gICAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVmYXVsdE9wZXJhdGlvbihlbnRyeSwgcHJvZ3JhbURhdGEsIG9wZXJhdG9yRGF0YSwgcHJvZ3JhbSkge1xuICAgIGlmIChwcm9ncmFtLm9wZXJhdG9yLmV2YWx1YXRlICYmIHByb2dyYW0ub3BlcmF0b3IuZXZhbHVhdGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBhc3NlbWJsZUZ1bmN0aW9uQXJncyhlbnRyeSwgcHJvZ3JhbURhdGEsIHByb2dyYW0pO1xuXG4gICAgICAgIGlmIChwcm9ncmFtLmtlcm5lbENvZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHByZXBhcmVXZWJDTEtlcm5lbChwcm9ncmFtRGF0YSwgcHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgLy9jb25zb2xlLnRpbWUoJ0NMUHJvZ3JhbSAoJyArIHByb2dyYW0ub3BlcmF0b3IubmFtZSArICcpJyk7XG4gICAgICAgIGlmIChwcm9ncmFtLm1haW5Qcm9ncmFtID09PSBudWxsKSB7XG4gICAgICAgICAgICBwcm9ncmFtLm1haW5Qcm9ncmFtID0gY3JlYXRlTWFpbldlYkNMUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9ncmFtLm1haW5Qcm9ncmFtKCk7XG4gICAgICAgIC8vY29uc29sZS50aW1lRW5kKCdDTFByb2dyYW0gKCcgKyBwcm9ncmFtLm9wZXJhdG9yLm5hbWUgKyAnKScpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBNYXBzIFhmbG93IGlucHV0cyBhbmQgb3V0cHV0cyBpbnRvIFdlYkNMIGtlcm5lbCBpbnB1dHMgYW5kIG91dHB1dHMuXG4gKlxuICogQGZ1bmN0aW9uIGFzc2VtYmxlRnVuY3Rpb25BcmdzXG4gKiBAcGFyYW0gZW50cnlcbiAqIEBwYXJhbSBwcm9ncmFtRGF0YVxuICogQHBhcmFtIHByb2dyYW1cbiAqL1xuXG5mdW5jdGlvbiBhc3NlbWJsZUZ1bmN0aW9uQXJncyhlbnRyeSwgcHJvZ3JhbURhdGEsIHByb2dyYW0pIHtcbiAgICB2YXIgZCwgZGF0YUVudHJ5LCBpO1xuICAgIHZhciBrZXJuZWxGdW5jdGlvblBhcmFtcyA9IHByb2dyYW0ua2VybmVsRnVuY3Rpb25QYXJhbXM7XG4gICAgdmFyIG91dHB1dHMgPSBwcm9ncmFtLm9wZXJhdG9yLm91dHB1dHM7XG5cbiAgICBrZXJuZWxGdW5jdGlvblBhcmFtcy5sZW5ndGggPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZCA9IG91dHB1dHNbaV07XG4gICAgICAgIGRhdGFFbnRyeSA9IHByb2dyYW1EYXRhLm91dHB1dHNbZW50cnkuZ2V0T3V0cHV0SW5kZXgoaSldLmRhdGFFbnRyeTtcblxuICAgICAgICBwcmVwYXJlS2VybmVsUGFyYW1ldGVyKGQsICEhKGQuc291cmNlKSwgcHJvZ3JhbSwga2VybmVsRnVuY3Rpb25QYXJhbXMsIGRhdGFFbnRyeSwgaSk7XG4gICAgfVxuXG4gICAgYWRkSW5wdXRUb0FyZ3MoZW50cnksIHByb2dyYW1EYXRhLCBwcm9ncmFtLCBrZXJuZWxGdW5jdGlvblBhcmFtcyk7XG59XG5cblxuZnVuY3Rpb24gYWRkSW5wdXRUb0FyZ3MoZW50cnksIHByb2dyYW1EYXRhLCBwcm9ncmFtLCBrZXJuZWxGdW5jdGlvblBhcmFtcykge1xuICAgIHZhciBtYXBFbnRyeSwgZGF0YUVudHJ5LCBpO1xuICAgIHZhciBtYXBwaW5nID0gZW50cnkub3BlcmF0b3IubWFwcGluZztcblxuICAgIGZvciAoaSA9IDA7IGkgPCBtYXBwaW5nLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG1hcEVudHJ5ID0gbWFwcGluZ1tpXTtcbiAgICAgICAgZGF0YUVudHJ5ID0gcHJvZ3JhbURhdGEuZ2V0RGF0YUVudHJ5KGVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaSkpO1xuXG4gICAgICAgIHByZXBhcmVLZXJuZWxQYXJhbWV0ZXIobWFwRW50cnksICEhKG1hcEVudHJ5LnNvdXJjZSksIHByb2dyYW0sIGtlcm5lbEZ1bmN0aW9uUGFyYW1zLCBkYXRhRW50cnksIGkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEtlcm5lbFBhcmFtIHV0aWxpdHkgb2JqZWN0IG9yIHVwZGF0ZXMgdGhlIGV4aXN0aW5nIG9iamVjdCBpZiBpbnB1dCB2YWx1ZSBoYXMgYmVlbiBjaGFuZ2VkLlxuICogQWRkaXRpb25hbGx5LCB0aGlzIGlzIHVzZWQgZm9yIGdlbmVyYXRpbmcgdGhlIFdlYkNMIGtlcm5lbCBmdW5jdGlvbiBoZWFkZXIuXG4gKlxuICogQGZ1bmN0aW9uIHByZXBhcmVLZXJuZWxQYXJhbWV0ZXJcbiAqIEBwYXJhbSBwYXJhbVxuICogQHBhcmFtIGlucHV0XG4gKiBAcGFyYW0gcHJvZ3JhbVxuICogQHBhcmFtIGZ1bmN0aW9uUGFyYW1zXG4gKiBAcGFyYW0gYXJnXG4gKiBAcGFyYW0gaVxuICovXG5cbmZ1bmN0aW9uIHByZXBhcmVLZXJuZWxQYXJhbWV0ZXIocGFyYW0sIGlucHV0LCBwcm9ncmFtLCBmdW5jdGlvblBhcmFtcywgYXJnLCBpKSB7XG4gICAgdmFyIGtlcm5lbFBhcmFtcztcbiAgICB2YXIgZW50cnlWYWwgPSBhcmcgPyBhcmcuZ2V0VmFsdWUoKSA6IG51bGw7XG5cbiAgICBpZiAoaW5wdXQpIHtcbiAgICAgICAga2VybmVsUGFyYW1zID0gcHJvZ3JhbS5rZXJuZWxQYXJhbU1hcC5pbnB1dHM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2VybmVsUGFyYW1zID0gcHJvZ3JhbS5rZXJuZWxQYXJhbU1hcC5vdXRwdXRzO1xuICAgIH1cblxuICAgIGlmIChrZXJuZWxQYXJhbXNbaV0pIHtcbiAgICAgICAga2VybmVsUGFyYW1zW2ldLnVwZGF0ZVZhbHVlKGVudHJ5VmFsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGtlcm5lbFBhcmFtc1tpXSA9IG5ldyBLZXJuZWxQYXJhbShwcm9ncmFtLCBwYXJhbS5uYW1lLCBwYXJhbS50eXBlLCBudWxsLCBlbnRyeVZhbCwgaW5wdXQpO1xuXG4gICAgLy8gUHVzaGluZyBnZW5lcmF0ZWQga2VybmVsIGZ1bmN0aW9uIHBhcmFtcyBpbnRvIGFycmF5LlxuICAgIC8vIFRoaXMgYXJyYXkgaXMgbGF0ZXIgdXNlZCBpbiBnZW5lcmF0aW5nIHRoZSBXZWJDTCBrZXJuZWwgZnVuY3Rpb24gaGVhZGVyLlxuICAgIGZ1bmN0aW9uUGFyYW1zLnB1c2goa2VybmVsUGFyYW1zW2ldLmNsRnVuY3Rpb25QYXJhbSk7XG5cbiAgICBrZXJuZWxQYXJhbXNbaV0uaGVscGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIGZ1bmN0aW9uUGFyYW1zLnB1c2gocC5jbEZ1bmN0aW9uUGFyYW0pO1xuICAgIH0pO1xufVxuXG5cbi8qKiBLRVJORUwgQ09ERSBQUkVQQVJBVElPTiAqKi9cblxuXG4vKipcbiAqIENvbXBpbGVzIGFuZCByZWdpc3RlcnMgdGhlIHByZXBhcmVkIFdlYkNMIGtlcm5lbCBjb2RlLlxuICpcbiAqIEBmdW5jdGlvbiBwcmVwYXJlV2ViQ0xLZXJuZWxcbiAqIEBwYXJhbSBwcm9ncmFtRGF0YVxuICogQHBhcmFtIHByb2dyYW1cbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIHByZXBhcmVXZWJDTEtlcm5lbChwcm9ncmFtRGF0YSwgcHJvZ3JhbSkge1xuICAgIHZhciBrZXJuZWxDb2RlO1xuICAgIHZhciBrZXJuZWxNYW5hZ2VyID0gcHJvZ3JhbS5jbC5rZXJuZWxNYW5hZ2VyO1xuICAgIHZhciBpbnB1dEtlcm5lbCA9IHByb2dyYW0ub3BlcmF0b3IuZXZhbHVhdGU7XG4gICAgdmFyIGtlcm5lbE5hbWUgPSBwcm9ncmFtLmtlcm5lbE5hbWUgPSBwcm9ncmFtLm9wZXJhdG9yLm5hbWUuc3BsaXQoJ3hmbG93LicpWzFdO1xuXG4gICAgaWYgKCFpbnB1dEtlcm5lbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAga2VybmVsQ29kZSA9IHByb2dyYW0ua2VybmVsQ29kZSA9IHByZXBhcmVLZXJuZWxDb2RlKGtlcm5lbE5hbWUsIGlucHV0S2VybmVsLCBwcm9ncmFtKTtcblxuICAgIHRyeSB7XG4gICAgICAgIGtlcm5lbE1hbmFnZXIucmVnaXN0ZXIoa2VybmVsTmFtZSwga2VybmVsQ29kZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcHJvZ3JhbS5rZXJuZWxQcm9ncmFtID0ga2VybmVsTWFuYWdlci5nZXRLZXJuZWwocHJvZ3JhbS5rZXJuZWxOYW1lKTtcblxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqXG4gKiBHZW5lcmF0ZXMga2VybmVsIGZ1bmN0aW9uIGhlYWRlciBhbmQgaGVscGVyIGtlcm5lbCBjb2RlIGFuZCBjb21iaW5lcyBpdCB3aXRoIHVzZXIncyBpbnB1dCBrZXJuZWwgY29kZS5cbiAqXG4gKiBAZnVuY3Rpb24gcHJlcGFyZUtlcm5lbENvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBrZXJuZWxOYW1lXG4gKiBAcGFyYW0ge0FycmF5fSBpbnB1dEtlcm5lbFxuICogQHBhcmFtIHByb2dyYW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gcHJlcGFyZUtlcm5lbENvZGUoa2VybmVsTmFtZSwgaW5wdXRLZXJuZWwsIHByb2dyYW0pIHtcbiAgICB2YXIgcmVzdWx0LCBpbm5lcktlcm5lbENvZGU7XG5cbiAgICByZXN1bHQgPSBjcmVhdGVLZXJuZWxIZWFkZXIoa2VybmVsTmFtZSwgcHJvZ3JhbSk7XG5cbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmVzdWx0ICs9ICd7XFxuJztcblxuICAgIGlubmVyS2VybmVsQ29kZSA9IGNyZWF0ZUlubmVyS2VybmVsQ29kZShwcm9ncmFtKTtcblxuICAgIGlmICghaW5uZXJLZXJuZWxDb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXN1bHQgKz0gaW5uZXJLZXJuZWxDb2RlO1xuICAgIHJlc3VsdCArPSBpbnB1dEtlcm5lbC5qb2luKCdcXG4nKTtcbiAgICByZXN1bHQgKz0gJ1xcbn0nO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBrZXJuZWwgZnVuY3Rpb24gaGVhZGVyIGZyb20gYXNzZW1ibGVkIGtlcm5lbCBwYXJhbWV0ZXJzLlxuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVLZXJuZWxIZWFkZXJcbiAqIEBwYXJhbSBrZXJuZWxOYW1lXG4gKiBAcGFyYW0gcHJvZ3JhbVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVLZXJuZWxIZWFkZXIoa2VybmVsTmFtZSwgcHJvZ3JhbSkge1xuICAgIHZhciBmdW5jdGlvbkhlYWRlciA9IFtdO1xuXG4gICAgZnVuY3Rpb25IZWFkZXIucHVzaChcIl9fa2VybmVsIHZvaWRcIik7XG4gICAgZnVuY3Rpb25IZWFkZXIucHVzaChrZXJuZWxOYW1lICsgJygnKTtcbiAgICBmdW5jdGlvbkhlYWRlci5wdXNoKHByb2dyYW0ua2VybmVsRnVuY3Rpb25QYXJhbXMuam9pbignLCAnKSk7XG4gICAgZnVuY3Rpb25IZWFkZXIucHVzaCgnKScpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uSGVhZGVyLmpvaW4oJyAnKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgaGVscGVyIGtlcm5lbCBjb2RlLlxuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVJbm5lcktlcm5lbENvZGVcbiAqIEBwYXJhbSBwcm9ncmFtXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUlubmVyS2VybmVsQ29kZShwcm9ncmFtKSB7XG4gICAgdmFyIGNvZGVMaW5lcyA9IFtdO1xuXG4gICAgdmFyIGZpcnN0SW5wdXQgPSBwcm9ncmFtLmtlcm5lbFBhcmFtTWFwLmlucHV0c1swXTtcblxuICAgIGlmIChmaXJzdElucHV0LnR5cGUgPT09IFwidWNoYXI0KlwiKSB7XG4gICAgICAgIC8vIEFkZCBcIml0ZXJhdG9yc1wiXG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFwiaW50IHggPSBnZXRfZ2xvYmFsX2lkKDApO1wiKTtcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXCJpbnQgeSA9IGdldF9nbG9iYWxfaWQoMSk7XCIpO1xuXG4gICAgICAgIC8vIEFkZCBib3VuZHMgY2hlY2tlcnNcbiAgICAgICAgY29kZUxpbmVzLnB1c2goXCJpZiAoeCA+PSBcIiArIGZpcnN0SW5wdXQubmFtZSArIFwiX3dpZHRoIHx8IHkgPj0gXCIgKyBmaXJzdElucHV0Lm5hbWUgKyBcIl9oZWlnaHQpIHJldHVybjtcIik7XG5cbiAgICAgICAgLy8gQWRkIGlucHV0IGl0ZXJhdG9yXG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFwiaW50IFwiICsgZmlyc3RJbnB1dC5uYW1lICsgXCJfaSA9IHkgKiBcIiArIGZpcnN0SW5wdXQubmFtZSArIFwiX3dpZHRoICsgeDtcIik7XG5cbiAgICB9IGVsc2UgeyAvLyBFbHNlLCBhc3N1bWluZyB0aGF0IHRoZSBmaXJzdCBpbnB1dCBpcyBhbiAxLWRpbWVuc2lvbmFsIGJ1ZmZlclxuXG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFwiaW50IFwiICsgZmlyc3RJbnB1dC5uYW1lICsgXCJfaSA9IGdldF9nbG9iYWxfaWQoMCk7XCIpO1xuXG4gICAgICAgIGNvZGVMaW5lcy5wdXNoKFwiaWYgKFwiICsgZmlyc3RJbnB1dC5uYW1lICsgXCJfaSA+PSBcIiArIGZpcnN0SW5wdXQubmFtZSArIFwiX2xlbmd0aCkgcmV0dXJuO1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29kZUxpbmVzLmpvaW4oJ1xcbicpO1xuXG59XG5cblxuLyoqIE1BSU4gV0VCQ0wgUFJPR1JBTSBJTklUSUFMSVNBVElPTiAqKi9cblxuLyoqXG4gKiBJbml0aWFsaXNlcyB0aGUgbWFpbiBXZWJDTCBhcHBsaWNhdGlvbiBjb2RlIHRoYXQgZXhlY3V0ZXMgdGhlIFdlYkNMIGtlcm5lbFxuICpcbiAqIEBmdW5jdGlvbiBjcmVhdGVNYWluV2ViQ0xQcm9ncmFtXG4gKiBAcGFyYW0gcHJvZ3JhbVxuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU1haW5XZWJDTFByb2dyYW0ocHJvZ3JhbSkge1xuICAgIHZhciBjbCA9IHByb2dyYW0uY2w7XG4gICAgdmFyIGtlcm5lbE1hbmFnZXIgPSBjbC5rZXJuZWxNYW5hZ2VyO1xuICAgIHZhciBjbWRRdWV1ZSA9IGNsLmNtZFF1ZXVlO1xuICAgIHZhciBtZW1PYmplY3RzID0ge2lucHV0czogW10sIG91dHB1dHM6IFtdfTtcbiAgICB2YXIgYXNzZW1ibGVkQXJncyA9IGFzc2VtYmxlS2VybmVsQXJndW1lbnRzKHByb2dyYW0ua2VybmVsUGFyYW1NYXAsIG1lbU9iamVjdHMpO1xuICAgIHZhciBXU1NpemVzID0gY29tcHV0ZVdvcmtHcm91cFNpemUocHJvZ3JhbS5rZXJuZWxQYXJhbU1hcC5pbnB1dHNbMF0pO1xuICAgIHZhciBrZXJuZWwgPSBwcm9ncmFtLmtlcm5lbFByb2dyYW07XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaSwgbGVuLCBtZW1PYmosIGFyZ3M7XG4gICAgICAgIHZhciBpbnB1dE1lbU9ianMgPSBtZW1PYmplY3RzLmlucHV0cztcbiAgICAgICAgdmFyIG91dHB1dE1lbU9ianMgPSBtZW1PYmplY3RzLm91dHB1dHM7XG5cbiAgICAgICAgaWYgKCFrZXJuZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFyZ3MgPSBhc3NlbWJsZWRBcmdzLm1hcChmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgcmV0dXJuIGEuYXJnO1xuICAgICAgICB9KTtcblxuICAgICAgICBrZXJuZWxNYW5hZ2VyLnNldEFyZ3MuYXBwbHkobnVsbCwgW2tlcm5lbF0uY29uY2F0KGFyZ3MpKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV3JpdGUgdGhlIGJ1ZmZlciB0byBPcGVuQ0wgZGV2aWNlIG1lbW9yeVxuICAgICAgICAgICAgbGVuID0gaW5wdXRNZW1PYmpzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbU9iaiA9IGlucHV0TWVtT2Jqc1tpXTtcbiAgICAgICAgICAgICAgICBjbWRRdWV1ZS5lbnF1ZXVlV3JpdGVCdWZmZXIobWVtT2JqLmFyZywgZmFsc2UsIDAsIC8qbWVtT2JqLmFyZy5nZXRJbmZvKFdlYkNMLk1FTV9TSVpFKSovbWVtT2JqLm1lbU9iamVjdFNpemUsIG1lbU9iai52YWwsIFtdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gRXhlY3V0ZSAoZW5xdWV1ZSkga2VybmVsXG4gICAgICAgICAgICBjbWRRdWV1ZS5lbnF1ZXVlTkRSYW5nZUtlcm5lbChrZXJuZWwsIFdTU2l6ZXNbMV0ubGVuZ3RoLCBbXSwgV1NTaXplc1sxXSwgV1NTaXplc1swXSk7XG5cbiAgICAgICAgICAgIC8vIFJlYWQgdGhlIHJlc3VsdCBidWZmZXIgZnJvbSBPcGVuQ0wgZGV2aWNlXG4gICAgICAgICAgICBsZW4gPSBvdXRwdXRNZW1PYmpzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbU9iaiA9IG91dHB1dE1lbU9ianNbaV07XG4gICAgICAgICAgICAgICAgY21kUXVldWUuZW5xdWV1ZVJlYWRCdWZmZXIobWVtT2JqLmFyZywgZmFsc2UsIDAsIC8qbWVtT2JqLmFyZy5nZXRJbmZvKFdlYkNMLk1FTV9TSVpFKSovbWVtT2JqLm1lbU9iamVjdFNpemUsIG1lbU9iai52YWwsIFtdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY21kUXVldWUuZmluaXNoKCk7IC8vRmluaXNoIGFsbCB0aGUgb3BlcmF0aW9uc1xuXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cblxuLyoqXG4gKiBBcnJhbmdlcyBpbml0aWFsaXNlZCBrZXJuZWwgYXJndW1lbnRzIGludG8gaGVscGVyIGFycmF5cyBzbyB0aGV5IGFyZSBtb3JlIGVhc2lseSBhdmFpbGFibGUgaW5cbiAqIHRoZSBtYWluIFdlYkNMIGFwcGxpY2F0aW9uLlxuICpcbiAqIEBmdW5jdGlvbiBhc3NlbWJsZUtlcm5lbEFyZ3VtZW50c1xuICogQHBhcmFtIHBhcmFtTWFwXG4gKiBAcGFyYW0gbWVtT2JqZWN0c1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGFzc2VtYmxlS2VybmVsQXJndW1lbnRzKHBhcmFtTWFwLCBtZW1PYmplY3RzKSB7XG4gICAgdmFyIG91dHB1dHMgPSBwYXJhbU1hcC5vdXRwdXRzO1xuICAgIHZhciBpbnB1dHMgPSBwYXJhbU1hcC5pbnB1dHM7XG4gICAgdmFyIGtlcm5lbEFyZ3MgPSBbXTtcblxuICAgIG91dHB1dHMuZm9yRWFjaChmdW5jdGlvbiAocCkge1xuICAgICAgICBtYXBLZXJuZWxBcmd1bWVudChwLCBrZXJuZWxBcmdzLCBtZW1PYmplY3RzLm91dHB1dHMpO1xuICAgIH0pO1xuXG4gICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgICAgbWFwS2VybmVsQXJndW1lbnQocCwga2VybmVsQXJncywgbWVtT2JqZWN0cy5pbnB1dHMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGtlcm5lbEFyZ3M7XG59XG5cbmZ1bmN0aW9uIG1hcEtlcm5lbEFyZ3VtZW50KHBhcmFtLCBrZXJuZWxBcmdzLCBtZW1PYmplY3RzKSB7XG4gICAga2VybmVsQXJncy5wdXNoKHBhcmFtKTtcblxuICAgIGlmIChwYXJhbS5oYXNNZW1PYmplY3QpIHtcbiAgICAgICAgbWVtT2JqZWN0cy5wdXNoKHBhcmFtKTtcbiAgICAgICAgcGFyYW0uaGVscGVycy5mb3JFYWNoKGZ1bmN0aW9uIChwKSB7XG4gICAgICAgICAgICBrZXJuZWxBcmdzLnB1c2gocCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyBhIHByb3BlciBXZWJDTCBrZXJuZWwgd29ya2dyb3VwIHNpemUgZm9yIHRhcmdldCBpbnB1dCBidWZmZXJcbiAqXG4gKiBAZnVuY3Rpb24gY29tcHV0ZVdvcmtHcm91cFNpemVcbiAqIEBwYXJhbSB0YXJnZXRJbnB1dFxuICogQHJldHVybnMge0FycmF5fVxuICovXG5cbmZ1bmN0aW9uIGNvbXB1dGVXb3JrR3JvdXBTaXplKHRhcmdldElucHV0KSB7XG4gICAgdmFyIGxvY2FsV1MsIGdsb2JhbFdTO1xuICAgIHZhciBlbnRyeVZhbCA9IHRhcmdldElucHV0LmVudHJ5VmFsdWU7XG5cbiAgICBpZiAodGFyZ2V0SW5wdXQueGZsb3dUeXBlID09PSBDLkRBVEFfVFlQRS5URVhUVVJFKSB7XG4gICAgICAgIGxvY2FsV1MgPSBbMTYsIDRdO1xuICAgICAgICBnbG9iYWxXUyA9IFtNYXRoLmNlaWwoZW50cnlWYWwud2lkdGggLyBsb2NhbFdTWzBdKSAqIGxvY2FsV1NbMF0sIE1hdGguY2VpbChlbnRyeVZhbC5oZWlnaHQgLyBsb2NhbFdTWzFdKSAqIGxvY2FsV1NbMV1dO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrID0gMTtcbiAgICAgICAgc3dpdGNoICh0YXJnZXRJbnB1dC54Zmxvd1R5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuSU5UNDpcbiAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGsgPSA0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDM6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgayA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNFg0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGsgPSAxNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsb2NhbFdTID0gWzE2XTtcbiAgICAgICAgZ2xvYmFsV1MgPSBbTWF0aC5jZWlsKGVudHJ5VmFsLmxlbmd0aCAvIChsb2NhbFdTWzBdICogaykpICogbG9jYWxXU1swXV07XG4gICAgfVxuXG4gICAgcmV0dXJuIFtsb2NhbFdTLCBnbG9iYWxXU107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ0xQcm9ncmFtO1xuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmFkZFwiLCB7XG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWUxJ30sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZTInfV0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUxLCB2YWx1ZTIsIGluZm8pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IHVzZWQhXCIpO1xuICAgIH0sXG4gICAgZXZhbHVhdGVfY29yZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMil7XG4gICAgICAgIHJlc3VsdFswXSA9IHZhbHVlMVswXSArIHZhbHVlMlswXTtcbiAgICAgICAgcmVzdWx0WzFdID0gdmFsdWUxWzFdICsgdmFsdWUyWzFdO1xuICAgICAgICByZXN1bHRbMl0gPSB2YWx1ZTFbMl0gKyB2YWx1ZTJbMl07XG4gICAgfVxufSk7XG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuYnVmZmVyU2VsZWN0XCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnLCBub0FsbG9jOiB0cnVlfV0sXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd0cnVlT3B0aW9uJywgYXJyYXk6IHRydWV9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAnZmFsc2VPcHRpb24nLCBhcnJheTogdHJ1ZX0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdib29sJywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX1dLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGZhbHNlT3B0aW9uLCB0cnVlT3B0aW9uLCB2YWx1ZSkge1xuICAgICAgICByZXN1bHQuYXNzaWduID0gdmFsdWVbMF0gPyB0cnVlT3B0aW9uIDogZmFsc2VPcHRpb247XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuY2xhbXBJbWFnZVwiLCB7XG4gICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZiA6ICdpbWFnZScsIGZvcm1hdFR5cGU6ICdJbWFnZURhdGEnfSBdLFxuICAgIHBhcmFtczogIFsge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30sXG4gICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlIDogJ21pbid9LFxuICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZSA6ICdtYXgnfVxuICAgICAgICAgICAgIF0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciBpbnBpeCA9IGltYWdlLmRhdGE7XG4gICAgICAgIHZhciBvdXRwaXggPSByZXN1bHQuZGF0YTtcbiAgICAgICAgdmFyIG1pbnYgPSBtaW5bMF07XG4gICAgICAgIHZhciBtYXh2ID0gbWF4WzBdO1xuICAgICAgICB2YXIgbGVuID0gaW1hZ2UuZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gaW5waXhbaV07XG4gICAgICAgICAgICBpZiAodmFsIDwgbWludikgdmFsID0gbWludjtcbiAgICAgICAgICAgIGlmICh2YWwgPiBtYXh2KSB2YWwgPSBtYXh2O1xuICAgICAgICAgICAgb3V0cGl4W2ldID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuIiwiLy8gQ29kZSBwb3J0aW9ucyBmcm9tIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2NhbnZhcy9pbWFnZWZpbHRlcnMvXG5cbihmdW5jdGlvbigpIHtcblxuICAgIGZ1bmN0aW9uIGNvbnZvbHV0ZShpbnBpeGVscywgb3V0cGl4ZWxzLCB3ZWlnaHRzLCBvcGFxdWUpIHtcbiAgICAgICAgdmFyIHNpZGUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh3ZWlnaHRzLmxlbmd0aCkpO1xuICAgICAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUvMik7XG4gICAgICAgIHZhciBzcmMgPSBpbnBpeGVscy5kYXRhO1xuICAgICAgICB2YXIgc3cgPSBpbnBpeGVscy53aWR0aDtcbiAgICAgICAgdmFyIHNoID0gaW5waXhlbHMuaGVpZ2h0O1xuICAgICAgICAvLyBwYWQgb3V0cHV0IGJ5IHRoZSBjb252b2x1dGlvbiBtYXRyaXhcbiAgICAgICAgdmFyIHcgPSBzdztcbiAgICAgICAgdmFyIGggPSBzaDtcbiAgICAgICAgdmFyIGRzdCA9IG91dHBpeGVscy5kYXRhO1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBkZXN0aW5hdGlvbiBpbWFnZSBwaXhlbHNcbiAgICAgICAgdmFyIGFscGhhRmFjID0gb3BhcXVlID8gMSA6IDA7XG4gICAgICAgIGZvciAodmFyIHk9MDsgeTxoOyB5KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHg9MDsgeDx3OyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3kgPSB5O1xuICAgICAgICAgICAgICAgIHZhciBzeCA9IHg7XG4gICAgICAgICAgICAgICAgdmFyIGRzdE9mZiA9ICh5KncreCkqNDtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcbiAgICAgICAgICAgICAgICAvLyBmYWxsIHVuZGVyIHRoZSBjb252b2x1dGlvbiBtYXRyaXhcbiAgICAgICAgICAgICAgICB2YXIgcj0wLCBnPTAsIGI9MCwgYT0wO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGN5PTA7IGN5PHNpZGU7IGN5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY3g9MDsgY3g8c2lkZTsgY3grKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNjeSA9IHN5ICsgY3kgLSBoYWxmU2lkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3ggPSBzeCArIGN4IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2N5ID49IDAgJiYgc2N5IDwgc2ggJiYgc2N4ID49IDAgJiYgc2N4IDwgc3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3JjT2ZmID0gKHNjeSpzdytzY3gpKjQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSpzaWRlK2N4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByICs9IHNyY1tzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZyArPSBzcmNbc3JjT2ZmKzFdICogd3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYiArPSBzcmNbc3JjT2ZmKzJdICogd3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYSArPSBzcmNbc3JjT2ZmKzNdICogd3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHN0W2RzdE9mZl0gPSByO1xuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrMV0gPSBnO1xuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrMl0gPSBiO1xuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrM10gPSBhICsgYWxwaGFGYWMqKDI1NS1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cGl4ZWxzO1xuICAgIH07XG5cbiAgICBYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuY29udm9sdXRlSW1hZ2VcIiwge1xuICAgICAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlJ30gXSxcbiAgICAgICAgcGFyYW1zOiAgW1xuICAgICAgICAgICAge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30sXG4gICAgICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlIDogJ2tlcm5lbCd9XG4gICAgICAgIF0sXG4gICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGltYWdlLCBrZXJuZWwpIHtcbiAgICAgICAgICAgIGNvbnZvbHV0ZShpbWFnZSwgcmVzdWx0LCBrZXJuZWwsIHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIFhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5jb252b2x1dGVJbWFnZVRvRmxvYXRcIiwge1xuICAgICAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mOiAnaW1hZ2UnLCBmb3JtYXRUeXBlIDogJ2Zsb2F0MzInfSBdLFxuICAgICAgICBwYXJhbXM6ICBbXG4gICAgICAgICAgICB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UnfSxcbiAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2UgOiAna2VybmVsJ31cbiAgICAgICAgXSxcbiAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UsIGtlcm5lbCkge1xuICAgICAgICAgICAgY29udm9sdXRlKGltYWdlLCByZXN1bHQsIGtlcm5lbCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG59KSgpO1xuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmNyZWF0ZUlHSW5kZXhcIiwge1xuICAgIG91dHB1dHM6W1xuICAgICAgICAvL3t0eXBlOidpbnQnLCBuYW1lOidpbmRleCcsIGN1c3RvbUFsbG9jOnRydWUgfSxcbiAgICAgICAge3R5cGU6J2Zsb2F0MicsIG5hbWU6J3RleGNvb3JkJywgY3VzdG9tQWxsb2M6dHJ1ZSB9XG4gICAgXSxcbiAgICBwYXJhbXM6W1xuICAgICAgICB7dHlwZTonaW50Jywgc291cmNlOid2ZXJ0ZXhDb3VudCcsIG9wdGlvbmFsOmZhbHNlfSxcbiAgICAgICAge3R5cGU6J3RleHR1cmUnLCBzb3VyY2U6J3Bvc2l0aW9uVGV4Jywgb3B0aW9uYWw6IGZhbHNlfVxuICAgIF0sXG4gICAgYWxsb2M6ZnVuY3Rpb24gKHNpemVzLCB2ZXJ0ZXhDb3VudCwgaW1hZ2UpIHtcbiAgICAgICAgc2l6ZXNbJ3RleGNvb3JkJ10gPSBpbWFnZS53aWR0aCAqIGltYWdlLmhlaWdodDtcbiAgICAgICAgLy9zaXplc1snaW5kZXgnXSA9IHZlcnRleENvdW50WzBdO1xuICAgIH0sXG4gICAgZXZhbHVhdGU6ZnVuY3Rpb24gKHRleGNvb3JkLCB2ZXJ0ZXhDb3VudCwgaW1hZ2UsIGluZm8pIHtcbiAgICAgICAgLy8gdGV4IGNvb3Jkc1xuICAgICAgICB2YXIgaGFsZlBpeGVsID0ge1xuICAgICAgICAgICAgeDogMC41IC8gaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICB5OiAwLjUgLyBpbWFnZS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKHZhciB5ID0gMCwgeWxlbmd0aCA9IGltYWdlLmhlaWdodDsgeSA8IHlsZW5ndGg7IHkrKylcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDAsIHhsZW5ndGggPSBpbWFnZS53aWR0aDsgeCA8IHhsZW5ndGg7IHgrKylcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0ZXhjb29yZFtpKytdID0gKHggLyB4bGVuZ3RoKSArIGhhbGZQaXhlbC54O1xuICAgICAgICAgICAgICAgIHRleGNvb3JkW2krK10gPSAxIC0gKCh5IC8geWxlbmd0aCkgKyBoYWxmUGl4ZWwueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbmRleCBjcmVhdGlvblxuICAgICAgICAvKmZvcih2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhDb3VudFswXTsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleFtpXSA9IGk7XG4gICAgICAgIH0qL1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcbiIsIihmdW5jdGlvbigpIHtcbiAgICB2YXIgVE1QX01BVFJJWCA9IFhNTDNELm1hdGgubWF0NC5jcmVhdGUoKTtcbiAgICB2YXIgVE1QX1ZFQyA9IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKTtcbiAgICB2YXIgVE1QX1FVQVQgPSBYTUwzRC5tYXRoLnF1YXQuY3JlYXRlKCk7XG4gICAgdmFyIG1hdDQgPSBYTUwzRC5tYXRoLm1hdDQ7XG5cbiAgICBYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuY3JlYXRlVHJhbnNmb3JtXCIsIHtcbiAgICAgICAgb3V0cHV0czogW3t0eXBlOiAnZmxvYXQ0eDQnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgICAgICBwYXJhbXM6IFt7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3RyYW5zbGF0aW9uJywgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICdyb3RhdGlvbicsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAnc2NhbGUnLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgICAgICB7dHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ2NlbnRlcicsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0Jywgc291cmNlOiAnc2NhbGVPcmllbnRhdGlvbicsIG9wdGlvbmFsOiB0cnVlfV0sXG4gICAgICAgIGV2YWx1YXRlOiBmdW5jdGlvbiAocmVzdWx0LCB0cmFuc2xhdGlvbiwgcm90YXRpb24sIHNjYWxlLCBjZW50ZXIsIHNjYWxlT3JpZW50YXRpb24sIGluZm8pIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5mby5pdGVyYXRlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBkZXN0ID0gcmVzdWx0LnN1YmFycmF5KGkgKiAxNik7XG4gICAgICAgICAgICAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiAmJiBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCBpbmZvLml0ZXJGbGFnWzBdID8gdHJhbnNsYXRpb24uc3ViYXJyYXkoaSozKSA6IHRyYW5zbGF0aW9uKTtcbiAgICAgICAgICAgICAgICBjZW50ZXIgJiYgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgaW5mby5pdGVyRmxhZ1swXSA/IGNlbnRlci5zdWJhcnJheShpKjMpIDogY2VudGVyKTtcbiAgICAgICAgICAgICAgICBpZiAocm90YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbihUTVBfTUFUUklYLCBpbmZvLml0ZXJGbGFnWzFdID8gcm90YXRpb24uc3ViYXJyYXkoaSo0KSA6IHJvdGF0aW9uLCBbMCwgMCwgMF0pO1xuICAgICAgICAgICAgICAgICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIGRlc3QsIFRNUF9NQVRSSVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2NhbGVPcmllbnRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtYXQ0LmZyb21Sb3RhdGlvblRyYW5zbGF0aW9uKFRNUF9NQVRSSVgsIGluZm8uaXRlckZsYWdbNF0gPyBzY2FsZU9yaWVudGF0aW9uLnN1YmFycmF5KGkqNCkgOiBzY2FsZU9yaWVudGF0aW9uLCBbMCwgMCwgMF0pO1xuICAgICAgICAgICAgICAgICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIGRlc3QsIFRNUF9NQVRSSVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY2FsZSAmJiBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIGluZm8uaXRlckZsYWdbMl0gPyBzY2FsZS5zdWJhcnJheShpKjMpIDogc2NhbGUpO1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZU9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGgucXVhdC5jb3B5KFRNUF9RVUFULCBpbmZvLml0ZXJGbGFnWzRdID8gc2NhbGVPcmllbnRhdGlvbi5zdWJhcnJheShpKjQpIDogc2NhbGVPcmllbnRhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbihUTVBfTUFUUklYLCBYTUwzRC5tYXRoLnF1YXQubmVnYXRlKFRNUF9RVUFULCBUTVBfUVVBVCksIFswLCAwLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgZGVzdCwgVE1QX01BVFJJWCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2VudGVyICYmIG1hdDQudHJhbnNsYXRlKGRlc3QsIGRlc3QsIFhNTDNELm1hdGgudmVjMy5uZWdhdGUoVE1QX1ZFQywgaW5mby5pdGVyRmxhZ1szXSA/IGNlbnRlci5zdWJhcnJheShpKjMpIDogY2VudGVyKSk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG5cbn0pKCk7IiwiKGZ1bmN0aW9uKCkge1xuICAgIHZhciBUTVBfTUFUUklYID0gWE1MM0QubWF0aC5tYXQ0LmNyZWF0ZSgpO1xuICAgIHZhciBUTVBfVkVDID0gWE1MM0QubWF0aC52ZWMzLmNyZWF0ZSgpO1xuICAgIHZhciBUTVBfUVVBVCA9IFhNTDNELm1hdGgucXVhdC5jcmVhdGUoKTtcbiAgICB2YXIgbWF0NCA9IFhNTDNELm1hdGgubWF0NDtcblxuICAgIFhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5jcmVhdGVUcmFuc2Zvcm1JbnZcIiwge1xuICAgICAgICBvdXRwdXRzOiBbe3R5cGU6ICdmbG9hdDR4NCcsIG5hbWU6ICdyZXN1bHQnfV0sXG4gICAgICAgIHBhcmFtczogW3t0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndHJhbnNsYXRpb24nLCBvcHRpb25hbDogdHJ1ZX0sXG4gICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NCcsIHNvdXJjZTogJ3JvdGF0aW9uJywgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdzY2FsZScsIG9wdGlvbmFsOiB0cnVlfSxcbiAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAnY2VudGVyJywgb3B0aW9uYWw6IHRydWV9LFxuICAgICAgICAgICAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICdzY2FsZU9yaWVudGF0aW9uJywgb3B0aW9uYWw6IHRydWV9XSxcbiAgICAgICAgZXZhbHVhdGU6IGZ1bmN0aW9uIChyZXN1bHQsIHRyYW5zbGF0aW9uLCByb3RhdGlvbiwgc2NhbGUsIGNlbnRlciwgc2NhbGVPcmllbnRhdGlvbiwgaW5mbykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmZvLml0ZXJhdGVDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc3QgPSByZXN1bHQuc3ViYXJyYXkoaSAqIDE2KTtcbiAgICAgICAgICAgICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICAgICAgICAgICAgICAgIGNlbnRlciAmJiBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCBpbmZvLml0ZXJGbGFnWzNdID8gY2VudGVyLnN1YmFycmF5KGkqMykgOiBjZW50ZXIpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlT3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbihUTVBfTUFUUklYLCBpbmZvLml0ZXJGbGFnWzRdID8gc2NhbGVPcmllbnRhdGlvbi5zdWJhcnJheShpKjQpIDogc2NhbGVPcmllbnRhdGlvbiwgWzAsIDAsIDBdKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBkZXN0LCBUTVBfTUFUUklYKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NhbGUgJiYgbWF0NC5zY2FsZShkZXN0LCBkZXN0LCBYTUwzRC5tYXRoLnZlYzMucmVjaXByb2NhbChUTVBfVkVDLCBpbmZvLml0ZXJGbGFnWzJdID8gc2NhbGUuc3ViYXJyYXkoaSozKSA6IHNjYWxlKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlT3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5xdWF0LmNvcHkoVE1QX1FVQVQsIGluZm8uaXRlckZsYWdbNF0gPyBzY2FsZU9yaWVudGF0aW9uLnN1YmFycmF5KGkqNCkgOiBzY2FsZU9yaWVudGF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0NC5mcm9tUm90YXRpb25UcmFuc2xhdGlvbihUTVBfTUFUUklYLCBYTUwzRC5tYXRoLnF1YXQuaW52ZXJ0KFRNUF9RVUFULCBUTVBfUVVBVCksIFswLCAwLCAwXSk7XG4gICAgICAgICAgICAgICAgICAgIG1hdDQubXVsdGlwbHkoZGVzdCwgZGVzdCwgVE1QX01BVFJJWCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLnF1YXQuY29weShUTVBfUVVBVCwgaW5mby5pdGVyRmxhZ1sxXSA/IHJvdGF0aW9uLnN1YmFycmF5KGkqNCkgOiByb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIG1hdDQuZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24oVE1QX01BVFJJWCwgWE1MM0QubWF0aC5xdWF0LmludmVydChUTVBfUVVBVCwgVE1QX1FVQVQpLCBbMCwgMCwgMF0pO1xuICAgICAgICAgICAgICAgICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIGRlc3QsIFRNUF9NQVRSSVgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjZW50ZXIgJiYgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgWE1MM0QubWF0aC52ZWMzLm5lZ2F0ZShUTVBfVkVDLCBpbmZvLml0ZXJGbGFnWzNdID8gY2VudGVyLnN1YmFycmF5KGkqMykgOiBjZW50ZXIpKTtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbiAmJiBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCBYTUwzRC5tYXRoLnZlYzMubmVnYXRlKFRNUF9WRUMsIGluZm8uaXRlckZsYWdbMF0gPyB0cmFuc2xhdGlvbi5zdWJhcnJheShpKjMpIDogdHJhbnNsYXRpb24pKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KSgpO1xuIiwiKGZ1bmN0aW9uKCl7XG5cbnZhciBjX0N1YmVQb3NpdGlvbnMgPSAgW1xuICAgIFstMSwtMSwtMV0sIFsxLC0xLC0xXSwgWy0xLDEsLTFdLCBbMSwxLC0xXSwgLy8gZnJvbnRcbiAgICBbLTEsLTEsLTFdLCBbLTEsLTEsMV0sIFstMSwxLC0xXSwgWy0xLDEsMV0sIC8vIGxlZnRcbiAgICBbLTEsLTEsLTFdLCBbMSwtMSwtMV0sIFstMSwtMSwxXSwgWzEsLTEsMV0sIC8vIHRvcFxuICAgIFsxLC0xLC0xXSwgWzEsMSwtMV0sIFsxLC0xLDFdLCBbMSwxLDFdLCAgICAgLy8gcmlnaHRcbiAgICBbLTEsMSwtMV0sIFsxLDEsLTFdLCBbLTEsMSwxXSwgWzEsMSwxXSwgICAgIC8vIGJvdHRvbVxuICAgIFstMSwtMSwxXSwgWzEsLTEsMV0sIFstMSwxLDFdLCBbMSwxLDFdICAgICAgLy8gYmFja1xuXTtcbnZhciBjX0N1YmVOb3JtYWxzID0gIFtcbiAgICBbMCwwLC0xXSwgWzAsMCwtMV0sIFswLDAsLTFdLCBbMCwwLC0xXSwgLy8gZnJvbnRcbiAgICBbLTEsMCwwXSwgWy0xLDAsMF0sIFstMSwwLDBdLCBbLTEsMCwwXSwgLy8gbGVmdFxuICAgIFswLC0xLDBdLCBbMCwtMSwwXSwgWzAsLTEsMF0sIFswLC0xLDBdLCAvLyB0b3BcbiAgICBbMSwwLDBdLCBbMSwwLDBdLCBbMSwwLDBdLCBbMSwwLDBdLCAgICAgLy8gcmlnaHRcbiAgICBbMCwxLDBdLCBbMCwxLDBdLCBbMCwxLDBdLCBbMCwxLDBdLCAgICAgLy8gYm90dG9tXG4gICAgWzAsMCwxXSwgWzAsMCwxXSwgWzAsMCwxXSwgWzAsMCwxXSAgICAgIC8vIGJhY2tcbl07XG52YXIgY19DdWJlSW5kZXggPSBbXG4gICAgWzAsMSwyLDEsMiwzXSxcbiAgICBbNCw1LDYsNSw2LDddLFxuICAgIFs4LDksMTAsOSwxMCwxMV0sXG4gICAgWzEyLDEzLDE0LDEzLDE0LDE1XSxcbiAgICBbMTYsMTcsMTgsMTcsMTgsMTldLFxuICAgIFsyMCwyMSwyMiwyMSwyMiwyM11cbl1cblxuLyoqXG4gKiBHcmlkIEdlbmVyYXRpb25cbiAqL1xuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmRlYnVnLmNyZWF0ZVNraW5DdWJlc1wiLCB7XG4gICAgb3V0cHV0czogW1x0e3R5cGU6ICdpbnQnLCBuYW1lOiAnaW5kZXgnLCBjdXN0b21BbGxvYzogdHJ1ZX0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncG9zaXRpb24nLCBjdXN0b21BbGxvYzogdHJ1ZX0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAnbm9ybWFsJywgY3VzdG9tQWxsb2M6IHRydWV9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50NCcsIG5hbWU6ICdib25lSW5kaWNlcycsIGN1c3RvbUFsbG9jOiB0cnVlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NCcsIG5hbWU6ICdib25lV2VpZ2h0cycsIGN1c3RvbUFsbG9jOiB0cnVlfV0sXG4gICAgcGFyYW1zOiAgW3t0eXBlOiAnZmxvYXQ0eDQnLCBzb3VyY2U6ICdiaW5kVHJhbnNmb3JtcycsIGFycmF5OiB0cnVlfSxcbiAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ3NpemUnLCBhcnJheTogdHJ1ZSwgb3B0aW9uYWw6IHRydWV9XSxcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIGJpbmRUcmFuc2Zvcm1zKVxuICAgIHtcbiAgICAgICAgdmFyIHMgPSBiaW5kVHJhbnNmb3Jtcy5sZW5ndGggLyAxNjtcbiAgICAgICAgc2l6ZXNbJ3Bvc2l0aW9uJ10gPSBzICogNCAqIDY7XG4gICAgICAgIHNpemVzWydub3JtYWwnXSA9IHMgKiA0ICogNjtcbiAgICAgICAgc2l6ZXNbJ2JvbmVJbmRpY2VzJ10gPSBzICogNCAqIDY7XG4gICAgICAgIHNpemVzWydib25lV2VpZ2h0cyddID0gcyAqIDQgKiA2O1xuICAgICAgICBzaXplc1snaW5kZXgnXSA9IHMgKiA2ICogNjtcbiAgICB9LFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihpbmRleCwgcG9zaXRpb24sIG5vcm1hbCwgYm9uZUlkeCwgYm9uZVdlaWdodCwgYmluZFRyYW5zZm9ybXMsIHNpemUpIHtcbiAgICAgICAgdmFyIGN1YmVDb3VudCA9IGJpbmRUcmFuc2Zvcm1zLmxlbmd0aCAvIDE2O1xuICAgICAgICB2YXIgc2l6ZSA9IChzaXplICYmIHNpemVbMF0gfHwgMSkgLyAyO1xuXG4gICAgICAgIHZhciB0bXBQb3NpdGlvbiA9IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKSxcbiAgICAgICAgICAgIHRtcE5vcm1hbCA9IFhNTDNELm1hdGgudmVjMy5jcmVhdGUoKTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY3ViZUNvdW50OyArK2kpe1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDY7ICsrail7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IDQ7IGsrKyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsb2NhbElkeCA9IGoqNCsgaywgZ2xvYmFsSWR4ID0gaSo2KjQgKyBsb2NhbElkeDtcblxuICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLnZlYzMuY29weSh0bXBQb3NpdGlvbiwgY19DdWJlUG9zaXRpb25zW2xvY2FsSWR4XSk7XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGgudmVjMy5zY2FsZSh0bXBQb3NpdGlvbiwgdG1wUG9zaXRpb24sIHNpemUpO1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXRWZWMzKGJpbmRUcmFuc2Zvcm1zLCBpKjE2LCB0bXBQb3NpdGlvbiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIFhNTDNELm1hdGgudmVjMy5jb3B5KHRtcE5vcm1hbCwgY19DdWJlTm9ybWFsc1tsb2NhbElkeF0pO1xuICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXREaXJlY3Rpb24oYmluZFRyYW5zZm9ybXMsIGkqMTYsIHRtcE5vcm1hbCwgMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bZ2xvYmFsSWR4KjMrMF0gPSB0bXBQb3NpdGlvblswXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bZ2xvYmFsSWR4KjMrMV0gPSB0bXBQb3NpdGlvblsxXTtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25bZ2xvYmFsSWR4KjMrMl0gPSB0bXBQb3NpdGlvblsyXTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsW2dsb2JhbElkeCozKzBdID0gdG1wTm9ybWFsWzBdO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWxbZ2xvYmFsSWR4KjMrMV0gPSB0bXBOb3JtYWxbMV07XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbFtnbG9iYWxJZHgqMysyXSA9IHRtcE5vcm1hbFsyXTtcbiAgICAgICAgICAgICAgICAgICAgYm9uZUlkeFtnbG9iYWxJZHgqNCswXSA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJvbmVJZHhbZ2xvYmFsSWR4KjQrMV0gPSBib25lSWR4W2dsb2JhbElkeCo0KzJdID0gYm9uZUlkeFtnbG9iYWxJZHgqNCszXT0gMDtcbiAgICAgICAgICAgICAgICAgICAgYm9uZVdlaWdodFtnbG9iYWxJZHgqNCswXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGJvbmVXZWlnaHRbZ2xvYmFsSWR4KjQrMV0gPSBib25lV2VpZ2h0W2dsb2JhbElkeCo0KzJdID0gYm9uZVdlaWdodFtnbG9iYWxJZHgqNCszXT0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGdsb2JhbEluZGV4SWR4ID0gaSo2KjYgKyBqKjY7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBrID0gMDsgayA8IDY7ICsrayl7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4W2dsb2JhbEluZGV4SWR4K2tdID0gaSo2KjQgKyBjX0N1YmVJbmRleFtqXVtrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYXJlIGRvbmUhXG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgfVxufSk7XG5cbn0oKSk7XG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZmxpcE5vcm1hbFwiLCB7XG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWUnfV0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZm8pIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaTxpbmZvLml0ZXJhdGVDb3VudCozOyBpKyspXG4gICAgICAgICAgICByZXN1bHRbaV0gPSAtdmFsdWVbaV07XG4gICAgfVxufSk7XG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZmxpcFZlcnRpY2FsSW1hZ2VcIiwge1xuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdyZXN1bHQnLCBzaXplb2YgOiAnaW1hZ2UnfSBdLFxuICAgIHBhcmFtczogIFsge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30gXSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSkge1xuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuICAgICAgICB2YXIgZGVzdHBpeCA9IHJlc3VsdC5kYXRhO1xuICAgICAgICB2YXIgc3JjcGl4ID0gaW1hZ2UuZGF0YTtcblxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgKyt5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyArK3gpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93T2Zmc2V0ID0geSAqIHdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBzcmNPZmZzZXQgPSAocm93T2Zmc2V0ICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgIHZhciBkc3RPZmZzZXQgPSAocm93T2Zmc2V0ICsgKCh3aWR0aC0xKSAtIHgpKSAqIDQ7XG4gICAgICAgICAgICAgICAgZGVzdHBpeFtkc3RPZmZzZXRdID0gIHNyY3BpeFtzcmNPZmZzZXRdO1xuICAgICAgICAgICAgICAgIGRlc3RwaXhbZHN0T2Zmc2V0KzFdID0gc3JjcGl4W3NyY09mZnNldCsxXTtcbiAgICAgICAgICAgICAgICBkZXN0cGl4W2RzdE9mZnNldCsyXSA9IHNyY3BpeFtzcmNPZmZzZXQrMl07XG4gICAgICAgICAgICAgICAgZGVzdHBpeFtkc3RPZmZzZXQrM10gPSBzcmNwaXhbc3JjT2Zmc2V0KzNdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuIiwiWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmZvcndhcmRLaW5lbWF0aWNzXCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0NHg0JywgIG5hbWU6ICdyZXN1bHQnLCBjdXN0b21BbGxvYzogdHJ1ZX1dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnaW50JywgICAgICAgc291cmNlOiAncGFyZW50JywgYXJyYXk6IHRydWUgfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NHg0JywgIHNvdXJjZTogJ3hmb3JtJywgYXJyYXk6IHRydWUgfV0sXG4gICAgYWxsb2M6IGZ1bmN0aW9uKHNpemVzLCBwYXJlbnQsIHhmb3JtKVxuICAgIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKHBhcmVudC5sZW5ndGgsIHhmb3JtLmxlbmd0aCAvIDE2KTtcbiAgICAgICAgc2l6ZXNbJ3Jlc3VsdCddID0gbGVuZ3RoO1xuICAgIH0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgcGFyZW50LHhmb3JtLCBpbmZvKSB7XG5cbiAgICAgICAgdmFyIGJvbmVDb3VudCA9IHJlc3VsdC5sZW5ndGggLyAxNjtcblxuICAgICAgICB2YXIgY29tcHV0ZWQgPSBbXTtcbiAgICAgICAgLy9Gb3IgZWFjaCBib25lIGRvOlxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgYm9uZUNvdW50Oyl7XG4gICAgICAgICAgICBpZighY29tcHV0ZWRbaV0pIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IHBhcmVudFtpXTtcbiAgICAgICAgICAgICAgICBpZihwID49IDApe1xuICAgICAgICAgICAgICAgICAgICAvL1RoaXMgYm9uZSBoYXMgYSBwYXJlbnQgYm9uZVxuICAgICAgICAgICAgICAgICAgICBpZighY29tcHV0ZWRbcF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9UaGUgcGFyZW50IGJvbmUncyB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggaGFzbid0IGJlZW4gY29tcHV0ZWQgeWV0XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZShwYXJlbnRbcF0gPj0gMCAmJiAhY29tcHV0ZWRbcGFyZW50W3BdXSkgcCA9IHBhcmVudFtwXTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYocGFyZW50W3BdID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHJlc3VsdCwgcCoxNiwgeGZvcm0sIHAqMTYsIHJlc3VsdCwgcGFyZW50W3BdKjE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbcCoxNitqXSA9IHhmb3JtW3AqMTYral07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29tcHV0ZWRbcF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQocmVzdWx0LCBpKjE2LCB4Zm9ybSwgaSoxNiwgcmVzdWx0LCAgcCoxNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpKjE2K2pdID0geGZvcm1baSoxNitqXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb21wdXRlZFtpXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5mb3J3YXJkS2luZW1hdGljc0ludlwiLCB7XG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDR4NCcsICBuYW1lOiAncmVzdWx0JywgY3VzdG9tQWxsb2M6IHRydWV9XSxcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2ludCcsICAgICAgIHNvdXJjZTogJ3BhcmVudCcsIGFycmF5OiB0cnVlIH0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDR4NCcsICBzb3VyY2U6ICd4Zm9ybScsIGFycmF5OiB0cnVlIH1dLFxuICAgIGFsbG9jOiBmdW5jdGlvbihzaXplcywgcGFyZW50LCB4Zm9ybSlcbiAgICB7XG4gICAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihwYXJlbnQubGVuZ3RoLCB4Zm9ybS5sZW5ndGggLyAxNik7XG4gICAgICAgIHNpemVzWydyZXN1bHQnXSA9IGxlbmd0aDtcbiAgICB9LFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHBhcmVudCx4Zm9ybSwgaW5mbykge1xuICAgICAgICB2YXIgYm9uZUNvdW50ID0geGZvcm0ubGVuZ3RoIC8gMTY7XG5cbiAgICAgICAgdmFyIGNvbXB1dGVkID0gW107XG4gICAgICAgIC8vRm9yIGVhY2ggYm9uZSBkbzpcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGJvbmVDb3VudDspe1xuICAgICAgICAgICAgaWYoIWNvbXB1dGVkW2ldKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwYXJlbnRbaV07XG4gICAgICAgICAgICAgICAgaWYocCA+PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgLy9UaGlzIGJvbmUgaGFzIGEgcGFyZW50IGJvbmVcbiAgICAgICAgICAgICAgICAgICAgaWYoIWNvbXB1dGVkW3BdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vVGhlIHBhcmVudCBib25lJ3MgdHJhbnNmb3JtYXRpb24gbWF0cml4IGhhc24ndCBiZWVuIGNvbXB1dGVkIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUocGFyZW50W3BdID49IDAgJiYgIWNvbXB1dGVkW3BhcmVudFtwXV0pIHAgPSBwYXJlbnRbcF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RoZSBjdXJyZW50IGJvbmUgaGFzIGEgcGFyZW50IGFuZCBpdHMgdHJhbnNmb3JtIGhhc24ndCBiZWVuIGNvbXB1dGVkIHlldFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihwYXJlbnRbcF0gPj0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQocmVzdWx0LCBwKjE2LCByZXN1bHQsIHBhcmVudFtwXSoxNiwgeGZvcm0sIHAqMTYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtwKjE2K2pdID0geGZvcm1bcCoxNitqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wdXRlZFtwXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QubWF0aC5tYXQ0Lm11bHRpcGx5T2Zmc2V0KHJlc3VsdCwgaSoxNiwgIHJlc3VsdCwgIHAqMTYsIHhmb3JtLCBpKjE2KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgMTY7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2kqMTYral0gPSB4Zm9ybVtpKjE2K2pdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbXB1dGVkW2ldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiLy8gQmFzZWQgb246IGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzEwMDYzOTI1L2h0dHA6Ly9kZW0ub2NyYWN5Lm9yZy9saWJlcm8vcGhvdG9ib290aC9cblxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmZ1bk1pcnJvckltYWdlXCIsIHtcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlJ30gXSxcbiAgICBwYXJhbXM6ICBbIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZSd9LFxuICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZSA6ICd0aW1lJ30gXSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSwgdGltZSkge1xuICAgICAgICB2YXIgd2lkdGggPSByZXN1bHQud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSByZXN1bHQuaGVpZ2h0O1xuICAgICAgICB2YXIgdGltZSA9IHRpbWVbMF07XG5cbiAgICAgICAgdmFyIHMgPSBpbWFnZS5kYXRhO1xuICAgICAgICB2YXIgZCA9IHJlc3VsdC5kYXRhO1xuXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuXG4gICAgICAgICAgICAgICAgLypvcmlnaW5hbCBjb29yZGluYXRlcyovXG4gICAgICAgICAgICAgICAgLy8gWzAuMCAsMS4wXSB4IFswLjAsIDEuMF1cbiAgICAgICAgICAgICAgICB2YXIgY29vcmRYID0geCAvIHdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciBjb29yZFkgPSB5IC8gaGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgLy8gWy0xLjAgLDEuMF0geCBbLTEuMCwgMS4wXVxuICAgICAgICAgICAgICAgIHZhciBub3JtQ29vcmRYID0gMi4wICogY29vcmRYIC0gMS4wO1xuICAgICAgICAgICAgICAgIHZhciBub3JtQ29vcmRZID0gMi4wICogY29vcmRZIC0gMS4wO1xuXG4gICAgICAgICAgICAgICAgLypnbyB0byBwb2xhciBjb29yZGluYXRlcyovXG4gICAgICAgICAgICAgICAgdmFyIHIgPSBNYXRoLnNxcnQobm9ybUNvb3JkWCpub3JtQ29vcmRYICsgbm9ybUNvb3JkWSpub3JtQ29vcmRZKTsgLy8gbGVuZ3RoKG5vcm1Db29yZClcbiAgICAgICAgICAgICAgICB2YXIgcGhpID0gTWF0aC5hdGFuMihub3JtQ29vcmRZLCBub3JtQ29vcmRYKTtcblxuICAgICAgICAgICAgICAgIC8qc3F1ZWV6ZSBhbmQgdmFyeSBpdCBvdmVyIHRpbWUqL1xuICAgICAgICAgICAgICAgIHIgPSBNYXRoLnBvdyhyLCAxLjAvMS44KSAqIHRpbWU7XG5cbiAgICAgICAgICAgICAgICAvKmJhY2sgdG8gY2FydGVzaWFuIGNvb3JkaW5hdGVzKi9cbiAgICAgICAgICAgICAgICBub3JtQ29vcmRYID0gciAqIE1hdGguY29zKHBoaSk7XG4gICAgICAgICAgICAgICAgbm9ybUNvb3JkWSA9IHIgKiBNYXRoLnNpbihwaGkpO1xuICAgICAgICAgICAgICAgIC8vIFswLjAgLDEuMF0geCBbMC4wLCAxLjBdXG4gICAgICAgICAgICAgICAgY29vcmRYID0gbm9ybUNvb3JkWCAvIDIuMCArIDAuNTtcbiAgICAgICAgICAgICAgICBjb29yZFkgPSBub3JtQ29vcmRZIC8gMi4wICsgMC41O1xuXG4gICAgICAgICAgICAgICAgdmFyIHNYID0gTWF0aC5yb3VuZChjb29yZFggKiB3aWR0aCk7XG4gICAgICAgICAgICAgICAgdmFyIHNZID0gTWF0aC5yb3VuZChjb29yZFkgKiBoZWlnaHQpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGkgPSAoc1kgKiB3aWR0aCArIHNYKSo0O1xuICAgICAgICAgICAgICAgIHZhciByID0gc1tpXTtcbiAgICAgICAgICAgICAgICB2YXIgZyA9IHNbaSArIDFdO1xuICAgICAgICAgICAgICAgIHZhciBiID0gc1tpICsgMl07XG4gICAgICAgICAgICAgICAgdmFyIGEgPSBzW2kgKyAzXTtcblxuICAgICAgICAgICAgICAgIC8qY29sb3IgdGhlIGZyYWdtZW50IHdpdGggY2FsY3VsYXRlZCB0ZXh0dXJlKi9cbiAgICAgICAgICAgICAgICB2YXIgaSA9ICh5ICogd2lkdGggKyB4KSo0O1xuICAgICAgICAgICAgICAgIGRbaV0gPSByO1xuICAgICAgICAgICAgICAgIGRbaSArIDFdID0gZztcbiAgICAgICAgICAgICAgICBkW2kgKyAyXSA9IGI7XG4gICAgICAgICAgICAgICAgZFtpICsgM10gPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuIiwiXG5mdW5jdGlvbiBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgY29tcG9uZW50cyl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGluZGV4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBvZmZzZXQgPSBpbmRleFtpXSAqIGNvbXBvbmVudHM7XG4gICAgICAgIHZhciBqID0gY29tcG9uZW50cztcbiAgICAgICAgd2hpbGUoai0tKSB7XG4gICAgICAgICAgICByZXN1bHRbaSpjb21wb25lbnRzICsgal0gPSB2YWx1ZVtvZmZzZXQgKyBqXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmdldFwiLCB7XG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdCcsIG5hbWU6ICdyZXN1bHQnfV0sXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50Jywgc291cmNlOiAnaW5kZXgnfV0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBpbmZvKSB7XG4gICAgICAgIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCAxKTtcbiAgICB9XG59KTtcblxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmdldFwiLCB7XG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDInLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQyJywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcbiAgICAgICAgZmV0Y2gocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIDIpO1xuICAgIH1cbn0pO1xuXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludCcsIHNvdXJjZTogJ2luZGV4J31dLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xuICAgICAgICBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgNCk7XG4gICAgfVxufSk7XG5cblxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmdldFwiLCB7XG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDQnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQ0Jywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcbiAgICAgICAgZmV0Y2gocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIDQpO1xuICAgIH1cbn0pO1xuXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0NHg0JywgbmFtZTogJ3Jlc3VsdCd9XSxcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0NHg0Jywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcbiAgICAgICAgZmV0Y2gocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIDE2KTtcbiAgICB9XG59KTtcblxuXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2ludCcsIG5hbWU6ICdyZXN1bHQnfV0sXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludCcsIHNvdXJjZTogJ2luZGV4J31dLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xuICAgICAgICBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgMSk7XG4gICAgfVxufSk7XG5cblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnYm9vbCcsIG5hbWU6ICdyZXN1bHQnfV0sXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdib29sJywgc291cmNlOiAndmFsdWUnLCBhcnJheTogdHJ1ZX0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICdpbmRleCd9XSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIGluZm8pIHtcbiAgICAgICAgZmV0Y2gocmVzdWx0LCB2YWx1ZSwgaW5kZXgsIDEpO1xuICAgIH1cbn0pO1xuXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ2V0XCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2J5dGUnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnYnl0ZScsIHNvdXJjZTogJ3ZhbHVlJywgYXJyYXk6IHRydWV9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50Jywgc291cmNlOiAnaW5kZXgnfV0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZGV4LCBpbmZvKSB7XG4gICAgICAgIGZldGNoKHJlc3VsdCwgdmFsdWUsIGluZGV4LCAxKTtcbiAgICB9XG59KTtcblxuXG5cblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5nZXRcIiwge1xuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAndWJ5dGUnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAndWJ5dGUnLCBzb3VyY2U6ICd2YWx1ZScsIGFycmF5OiB0cnVlfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2ludCcsIHNvdXJjZTogJ2luZGV4J31dLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBpbmRleCwgaW5mbykge1xuICAgICAgICBmZXRjaChyZXN1bHQsIHZhbHVlLCBpbmRleCwgMSk7XG4gICAgfVxufSk7XG4iLCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuZ3JheXNjYWxlSW1hZ2VcIiwge1xuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdyZXN1bHQnLCBzaXplb2YgOiAnaW1hZ2UnfSBdLFxuICAgIHBhcmFtczogIFsge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30gXSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSkge1xuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGltYWdlLmhlaWdodDtcblxuICAgICAgICB2YXIgcyA9IGltYWdlLmRhdGE7XG4gICAgICAgIHZhciBkID0gcmVzdWx0LmRhdGE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgdmFyIHIgPSBzW2ldO1xuICAgICAgICAgICAgdmFyIGcgPSBzW2kgKyAxXTtcbiAgICAgICAgICAgIHZhciBiID0gc1tpICsgMl07XG4gICAgICAgICAgICB2YXIgYSA9IHNbaSArIDNdO1xuICAgICAgICAgICAgLy8gQ0lFIGx1bWluYW5jZSBmb3IgdGhlIFJHQlxuICAgICAgICAgICAgLy8gVGhlIGh1bWFuIGV5ZSBpcyBiYWQgYXQgc2VlaW5nIHJlZCBhbmQgYmx1ZSwgc28gd2UgZGUtZW1waGFzaXplIHRoZW0uXG4gICAgICAgICAgICB2YXIgdiA9IDAuMjEyNiAqIHIgKyAwLjcxNTIgKiBnICsgMC4wNzIyICogYjtcbiAgICAgICAgICAgIGRbaV0gPSBkW2kgKyAxXSA9IGRbaSArIDJdID0gdlxuICAgICAgICAgICAgZFtpICsgM10gPSBhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuIiwicmVxdWlyZShcIi4vYWRkLmpzXCIpO1xucmVxdWlyZShcIi4vYnVmZmVyU2VsZWN0LmpzXCIpO1xucmVxdWlyZShcIi4vY2xhbXBJbWFnZS5qc1wiKTtcbnJlcXVpcmUoXCIuL2NvbnZvbHV0ZUltYWdlLmpzXCIpO1xucmVxdWlyZShcIi4vY3JlYXRlSUdJbmRleC5qc1wiKTtcbnJlcXVpcmUoXCIuL2NyZWF0ZVRyYW5zZm9ybS5qc1wiKTtcbnJlcXVpcmUoXCIuL2NyZWF0ZVRyYW5zZm9ybUludi5qc1wiKTtcbnJlcXVpcmUoXCIuL2RlYnVnLmpzXCIpO1xucmVxdWlyZShcIi4vZmxpcE5vcm1hbC5qc1wiKTtcbnJlcXVpcmUoXCIuL2ZsaXBWZXJ0aWNhbEltYWdlLmpzXCIpO1xucmVxdWlyZShcIi4vZm9yd2FyZEtpbmVtYXRpY3MuanNcIik7XG5yZXF1aXJlKFwiLi9mb3J3YXJkS2luZW1hdGljc0ludi5qc1wiKTtcbnJlcXVpcmUoXCIuL2Z1bk1pcnJvckltYWdlLmpzXCIpO1xucmVxdWlyZShcIi4vZ2V0LmpzXCIpO1xucmVxdWlyZShcIi4vZ3JheXNjYWxlSW1hZ2UuanNcIik7XG5yZXF1aXJlKFwiLi9sZXJwM3NlcS5qc1wiKTtcbnJlcXVpcmUoXCIuL21hZ25pdHVkZUltYWdlLmpzXCIpO1xucmVxdWlyZShcIi4vbWVyZ2UzLmpzXCIpO1xucmVxdWlyZShcIi4vbW9ycGgzLmpzXCIpO1xucmVxdWlyZShcIi4vbXVsNHg0LmpzXCIpO1xucmVxdWlyZShcIi4vbm9pc2VJbWFnZS5qc1wiKTtcbnJlcXVpcmUoXCIuL25vcm1hbGl6ZTMuanNcIik7XG5yZXF1aXJlKFwiLi9wb3BhcnRJbWFnZS5qc1wiKTtcbnJlcXVpcmUoXCIuL3JnYmVQTkd0b0Zsb2F0LmpzXCIpO1xucmVxdWlyZShcIi4vc2VsZWN0Qm9vbC5qc1wiKTtcbnJlcXVpcmUoXCIuL3NlbGVjdFRyYW5zZm9ybS5qc1wiKTtcbnJlcXVpcmUoXCIuL3NlcGlhSW1hZ2UuanNcIik7XG5yZXF1aXJlKFwiLi9za2luRGlyZWN0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vc2tpblBvc2l0aW9uLmpzXCIpO1xucmVxdWlyZShcIi4vc2xlcnBzZXEuanNcIik7XG5yZXF1aXJlKFwiLi9zb2JlbEltYWdlLmpzXCIpO1xucmVxdWlyZShcIi4vc3ViMy5qc1wiKTtcbiIsInZhciBiaW5hcnlTZWFyY2ggPSByZXF1aXJlKFwiLi4vLi4vdXRpbHMvdXRpbHNcIikuYmluYXJ5U2VhcmNoO1xudmFyIFhDID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG5cblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5sZXJwU2VxXCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdzZXF1ZW5jZSd9LFxuICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5J31dLFxuICAgIG1hcHBpbmc6IFsgIHsgbmFtZTogJ3ZhbHVlMScsIHNvdXJjZTogJ3NlcXVlbmNlJywgc2VxdWVuY2U6IFhDLlNFUVVFTkNFLlBSRVZfQlVGRkVSLCBrZXlTb3VyY2U6ICdrZXknfSxcbiAgICAgICAgeyBuYW1lOiAndmFsdWUyJywgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuTkVYVF9CVUZGRVIsIGtleVNvdXJjZTogJ2tleSd9LFxuICAgICAgICB7IG5hbWU6ICd3ZWlnaHQnLCBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5MSU5FQVJfV0VJR0hULCBrZXlTb3VyY2U6ICdrZXknfV0sXG4gICAgZXZhbHVhdGVfY29yZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMiwgd2VpZ2h0KXtcbiAgICAgICAgdmFyIGludldlaWdodCA9IDEgLSB3ZWlnaHRbMF07XG4gICAgICAgIHJlc3VsdFswXSA9IGludldlaWdodCp2YWx1ZTFbMF0gKyB3ZWlnaHRbMF0qdmFsdWUyWzBdO1xuICAgICAgICByZXN1bHRbMV0gPSBpbnZXZWlnaHQqdmFsdWUxWzFdICsgd2VpZ2h0WzBdKnZhbHVlMlsxXTtcbiAgICAgICAgcmVzdWx0WzJdID0gaW52V2VpZ2h0KnZhbHVlMVsyXSArIHdlaWdodFswXSp2YWx1ZTJbMl07XG4gICAgfVxufSk7XG5cblxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmxlcnBTZXFBc3luY1wiLCB7XG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAnc2VxdWVuY2UnfSxcbiAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ2tleSd9XSxcbiAgICBtYXBwaW5nOiBbICB7IG5hbWU6ICd2YWx1ZTEnLCBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5QUkVWX0JVRkZFUiwga2V5U291cmNlOiAna2V5J30sXG4gICAgICAgIHsgbmFtZTogJ3ZhbHVlMicsIHNvdXJjZTogJ3NlcXVlbmNlJywgc2VxdWVuY2U6IFhDLlNFUVVFTkNFLk5FWFRfQlVGRkVSLCBrZXlTb3VyY2U6ICdrZXknfSxcbiAgICAgICAgeyBuYW1lOiAnd2VpZ2h0Jywgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuTElORUFSX1dFSUdIVCwga2V5U291cmNlOiAna2V5J31dLFxuICAgIGV2YWx1YXRlX2FzeW5jOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlMSwgdmFsdWUyLCB3ZWlnaHQsIGluZm8sIGNhbGxiYWNrKXtcbiAgICAgICAgdmFyIGkgPSBpbmZvLml0ZXJhdGVDb3VudCwgb2ZmMCwgb2ZmMSwgb2ZmMjtcbiAgICAgICAgd2hpbGUoaS0tKXtcbiAgICAgICAgICAgIG9mZjAgPSAoaW5mby5pdGVyRmxhZ1swXSA/IGkgOiAwKSozO1xuICAgICAgICAgICAgb2ZmMSA9IChpbmZvLml0ZXJGbGFnWzFdID8gaSA6IDApKjM7XG4gICAgICAgICAgICBvZmYyID0gaW5mby5pdGVyRmxhZ1syXSA/IGkgOiAwO1xuICAgICAgICAgICAgdmFyIGludldlaWdodCA9IDEgLSB3ZWlnaHRbb2ZmMl07XG4gICAgICAgICAgICByZXN1bHRbaSozXSA9IGludldlaWdodCp2YWx1ZTFbb2ZmMF0gKyB3ZWlnaHRbb2ZmMl0qdmFsdWUyW29mZjFdO1xuICAgICAgICAgICAgcmVzdWx0W2kqMysxXSA9IGludldlaWdodCp2YWx1ZTFbb2ZmMCsxXSArIHdlaWdodFtvZmYyXSp2YWx1ZTJbb2ZmMSsxXTtcbiAgICAgICAgICAgIHJlc3VsdFtpKjMrMl0gPSBpbnZXZWlnaHQqdmFsdWUxW29mZjArMl0gKyB3ZWlnaHRbb2ZmMl0qdmFsdWUyW29mZjErMl07XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoY2FsbGJhY2ssIDIwMCk7XG4gICAgfVxufSk7XG5cblxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LmxlcnBLZXlzXCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnfV0sXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ2tleXMnLCBhcnJheTogdHJ1ZX0sXG4gICAgICAgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWVzJywgYXJyYXk6IHRydWV9LFxuICAgICAgICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5J31dLFxuICAgIGFsbG9jOiBmdW5jdGlvbihzaXplcywga2V5cywgdmFsdWVzLCBrZXkpXG4gICAge1xuICAgICAgICBzaXplc1sncmVzdWx0J10gPSAzO1xuICAgIH0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwga2V5cywgdmFsdWVzLCBrZXkpIHtcbiAgICAgICAgdmFyIG1heElkeCA9IE1hdGgubWluKGtleXMubGVuZ3RoLCBNYXRoLmZsb29yKHZhbHVlcy5sZW5ndGggLyAzKSk7XG4gICAgICAgIHZhciBpZHggPSBiaW5hcnlTZWFyY2goa2V5cywga2V5WzBdLCBtYXhJZHgpO1xuXG4gICAgICAgIGlmKGlkeCA8IDAgfHwgaWR4ID09IG1heElkeCAtIDEpe1xuICAgICAgICAgICAgaWR4ID0gTWF0aC5tYXgoMCxpZHgpO1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gdmFsdWVzWzMqaWR4XTtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IHZhbHVlc1szKmlkeCsxXTtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IHZhbHVlc1szKmlkeCsyXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgdmFyIHdlaWdodCA9IChrZXlbMF0gLSBrZXlzW2lkeF0pIC8gKGtleXNbaWR4KzFdIC0ga2V5c1tpZHhdKTtcbiAgICAgICAgICAgIHZhciBpbnZXZWlnaHQgPSAxIC0gd2VpZ2h0O1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gaW52V2VpZ2h0KnZhbHVlc1szKmlkeF0gKyB3ZWlnaHQqdmFsdWVzWzMqaWR4ICsgM107XG4gICAgICAgICAgICByZXN1bHRbMV0gPSBpbnZXZWlnaHQqdmFsdWVzWzMqaWR4KzFdICsgd2VpZ2h0KnZhbHVlc1szKmlkeCArIDRdO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gaW52V2VpZ2h0KnZhbHVlc1szKmlkeCsyXSArIHdlaWdodCp2YWx1ZXNbMyppZHggKyA1XTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblxuXG5cbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5tYWduaXR1ZGVJbWFnZVwiLCB7XG4gICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZiA6ICdpbWFnZTEnfSBdLFxuICAgIHBhcmFtczogIFtcbiAgICAgICAge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlMSd9LFxuICAgICAgICB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UyJ31cbiAgICBdLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGltYWdlMSwgaW1hZ2UyKSB7XG4gICAgICAgIHZhciBpbnBpeDEgPSBpbWFnZTEuZGF0YTtcbiAgICAgICAgdmFyIGlucGl4MiA9IGltYWdlMi5kYXRhO1xuICAgICAgICB2YXIgb3V0cGl4ID0gcmVzdWx0LmRhdGE7XG5cbiAgICAgICAgdmFyIGxlbiA9IGlucGl4MS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGxlbjsgaSs9MSkge1xuICAgICAgICAgICAgdmFyIHZhbDEgPSBpbnBpeDFbaV07XG4gICAgICAgICAgICB2YXIgdmFsMiA9IGlucGl4MltpXTtcbiAgICAgICAgICAgIG91dHBpeFtpXSA9IE1hdGguc3FydCh2YWwxKnZhbDEgKyB2YWwyKnZhbDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn0pO1xuIiwiXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cubWVyZ2UzXCIsIHtcbiAgICBvdXRwdXRzOiBbe25hbWU6ICdyZXN1bHQnLCB0dXBsZVNpemU6ICcxNid9XSxcbiAgICBwYXJhbXM6ICBbJ3ZhbHVlMScsJ3ZhbHVlMicsJ3ZhbHVlMyddLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMiwgdmFsdWUzKSB7XG4gICAgICAgIGlmKCEodmFsdWUxICYmIHZhbHVlMiAmJiB2YWx1ZTMpKVxuICAgICAgICAgICAgdGhyb3cgXCJYZmxvdzo6bW9ycGgzOiBOb3QgYWxsIHBhcmFtZXRlcnMgYXJlIHNldFwiO1xuXG4gICAgICAgIHZhciBvdmVyYWxsTGVuZ3RoID0gdmFsdWUxLmxlbmd0aCArIHZhbHVlMi5sZW5ndGggKyB2YWx1ZTMubGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMudG1wIHx8IHRoaXMudG1wLmxlbmd0aCAhPSBvdmVyYWxsTGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy50bXAgPSBuZXcgRmxvYXQzMkFycmF5KG92ZXJhbGxMZW5ndGgpO1xuXG4gICAgICAgIHRoaXMudG1wLnNldCh2YWx1ZTEpO1xuICAgICAgICB0aGlzLnRtcC5zZXQodmFsdWUyLCB2YWx1ZTEubGVuZ3RoKTtcbiAgICAgICAgdGhpcy50bXAuc2V0KHZhbHVlMywgdmFsdWUxLmxlbmd0aCArIHZhbHVlMi5sZW5ndGgpO1xuICAgICAgICB0aGlzLnJlc3VsdC5yZXN1bHQgPSB0aGlzLnRtcDtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cubWVyZ2U4XCIsIHtcbiAgICBvdXRwdXRzOiBbe25hbWU6ICdyZXN1bHQnLCB0dXBsZVNpemU6ICcxNid9XSxcbiAgICBwYXJhbXM6ICBbJ3ZhbHVlMScsJ3ZhbHVlMicsJ3ZhbHVlMycsJ3ZhbHVlNCcsJ3ZhbHVlNScsJ3ZhbHVlNicsJ3ZhbHVlNycsJ3ZhbHVlOCddLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbih2YWx1ZTEsIHZhbHVlMiwgdmFsdWUzLHZhbHVlNCx2YWx1ZTUsdmFsdWU2LHZhbHVlNyx2YWx1ZTgpIHtcbiAgICAgICAgaWYoISh2YWx1ZTEgJiYgdmFsdWUyICYmIHZhbHVlMyAmJiB2YWx1ZTQgJiYgdmFsdWU1ICYmIHZhbHVlNiAmJiB2YWx1ZTcgJiYgdmFsdWU4KSlcbiAgICAgICAgICAgIHRocm93IFwiWGZsb3c6Om1vcnBoMzogTm90IGFsbCBwYXJhbWV0ZXJzIGFyZSBzZXRcIjtcblxuICAgICAgICB2YXIgb3ZlcmFsbExlbmd0aCA9IHZhbHVlMS5sZW5ndGggKyB2YWx1ZTIubGVuZ3RoICsgdmFsdWUzLmxlbmd0aCArIHZhbHVlNC5sZW5ndGggKyB2YWx1ZTUubGVuZ3RoICsgdmFsdWU2Lmxlbmd0aCArIHZhbHVlNy5sZW5ndGggKyB2YWx1ZTgubGVuZ3RoO1xuICAgICAgICBpZiAoIXRoaXMudG1wIHx8IHRoaXMudG1wLmxlbmd0aCAhPSBvdmVyYWxsTGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy50bXAgPSBuZXcgRmxvYXQzMkFycmF5KG92ZXJhbGxMZW5ndGgpO1xuXG4gICAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLnRtcC5zZXQodmFsdWUxLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLnRtcC5zZXQodmFsdWUyLCAob2Zmc2V0Kz12YWx1ZTEubGVuZ3RoKSk7XG4gICAgICAgIHRoaXMudG1wLnNldCh2YWx1ZTMsIChvZmZzZXQrPXZhbHVlMi5sZW5ndGgpKTtcbiAgICAgICAgdGhpcy50bXAuc2V0KHZhbHVlNCwgKG9mZnNldCs9dmFsdWUzLmxlbmd0aCkpO1xuICAgICAgICB0aGlzLnRtcC5zZXQodmFsdWU1LCAob2Zmc2V0Kz12YWx1ZTQubGVuZ3RoKSk7XG4gICAgICAgIHRoaXMudG1wLnNldCh2YWx1ZTYsIChvZmZzZXQrPXZhbHVlNS5sZW5ndGgpKTtcbiAgICAgICAgdGhpcy50bXAuc2V0KHZhbHVlNywgKG9mZnNldCs9dmFsdWU2Lmxlbmd0aCkpO1xuICAgICAgICB0aGlzLnRtcC5zZXQodmFsdWU4LCAob2Zmc2V0Kz12YWx1ZTcubGVuZ3RoKSk7XG4gICAgICAgIHRoaXMucmVzdWx0LnJlc3VsdCA9IHRoaXMudG1wO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcbiIsIlxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93Lm1vcnBoXCIsIHtcbiAgICBvdXRwdXRzOiBbe3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFtcbiAgICAgICAgeyB0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWUnIH0sXG4gICAgICAgIHsgdHlwZTogJ2Zsb2F0MycsIHNvdXJjZTogJ3ZhbHVlQWRkJ30sXG4gICAgICAgIHsgdHlwZTogJ2Zsb2F0Jywgc291cmNlOiAnd2VpZ2h0J31cbiAgICBdLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCB2YWx1ZUFkZCwgd2VpZ2h0LCBpbmZvKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbmZvLml0ZXJhdGVDb3VudDsgaSsrKXtcbiAgICAgICAgICAgIHZhciB3ID0gd2VpZ2h0W2luZm8uaXRlckZsYWdbMl0gPyBpIDogMF07XG4gICAgICAgICAgICByZXN1bHRbMyppXSA9IHZhbHVlWyBpbmZvLml0ZXJGbGFnWzBdID8gMyppIDogMF0gKyB3ICogdmFsdWVBZGRbaW5mby5pdGVyRmxhZ1sxXSA/IDMqaSA6IDBdO1xuICAgICAgICAgICAgcmVzdWx0WzMqaSsxXSA9IHZhbHVlWyBpbmZvLml0ZXJGbGFnWzBdID8gMyppKzEgOiAxXSArIHcgKiB2YWx1ZUFkZFtpbmZvLml0ZXJGbGFnWzFdID8gMyppKzEgOiAxXTtcbiAgICAgICAgICAgIHJlc3VsdFszKmkrMl0gPSB2YWx1ZVsgaW5mby5pdGVyRmxhZ1swXSA/IDMqaSsyIDogMl0gKyB3ICogdmFsdWVBZGRbaW5mby5pdGVyRmxhZ1sxXSA/IDMqaSsyIDogMl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBldmFsdWF0ZV9jb3JlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCB2YWx1ZUFkZCwgd2VpZ2h0KXtcbiAgICAgICAgcmVzdWx0WzBdID0gdmFsdWVbMF0gKyB3ZWlnaHRbMF0gKiB2YWx1ZUFkZFswXTtcbiAgICAgICAgcmVzdWx0WzFdID0gdmFsdWVbMV0gKyB3ZWlnaHRbMF0gKiB2YWx1ZUFkZFsxXTtcbiAgICAgICAgcmVzdWx0WzJdID0gdmFsdWVbMl0gKyB3ZWlnaHRbMF0gKiB2YWx1ZUFkZFsyXTtcbiAgICB9XG59KTtcbiIsIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5tdWxcIiwge1xuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQ0eDQnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQ0eDQnLCBzb3VyY2U6ICd2YWx1ZTEnfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NHg0Jywgc291cmNlOiAndmFsdWUyJ31dLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIHZhbHVlMSwgdmFsdWUyLCBpbmZvKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbmZvLml0ZXJhdGVDb3VudDsgaSsrKVxuICAgICAgICB7XG4gICAgICAgICAgICBYTUwzRC5tYXRoLm1hdDQubXVsdGlwbHlPZmZzZXQocmVzdWx0LCBpKjE2LFxuICAgICAgICAgICAgICAgIHZhbHVlMSwgIGluZm8uaXRlckZsYWdbMF0gPyBpKjE2IDogMCxcbiAgICAgICAgICAgICAgICB2YWx1ZTIsIGluZm8uaXRlckZsYWdbMV0gPyBpKjE2IDogMCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIlxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93Lm5vaXNlSW1hZ2VcIiwge1xuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdpbWFnZScsIGN1c3RvbUFsbG9jOiB0cnVlfSBdLFxuICAgIHBhcmFtczogIFsge3R5cGU6ICdpbnQnLCBzb3VyY2U6ICd3aWR0aCd9LFxuICAgICAgICAgICAgICAge3R5cGU6ICdpbnQnLCBzb3VyY2U6J2hlaWdodCd9LFxuICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDInLCBzb3VyY2U6ICdzY2FsZSd9LFxuICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdCcsIHNvdXJjZTogJ21pbkZyZXEnfSxcbiAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdtYXhGcmVxJ30gXSxcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIHdpZHRoLCBoZWlnaHQsIHNjYWxlLCBtaW5GcmVxLCBtYXhGcmVxKSB7XG4gICAgICAgIHZhciBzYW1wbGVyQ29uZmlnID0gbmV3IFhmbG93LlNhbXBsZXJDb25maWc7XG4gICAgICAgIHNhbXBsZXJDb25maWcuc2V0RGVmYXVsdHMoKTtcbiAgICAgICAgc2l6ZXNbJ2ltYWdlJ10gPSB7XG4gICAgICAgICAgICBpbWFnZUZvcm1hdCA6IHt3aWR0aDogd2lkdGhbMF0sIGhlaWdodCA6aGVpZ2h0WzBdfSxcbiAgICAgICAgICAgIHNhbXBsZXJDb25maWcgOiBzYW1wbGVyQ29uZmlnXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24oaW1hZ2UsIHdpZHRoLCBoZWlnaHQsIHNjYWxlLCBtaW5GcmVxLCBtYXhGcmVxKSB7XG4gICAgICAgIHdpZHRoID0gd2lkdGhbMF07XG4gICAgICAgIGhlaWdodCA9IGhlaWdodFswXTtcbiAgICAgICAgbWluRnJlcSA9IG1pbkZyZXFbMF07XG4gICAgICAgIG1heEZyZXEgPSBtYXhGcmVxWzBdO1xuXG4gICAgICAgIHZhciBpZCA9IGltYWdlO1xuICAgICAgICB2YXIgcGl4ID0gaWQuZGF0YTtcbiAgICAgICAgdGhpcy5ub2lzZSA9IHRoaXMubm9pc2UgfHwgbmV3IFNpbXBsZXhOb2lzZSgpO1xuICAgICAgICB2YXIgbm9pc2UgPSB0aGlzLm5vaXNlO1xuXG4gICAgICAgIHZhciB1c2VUdXJidWxlbmNlID0gbWluRnJlcSAhPSAwLjAgJiYgbWF4RnJlcSAhPSAwLjAgJiYgbWluRnJlcSA8IG1heEZyZXE7XG5cbiAgICAgICAgdmFyIHNub2lzZSA9IGZ1bmN0aW9uKHgseSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vaXNlLm5vaXNlKHgsIHkpOyAvLyBub2lzZS5ub2lzZSByZXR1cm5zIHZhbHVlcyBpbiByYW5nZSBbLTEsMV1cbiAgICAgICAgICAgIC8vcmV0dXJuIDIuMCAqIG5vaXNlLm5vaXNlKHgsIHkpIC0gMS4wOyAvLyB0aGlzIGNvZGUgaXMgZm9yIG5vaXNlIHZhbHVlIGluIHJhbmdlIFswLDFdXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHR1cmJ1bGVuY2UgPSBmdW5jdGlvbihtaW5GcmVxLCBtYXhGcmVxLCBzLCB0KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgZiA9IG1pbkZyZXE7IGYgPCBtYXhGcmVxOyBmICo9IDIpXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gTWF0aC5hYnMoc25vaXNlKHMgKiBmLCB0ICogZikpL2Y7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSlcbiAgICAgICAge1xuICAgICAgICAgICAgdmFyIHQgPSB5IC8gaGVpZ2h0ICogc2NhbGVbMV07XG4gICAgICAgICAgICB2YXIgaW52V2lkdGggPSAxLjAgLyB3aWR0aDtcblxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBzID0geCAqIGludldpZHRoICogc2NhbGVbMF07XG4gICAgICAgICAgICAgICAgdmFyIHYgPSB1c2VUdXJidWxlbmNlID8gdHVyYnVsZW5jZShtaW5GcmVxLCBtYXhGcmVxLCBzLCB0KSA6IHNub2lzZShzLCB0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0ID0gKHggKiB3aWR0aCArIHkpICogNDtcbiAgICAgICAgICAgICAgICBwaXhbb2Zmc2V0XSA9ICBNYXRoLmZsb29yKHYgKiAyNTUpO1xuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXQrMV0gPSBNYXRoLmZsb29yKHYgKiAyNTUpO1xuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXQrMl0gPSBNYXRoLmZsb29yKHYgKiAyNTUpO1xuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXQrM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBGaWxsIHdpdGggZ3JlZW4gY29sb3JcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoeCAqIHdpZHRoICsgeSkgKiA0O1xuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXRdID0gIDBcbiAgICAgICAgICAgICAgICBwaXhbb2Zmc2V0KzFdID0gMjU1O1xuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXQrMl0gPSAwO1xuICAgICAgICAgICAgICAgIHBpeFtvZmZzZXQrM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKi9cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcbiIsIlxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93Lm5vcm1hbGl6ZVwiLCB7XG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWUnfV0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGluZm8pIHtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGluZm8uaXRlcmF0ZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSAzKmk7XG4gICAgICAgICAgICB2YXIgeCA9IHZhbHVlW29mZnNldF07XG4gICAgICAgICAgICB2YXIgeSA9IHZhbHVlW29mZnNldCsxXTtcbiAgICAgICAgICAgIHZhciB6ID0gdmFsdWVbb2Zmc2V0KzJdO1xuICAgICAgICAgICAgdmFyIGwgPSAxLjAvTWF0aC5zcXJ0KHgqeCt5Knkreip6KTtcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXRdID0geCpsO1xuICAgICAgICAgICAgcmVzdWx0W29mZnNldCsxXSA9IHkqbDtcbiAgICAgICAgICAgIHJlc3VsdFtvZmZzZXQrMl0gPSB6Kmw7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIlxuLy8gQmFzZWQgb24gaHR0cDovL2tvZGVtb25na2kuYmxvZ3Nwb3QuZGUvMjAxMS8wNi9rYW1lcmFrdS1jdXN0b20tc2hhZGVyLWVmZmVjdHMtZXhhbXBsZS5odG1sXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cucG9wYXJ0SW1hZ2VcIiwge1xuICAgIG91dHB1dHM6IFsge3R5cGU6ICd0ZXh0dXJlJywgbmFtZSA6ICdyZXN1bHQnLCBzaXplb2YgOiAnaW1hZ2UnfSBdLFxuICAgIHBhcmFtczogIFsge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ30sXG4gICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2UgOiAndGltZSd9IF0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UsIHRpbWUpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHMgPSBpbWFnZS5kYXRhO1xuICAgICAgICB2YXIgZCA9IHJlc3VsdC5kYXRhO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICAgIHZhciByID0gc1tpXSAvIDI1NTtcbiAgICAgICAgICAgIHZhciBnID0gc1tpICsgMV0gLyAyNTU7XG4gICAgICAgICAgICB2YXIgYiA9IHNbaSArIDJdIC8gMjU1O1xuICAgICAgICAgICAgdmFyIGEgPSBzW2kgKyAzXSAvIDI1NTtcblxuICAgICAgICAgICAgdmFyIHkgPSAwLjMgKiByICsgMC41OSAqIGcgKyAwLjExICogYjtcbiAgICAgICAgICAgIHkgPSB5IDwgMC4zID8gMC4wIDogKHkgPCAwLjYgPyAwLjUgOiAxLjApO1xuICAgICAgICAgICAgaWYgKHkgPT0gMC41KSB7XG4gICAgICAgICAgICAgICAgZFtpXSAgID0gMC44ICogMjU1O1xuICAgICAgICAgICAgICAgIGRbaSsxXSA9IDA7XG4gICAgICAgICAgICAgICAgZFtpKzJdID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeSA9PSAxLjApIHtcbiAgICAgICAgICAgICAgICBkW2ldICAgPSAwLjkgKiAyNTU7XG4gICAgICAgICAgICAgICAgZFtpKzFdID0gMC45ICogMjU1O1xuICAgICAgICAgICAgICAgIGRbaSsyXSA9IDA7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRbaV0gPSAwO1xuICAgICAgICAgICAgICAgIGRbaSsxXSA9IDA7XG4gICAgICAgICAgICAgICAgZFtpKzJdID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRbaSszXSA9IHNbaSszXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcbiIsInZhciBTYW1wbGVyQ29uZmlnID0gcmVxdWlyZShcIi4uLy4uL2ludGVyZmFjZS9kYXRhLmpzXCIpLlNhbXBsZXJDb25maWc7XG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcblxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnJnYmVQTkd0b0Zsb2F0XCIsIHtcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0JywgY3VzdG9tQWxsb2M6IHRydWUgfSBdLFxuICAgIHBhcmFtczogIFtcbiAgICAgICAge3R5cGU6ICd0ZXh0dXJlJywgc291cmNlIDogJ2ltYWdlJ31cbiAgICBdLFxuICAgIGFsbG9jOiBmdW5jdGlvbiAoc2l6ZXMsIGltYWdlKSB7XG4gICAgICAgIHZhciBzYW1wbGVyQ29uZmlnID0gbmV3IFNhbXBsZXJDb25maWc7XG4gICAgICAgIHNhbXBsZXJDb25maWcuc2V0RGVmYXVsdHMoKTtcbiAgICAgICAgc2FtcGxlckNvbmZpZy5taW5GaWx0ZXIgPSBYQy5URVhfRklMVEVSX1RZUEUuTkVBUkVTVDtcbiAgICAgICAgc2FtcGxlckNvbmZpZy5tYWdGaWx0ZXIgPSBYQy5URVhfRklMVEVSX1RZUEUuTkVBUkVTVDtcbiAgICAgICAgc2l6ZXNbXCJyZXN1bHRcIl0gPSB7XG4gICAgICAgICAgICBpbWFnZUZvcm1hdCA6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogaW1hZ2Uud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpbWFnZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgdGV4ZWxUeXBlOiBYQy5URVhUVVJFX1RZUEUuRkxPQVQsXG4gICAgICAgICAgICAgICAgdGV4ZWxGb3JtYXQ6IFhDLlRFWFRVUkVfRk9STUFULlJHQlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNhbXBsZXJDb25maWc6IHNhbXBsZXJDb25maWdcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbWFnZSkge1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBpbWFnZS5kYXRhLmxlbmd0aDsgaWR4ICs9IDQpIHtcbiAgICAgICAgICAgIHZhciByZ2JlID0gaW1hZ2UuZGF0YS5zdWJhcnJheShpZHgsIGlkeCArIDQpO1xuICAgICAgICAgICAgdmFyIGYgPSAwLjA7XG4gICAgICAgICAgICB2YXIgZSA9IHJnYmVbM107XG5cbiAgICAgICAgICAgIGlmIChlID4gMC4wKVxuICAgICAgICAgICAgICAgIGYgPSBNYXRoLnBvdygyLjAsIGUgLSAoMTI4LjAgKyA4LjApKTtcblxuICAgICAgICAgICAgdmFyIHJnYiA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgICAgICAgICByZ2JbMF0gPSByZ2JlWzBdICogZjtcbiAgICAgICAgICAgIHJnYlsxXSA9IHJnYmVbMV0gKiBmO1xuICAgICAgICAgICAgcmdiWzJdID0gcmdiZVsyXSAqIGY7XG4gICAgICAgICAgICByZXN1bHQuZGF0YS5zZXQocmdiLCBpZHggLyA0ICogMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufSk7XG4iLCJcblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5zZWxlY3RCb29sXCIsIHtcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAnYm9vbCcsIG5hbWUgOiAncmVzdWx0JywgY3VzdG9tQWxsb2M6IHRydWV9IF0sXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ2ludCcsIHNvdXJjZSA6ICdpbmRleCd9LFxuICAgICAgICAgICAgICAge3R5cGU6ICdib29sJywgc291cmNlOiAndmFsdWUnfSBdLFxuICAgIGFsbG9jOiBmdW5jdGlvbihzaXplcywgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIHNpemVzWydyZXN1bHQnXSA9IDE7XG4gICAgfSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGkgPSBpbmRleFswXTtcbiAgICAgICAgaWYgKGkgPCB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHZhbHVlW2ldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59KTtcbiIsIlxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnNlbGVjdFRyYW5zZm9ybVwiLCB7XG4gICAgb3V0cHV0czogWyB7dHlwZTogJ2Zsb2F0NHg0JywgbmFtZSA6ICdyZXN1bHQnLCBjdXN0b21BbGxvYzogdHJ1ZX0gXSxcbiAgICBwYXJhbXM6ICBbIHt0eXBlOiAnaW50Jywgc291cmNlIDogJ2luZGV4J30sXG4gICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NHg0Jywgc291cmNlOiAndHJhbnNmb3JtJ30gXSxcbiAgICBhbGxvYzogZnVuY3Rpb24oc2l6ZXMsIGluZGV4LCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgc2l6ZXNbJ3Jlc3VsdCddID0gMTtcbiAgICB9LFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGluZGV4LCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIGkgPSAxNiAqIGluZGV4WzBdO1xuICAgICAgICBpZiAoaSA8IHRyYW5zZm9ybS5sZW5ndGggJiYgaSsxNSA8IHRyYW5zZm9ybS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdFswXSA9IHRyYW5zZm9ybVtpKzBdO1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdHJhbnNmb3JtW2krMV07XG4gICAgICAgICAgICByZXN1bHRbMl0gPSB0cmFuc2Zvcm1baSsyXTtcbiAgICAgICAgICAgIHJlc3VsdFszXSA9IHRyYW5zZm9ybVtpKzNdO1xuICAgICAgICAgICAgcmVzdWx0WzRdID0gdHJhbnNmb3JtW2krNF07XG4gICAgICAgICAgICByZXN1bHRbNV0gPSB0cmFuc2Zvcm1baSs1XTtcbiAgICAgICAgICAgIHJlc3VsdFs2XSA9IHRyYW5zZm9ybVtpKzZdO1xuICAgICAgICAgICAgcmVzdWx0WzddID0gdHJhbnNmb3JtW2krN107XG4gICAgICAgICAgICByZXN1bHRbOF0gPSB0cmFuc2Zvcm1baSs4XTtcbiAgICAgICAgICAgIHJlc3VsdFs5XSA9IHRyYW5zZm9ybVtpKzldO1xuICAgICAgICAgICAgcmVzdWx0WzEwXSA9IHRyYW5zZm9ybVtpKzEwXTtcbiAgICAgICAgICAgIHJlc3VsdFsxMV0gPSB0cmFuc2Zvcm1baSsxMV07XG4gICAgICAgICAgICByZXN1bHRbMTJdID0gdHJhbnNmb3JtW2krMTJdO1xuICAgICAgICAgICAgcmVzdWx0WzEzXSA9IHRyYW5zZm9ybVtpKzEzXTtcbiAgICAgICAgICAgIHJlc3VsdFsxNF0gPSB0cmFuc2Zvcm1baSsxNF07XG4gICAgICAgICAgICByZXN1bHRbMTVdID0gdHJhbnNmb3JtW2krMTVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gMTtcbiAgICAgICAgICAgIHJlc3VsdFsxXSA9IDA7XG4gICAgICAgICAgICByZXN1bHRbMl0gPSAwO1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gMDtcbiAgICAgICAgICAgIHJlc3VsdFs0XSA9IDA7XG4gICAgICAgICAgICByZXN1bHRbNV0gPSAxO1xuICAgICAgICAgICAgcmVzdWx0WzZdID0gMDtcbiAgICAgICAgICAgIHJlc3VsdFs3XSA9IDA7XG4gICAgICAgICAgICByZXN1bHRbOF0gPSAwO1xuICAgICAgICAgICAgcmVzdWx0WzldID0gMDtcbiAgICAgICAgICAgIHJlc3VsdFsxMF0gPSAxO1xuICAgICAgICAgICAgcmVzdWx0WzExXSA9IDA7XG4gICAgICAgICAgICByZXN1bHRbMTJdID0gMDtcbiAgICAgICAgICAgIHJlc3VsdFsxM10gPSAwO1xuICAgICAgICAgICAgcmVzdWx0WzE0XSA9IDA7XG4gICAgICAgICAgICByZXN1bHRbMTVdID0gMTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuc2VwaWFJbWFnZVwiLCB7XG4gICAgb3V0cHV0czogWyB7dHlwZTogJ3RleHR1cmUnLCBuYW1lIDogJ3Jlc3VsdCcsIHNpemVvZiA6ICdpbWFnZSd9IF0sXG4gICAgcGFyYW1zOiAgWyB7dHlwZTogJ3RleHR1cmUnLCBzb3VyY2UgOiAnaW1hZ2UnfSBdLFxuICAgIGV2YWx1YXRlOiBmdW5jdGlvbihyZXN1bHQsIGltYWdlKSB7XG4gICAgICAgIHZhciBzID0gaW1hZ2UuZGF0YTtcbiAgICAgICAgdmFyIGQgPSByZXN1bHQuZGF0YTtcbiAgICAgICAgdmFyIHIgPSAwLCBnID0gMCwgYiA9IDA7XG4gICAgICAgIGZvcih2YXIgaSA9IDAgOyBpIDwgcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgciA9IChzW2ldICogMC4zOTMgKyBzW2krMV0gKiAwLjc2OSArIHNbaSsyXSAqIDAuMTg5KTtcbiAgICAgICAgICAgIGcgPSAoc1tpXSAqIDAuMzQ5ICsgc1tpKzFdICogMC42ODYgKyBzW2krMl0gKiAwLjE2OCk7XG4gICAgICAgICAgICBiID0gKHNbaV0gKiAwLjI3MiArIHNbaSsxXSAqIDAuNTM0ICsgc1tpKzJdICogMC4xMzEpO1xuICAgICAgICAgICAgaWYgKHI+MjU1KSByID0gMjU1O1xuICAgICAgICAgICAgaWYgKGc+MjU1KSBnID0gMjU1O1xuICAgICAgICAgICAgaWYgKGI+MjU1KSBiID0gMjU1O1xuICAgICAgICAgICAgaWYgKHI8MCkgciA9IDA7XG4gICAgICAgICAgICBpZiAoZzwwKSBnID0gMDtcbiAgICAgICAgICAgIGlmIChiPDApIGIgPSAwO1xuICAgICAgICAgICAgZFtpXSA9IHI7XG4gICAgICAgICAgICBkW2krMV0gPSBnO1xuICAgICAgICAgICAgZFtpKzJdID0gYjtcbiAgICAgICAgICAgIGRbaSszXSA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcbiIsIlxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnNraW5EaXJlY3Rpb25cIiwge1xuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQzJywgbmFtZTogJ3Jlc3VsdCcgfV0sXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICdkaXInIH0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdpbnQ0Jywgc291cmNlOiAnYm9uZUlkeCcgfSxcbiAgICAgICAgICAgICAgICB7dHlwZTogJ2Zsb2F0NCcsIHNvdXJjZTogJ2JvbmVXZWlnaHQnIH0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDR4NCcsIHNvdXJjZTogJ2JvbmVYZm9ybScsIGFycmF5OiB0cnVlIH0gXSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBkaXIsYm9uZUlkeCxib25lV2VpZ2h0LGJvbmVYZm9ybSwgaW5mbykge1xuICAgICAgICB2YXIgdmVjMyA9IFhNTDNELm1hdGgudmVjMyxcbiAgICAgICAgICAgIG1hdDQgPSBYTUwzRC5tYXRoLm1hdDQ7XG4gICAgICAgIHZhciByID0gdmVjMy5jcmVhdGUoKTtcbiAgICAgICAgdmFyIHRtcCA9ICB2ZWMzLmNyZWF0ZSgpO1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGk8IGluZm8uaXRlcmF0ZUNvdW50OysraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkqMztcbiAgICAgICAgICAgIHJbMF0gPSByWzFdID0gclsyXSA9ICswO1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBib25lV2VpZ2h0W2luZm8uaXRlckZsYWdbMl0gPyBpKjQraiA6IGpdO1xuICAgICAgICAgICAgICAgIGlmICh3ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vID0gYm9uZUlkeFtpbmZvLml0ZXJGbGFnWzFdID8gaSo0K2ogOiBqXSoxNjtcblxuICAgICAgICAgICAgICAgICAgICBtYXQ0Lm11bHRpcGx5T2Zmc2V0RGlyZWN0aW9uKGJvbmVYZm9ybSwgbW8sIGRpciwgb2Zmc2V0LCB0bXApO1xuICAgICAgICAgICAgICAgICAgICB2ZWMzLnNjYWxlKHRtcCwgdG1wLCB3ZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICB2ZWMzLmFkZChyLCByLCB0bXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZlYzMubm9ybWFsaXplKHIsIHIpO1xuICAgICAgICAgICAgcmVzdWx0W29mZnNldF0gPSByWzBdO1xuICAgICAgICAgICAgcmVzdWx0W29mZnNldCsxXSA9IHJbMV07XG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0KzJdID0gclsyXTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiXG5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yKFwieGZsb3cuc2tpblBvc2l0aW9uXCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0MycsIG5hbWU6ICdyZXN1bHQnIH1dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAncG9zJyB9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiAnaW50NCcsIHNvdXJjZTogJ2JvbmVJZHgnIH0sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICdib25lV2VpZ2h0JyB9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQ0eDQnLCBzb3VyY2U6ICdib25lWGZvcm0nLCBhcnJheTogdHJ1ZSB9IF0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgcG9zLGJvbmVJZHgsYm9uZVdlaWdodCxib25lWGZvcm0sIGluZm8pIHtcbiAgICAgICAgdmFyIHZlYzMgPSBYTUwzRC5tYXRoLnZlYzMsXG4gICAgICAgICAgICBtYXQ0ID0gWE1MM0QubWF0aC5tYXQ0O1xuICAgICAgICB2YXIgciA9IHZlYzMuY3JlYXRlKCk7XG4gICAgICAgIHZhciB0bXAgPSAgdmVjMy5jcmVhdGUoKTtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpPCBpbmZvLml0ZXJhdGVDb3VudDsrK2kpIHtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBpKjM7XG4gICAgICAgICAgICByWzBdID0gclsxXSA9IHJbMl0gPSArMDtcbiAgICAgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCA0OyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gYm9uZVdlaWdodFtpbmZvLml0ZXJGbGFnWzJdID8gaSo0K2ogOiBqXTtcbiAgICAgICAgICAgICAgICBpZiAod2VpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtbyA9IGJvbmVJZHhbaW5mby5pdGVyRmxhZ1sxXSA/IGkqNCtqIDogal0qMTY7XG5cbiAgICAgICAgICAgICAgICAgICAgbWF0NC5tdWx0aXBseU9mZnNldFZlYzMoYm9uZVhmb3JtLCBtbywgcG9zLCBvZmZzZXQsIHRtcCk7XG4gICAgICAgICAgICAgICAgICAgIHZlYzMuc2NhbGUodG1wLCB0bXAsIHdlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIHZlYzMuYWRkKHIsIHIsIHRtcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0W29mZnNldF0gPSByWzBdO1xuICAgICAgICAgICAgcmVzdWx0W29mZnNldCsxXSA9IHJbMV07XG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0KzJdID0gclsyXTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwidmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoXCIuLi8uLi91dGlscy91dGlsc1wiKS5iaW5hcnlTZWFyY2g7XG52YXIgWEMgPSByZXF1aXJlKFwiLi4vLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcblxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnNsZXJwU2VxXCIsIHtcbiAgICBvdXRwdXRzOiBbICB7dHlwZTogJ2Zsb2F0NCcsIG5hbWU6ICdyZXN1bHQnfV0sXG4gICAgcGFyYW1zOiAgWyAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICdzZXF1ZW5jZSd9LFxuICAgICAgICAgICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdrZXknfV0sXG4gICAgbWFwcGluZzogWyAge25hbWU6ICd2YWx1ZTEnLCBzb3VyY2U6ICdzZXF1ZW5jZScsIHNlcXVlbmNlOiBYQy5TRVFVRU5DRS5QUkVWX0JVRkZFUiwga2V5U291cmNlOiAna2V5J30sXG4gICAgICAgICAgICAgICAge25hbWU6ICd2YWx1ZTInLCAgc291cmNlOiAnc2VxdWVuY2UnLCBzZXF1ZW5jZTogWEMuU0VRVUVOQ0UuTkVYVF9CVUZGRVIsIGtleVNvdXJjZTogJ2tleSd9LFxuICAgICAgICAgICAgICAgIHtuYW1lOiAnd2VpZ2h0JywgIHNvdXJjZTogJ3NlcXVlbmNlJywgc2VxdWVuY2U6IFhDLlNFUVVFTkNFLkxJTkVBUl9XRUlHSFQsIGtleVNvdXJjZTogJ2tleSd9XSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZTEsIHZhbHVlMiwgd2VpZ2h0LCBpbmZvKSB7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpbmZvLml0ZXJhdGVDb3VudDsgKytpKXtcbiAgICAgICAgICAgIFhNTDNELm1hdGgucXVhdC5zbGVycE9mZnNldCggIHZhbHVlMSxpbmZvLml0ZXJGbGFnWzBdID8gaSo0IDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlMixpbmZvLml0ZXJGbGFnWzFdID8gaSo0IDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCwgaSo0LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5zbGVycEtleXNcIiwge1xuICAgIG91dHB1dHM6IFsgIHt0eXBlOiAnZmxvYXQ0JywgbmFtZTogJ3Jlc3VsdCd9XSxcbiAgICBwYXJhbXM6ICBbICB7dHlwZTogJ2Zsb2F0Jywgc291cmNlOiAna2V5cycsIGFycmF5OiB0cnVlfSxcbiAgICAgICAge3R5cGU6ICdmbG9hdDQnLCBzb3VyY2U6ICd2YWx1ZXMnLCBhcnJheTogdHJ1ZX0sXG4gICAgICAgIHt0eXBlOiAnZmxvYXQnLCBzb3VyY2U6ICdrZXknfV0sXG4gICAgYWxsb2M6IGZ1bmN0aW9uKHNpemVzLCBrZXlzLCB2YWx1ZXMsIGtleSlcbiAgICB7XG4gICAgICAgIHNpemVzWydyZXN1bHQnXSA9IDQ7XG4gICAgfSxcbiAgICBldmFsdWF0ZTogZnVuY3Rpb24ocmVzdWx0LCBrZXlzLCB2YWx1ZXMsIGtleSkge1xuICAgICAgICB2YXIgbWF4SWR4ID0gTWF0aC5taW4oa2V5cy5sZW5ndGgsIE1hdGguZmxvb3IodmFsdWVzLmxlbmd0aCAvIDQpKTtcbiAgICAgICAgdmFyIGlkeCA9IGJpbmFyeVNlYXJjaChrZXlzLCBrZXlbMF0sIG1heElkeCk7XG5cbiAgICAgICAgaWYoaWR4IDwgMCB8fCBpZHggPT0gbWF4SWR4IC0gMSl7XG4gICAgICAgICAgICBpZHggPSBNYXRoLm1heCgwLGlkeCk7XG4gICAgICAgICAgICByZXN1bHRbMF0gPSB2YWx1ZXNbNCppZHhdO1xuICAgICAgICAgICAgcmVzdWx0WzFdID0gdmFsdWVzWzQqaWR4KzFdO1xuICAgICAgICAgICAgcmVzdWx0WzJdID0gdmFsdWVzWzQqaWR4KzJdO1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gdmFsdWVzWzQqaWR4KzNdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB2YXIgd2VpZ2h0ID0gKGtleVswXSAtIGtleXNbaWR4XSkgLyAoa2V5c1tpZHgrMV0gLSBrZXlzW2lkeF0pO1xuICAgICAgICAgICAgWE1MM0QubWF0aC5xdWF0LnNsZXJwT2Zmc2V0KCAgdmFsdWVzLCBpZHgqNCxcbiAgICAgICAgICAgICAgICB2YWx1ZXMsKGlkeCsxKSo0LCB3ZWlnaHQsXG4gICAgICAgICAgICAgICAgcmVzdWx0LCAwLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbn0pO1xuIiwiXG4vLyBDb2RlIHBvcnRpb25zIGZyb20gaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvY2FudmFzL2ltYWdlZmlsdGVycy9cbihmdW5jdGlvbigpIHtcbiAgICBYZmxvdy5GaWx0ZXJzID0ge307XG5cbiAgICB2YXIgdG1wQ2FudmFzID0gbnVsbDtcbiAgICB2YXIgdG1wQ3R4ID0gbnVsbDtcblxuICAgIFhmbG93LkZpbHRlcnMuY3JlYXRlSW1hZ2VEYXRhID0gZnVuY3Rpb24odyxoKSB7XG4gICAgICAgIGlmICghdG1wQ2FudmFzKVxuICAgICAgICAgICAgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIGlmICghdG1wQ3R4KVxuICAgICAgICAgICAgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHJldHVybiB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHcsIGgpO1xuICAgIH07XG5cbiAgICBYZmxvdy5GaWx0ZXJzLmNyZWF0ZUltYWdlRGF0YUZsb2F0MzIgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgICAgIHJldHVybiB7d2lkdGg6IHcsIGhlaWdodDogaCwgZGF0YTogbmV3IEZsb2F0MzJBcnJheSh3ICogaCAqIDQpfTtcbiAgICB9O1xuXG4gICAgWGZsb3cuRmlsdGVycy5ncmF5c2NhbGUgPSBmdW5jdGlvbihpbnBpeGVscywgb3V0cGl4ZWxzLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgcyA9IGlucGl4ZWxzLmRhdGE7XG4gICAgICAgICAgICB2YXIgZCA9IG91dHBpeGVscy5kYXRhO1xuICAgICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoOyBpKz00KSB7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSBzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBnID0gc1tpKzFdO1xuICAgICAgICAgICAgICAgIHZhciBiID0gc1tpKzJdO1xuICAgICAgICAgICAgICAgIHZhciBhID0gc1tpKzNdO1xuICAgICAgICAgICAgICAgIC8vIENJRSBsdW1pbmFuY2UgZm9yIHRoZSBSR0JcbiAgICAgICAgICAgICAgICAvLyBUaGUgaHVtYW4gZXllIGlzIGJhZCBhdCBzZWVpbmcgcmVkIGFuZCBibHVlLCBzbyB3ZSBkZS1lbXBoYXNpemUgdGhlbS5cbiAgICAgICAgICAgICAgICB2YXIgdiA9IDAuMjEyNipyICsgMC43MTUyKmcgKyAwLjA3MjIqYjtcbiAgICAgICAgICAgICAgICBkW2ldID0gZFtpKzFdID0gZFtpKzJdID0gdlxuICAgICAgICAgICAgICAgIGRbaSszXSA9IGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5waXhlbHM7XG4gICAgfTtcblxuICAgIFhmbG93LkZpbHRlcnMuY29udm9sdXRlID0gZnVuY3Rpb24oaW5waXhlbHMsIG91dHBpeGVscywgd2VpZ2h0cywgb3BhcXVlKSB7XG4gICAgICAgICAgICB2YXIgc2lkZSA9IE1hdGgucm91bmQoTWF0aC5zcXJ0KHdlaWdodHMubGVuZ3RoKSk7XG4gICAgICAgICAgICB2YXIgaGFsZlNpZGUgPSBNYXRoLmZsb29yKHNpZGUvMik7XG4gICAgICAgICAgICB2YXIgc3JjID0gaW5waXhlbHMuZGF0YTtcbiAgICAgICAgICAgIHZhciBzdyA9IGlucGl4ZWxzLndpZHRoO1xuICAgICAgICAgICAgdmFyIHNoID0gaW5waXhlbHMuaGVpZ2h0O1xuICAgICAgICAgICAgLy8gcGFkIG91dHB1dCBieSB0aGUgY29udm9sdXRpb24gbWF0cml4XG4gICAgICAgICAgICB2YXIgdyA9IHN3O1xuICAgICAgICAgICAgdmFyIGggPSBzaDtcbiAgICAgICAgICAgIHZhciBkc3QgPSBvdXRwaXhlbHMuZGF0YTtcbiAgICAgICAgICAgIC8vIGdvIHRocm91Z2ggdGhlIGRlc3RpbmF0aW9uIGltYWdlIHBpeGVsc1xuICAgICAgICAgICAgdmFyIGFscGhhRmFjID0gb3BhcXVlID8gMSA6IDA7XG4gICAgICAgICAgICBmb3IgKHZhciB5PTA7IHk8aDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeD0wOyB4PHc7IHgrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3kgPSB5O1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3ggPSB4O1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHN0T2ZmID0gKHkqdyt4KSo0O1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIHdlaWdoZWQgc3VtIG9mIHRoZSBzb3VyY2UgaW1hZ2UgcGl4ZWxzIHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gZmFsbCB1bmRlciB0aGUgY29udm9sdXRpb24gbWF0cml4XG4gICAgICAgICAgICAgICAgICAgIHZhciByPTAsIGc9MCwgYj0wLCBhPTA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGN5PTA7IGN5PHNpZGU7IGN5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGN4PTA7IGN4PHNpZGU7IGN4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2N5ID0gc3kgKyBjeSAtIGhhbGZTaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3ggPSBzeCArIGN4IC0gaGFsZlNpZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjeSA+PSAwICYmIHNjeSA8IHNoICYmIHNjeCA+PSAwICYmIHNjeCA8IHN3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzcmNPZmYgPSAoc2N5KnN3K3NjeCkqNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSpzaWRlK2N4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgciArPSBzcmNbc3JjT2ZmXSAqIHd0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnICs9IHNyY1tzcmNPZmYrMV0gKiB3dDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYiArPSBzcmNbc3JjT2ZmKzJdICogd3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGEgKz0gc3JjW3NyY09mZiszXSAqIHd0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmXSA9IHI7XG4gICAgICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYrMV0gPSBnO1xuICAgICAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmKzJdID0gYjtcbiAgICAgICAgICAgICAgICAgICAgZHN0W2RzdE9mZiszXSA9IGEgKyBhbHBoYUZhYyooMjU1LWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwaXhlbHM7XG4gICAgICAgIH07XG4vKlxuICAgIFhmbG93LkZpbHRlcnMuY29udm9sdXRlRmxvYXQzMiA9IGZ1bmN0aW9uKHBpeGVscywgd2VpZ2h0cywgb3BhcXVlKSB7XG4gICAgICAgIHZhciBzaWRlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQod2VpZ2h0cy5sZW5ndGgpKTtcbiAgICAgICAgdmFyIGhhbGZTaWRlID0gTWF0aC5mbG9vcihzaWRlIC8gMik7XG5cbiAgICAgICAgdmFyIHNyYyA9IHBpeGVscy5kYXRhO1xuICAgICAgICB2YXIgc3cgPSBwaXhlbHMud2lkdGg7XG4gICAgICAgIHZhciBzaCA9IHBpeGVscy5oZWlnaHQ7XG5cbiAgICAgICAgdmFyIHcgPSBzdztcbiAgICAgICAgdmFyIGggPSBzaDtcbiAgICAgICAgdmFyIG91dHB1dCA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB3LCBoZWlnaHQ6IGgsIGRhdGE6IG5ldyBGbG9hdDMyQXJyYXkodyAqIGggKiA0KVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZHN0ID0gb3V0cHV0LmRhdGE7XG5cbiAgICAgICAgdmFyIGFscGhhRmFjID0gb3BhcXVlID8gMSA6IDA7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN5ID0geTtcbiAgICAgICAgICAgICAgICB2YXIgc3ggPSB4O1xuICAgICAgICAgICAgICAgIHZhciBkc3RPZmYgPSAoeSAqIHcgKyB4KSAqIDQ7XG4gICAgICAgICAgICAgICAgdmFyIHIgPSAwLCBnID0gMCwgYiA9IDAsIGEgPSAwO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGN5ID0gMDsgY3kgPCBzaWRlOyBjeSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGN4ID0gMDsgY3ggPCBzaWRlOyBjeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2N5ID0gTWF0aC5taW4oc2ggLSAxLCBNYXRoLm1heCgwLCBzeSArIGN5IC0gaGFsZlNpZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzY3ggPSBNYXRoLm1pbihzdyAtIDEsIE1hdGgubWF4KDAsIHN4ICsgY3ggLSBoYWxmU2lkZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNyY09mZiA9IChzY3kgKiBzdyArIHNjeCkgKiA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHd0ID0gd2VpZ2h0c1tjeSAqIHNpZGUgKyBjeF07XG4gICAgICAgICAgICAgICAgICAgICAgICByICs9IHNyY1tzcmNPZmZdICogd3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBnICs9IHNyY1tzcmNPZmYgKyAxXSAqIHd0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYiArPSBzcmNbc3JjT2ZmICsgMl0gKiB3dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgKz0gc3JjW3NyY09mZiArIDNdICogd3Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZHN0W2RzdE9mZl0gPSByO1xuICAgICAgICAgICAgICAgIGRzdFtkc3RPZmYgKyAxXSA9IGc7XG4gICAgICAgICAgICAgICAgZHN0W2RzdE9mZiArIDJdID0gYjtcbiAgICAgICAgICAgICAgICBkc3RbZHN0T2ZmICsgM10gPSBhICsgYWxwaGFGYWMgKiAoMjU1IC0gYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4qL1xufSgpKTtcblxuZnVuY3Rpb24gZmxvYXQ0KHgseSx6LHcpIHtcbiAgICB2YXIgdiA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHZbMF0gPSAwO1xuICAgICAgICAgICAgdlsxXSA9IDA7XG4gICAgICAgICAgICB2WzJdID0gMDtcbiAgICAgICAgICAgIHZbM10gPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHZbMF0gPSB4O1xuICAgICAgICAgICAgdlsxXSA9IHg7XG4gICAgICAgICAgICB2WzJdID0geDtcbiAgICAgICAgICAgIHZbM10gPSB4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHZbMF0gPSB4O1xuICAgICAgICAgICAgdlsxXSA9IHk7XG4gICAgICAgICAgICB2WzJdID0gMDtcbiAgICAgICAgICAgIHZbM10gPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHZbMF0gPSB4O1xuICAgICAgICAgICAgdlsxXSA9IHk7XG4gICAgICAgICAgICB2WzJdID0gejtcbiAgICAgICAgICAgIHZbM10gPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2WzBdID0geDtcbiAgICAgICAgICAgIHZbMV0gPSB5O1xuICAgICAgICAgICAgdlsyXSA9IHo7XG4gICAgICAgICAgICB2WzNdID0gdztcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG5cbmZ1bmN0aW9uIGh5cG90KGEsIGIpXG57XG4gICAgcmV0dXJuIE1hdGguc3FydChhKmEgKyBiKmIpO1xufVxuXG5mdW5jdGlvbiBoeXBvdDQoYSwgYilcbntcbiAgICByZXR1cm4gZmxvYXQ0KGh5cG90KGFbMF0sIGJbMF0pLFxuICAgICAgICAgICAgICAgICAgaHlwb3QoYVsxXSwgYlsxXSksXG4gICAgICAgICAgICAgICAgICBoeXBvdChhWzJdLCBiWzJdKSxcbiAgICAgICAgICAgICAgICAgIGh5cG90KGFbM10sIGJbM10pKTtcbn1cblxuZnVuY3Rpb24gaHlwb3Q0VG8ociwgYSwgYilcbntcbiAgICByWzBdID0gaHlwb3QoYVswXSwgYlswXSk7XG4gICAgclsxXSA9IGh5cG90KGFbMV0sIGJbMV0pO1xuICAgIHJbMl0gPSBoeXBvdChhWzJdLCBiWzJdKTtcbiAgICByWzNdID0gaHlwb3QoYVszXSwgYlszXSk7XG59XG5cbmZ1bmN0aW9uIGdldFRleGVsMkQoaW1hZ2VkYXRhLCB4LCB5KSB7XG4gICAgdmFyIG9mZnNldCA9ICh5ICogaW1hZ2VkYXRhLndpZHRoICsgeCkgKiA0O1xuICAgIHZhciBkYXRhID0gaW1hZ2VkYXRhLmRhdGE7XG4gICAgdmFyIGNvbG9yID0gbmV3IEZsb2F0MzJBcnJheSg0KTtcbiAgICBjb2xvclswXSA9IGRhdGFbb2Zmc2V0XSAvIDI1NS4wO1xuICAgIGNvbG9yWzFdID0gZGF0YVtvZmZzZXQrMV0gLyAyNTUuMDtcbiAgICBjb2xvclsyXSA9IGRhdGFbb2Zmc2V0KzJdIC8gMjU1LjA7XG4gICAgY29sb3JbM10gPSBkYXRhW29mZnNldCszXSAvIDI1NS4wO1xuICAgIHJldHVybiBjb2xvcjtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4ZWwyRFRvKGNvbG9yLCBpbWFnZWRhdGEsIHgsIHkpIHtcbiAgICB2YXIgb2Zmc2V0ID0gKHkgKiBpbWFnZWRhdGEud2lkdGggKyB4KSAqIDQ7XG4gICAgdmFyIGRhdGEgPSBpbWFnZWRhdGEuZGF0YTtcbiAgICBjb2xvclswXSA9IGRhdGFbb2Zmc2V0XSAvIDI1NS4wO1xuICAgIGNvbG9yWzFdID0gZGF0YVtvZmZzZXQrMV0gLyAyNTUuMDtcbiAgICBjb2xvclsyXSA9IGRhdGFbb2Zmc2V0KzJdIC8gMjU1LjA7XG4gICAgY29sb3JbM10gPSBkYXRhW29mZnNldCszXSAvIDI1NS4wO1xuICAgIHJldHVybiBjb2xvcjtcbn1cblxuZnVuY3Rpb24gc2V0VGV4ZWwyRChpbWFnZWRhdGEsIHgsIHksIGNvbG9yKSB7XG4gICAgdmFyIG9mZnNldCA9ICh5ICogaW1hZ2VkYXRhLndpZHRoICsgeCkgKiA0O1xuICAgIHZhciBkYXRhID0gaW1hZ2VkYXRhLmRhdGE7XG4gICAgZGF0YVtvZmZzZXRdID0gY29sb3JbMF0gKiAyNTUuMCA7XG4gICAgZGF0YVtvZmZzZXQrMV0gPSBjb2xvclsxXSAqIDI1NS4wO1xuICAgIGRhdGFbb2Zmc2V0KzJdID0gY29sb3JbMl0gKiAyNTUuMDtcbiAgICBkYXRhW29mZnNldCszXSA9IGNvbG9yWzNdICogMjU1LjA7XG59XG5cblhmbG93LnJlZ2lzdGVyT3BlcmF0b3IoXCJ4Zmxvdy5zb2JlbEltYWdlXCIsIHtcbiAgICBvdXRwdXRzOiBbIHt0eXBlOiAndGV4dHVyZScsIG5hbWUgOiAncmVzdWx0Jywgc2l6ZW9mIDogJ2ltYWdlJ30gXSxcbiAgICBwYXJhbXM6ICBbIHt0eXBlOiAndGV4dHVyZScsIHNvdXJjZSA6ICdpbWFnZSd9IF0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgaW1hZ2UpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIHZhciBoZWlnaHQgPSBpbWFnZS5oZWlnaHQ7XG5cbiAgICAgICAgLy8gU29iZWwgZmlsdGVyLCBBbnlTTCBtZXRob2RcbiAgICAgICAgdmFyIGd4ID0gZmxvYXQ0KDAuMCk7XG4gICAgICAgIHZhciBneSA9IGZsb2F0NCgwLjApO1xuICAgICAgICB2YXIgaTAwID0gZmxvYXQ0KCk7XG4gICAgICAgIHZhciBpMDAgPSBmbG9hdDQoKTtcbiAgICAgICAgdmFyIGkxMCA9IGZsb2F0NCgpO1xuICAgICAgICB2YXIgaTIwID0gZmxvYXQ0KCk7XG4gICAgICAgIHZhciBpMDEgPSBmbG9hdDQoKTtcbiAgICAgICAgdmFyIGkxMSA9IGZsb2F0NCgpO1xuICAgICAgICB2YXIgaTIxID0gZmxvYXQ0KCk7XG4gICAgICAgIHZhciBpMDIgPSBmbG9hdDQoKTtcbiAgICAgICAgdmFyIGkxMiA9IGZsb2F0NCgpO1xuICAgICAgICB2YXIgaTIyID0gZmxvYXQ0KCk7XG4gICAgICAgIHZhciBjb2xvciA9IGZsb2F0NCgpO1xuXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7ICsreClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvKiBSZWFkIGVhY2ggdGV4ZWwgY29tcG9uZW50IGFuZCBjYWxjdWxhdGUgdGhlIGZpbHRlcmVkIHZhbHVlIHVzaW5nIG5laWdoYm91cmluZyB0ZXhlbCBjb21wb25lbnRzICovXG4gICAgICAgICAgICAgICAgaWYgKCB4ID49IDEgJiYgeCA8ICh3aWR0aC0xKSAmJiB5ID49IDEgJiYgeSA8IGhlaWdodCAtIDEpXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTAwLCBpbWFnZSwgeC0xLCB5LTEpO1xuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTEwLCBpbWFnZSwgeCwgeS0xKTtcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGV4ZWwyRFRvKGkyMCwgaW1hZ2UsIHgrMSwgeS0xKTtcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGV4ZWwyRFRvKGkwMSwgaW1hZ2UsIHgtMSwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGdldFRleGVsMkRUbyhpMTEsIGltYWdlLCB4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgZ2V0VGV4ZWwyRFRvKGkyMSwgaW1hZ2UsIHgrMSwgeSk7XG4gICAgICAgICAgICAgICAgICAgIGdldFRleGVsMkRUbyhpMDIsIGltYWdlLCB4LTEsIHkrMSk7XG4gICAgICAgICAgICAgICAgICAgIGdldFRleGVsMkRUbyhpMTIsIGltYWdlLCB4LCB5KzEpO1xuICAgICAgICAgICAgICAgICAgICBnZXRUZXhlbDJEVG8oaTIyLCBpbWFnZSwgeCsxLCB5KzEpO1xuXG4gICAgICAgICAgICAgICAgICAgIGd4WzBdID0gaTAwWzBdICsgMiAqIGkxMFswXSArIGkyMFswXSAtIGkwMlswXSAgLSAyICogaTEyWzBdIC0gaTIyWzBdO1xuICAgICAgICAgICAgICAgICAgICBneFsxXSA9IGkwMFsxXSArIDIgKiBpMTBbMV0gKyBpMjBbMV0gLSBpMDJbMV0gIC0gMiAqIGkxMlsxXSAtIGkyMlsxXTtcbiAgICAgICAgICAgICAgICAgICAgZ3hbMl0gPSBpMDBbMl0gKyAyICogaTEwWzJdICsgaTIwWzJdIC0gaTAyWzJdICAtIDIgKiBpMTJbMl0gLSBpMjJbMl07XG5cbiAgICAgICAgICAgICAgICAgICAgZ3lbMF0gPSBpMDBbMF0gLSBpMjBbMF0gICsgMippMDFbMF0gLSAyKmkyMVswXSArIGkwMlswXSAgLSAgaTIyWzBdO1xuICAgICAgICAgICAgICAgICAgICBneVsxXSA9IGkwMFsxXSAtIGkyMFsxXSAgKyAyKmkwMVsxXSAtIDIqaTIxWzFdICsgaTAyWzFdICAtICBpMjJbMV07XG4gICAgICAgICAgICAgICAgICAgIGd5WzJdID0gaTAwWzJdIC0gaTIwWzJdICArIDIqaTAxWzJdIC0gMippMjFbMl0gKyBpMDJbMl0gIC0gIGkyMlsyXTtcblxuICAgICAgICAgICAgICAgICAgICAvKiB0YWtpbmcgcm9vdCBvZiBzdW1zIG9mIHNxdWFyZXMgb2YgR3ggYW5kIEd5ICovXG4gICAgICAgICAgICAgICAgICAgIGh5cG90NFRvKGNvbG9yLCBneCwgZ3kpO1xuICAgICAgICAgICAgICAgICAgICBjb2xvclswXS89MjtcbiAgICAgICAgICAgICAgICAgICAgY29sb3JbMV0vPTI7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yWzJdLz0yO1xuICAgICAgICAgICAgICAgICAgICBjb2xvclszXT0xLjA7XG4gICAgICAgICAgICAgICAgICAgIHNldFRleGVsMkQocmVzdWx0LCB4LCB5LCBjb2xvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG4vLyBTb2JlbCBmaWx0ZXIgd2l0aCBzZXBhcmF0ZSBzdGVwc1xuLy9cbi8vICAgICAgICB2YXIgdmVydGljYWwgPSBYZmxvdy5GaWx0ZXJzLmNyZWF0ZUltYWdlRGF0YUZsb2F0MzIod2lkdGgsIGhlaWdodCk7XG4vLyAgICAgICAgWGZsb3cuRmlsdGVycy5jb252b2x1dGUocmVzdWx0LCB2ZXJ0aWNhbCxcbi8vICAgICAgICAgICAgWyAtMSwgMCwgMSxcbi8vICAgICAgICAgICAgICAtMiwgMCwgMixcbi8vICAgICAgICAgICAgICAtMSwgMCwgMSBdKTtcbi8vICAgICAgICB2YXIgaG9yaXpvbnRhbCA9IFhmbG93LkZpbHRlcnMuY3JlYXRlSW1hZ2VEYXRhRmxvYXQzMih3aWR0aCwgaGVpZ2h0KTtcbi8vICAgICAgICBYZmxvdy5GaWx0ZXJzLmNvbnZvbHV0ZShyZXN1bHQsIGhvcml6b250YWwsXG4vLyAgICAgICAgICAgIFsgLTEsIC0yLCAtMSxcbi8vICAgICAgICAgICAgICAgMCwgIDAsICAwLFxuLy8gICAgICAgICAgICAgICAxLCAgMiwgIDEgXSk7XG4vL1xuLy8gICAgICAgIGZvciAodmFyIGk9MDsgaTxyZXN1bHQuZGF0YS5sZW5ndGg7IGkrPTQpIHtcbi8vICAgICAgICAgICAgLy8gbWFrZSB0aGUgdmVydGljYWwgZ3JhZGllbnQgcmVkXG4vLyAgICAgICAgICAgIHZhciB2ID0gTWF0aC5hYnModmVydGljYWwuZGF0YVtpXSk7XG4vLyAgICAgICAgICAgIHJlc3VsdC5kYXRhW2ldID0gdjtcbi8vICAgICAgICAgICAgLy8gbWFrZSB0aGUgaG9yaXpvbnRhbCBncmFkaWVudCBncmVlblxuLy8gICAgICAgICAgICB2YXIgaCA9IE1hdGguYWJzKGhvcml6b250YWwuZGF0YVtpXSk7XG4vLyAgICAgICAgICAgIHJlc3VsdC5kYXRhW2krMV0gPSBoO1xuLy8gICAgICAgICAgICAvLyBhbmQgbWl4IGluIHNvbWUgYmx1ZSBmb3IgYWVzdGhldGljc1xuLy8gICAgICAgICAgICByZXN1bHQuZGF0YVtpKzJdID0gKHYraCkvNDtcbi8vICAgICAgICAgICAgcmVzdWx0LmRhdGFbaSszXSA9IDI1NTsgLy8gb3BhcXVlIGFscGhhXG4vLyAgICAgICAgfVxuXG4gICAgICAgIC8qIENvcHkgaW1hZ2VcbiAgICAgICAgdmFyIGRlc3RwaXggPSByZXN1bHQuZGF0YTtcbiAgICAgICAgdmFyIHNyY3BpeCA9IGltYWdlLmRhdGE7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7ICsreSlcbiAgICAgICAge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgKyt4KVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBvZmZzZXQgPSAoeSAqIHdpZHRoICsgeCkgKiA0O1xuICAgICAgICAgICAgICAgIGRlc3RwaXhbb2Zmc2V0XSA9ICBzcmNwaXhbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBkZXN0cGl4W29mZnNldCsxXSA9IHNyY3BpeFtvZmZzZXQrMV07XG4gICAgICAgICAgICAgICAgZGVzdHBpeFtvZmZzZXQrMl0gPSBzcmNwaXhbb2Zmc2V0KzJdO1xuICAgICAgICAgICAgICAgIGRlc3RwaXhbb2Zmc2V0KzNdID0gc3JjcGl4W29mZnNldCszXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAqL1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59KTtcbiIsIlxuWGZsb3cucmVnaXN0ZXJPcGVyYXRvcihcInhmbG93LnN1YlwiLCB7XG4gICAgb3V0cHV0czogWyAge3R5cGU6ICdmbG9hdDMnLCBuYW1lOiAncmVzdWx0J31dLFxuICAgIHBhcmFtczogIFsgIHt0eXBlOiAnZmxvYXQzJywgc291cmNlOiAndmFsdWUxJ30sXG4gICAgICAgICAgICAgICAge3R5cGU6ICdmbG9hdDMnLCBzb3VyY2U6ICd2YWx1ZTInfV0sXG4gICAgZXZhbHVhdGU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUxLCB2YWx1ZTIsIGluZm8pIHtcbiAgICAgICAgdGhyb3cgXCJOb3QgdXNlZCFcIjtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpPCBpbmZvLml0ZXJhdGVDb3VudCozOyBpKyspXG4gICAgICAgICAgICByZXN1bHRbaV0gPSB2YWx1ZTFbaV0gLSB2YWx1ZTJbaV07XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIGV2YWx1YXRlX2NvcmU6IGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUxLCB2YWx1ZTIpe1xuICAgICAgICByZXN1bHRbMF0gPSB2YWx1ZTFbMF0gLSB2YWx1ZTJbMF07XG4gICAgICAgIHJlc3VsdFsxXSA9IHZhbHVlMVsxXSAtIHZhbHVlMlsxXTtcbiAgICAgICAgcmVzdWx0WzJdID0gdmFsdWUxWzJdIC0gdmFsdWUyWzJdO1xuICAgIH1cbn0pO1xuIiwiLyoqXG4gKiBPbmUgb3BlcmF0b3IgZXhlY3V0aW9uIHdpdGhpbiB0aGUgQHNlZXtPcGVyYXRvckxpc3R9LlxuICogQHBhcmFtIG9wZXJhdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE9wZXJhdG9yRW50cnkgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBpbiBPcGVyYXRvckxpc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXggPSAwO1xuXG4gICAgLyoqXG4gICAgICogT3BlcmF0b3Igb2JqZWN0XG4gICAgICogQHR5cGUge3t9fVxuICAgICAqL1xuICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcblxuICAgIC8qKlxuICAgICAqIG9wZXJhdG9ySW5kZXg6IFBvc2l0aW9uIG9mIHRoZSBpbnB1dCdzIG9wZXJhdG9yIGluIHRoZSBPcGVyYXRvckxpc3QgaWYgdGhlIGlucHV0IGNvbWVzIGZyb21cbiAgICAgKiBwcmV2aW91c2x5IGV4ZWN1dGVkIG9wZXJhdG9yIG90aGVyd2lzZSB1bmRlZmluZWRcbiAgICAgKiBvdXRwdXRJbmRleDogUmVmZXJlbmNlcyB0aGUgb3V0cHV0cyBvZiB0aGUgb3BlcmF0b3Igb2JqZWN0IGRlZmluZWQgYnkgdGhlIG9wZXJhdG9ySW5kZXhcbiAgICAgKiBtYXBwZWROYW1lOiBPcmlnaW5hbCBuYW1lIGFzIGRlZmluZWQgaW4gb3BlcmF0b3IgaW52b2NhdGlvbiBpbiBEYXRhTm9kZSAoY3VycmVudGx5IG5vdCB1c2VkKVxuICAgICAqIGlucHV0SW5kZXg6IE9ubHkgc2V0IGlmIHRoaXMgaXMgZGlyZWN0IGlucHV0IGFuZCByZWZlcmVuY2VzIGludG8gdGhlIGlucHV0cyBkZWZpbmVkIGluIEBzZWV7UHJvZ3JhbURhdGF9XG4gICAgICogQHR5cGUge0FycmF5Ljx7b3BlcmF0b3JJbmRleDogbnVtYmVyPywgb3V0cHV0SW5kZXg6IG51bWJlcj8sIG1hcHBlZE5hbWU6IHN0cmluZz8sIGlucHV0SW5kZXg6IG51bWJlcj99Pn1cbiAgICAgKi9cbiAgICB0aGlzLmlucHV0SW5mbyA9IFtdO1xuICAgIC8qKlxuICAgICAqIGZpbmFsT3V0OiB7bnVtYmVyfSBJcyBzZXQsIGlmIHRoaXMgb3V0cHV0IGEgZmluYWwgb3V0cHV0IChlLmcuIGEgdmFyeWluZyBpbiBhIHZlcnRleCBzaGFkZXIpLiBSZWZlcmVuY2VzIHRoZSBvdXRwdXRzIG9mIHRoZSBQcm9ncmFtRGF0YS5cbiAgICAgKiB0cmFuc2Zlcjoge2Jvb2xlYW59IElzIHRydWUgaWYgdGhpcyBpcyBhIHRyYW5zZmVyIG91dHB1dCBpLmUuIHRoaXMgb3V0cHV0IGlzIHVzZWQgYXMgaW5wdXQgYnkgYW5vdGhlciBvcGVyYXRvcixcbiAgICAgKiBsb3N0OiBEYXRhIHRoYXQgaXMgbG9zdCwgaS5lLiBub3QgdXNlZCBpbiBuZXh0IGV4ZWN1dG9yLiBSZWZlcmVuY2UgdG8gUHJvZ3JhbURhdGEncyBvdXRwdXRzXG4gICAgICogQHR5cGUge0FycmF5Ljx7ZmluYWxPdXQ6IG51bWJlcj8sIHRyYW5zZmVyOiBib29sZWFuPywgbG9zdDogbnVtYmVyP30+fVxuICAgICAqL1xuICAgIHRoaXMub3V0cHV0SW5mbyA9IFtdO1xufTtcblxuLyoqXG4gKiBJcyB0aGUgaW5wdXQgdGhlIHJlc3VsdCBvZiBhIHByZXZpb3VzbHkgZXhlY3V0ZWQgb3BlcmF0b3JcbiAqIEBwYXJhbSBtYXBwaW5nSW5kZXggSW5wdXQgaW5kZXggb2YgdGhlIG9wZXJhdG9yIChjYW4gYmUgbWFwcGVkIHVzaW5nIGEgbWFwcGluZyBkZWNsYXJhdGlvbilcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5pc1RyYW5zZmVySW5wdXQgPSBmdW5jdGlvbiAobWFwcGluZ0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJbmRleF0ub3BlcmF0b3JJbmRleCAhPT0gdW5kZWZpbmVkO1xufTtcblxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuZ2V0VHJhbnNmZXJJbnB1dE9wZXJhdG9ySW5kZXggPSBmdW5jdGlvbiAobWFwcGluZ0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJbmRleF0ub3BlcmF0b3JJbmRleDtcbn07XG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5nZXRUcmFuc2ZlcklucHV0T3V0cHV0SW5kZXggPSBmdW5jdGlvbiAobWFwcGluZ0luZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJbmRleF0ub3V0cHV0SW5kZXg7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIHVuaXF1ZSBuYW1lIGZvciBhIHNwZWNpZmllZCB0cmFuc2ZlciBpbnB1dFxuICogQHBhcmFtIG1hcHBpbmdJZHhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmdldFRyYW5zZmVySW5wdXRJZCA9IGZ1bmN0aW9uIChtYXBwaW5nSWR4KSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLmlucHV0SW5mb1ttYXBwaW5nSWR4XTtcbiAgICByZXR1cm4gaW5mby5vcGVyYXRvckluZGV4ICsgXCJfXCIgKyBpbmZvLm91dHB1dEluZGV4O1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB1bmlxdWUgbmFtZSBmb3IgdHJhbnNmZXIgb3V0cHV0XG4gKiBAcGFyYW0gb3V0cHV0SW5kZXhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmdldFRyYW5zZmVyT3V0cHV0SWQgPSBmdW5jdGlvbiAob3V0cHV0SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleCArIFwiX1wiICsgb3V0cHV0SW5kZXg7XG59O1xuXG4vKipcbiAqIFRPRE86IHJlbW92ZSBvciBpbnRlZ3JhdGUgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICogQHVudXNlZFxuICogQHBhcmFtIG1hcHBpbmdJZHhcbiAqIEByZXR1cm5zIHtzdHJpbmd8Kn1cbiAqL1xuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuZ2V0SW5wdXRNYXBwaW5nTmFtZSA9IGZ1bmN0aW9uIChtYXBwaW5nSWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJZHhdLm1hcHBlZE5hbWU7XG59O1xuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuZ2V0RGlyZWN0SW5wdXRJbmRleCA9IGZ1bmN0aW9uIChtYXBwaW5nSWR4KSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRJbmZvW21hcHBpbmdJZHhdLmlucHV0SW5kZXg7XG59O1xuXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5nZXRPdXRwdXRJbmRleCA9IGZ1bmN0aW9uIChvcGVyYXRvck91dHB1dElkeCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEluZm9bb3BlcmF0b3JPdXRwdXRJZHhdLmZpbmFsT3V0IHx8IHRoaXMub3V0cHV0SW5mb1tvcGVyYXRvck91dHB1dElkeF0ubG9zdCB8fCAwO1xufTtcblxuXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5pc0ZpbmFsT3V0cHV0ID0gZnVuY3Rpb24gKG91dHB1dEluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0SW5mb1tvdXRwdXRJbmRleF0gJiYgdGhpcy5vdXRwdXRJbmZvW291dHB1dEluZGV4XS5maW5hbE91dCAhPT0gdW5kZWZpbmVkO1xufTtcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmlzVHJhbnNmZXJPdXRwdXQgPSBmdW5jdGlvbiAob3V0cHV0SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRJbmZvW291dHB1dEluZGV4XSAmJiB0aGlzLm91dHB1dEluZm9bb3V0cHV0SW5kZXhdLnRyYW5zZmVyO1xufTtcbk9wZXJhdG9yRW50cnkucHJvdG90eXBlLmlzTG9zdE91dHB1dCA9IGZ1bmN0aW9uIChvdXRwdXRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEluZm9bb3V0cHV0SW5kZXhdICYmIHRoaXMub3V0cHV0SW5mb1tvdXRwdXRJbmRleF0ubG9zdCAhPT0gdW5kZWZpbmVkO1xufTtcblxuXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5zZXRUcmFuc2ZlcklucHV0ID0gZnVuY3Rpb24gKG1hcHBpbmdJbmRleCwgb3BlcmF0b3JJbmRleCwgb3V0cHV0SW5kZXgpIHtcbiAgICB0aGlzLmlucHV0SW5mb1ttYXBwaW5nSW5kZXhdID0ge29wZXJhdG9ySW5kZXg6IG9wZXJhdG9ySW5kZXgsIG91dHB1dEluZGV4OiBvdXRwdXRJbmRleH07XG59O1xuXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5zZXREaXJlY3RJbnB1dCA9IGZ1bmN0aW9uIChtYXBwaW5nSW5kZXgsIGlucHV0SW5kZXgsIG1hcHBlZE5hbWUpIHtcbiAgICB0aGlzLmlucHV0SW5mb1ttYXBwaW5nSW5kZXhdID0ge2lucHV0SW5kZXg6IGlucHV0SW5kZXgsIG1hcHBlZE5hbWU6IG1hcHBlZE5hbWV9O1xufTtcblxuT3BlcmF0b3JFbnRyeS5wcm90b3R5cGUuc2V0RmluYWxPdXRwdXQgPSBmdW5jdGlvbiAob3BlcmF0b3JPdXRwdXRJbmRleCwgZ2xvYmFsT3V0cHV0SW5kZXgpIHtcbiAgICB0aGlzLm91dHB1dEluZm9bb3BlcmF0b3JPdXRwdXRJbmRleF0gPSB7ZmluYWxPdXQ6IGdsb2JhbE91dHB1dEluZGV4fTtcbn07XG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5zZXRUcmFuc2Zlck91dHB1dCA9IGZ1bmN0aW9uIChvcGVyYXRvck91dHB1dEluZGV4KSB7XG4gICAgdGhpcy5vdXRwdXRJbmZvW29wZXJhdG9yT3V0cHV0SW5kZXhdID0ge3RyYW5zZmVyOiB0cnVlfTtcbn07XG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5zZXRMb3N0T3V0cHV0ID0gZnVuY3Rpb24gKG9wZXJhdG9yT3V0cHV0SW5kZXgsIGdsb2JhbE91dHB1dEluZGV4KSB7XG4gICAgdGhpcy5vdXRwdXRJbmZvW29wZXJhdG9yT3V0cHV0SW5kZXhdID0ge2xvc3Q6IGdsb2JhbE91dHB1dEluZGV4fTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGUgaGFzaC1hYmxlIGtleSBmb3IgdGhlIGVudHJ5XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvckVudHJ5LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleSA9IHRoaXMub3BlcmF0b3IubmFtZSArIFwiKk9cIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMub3V0cHV0SW5mby5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaW5mbyA9IHRoaXMub3V0cHV0SW5mb1tpXTtcbiAgICAgICAga2V5ICs9IFwiKlwiICsgKCBpbmZvLnRyYW5zZmVyID8gXCJfXCIgOiBpbmZvLmZpbmFsT3V0IHx8IChpbmZvLmxvc3QgKyBcIj9cIikpO1xuICAgIH1cbiAgICBrZXkgKz0gK1wiKklcIjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5pbnB1dEluZm8ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaW5mbyA9IHRoaXMuaW5wdXRJbmZvW2ldO1xuICAgICAgICBrZXkgKz0gXCIqXCIgKyAoaW5mby5pbnB1dEluZGV4ID8gaW5mby5pbnB1dEluZm8gOiBpbmZvLm9wZXJhdG9ySW5kZXggKyBcIj5cIiArIGluZm8ub3V0cHV0SW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBPcGVyYXRvckVudHJ5O1xuIiwidmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcbnZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XG5cblxuLyoqXG4gKiBMaXN0IG9mIHBsYXRmb3JtLXNwZWNpZmljIG9wZXJhdG9ycywgb3JkZXJlZCBieSBleGVjdXRpb24gKGxhc3QgZW50cnkgaXMgbGFzdCBvcGVyYXRvclxuICogZXhlY3V0ZWQpLlxuICpcbiAqIEBwYXJhbSB7Qy5QTEFURk9STX0gcGxhdGZvcm1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgT3BlcmF0b3JMaXN0ID0gZnVuY3Rpb24gKHBsYXRmb3JtKSB7XG4gICAgdGhpcy5wbGF0Zm9ybSA9IHBsYXRmb3JtO1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheS48T3BlcmF0b3JFbnRyeT59XG4gICAgICovXG4gICAgdGhpcy5lbnRyaWVzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBNYXAgZnJvbSBwb3NpdGlvbiBvZiBpbnB1dCBwYXJhbWV0ZXIgdG8gc2l6ZSBhbmQgaXRlcmF0b3IgdHlwZSBvZiBwYXJhbWV0ZXJzLlxuICAgICAqIFNpemUgaXMgb25seSBzcGVjaWZpZWQgZm9yIHVuaWZvcm0gYXJyYXkgaW5wdXQsIHJlcXVpcmVkIGZvciBwcm9ncmFtcyB0aGF0XG4gICAgICogaGF2ZSB0aGUgYXJyYXkgc2l6ZSBzcGVjaWZpZWQuXG4gICAgICogQHR5cGUge09iamVjdC48bnVtYmVyLHtzaXplOiBudW1iZXIsIGl0ZXJhdGU6IEMuSVRFUkFUSU9OX1RZUEV9Pn1cbiAgICAgKi9cbiAgICB0aGlzLmlucHV0SW5mbyA9IHt9O1xufTtcblxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5hZGRFbnRyeSA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIGVudHJ5LmluZGV4ID0gdGhpcy5lbnRyaWVzLmxlbmd0aDtcbiAgICB0aGlzLmVudHJpZXMucHVzaChlbnRyeSk7XG59O1xuXG4vKipcbiAqIEhhc2hhYmxlIGtleSBmb3Igd2hvbGUgbGlzdFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBrZXlzLnB1c2godGhpcy5lbnRyaWVzW2ldLmdldEtleSgpKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRoaXMucGxhdGZvcm0gKyBcIj5cIiArIGtleXMuam9pbihcIiFcIikgKyBcInxcIjtcbiAgICBmb3IgKHZhciBpIGluIHRoaXMuaW5wdXRJbmZvKSB7XG4gICAgICAgIHJlc3VsdCArPSBpICsgXCI+XCIgKyAodGhpcy5pbnB1dEluZm9baV0uaXRlcmF0ZSB8fCAwKSArIFwieFwiICsgKHRoaXMuaW5wdXRJbmZvW2ldLnNpemUgfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5PcGVyYXRvckxpc3QucHJvdG90eXBlLnNldElucHV0SXRlcmF0ZVR5cGUgPSBmdW5jdGlvbiAoaW5wdXRJbmRleCwgdHlwZSkge1xuICAgIGlmICghdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0pIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdID0ge307XG4gICAgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0uaXRlcmF0ZSA9IHR5cGU7XG59O1xuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5zZXRJbnB1dFNpemUgPSBmdW5jdGlvbiAoaW5wdXRJbmRleCwgc2l6ZSkge1xuICAgIGlmICghdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0pIHRoaXMuaW5wdXRJbmZvW2lucHV0SW5kZXhdID0ge307XG4gICAgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0uc2l6ZSA9IHNpemU7XG59O1xuXG5cbk9wZXJhdG9yTGlzdC5wcm90b3R5cGUuaXNJbnB1dEl0ZXJhdGUgPSBmdW5jdGlvbiAoaW5wdXRJbmRleCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XSAmJiB0aGlzLmlucHV0SW5mb1tpbnB1dEluZGV4XS5pdGVyYXRlID09IEMuSVRFUkFUSU9OX1RZUEUuTUFOWTtcbn07XG5PcGVyYXRvckxpc3QucHJvdG90eXBlLmlzSW5wdXRVbmlmb3JtID0gZnVuY3Rpb24gKGlucHV0SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0gJiYgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0uaXRlcmF0ZSA9PSBDLklURVJBVElPTl9UWVBFLk9ORTtcbn07XG5PcGVyYXRvckxpc3QucHJvdG90eXBlLmlzSW5wdXROdWxsID0gZnVuY3Rpb24gKGlucHV0SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0gJiYgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0uaXRlcmF0ZSA9PSBDLklURVJBVElPTl9UWVBFLk5VTEw7XG59O1xuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5nZXRJbnB1dEl0ZXJhdGVUeXBlID0gZnVuY3Rpb24gKGlucHV0SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0gJiYgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0uaXRlcmF0ZTtcbn07XG5cbk9wZXJhdG9yTGlzdC5wcm90b3R5cGUuZ2V0SW5wdXRTaXplID0gZnVuY3Rpb24gKGlucHV0SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0gJiYgdGhpcy5pbnB1dEluZm9baW5wdXRJbmRleF0uc2l6ZSB8fCAwO1xufTtcblxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5nZXRJdGVyYXRlQ291bnQgPSBmdW5jdGlvbiAocHJvZ3JhbURhdGEpIHtcbiAgICB2YXIgY291bnQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2dyYW1EYXRhLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodGhpcy5pc0lucHV0SXRlcmF0ZShpKSkge1xuICAgICAgICAgICAgdmFyIGRhdGFFbnRyeSA9IHByb2dyYW1EYXRhLmdldERhdGFFbnRyeShpKTtcbiAgICAgICAgICAgIGlmIChkYXRhRW50cnkgJiYgZGF0YUVudHJ5LmdldEl0ZXJhdGVDb3VudCkge1xuICAgICAgICAgICAgICAgIHZhciBzaXplID0gZGF0YUVudHJ5LmdldEl0ZXJhdGVDb3VudCgpO1xuICAgICAgICAgICAgICAgIGNvdW50ID0gY291bnQgPCAwID8gc2l6ZSA6IE1hdGgubWluKHNpemUsIGNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQgPCAwID8gMSA6IGNvdW50O1xufTtcblxudmFyIGNfc2l6ZXMgPSB7fTtcblxuT3BlcmF0b3JMaXN0LnByb3RvdHlwZS5hbGxvY2F0ZU91dHB1dCA9IGZ1bmN0aW9uIChwcm9ncmFtRGF0YSwgYXN5bmMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XG4gICAgICAgIHZhciBvcGVyYXRvciA9IGVudHJ5Lm9wZXJhdG9yO1xuICAgICAgICB2YXIgb3BlcmF0b3JEYXRhID0gcHJvZ3JhbURhdGEub3BlcmF0b3JEYXRhW2ldO1xuICAgICAgICB2YXIgaXRlcmF0ZUNvdW50ID0gdGhpcy5nZXRJdGVyYXRlQ291bnQocHJvZ3JhbURhdGEpO1xuICAgICAgICBpZiAob3BlcmF0b3IuYWxsb2MpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW2Nfc2l6ZXNdO1xuICAgICAgICAgICAgYWRkSW5wdXRUb0FyZ3MoYXJncywgZW50cnksIHByb2dyYW1EYXRhKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaChpdGVyYXRlQ291bnQpO1xuICAgICAgICAgICAgb3BlcmF0b3IuYWxsb2MuYXBwbHkob3BlcmF0b3JEYXRhLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9wZXJhdG9yLm91dHB1dHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIHZhciBkID0gb3BlcmF0b3Iub3V0cHV0c1tqXTtcbiAgICAgICAgICAgIHZhciBkYXRhU2xvdCA9IHByb2dyYW1EYXRhLm91dHB1dHNbZW50cnkuZ2V0T3V0cHV0SW5kZXgoaildLCBkYXRhRW50cnk7XG4gICAgICAgICAgICBkYXRhRW50cnkgPSBhc3luYyA/IGRhdGFTbG90LmFzeW5jRGF0YUVudHJ5IDogZGF0YVNsb3QuZGF0YUVudHJ5O1xuXG4gICAgICAgICAgICBpZiAoZC5ub0FsbG9jKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoZGF0YUVudHJ5LnR5cGUgPT0gQy5EQVRBX1RZUEUuVEVYVFVSRSkge1xuICAgICAgICAgICAgICAgIC8vIHRleHR1cmUgZW50cnlcbiAgICAgICAgICAgICAgICBpZiAoZC5jdXN0b21BbGxvYykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4UGFyYW1zID0gY19zaXplc1tkLm5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSB0ZXhQYXJhbXMuaW1hZ2VGb3JtYXQud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdIZWlnaHQgPSB0ZXhQYXJhbXMuaW1hZ2VGb3JtYXQuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3VHlwZSA9IHRleFBhcmFtcy5pbWFnZUZvcm1hdC50ZXhlbFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdGb3JtYXQgPSB0ZXhQYXJhbXMuaW1hZ2VGb3JtYXQudGV4ZWxGb3JtYXQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTYW1wbGVyQ29uZmlnID0gdGV4UGFyYW1zLnNhbXBsZXJDb25maWc7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFFbnRyeS5fY3JlYXRlSW1hZ2UobmV3V2lkdGgsIG5ld0hlaWdodCwgbmV3Rm9ybWF0LCBuZXdUeXBlLCBuZXdTYW1wbGVyQ29uZmlnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGQuc2l6ZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcmNFbnRyeSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgb3BlcmF0b3IubWFwcGluZy5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wZXJhdG9yLm1hcHBpbmdba10uc291cmNlID09IGQuc2l6ZW9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjRW50cnkgPSBwcm9ncmFtRGF0YS5nZXREYXRhRW50cnkoZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChrKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY0VudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3V2lkdGggPSBNYXRoLm1heChzcmNFbnRyeS53aWR0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoc3JjRW50cnkuaGVpZ2h0LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdGb3JtYXQgPSBkLnRleGVsRm9ybWF0IHx8IHNyY0VudHJ5LnRleGVsRm9ybWF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1R5cGUgPSBkLnRleGVsVHlwZSB8fCBzcmNFbnRyeS50ZXhlbFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U2FtcGxlckNvbmZpZyA9IGQuc2FtcGxlckNvbmZpZyB8fCBzcmNFbnRyeS5nZXRTYW1wbGVyQ29uZmlnKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhRW50cnkuX2NyZWF0ZUltYWdlKG5ld1dpZHRoLCBuZXdIZWlnaHQsIG5ld0Zvcm1hdCwgbmV3VHlwZSwgbmV3U2FtcGxlckNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0ZXh0dXJlIGlucHV0IHBhcmFtZXRlciAnXCIgKyBkLnNpemVvZiArIFwiJyBpbiBvcGVyYXRvciAnXCIgKyBvcGVyYXRvci5uYW1lICsgXCInXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIHRleHR1cmUuIFVzZSBjdXN0b21BbGxvYyBvciBzaXplb2YgcGFyYW1ldGVyIGF0dHJpYnV0ZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgc2l6ZSA9IChkLmN1c3RvbUFsbG9jID8gY19zaXplc1tkLm5hbWVdIDogaXRlcmF0ZUNvdW50KSAqIGRhdGFFbnRyeS5nZXRUdXBsZVNpemUoKTtcblxuICAgICAgICAgICAgICAgIGlmICghZGF0YUVudHJ5Ll92YWx1ZSB8fCBkYXRhRW50cnkuX3ZhbHVlLmxlbmd0aCAhPSBzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZGF0YUVudHJ5LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUNFg0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFFbnRyeS5fc2V0VmFsdWUobmV3IEZsb2F0MzJBcnJheShzaXplKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIEMuREFUQV9UWVBFLklOVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuSU5UNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuQk9PTDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhRW50cnkuX3NldFZhbHVlKG5ldyBJbnQzMkFycmF5KHNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgWE1MM0QuZGVidWcubG9nV2FybmluZyhcIkNvdWxkIG5vdCBhbGxvY2F0ZSBvdXRwdXQgYnVmZmVyIG9mIFRZUEU6IFwiICsgZGF0YUVudHJ5LnR5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUVudHJ5Ll9ub3RpZnlDaGFuZ2VkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufTtcblxuLypcbiBPcGVyYXRvckxpc3QucHJvdG90eXBlLmNoZWNrSW5wdXQgPSBmdW5jdGlvbihwcm9ncmFtRGF0YSl7XG4gZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuZW50cmllcy5sZW5ndGg7ICsraSl7XG4gdmFyIGVudHJ5ID0gdGhpcy5lbnRyaWVzW2ldO1xuIHZhciBtYXBwaW5nID0gZW50cnkub3BlcmF0b3IubWFwcGluZztcbiBmb3IodmFyIGogPSAwOyBqIDwgbWFwcGluZy5sZW5ndGg7ICsrail7XG4gaWYoZW50cnkuaXNUcmFuc2ZlcklucHV0KGopKXtcbiB2YXIgb3V0cHV0VHlwZSA9IHRoaXMuZW50cmllc1tlbnRyeS5nZXRUcmFuc2ZlcklucHV0T3BlcmF0b3JJbmRleChqKV0ub3BlcmF0b3Iub3V0cHV0c1tcbiBlbnRyeS5nZXRUcmFuc2ZlcklucHV0T3V0cHV0SW5kZXgoaildLnR5cGU7XG5cbiBpZihvdXRwdXRUeXBlICE9IGVudHJ5LnR5cGUpe1xuIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiWGZsb3c6IG9wZXJhdG9yIFwiICsgZW50cnkub3BlcmF0b3IubmFtZSArIFwiOiBJbnB1dCBmb3IgXCIgKyBlbnRyeS5zb3VyY2UgK1xuIFwiIGhhcyB3cm9uZyB0eXBlLiBFeHBlY3RlZDogXCIgKyBDLmdldFR5cGVOYW1lKGVudHJ5LnR5cGUpXG4gKyBcIiwgYnV0IGdvdDogXCIgKyAgQy5nZXRUeXBlTmFtZShvdXRwdXRUeXBlKSApO1xuIHJldHVybiBmYWxzZTtcbiB9XG5cbiB9XG4gZWxzZXtcbiB2YXIgbWFwcGluZ05hbWUgPSBlbnRyeS5nZXRJbnB1dE1hcHBpbmdOYW1lKGopO1xuIGlmKCFlbnRyeS5vcHRpb25hbCAmJiAhbWFwcGluZ05hbWUpe1xuIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiWGZsb3c6IG9wZXJhdG9yIFwiICsgZW50cnkub3BlcmF0b3IubmFtZSArIFwiOiBNaXNzaW5nIGlucHV0IGFyZ3VtZW50IGZvciBcIlxuICsgZW50cnkuc291cmNlKTtcbiByZXR1cm4gZmFsc2U7XG4gfVxuIGlmKG1hcHBpbmdOYW1lKXtcbiB2YXIgY2hhbm5lbCA9IHByb2dyYW1EYXRhLmdldENoYW5uZWwoZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChqKSk7XG4gaWYoIWNoYW5uZWwpe1xuIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiWGZsb3c6IG9wZXJhdG9yIFwiICsgZW50cnkub3BlcmF0b3IubmFtZSArIFwiOiBJbnB1dCBvZiBuYW1lICdcIiArIG1hcHBpbmdOYW1lICtcbiBcIicgbm90IGZvdW5kLiBVc2VkIGZvciBwYXJhbWV0ZXIgXCIgKyBlbnRyeS5zb3VyY2UpO1xuIHJldHVybiBmYWxzZTtcbiB9XG4gdmFyIGRhdGFFbnRyeSA9IGNoYW5uZWwuZ2V0RGF0YUVudHJ5KCk7XG4gaWYoIWVudHJ5Lm9wdGlvbmFsICYmICghZGF0YUVudHJ5IHx8IGRhdGFFbnRyeS5nZXRMZW5ndGgoKSA9PSAwKSl7XG4gWE1MM0QuZGVidWcubG9nRXJyb3IoXCJYZmxvdzogb3BlcmF0b3IgXCIgKyBlbnRyeS5vcGVyYXRvci5uYW1lICsgXCI6IElucHV0IGZvciBcIiArIGVudHJ5LnNvdXJjZSArXG4gJyBjb250YWlucyBubyBkYXRhLicpO1xuIHJldHVybiBmYWxzZTtcbiB9XG4gaWYoZGF0YUVudHJ5ICYmIGRhdGFFbnRyeS50eXBlICE9IGVudHJ5LnR5cGUpe1xuIFhNTDNELmRlYnVnLmxvZ0Vycm9yKFwiWGZsb3c6IG9wZXJhdG9yIFwiICsgZW50cnkub3BlcmF0b3IubmFtZSArIFwiOiBJbnB1dCBmb3IgXCIgKyBlbnRyeS5zb3VyY2UgK1xuIFwiIGhhcyB3cm9uZyB0eXBlLiBFeHBlY3RlZDogXCIgKyBDLmdldFR5cGVOYW1lKGVudHJ5LnR5cGUpXG4gKyBcIiwgYnV0IGdvdDogXCIgKyAgQy5nZXRUeXBlTmFtZShkYXRhRW50cnkudHlwZSkgKTtcbiByZXR1cm4gZmFsc2U7XG4gfVxuIH1cbiB9XG4gfVxuIH1cbiB9XG4gKi9cblxuICAgIC8vIFRPRE86IFRoaXMgZnVuY3Rpb24gYXBwZWFycyBpbiBtdWx0aXBsZSB1bml0c1xuICAgIGZ1bmN0aW9uIGFkZElucHV0VG9BcmdzKGFyZ3MsIGVudHJ5LCBwcm9ncmFtRGF0YSl7XG4gICAgICAgIHZhciBtYXBwaW5nID0gZW50cnkub3BlcmF0b3IubWFwcGluZztcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcHBpbmcubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIG1hcEVudHJ5ID0gbWFwcGluZ1tpXTtcbiAgICAgICAgICAgIHZhciBkYXRhRW50cnkgPSBwcm9ncmFtRGF0YS5nZXREYXRhRW50cnkoZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChpKSk7XG4gICAgICAgICAgICBhcmdzLnB1c2goZGF0YUVudHJ5ID8gZGF0YUVudHJ5LmdldFZhbHVlKCkgOiBudWxsKTtcbiAgICAgICAgfVxuICAgIH07XG5cbm1vZHVsZS5leHBvcnRzID0gT3BlcmF0b3JMaXN0O1xuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcbnZhciBDID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gcmVnaXN0ZXJPcGVyYXRvciAmJiBnZXRPcGVyYXRvclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBvcGVyYXRvcnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBYZmxvdyBvcGVyYXRvci5cbiAgICAgKiBUaGUgb3BlcmF0b3JzIGFyZSBzdG9yZWQgaW4gY29sbGVjdGlvbnMgdXNpbmcgdGhlaXIgcGxhdGZvcm0gYXMgYSBrZXkuIElmIG5vIHBsYXRmb3JtIGlzIGRlZmluZWQsIHRoZSBvcGVyYXRvclxuICAgICAqIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyBhIEphdmFTY3JpcHQtYmFzZWQgb3BlcmF0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICovXG5cbnZhciByZWdpc3Rlck9wZXJhdG9yID0gZnVuY3Rpb24obmFtZSwgZGF0YSl7XG4gICAgdmFyIG9wQ29sbGVjdGlvbiwgcGxhdGZvcm07XG5cbiAgICBpbml0T3BlcmF0b3IoZGF0YSk7XG4gICAgaWYoIW9wZXJhdG9yc1tuYW1lXSkge1xuICAgICAgICBvcGVyYXRvcnNbbmFtZV0gPSB7fTtcbiAgICB9XG5cbiAgICBwbGF0Zm9ybSA9IGRhdGFbJ3BsYXRmb3JtJ10gfHwgQy5QTEFURk9STS5KQVZBU0NSSVBUO1xuXG4gICAgb3BDb2xsZWN0aW9uID0gb3BlcmF0b3JzW25hbWVdO1xuXG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIFhNTDNELmxvZ1dhcm5pbmcoXCJYZmxvdy5yZWdpc3Rlck9wZXJhdG9yOiBPcGVyYXRvciBuYW1lIHVuZGVmaW5lZC5cIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgWE1MM0QubG9nV2FybmluZyhcIlhmbG93LnJlZ2lzdGVyT3BlcmF0b3I6IE9wZXJhdG9yIGRhdGEgdW5kZWZpbmVkLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRhdGEubmFtZSA9IG5hbWU7XG4gICAgaWYoIW9wQ29sbGVjdGlvbltwbGF0Zm9ybV0pXG4gICAgICAgIG9wQ29sbGVjdGlvbltwbGF0Zm9ybV0gPSBbXTtcblxuICAgIG9wQ29sbGVjdGlvbltwbGF0Zm9ybV0ucHVzaChkYXRhKTtcbn07XG5cbnZhciBpbml0QW5vbnltb3VzT3BlcmF0b3IgPSBmdW5jdGlvbihuYW1lLCBkYXRhKXtcbiAgICBpbml0T3BlcmF0b3IoZGF0YSk7XG4gICAgZGF0YS5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG5cbnZhciBpc09wZXJhdG9yQXN5bmMgPSBmdW5jdGlvbihvcGVyYXRvcil7XG4gICAgcmV0dXJuICEhb3BlcmF0b3IuZXZhbHVhdGVfYXN5bmM7XG59O1xuXG52YXIgZ2V0T3BlcmF0b3JzID0gZnVuY3Rpb24obmFtZSwgcGxhdGZvcm0pe1xuICAgIHBsYXRmb3JtID0gcGxhdGZvcm0gfHwgQy5QTEFURk9STS5KQVZBU0NSSVBUO1xuXG4gICAgaWYgKG5hbWUgJiYgIW9wZXJhdG9yc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZighb3BlcmF0b3JzW25hbWVdW3BsYXRmb3JtXSB8fCBvcGVyYXRvcnNbbmFtZV1bcGxhdGZvcm1dLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBvcGVyYXRvcnNbbmFtZV1bcGxhdGZvcm1dO1xufTtcblxuZnVuY3Rpb24gaW5pdE9wZXJhdG9yKG9wZXJhdG9yKXtcbiAgICB2YXIgaW5kZXhNYXAgPSB7fTtcbiAgICAvLyBJbml0IHR5cGVzIG9mIG91dHB1dHMgYW5kIHBhcmFtc1xuICAgIGZvcih2YXIgaT0gMDsgaSA8IG9wZXJhdG9yLm91dHB1dHMubGVuZ3RoOyArK2kpe1xuICAgICAgICBvcGVyYXRvci5vdXRwdXRzW2ldLnR5cGUgPSBDLkRBVEFfVFlQRV9NQVBbb3BlcmF0b3Iub3V0cHV0c1tpXS50eXBlXTtcbiAgICB9XG4gICAgZm9yKHZhciBpPSAwOyBpIDwgb3BlcmF0b3IucGFyYW1zLmxlbmd0aDsgKytpKXtcbiAgICAgICAgb3BlcmF0b3IucGFyYW1zW2ldLnR5cGUgPSBDLkRBVEFfVFlQRV9NQVBbb3BlcmF0b3IucGFyYW1zW2ldLnR5cGVdO1xuICAgICAgICBpbmRleE1hcFtvcGVyYXRvci5wYXJhbXNbaV0uc291cmNlXSA9IGk7XG4gICAgfVxuICAgIGlmKCFvcGVyYXRvci5tYXBwaW5nKVxuICAgICAgICBvcGVyYXRvci5tYXBwaW5nID0gb3BlcmF0b3IucGFyYW1zO1xuXG4gICAgLy8gSW5pdCBpbnRlclR5cGVzIG9mIG1hcHBpbmdcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3BlcmF0b3IubWFwcGluZy5sZW5ndGg7ICsraSl7XG4gICAgICAgIHZhciBtYXBwaW5nID0gb3BlcmF0b3IubWFwcGluZ1tpXTtcbiAgICAgICAgdmFyIHBhcmFtSWR4ID0gaW5kZXhNYXBbbWFwcGluZy5zb3VyY2VdO1xuICAgICAgICBtYXBwaW5nLnBhcmFtSWR4ID0gcGFyYW1JZHg7XG4gICAgICAgIHZhciB0eXBlID0gb3BlcmF0b3IucGFyYW1zW3BhcmFtSWR4XS50eXBlO1xuICAgICAgICBpZihtYXBwaW5nLnNlcXVlbmNlKVxuICAgICAgICAgICAgbWFwcGluZy5rZXlQYXJhbUlkeCA9IGluZGV4TWFwW21hcHBpbmcua2V5U291cmNlXTtcbiAgICAgICAgaWYobWFwcGluZy5zZXF1ZW5jZSA9PSBDLlNFUVVFTkNFLkxJTkVBUl9XRUlHSFQpXG4gICAgICAgICAgICB0eXBlID0gQy5EQVRBX1RZUEUuRkxPQVQ7XG4gICAgICAgIG1hcHBpbmcuaW50ZXJuYWxUeXBlID0gdHlwZTtcbiAgICAgICAgbWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lIHx8IG1hcHBpbmcuc291cmNlO1xuICAgIH1cblxuICAgIC8vQ2hlY2svaW5pdCBwbGF0Zm9ybVxuICAgIG9wZXJhdG9yLnBsYXRmb3JtID0gb3BlcmF0b3IucGxhdGZvcm0gfHwgQy5QTEFURk9STS5KQVZBU0NSSVBUO1xufVxuXG4vL3dpbmRvdy5YZmxvdy5yZWdpc3Rlck9wZXJhdG9yID0gcmVnaXN0ZXJPcGVyYXRvcjtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgcmVnaXN0ZXJPcGVyYXRvcjogcmVnaXN0ZXJPcGVyYXRvcixcbiAgICBpbml0QW5vbnltb3VzT3BlcmF0b3I6IGluaXRBbm9ueW1vdXNPcGVyYXRvcixcbiAgICBpc09wZXJhdG9yQXN5bmM6IGlzT3BlcmF0b3JBc3luYyxcbiAgICBnZXRPcGVyYXRvcnM6IGdldE9wZXJhdG9yc1xufTtcbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XG52YXIgQyA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvY29uc3RhbnRzLmpzXCIpO1xudmFyIFZTUHJvZ3JhbSA9IHJlcXVpcmUoXCIuL3ZzLXByb2dyYW0uanNcIik7XG52YXIgQ0xQcm9ncmFtID0gcmVxdWlyZShcIi4vY2wtcHJvZ3JhbS5qc1wiKTtcblxuLyoqXG4gKiBEYXRhIGZvciBhIE9wZXJhdG9yTGlzdCwgZ2VuZXJhdGVkIGJ5IGFuIEV4ZWN1dG9yXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFByb2dyYW1EYXRhID0gZnVuY3Rpb24oKXtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXkuPFByb2dyYW1JbnB1dENvbm5lY3Rpb24+fVxuICAgICAqL1xuICAgIHRoaXMuaW5wdXRzID0gW107XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtBcnJheS48RGF0YVNsb3Q+fVxuICAgICAqL1xuICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogaXRlcmF0ZUNvdW50OiBIb3cgb2Z0ZW4gd2UgaXRlcmF0ZSB3aXRoIHRoZSBkZWZhdWx0IGV4ZWN1dGlvbiBtb2RlbFxuICAgICAqIGl0ZXJGbGFnOiBQZXIgaW5wdXQ6IHRydWUgaWYgdGhlIGlucHV0IGNhbiBiZSBpdGVyYXRlZCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgICogY3VzdG9tRGF0YTogUGVyIGluc3RhbmNlIGRhdGEgdGhhdCB1c2VycyBjYW4gcGVyc2lzdCBiZXR3ZWVuIG9wZXJhdG9yIGludm9jYXRpb25zXG4gICAgICogQHR5cGUge0FycmF5Ljx7aXRlcmF0ZUNvdW50OiBudW1iZXIsIGl0ZXJGbGFnOiBBcnJheSwgY3VzdG9tRGF0YToge319Pn1cbiAgICAgKi9cbiAgICB0aGlzLm9wZXJhdG9yRGF0YSA9IFtdO1xufTtcblxuUHJvZ3JhbURhdGEucHJvdG90eXBlLmdldENoYW5uZWwgPSBmdW5jdGlvbihpbmRleCl7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRzW2luZGV4XS5jaGFubmVsO1xufTtcblxuUHJvZ3JhbURhdGEucHJvdG90eXBlLmdldERhdGFFbnRyeSA9IGZ1bmN0aW9uKGluZGV4KXtcbiAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0c1tpbmRleF07XG4gICAgdmFyIGNoYW5uZWwgPSBlbnRyeS5jaGFubmVsO1xuICAgIGlmKCFjaGFubmVsKSByZXR1cm4gbnVsbDtcbiAgICB2YXIga2V5ID0gMDtcbiAgICBpZihlbnRyeS5zZXF1ZW5jZUtleVNvdXJjZUNoYW5uZWwpe1xuICAgICAgICB2YXIga2V5RGF0YUVudHJ5ID0gZW50cnkuc2VxdWVuY2VLZXlTb3VyY2VDaGFubmVsLmdldERhdGFFbnRyeSgpO1xuICAgICAgICBrZXkgPSBrZXlEYXRhRW50cnkgJiYga2V5RGF0YUVudHJ5Ll92YWx1ZSA/IGtleURhdGFFbnRyeS5fdmFsdWVbMF0gOiAwO1xuICAgIH1cblxuICAgIHJldHVybiBjaGFubmVsLmdldERhdGFFbnRyeShlbnRyeS5zZXF1ZW5jZUFjY2Vzc1R5cGUsIGtleSk7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgUHJvZ3JhbUlucHV0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKCl7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0NoYW5uZWx9XG4gICAgICovXG4gICAgdGhpcy5jaGFubmVsID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIElzIHRoaXMgaW5wdXQgYSB1bmlmb3JtIGFycmF5XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5hcnJheUFjY2VzcyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0MuU0VRVUVOQ0V9XG4gICAgICovXG4gICAgdGhpcy5zZXF1ZW5jZUFjY2Vzc1R5cGUgPSBDLlNFUVVFTkNFLk5PX0FDQ0VTUztcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge0NoYW5uZWx8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLnNlcXVlbmNlS2V5U291cmNlQ2hhbm5lbCA9IG51bGw7XG59O1xuXG4vKipcbiAqIEhhc2gtYWJsZSBrZXkgdG8gaWRlbnRpZnkgZXF1YWwgaW5wdXRzIHdpdGhpbiBleGVjdXRvclxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUHJvZ3JhbUlucHV0Q29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gKHRoaXMuY2hhbm5lbCA/IHRoaXMuY2hhbm5lbC5pZCA6IFwiTlVMTFwiKSArIFwiO1wiICsgdGhpcy5hcnJheUFjY2VzcyArIFwiO1wiICsgdGhpcy5zZXF1ZW5jZUFjY2Vzc1R5cGUgKyBcIjtcIiArXG4gICAgKCB0aGlzLnNlcXVlbmNlS2V5U291cmNlQ2hhbm5lbCA/IHRoaXMuc2VxdWVuY2VLZXlTb3VyY2VDaGFubmVsLmlkIDogXCJcIik7XG59O1xuXG5cbnZhciBjX3Byb2dyYW1fY2FjaGUgPSB7fTtcblxudmFyIGNyZWF0ZVByb2dyYW0gPSBmdW5jdGlvbihvcGVyYXRvckxpc3Qpe1xuICAgIHZhciBmaXJzdE9wZXJhdG9yO1xuXG4gICAgaWYob3BlcmF0b3JMaXN0LmVudHJpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZpcnN0T3BlcmF0b3IgPSBvcGVyYXRvckxpc3QuZW50cmllc1swXS5vcGVyYXRvcjtcblxuICAgIHZhciBrZXkgPSBvcGVyYXRvckxpc3QuZ2V0S2V5KCk7XG4gICAgaWYoIWNfcHJvZ3JhbV9jYWNoZVtrZXldKXtcbiAgICAgICAgLy8gR0xTTCBvcGVyYXRvcnMgYXJlIGltcGxlbWVudGVkIGluIGEgZGlmZmVyZW50IHdheSwgc28gcGxhdGZvcm0gaW5mb3JtYXRpb24gaXMgZmV0Y2hlZCBmcm9tIHRoZSBvcGVyYXRvckxpc3RcbiAgICAgICAgLy8gYXMgYSBmYWxsYmFjayBtb2RlIHRvIG5vdCBicmVhayB0aGUgb2xkIGltcGxlbWVudGF0aW9uc1xuICAgICAgICBpZihvcGVyYXRvckxpc3QucGxhdGZvcm0gPT09IEMuUExBVEZPUk0uR0xTTCl7XG4gICAgICAgICAgICBjX3Byb2dyYW1fY2FjaGVba2V5XSA9IG5ldyBWU1Byb2dyYW0ob3BlcmF0b3JMaXN0KTtcblxuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0T3BlcmF0b3IucGxhdGZvcm0gPT09IEMuUExBVEZPUk0uQ0wpIHtcbiAgICAgICAgICAgIGNfcHJvZ3JhbV9jYWNoZVtrZXldID0gbmV3IENMUHJvZ3JhbShvcGVyYXRvckxpc3QpO1xuXG4gICAgICAgIH1lbHNlIGlmKGZpcnN0T3BlcmF0b3IucGxhdGZvcm0gPT09IEMuUExBVEZPUk0uSkFWQVNDUklQVCAmJiBvcGVyYXRvckxpc3QuZW50cmllcy5sZW5ndGggPT09IDEgKSB7XG4gICAgICAgICAgICBjX3Byb2dyYW1fY2FjaGVba2V5XSA9IG5ldyBTaW5nbGVQcm9ncmFtKG9wZXJhdG9yTGlzdCk7XG5cbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIkNvdWxkIG5vdCBjcmVhdGUgcHJvZ3JhbSBmcm9tIG9wZXJhdG9yTGlzdFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY19wcm9ncmFtX2NhY2hlW2tleV07XG59O1xuXG5cblxudmFyIFNpbmdsZVByb2dyYW0gPSBmdW5jdGlvbihvcGVyYXRvckxpc3Qpe1xuICAgIHRoaXMubGlzdCA9IG9wZXJhdG9yTGlzdDtcbiAgICB0aGlzLmVudHJ5ID0gb3BlcmF0b3JMaXN0LmVudHJpZXNbMF07XG4gICAgdGhpcy5vcGVyYXRvciA9IHRoaXMuZW50cnkub3BlcmF0b3I7XG4gICAgdGhpcy5faW5saW5lTG9vcCA9IG51bGw7XG59O1xuXG5TaW5nbGVQcm9ncmFtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihwcm9ncmFtRGF0YSwgYXN5bmNDYWxsYmFjayl7XG4gICAgdmFyIG9wZXJhdG9yRGF0YSA9IHByZXBhcmVPcGVyYXRvckRhdGEodGhpcy5saXN0LCAwLCBwcm9ncmFtRGF0YSk7XG5cbiAgICBpZihhc3luY0NhbGxiYWNrKVxuICAgICAgICBhcHBseUFzeW5jT3BlcmF0b3IodGhpcy5lbnRyeSwgcHJvZ3JhbURhdGEsIG9wZXJhdG9yRGF0YSwgYXN5bmNDYWxsYmFjayk7XG4gICAgZWxzZSBpZih0aGlzLm9wZXJhdG9yLmV2YWx1YXRlX2NvcmUpe1xuICAgICAgICBhcHBseUNvcmVPcGVyYXRpb24odGhpcywgcHJvZ3JhbURhdGEsIG9wZXJhdG9yRGF0YSk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIGFwcGx5RGVmYXVsdE9wZXJhdGlvbih0aGlzLmVudHJ5LCBwcm9ncmFtRGF0YSwgb3BlcmF0b3JEYXRhKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBhcHBseURlZmF1bHRPcGVyYXRpb24oZW50cnksIHByb2dyYW1EYXRhLCBvcGVyYXRvckRhdGEpe1xuICAgIHZhciBhcmdzID0gYXNzZW1ibGVGdW5jdGlvbkFyZ3MoZW50cnksIHByb2dyYW1EYXRhKTtcbiAgICBhcmdzLnB1c2gob3BlcmF0b3JEYXRhKTtcbiAgICBlbnRyeS5vcGVyYXRvci5ldmFsdWF0ZS5hcHBseShvcGVyYXRvckRhdGEsIGFyZ3MpO1xuICAgIGhhbmRsZVBvc3RQcm9jZXNzT3V0cHV0KGVudHJ5LCBwcm9ncmFtRGF0YSwgYXJncywgZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBhcHBseUFzeW5jT3BlcmF0b3IoZW50cnksIHByb2dyYW1EYXRhLCBvcGVyYXRvckRhdGEsIGFzeW5jQ2FsbGJhY2spe1xuICAgIHZhciBhcmdzID0gYXNzZW1ibGVGdW5jdGlvbkFyZ3MoZW50cnksIHByb2dyYW1EYXRhLCB0cnVlKTtcbiAgICBhcmdzLnB1c2gob3BlcmF0b3JEYXRhKTtcbiAgICBhcmdzLnB1c2goZnVuY3Rpb24oKXtcbiAgICAgICAgaGFuZGxlUG9zdFByb2Nlc3NPdXRwdXQoZW50cnksIHByb2dyYW1EYXRhLCBhcmdzLCB0cnVlKTtcbiAgICAgICAgYXN5bmNDYWxsYmFjaygpO1xuICAgIH0pO1xuICAgIGVudHJ5Lm9wZXJhdG9yLmV2YWx1YXRlX2FzeW5jLmFwcGx5KG9wZXJhdG9yRGF0YSwgYXJncyk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5Q29yZU9wZXJhdGlvbihwcm9ncmFtLCBwcm9ncmFtRGF0YSwgb3BlcmF0b3JEYXRhKXtcbiAgICB2YXIgYXJncyA9IGFzc2VtYmxlRnVuY3Rpb25BcmdzKHByb2dyYW0uZW50cnksIHByb2dyYW1EYXRhKTtcbiAgICBhcmdzLnB1c2gob3BlcmF0b3JEYXRhLml0ZXJhdGVDb3VudCk7XG5cbiAgICBpZighcHJvZ3JhbS5faW5saW5lTG9vcCl7XG4gICAgICAgIHByb2dyYW0uX2lubGluZUxvb3AgPSBjcmVhdGVPcGVyYXRvcklubGluZUxvb3AocHJvZ3JhbS5vcGVyYXRvciwgb3BlcmF0b3JEYXRhKTtcbiAgICB9XG4gICAgcHJvZ3JhbS5faW5saW5lTG9vcC5hcHBseShvcGVyYXRvckRhdGEsIGFyZ3MpO1xufVxuXG52YXIgY19WYXJQYXR0ZXJuID0gL3ZhclxccysoLikrWztcXG5dLztcbnZhciBjX0lubmVyVmFyUGF0dGVybiA9IC9bXj0sXFxzXStcXHMqKD1bXixdKyk/KCwpPy87XG5mdW5jdGlvbiBjcmVhdGVPcGVyYXRvcklubGluZUxvb3Aob3BlcmF0b3IsIG9wZXJhdG9yRGF0YSl7XG5cbiAgICB2YXIgY29kZSA9IFwiZnVuY3Rpb24gKFwiO1xuICAgIHZhciBmdW5jRGF0YSA9IHBhcnNlRnVuY3Rpb24ob3BlcmF0b3IuZXZhbHVhdGVfY29yZSk7XG4gICAgY29kZSArPSBmdW5jRGF0YS5hcmdzLmpvaW4oXCIsXCIpICsgXCIsX194Zmxvd01heCkge1xcblwiO1xuICAgIGNvZGUgKz0gXCIgICAgdmFyIF9feGZsb3dJID0gX194Zmxvd01heFxcblwiICtcbiAgICAgICAgXCIgICAgd2hpbGUoX194Zmxvd0ktLSl7XFxuXCI7XG5cbiAgICB2YXIgYm9keSA9IGZ1bmNEYXRhLmJvZHk7XG4gICAgYm9keSA9IHJlcGxhY2VBcnJheUFjY2Vzcyhib2R5LCBmdW5jRGF0YS5hcmdzLCBvcGVyYXRvciwgb3BlcmF0b3JEYXRhKTtcbiAgICBjb2RlICs9IGJvZHkgKyBcIlxcbiAgfVxcbn1cIjtcblxuICAgIHZhciBpbmxpbmVGdW5jID0gZXZhbChcIihcIiArIGNvZGUgKyBcIilcIik7XG4gICAgcmV0dXJuIGlubGluZUZ1bmM7XG59XG5cbiAgICB2YXIgY19GdW5jdGlvblBhdHRlcm4gPSAvZnVuY3Rpb25cXHMqKFteKF0qKVxcKChbXildKilcXClcXHMqXFx7KFtcXHNcXFNdKilcXH0vO1xuXG5mdW5jdGlvbiBwYXJzZUZ1bmN0aW9uKGZ1bmMpe1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIgbWF0Y2hlcyA9IGZ1bmMudG9TdHJpbmcoKS5tYXRjaChjX0Z1bmN0aW9uUGF0dGVybik7XG4gICAgaWYoIW1hdGNoZXMpe1xuICAgICAgICBCYXNlLm5vdGlmeUVycm9yKFwiWGZsb3cgSW50ZXJuYWw6IENvdWxkIG5vdCBwYXJzZSBmdW5jdGlvbjogXCIgKyBmdW5jKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5hcmdzID0gbWF0Y2hlc1syXS5zcGxpdChcIixcIik7XG4gICAgZm9yKHZhciBpIGluIHJlc3VsdC5hcmdzKSByZXN1bHQuYXJnc1tpXSA9IHJlc3VsdC5hcmdzW2ldLnRyaW0oKTtcbiAgICByZXN1bHQuYm9keSA9IG1hdGNoZXNbM107XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIGNfYnJhY2tldFBhdHRlcm4gPSAvKFthLXpBLVpfJF1bXFx3JF0qKShcXFspLztcblxuZnVuY3Rpb24gcmVwbGFjZUFycmF5QWNjZXNzKGNvZGUsIGFyZ3MsIG9wZXJhdG9yLCBvcGVyYXRvckRhdGEpe1xuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgIHZhciBpbmRleCA9IDAsIGJyYWNrZXRJbmRleCA9IGNvZGUuaW5kZXhPZihcIltcIiwgaW5kZXgpO1xuICAgIHdoaWxlKGJyYWNrZXRJbmRleCAhPSAtMSl7XG4gICAgICAgIHZhciBrZXkgPSBjb2RlLnN1YnN0cihpbmRleCkubWF0Y2goY19icmFja2V0UGF0dGVybilbMV07XG5cbiAgICAgICAgdmFyIGFyZ0lkeCA9IGFyZ3MuaW5kZXhPZihrZXkpO1xuICAgICAgICB2YXIgYWRkSW5kZXggPSBmYWxzZSwgdHVwbGVDbnQgPSAwO1xuICAgICAgICBpZihhcmdJZHggIT0gLTEpe1xuICAgICAgICAgICAgaWYoYXJnSWR4IDwgb3BlcmF0b3Iub3V0cHV0cy5sZW5ndGgpe1xuICAgICAgICAgICAgICAgIGFkZEluZGV4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0dXBsZUNudCA9IEMuREFUQV9UWVBFX1RVUExFX1NJWkVbW29wZXJhdG9yLm91dHB1dHNbYXJnSWR4XS50eXBlXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHZhciBpID0gYXJnSWR4IC0gb3BlcmF0b3Iub3V0cHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYWRkSW5kZXggPSBvcGVyYXRvckRhdGEuaXRlckZsYWdbaV07XG4gICAgICAgICAgICAgICAgdHVwbGVDbnQgPSBDLkRBVEFfVFlQRV9UVVBMRV9TSVpFW29wZXJhdG9yLm1hcHBpbmdbaV0uaW50ZXJuYWxUeXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdCArPSBjb2RlLnN1YnN0cmluZyhpbmRleCwgYnJhY2tldEluZGV4KSArIFwiW1wiO1xuICAgICAgICBpZihhZGRJbmRleCl7XG4gICAgICAgICAgICByZXN1bHQgKz0gdHVwbGVDbnQgKyBcIipfX3hmbG93SSArIFwiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gYnJhY2tldEluZGV4ICsgMTtcbiAgICAgICAgYnJhY2tldEluZGV4ID0gY29kZS5pbmRleE9mKFwiW1wiLCBpbmRleCk7XG4gICAgfVxuICAgIHJlc3VsdCArPSAgY29kZS5zdWJzdHJpbmcoaW5kZXgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cblxuZnVuY3Rpb24gcHJlcGFyZU9wZXJhdG9yRGF0YShsaXN0LCBpZHgsIHByb2dyYW1EYXRhKXtcbiAgICB2YXIgZGF0YSA9IHByb2dyYW1EYXRhLm9wZXJhdG9yRGF0YVswXTtcbiAgICB2YXIgZW50cnkgPSBsaXN0LmVudHJpZXNbaWR4XTtcbiAgICB2YXIgbWFwcGluZyA9IGVudHJ5Lm9wZXJhdG9yLm1hcHBpbmc7XG4gICAgZGF0YS5pdGVyRmxhZyA9IHt9O1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXBwaW5nLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIGRvSXRlcmF0ZSA9IChlbnRyeS5pc1RyYW5zZmVySW5wdXQoaSkgfHwgbGlzdC5pc0lucHV0SXRlcmF0ZShlbnRyeS5nZXREaXJlY3RJbnB1dEluZGV4KGkpKSk7XG4gICAgICAgIGRhdGEuaXRlckZsYWdbaV0gPSBkb0l0ZXJhdGU7XG4gICAgfVxuICAgIGRhdGEuaXRlcmF0ZUNvdW50ID0gbGlzdC5nZXRJdGVyYXRlQ291bnQocHJvZ3JhbURhdGEpO1xuICAgIGlmKCFkYXRhLmN1c3RvbURhdGEpXG4gICAgICAgIGRhdGEuY3VzdG9tRGF0YSA9IHt9O1xuICAgIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBhc3NlbWJsZUZ1bmN0aW9uQXJncyhlbnRyeSwgcHJvZ3JhbURhdGEsIGFzeW5jKXtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIHZhciBvdXRwdXRzID0gZW50cnkub3BlcmF0b3Iub3V0cHV0cztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgIGlmKG91dHB1dHNbaV0ubm9BbGxvYyl7XG4gICAgICAgICAgICBhcmdzLnB1c2goe2Fzc2lnbjogbnVsbH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2V7XG4gICAgICAgICAgICB2YXIgZGF0YVNsb3QgPSBwcm9ncmFtRGF0YS5vdXRwdXRzW2VudHJ5LmdldE91dHB1dEluZGV4KGkpXTtcbiAgICAgICAgICAgIHZhciBkYXRhRW50cnkgPSBhc3luYyA/IGRhdGFTbG90LmFzeW5jRGF0YUVudHJ5IDogZGF0YVNsb3QuZGF0YUVudHJ5O1xuICAgICAgICAgICAgYXJncy5wdXNoKGRhdGFFbnRyeSA/IGRhdGFFbnRyeS5nZXRWYWx1ZSgpIDogbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSW5wdXRUb0FyZ3MoYXJncywgZW50cnksIHByb2dyYW1EYXRhKTtcbiAgICByZXR1cm4gYXJncztcbn1cbmZ1bmN0aW9uIGhhbmRsZVBvc3RQcm9jZXNzT3V0cHV0KGVudHJ5LCBwcm9ncmFtRGF0YSwgcGFyYW1ldGVycywgYXN5bmMpe1xuICAgIHZhciBvdXRwdXRzID0gZW50cnkub3BlcmF0b3Iub3V0cHV0cztcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgIHZhciBkYXRhU2xvdCA9IHByb2dyYW1EYXRhLm91dHB1dHNbZW50cnkuZ2V0T3V0cHV0SW5kZXgoaSldO1xuICAgICAgICBpZihvdXRwdXRzW2ldLm5vQWxsb2Mpe1xuICAgICAgICAgICAgdmFyIGRhdGFFbnRyeSA9IGFzeW5jID8gZGF0YVNsb3QuYXN5bmNEYXRhRW50cnkgOiBkYXRhU2xvdC5kYXRhRW50cnk7XG4gICAgICAgICAgICBpZihkYXRhRW50cnkudHlwZSA9PSBDLkRBVEFfVFlQRS5URVhUVVJFICl7XG4gICAgICAgICAgICAgICAgZGF0YUVudHJ5Ll9zZXRJbWFnZShwYXJhbWV0ZXJzW2ldLmFzc2lnbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGRhdGFFbnRyeS5fc2V0VmFsdWUocGFyYW1ldGVyc1tpXS5hc3NpZ24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmKGFzeW5jKXtcbiAgICAgICAgICAgIGRhdGFTbG90LnN3YXBBc3luYygpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbmZ1bmN0aW9uIGFkZElucHV0VG9BcmdzKGFyZ3MsIGVudHJ5LCBwcm9ncmFtRGF0YSl7XG4gICAgdmFyIG1hcHBpbmcgPSBlbnRyeS5vcGVyYXRvci5tYXBwaW5nO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBtYXBwaW5nLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIG1hcEVudHJ5ID0gbWFwcGluZ1tpXTtcbiAgICAgICAgdmFyIGRhdGFFbnRyeSA9IHByb2dyYW1EYXRhLmdldERhdGFFbnRyeShlbnRyeS5nZXREaXJlY3RJbnB1dEluZGV4KGkpKTtcbiAgICAgICAgYXJncy5wdXNoKGRhdGFFbnRyeSA/IGRhdGFFbnRyeS5nZXRWYWx1ZSgpIDogbnVsbCk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjcmVhdGVQcm9ncmFtOiBjcmVhdGVQcm9ncmFtLFxuICAgIFByb2dyYW1EYXRhOiBQcm9ncmFtRGF0YSxcbiAgICBQcm9ncmFtSW5wdXRDb25uZWN0aW9uOiBQcm9ncmFtSW5wdXRDb25uZWN0aW9uXG59O1xuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcbnZhciBDID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG52YXIgVXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXRpbHMuanNcIik7XG52YXIgVmVydGV4U2hhZGVyID0gcmVxdWlyZShcIi4uL3Byb2Nlc3NpbmcvdnMtY29ubmVjdC5qc1wiKS5WZXJ0ZXhTaGFkZXI7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gT3BlcmF0b3JMaXN0XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNfU0hBREVSX0NPTlNUQU5UX1RZUEVTID0ge307XG5jX1NIQURFUl9DT05TVEFOVF9UWVBFU1tDLlNIQURFUl9DT05TVEFOVF9LRVkuT0JKRUNUX0lEXSA9ICdpbnQnO1xuY19TSEFERVJfQ09OU1RBTlRfVFlQRVNbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlNDUkVFTl9UUkFOU0ZPUk1dID0gJ21hdDQnO1xuY19TSEFERVJfQ09OU1RBTlRfVFlQRVNbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlNDUkVFTl9UUkFOU0ZPUk1fTk9STUFMXSA9ICdtYXQzJztcbmNfU0hBREVSX0NPTlNUQU5UX1RZUEVTW0MuU0hBREVSX0NPTlNUQU5UX0tFWS5WSUVXX1RSQU5TRk9STV0gPSAnbWF0NCc7XG5jX1NIQURFUl9DT05TVEFOVF9UWVBFU1tDLlNIQURFUl9DT05TVEFOVF9LRVkuVklFV19UUkFOU0ZPUk1fTk9STUFMXSA9ICdtYXQzJztcbmNfU0hBREVSX0NPTlNUQU5UX1RZUEVTW0MuU0hBREVSX0NPTlNUQU5UX0tFWS5XT1JMRF9UUkFOU0ZPUk1dID0gJ21hdDQnO1xuY19TSEFERVJfQ09OU1RBTlRfVFlQRVNbQy5TSEFERVJfQ09OU1RBTlRfS0VZLldPUkxEX1RSQU5TRk9STV9OT1JNQUxdID0gJ21hdDMnO1xuXG52YXIgVlNQcm9ncmFtID0gZnVuY3Rpb24ob3BlcmF0b3JMaXN0KXtcbiAgICB0aGlzLmxpc3QgPSBvcGVyYXRvckxpc3Q7XG4gICAgdGhpcy5fb3V0cHV0SW5mbyA9IHt9O1xuICAgIHNldE91dHB1dEl0ZXJhdGUodGhpcyk7XG59O1xuXG5WU1Byb2dyYW0ucHJvdG90eXBlLmdldE91dHB1dE5hbWVzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fb3V0cHV0SW5mbyk7XG59O1xuXG5WU1Byb2dyYW0ucHJvdG90eXBlLmdldE91dHB1dFR5cGUgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0SW5mb1tuYW1lXS50eXBlO1xufTtcblxuVlNQcm9ncmFtLnByb3RvdHlwZS5pc091dHB1dFVuaWZvcm0gPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gdGhpcy5fb3V0cHV0SW5mb1tuYW1lXS5pdGVyYXRpb24gPT0gQy5JVEVSQVRJT05fVFlQRS5PTkU7XG59O1xuXG5WU1Byb2dyYW0ucHJvdG90eXBlLmlzT3V0cHV0TnVsbCA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB0aGlzLl9vdXRwdXRJbmZvW25hbWVdLml0ZXJhdGlvbiA9PSBDLklURVJBVElPTl9UWVBFLk5VTEw7XG59O1xuXG5WU1Byb2dyYW0ucHJvdG90eXBlLmNyZWF0ZVZlcnRleFNoYWRlciA9IGZ1bmN0aW9uKHByb2dyYW1EYXRhLCB2c0NvbmZpZyl7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBWZXJ0ZXhTaGFkZXIocHJvZ3JhbURhdGEpO1xuICAgIGNvbnN0cnVjdFZTKHJlc3VsdCwgdGhpcywgdnNDb25maWcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBzZXRPdXRwdXRJdGVyYXRlKHByb2dyYW0pe1xuICAgIHZhciBvcGVyYXRvckxpc3QgPSBwcm9ncmFtLmxpc3QsIGVudHJpZXMgPSBvcGVyYXRvckxpc3QuZW50cmllcztcblxuICAgIHZhciBiYXNlRW50cnkgPSBlbnRyaWVzW2VudHJpZXMubGVuZ3RoIC0gMV0sIGJhc2VPcGVyYXRvciA9IGJhc2VFbnRyeS5vcGVyYXRvcjtcblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgYmFzZU9wZXJhdG9yLnBhcmFtcy5sZW5ndGg7ICsraSl7XG4gICAgICAgIHZhciBlbnRyeSA9IGJhc2VPcGVyYXRvci5wYXJhbXNbaV0sXG4gICAgICAgICAgICBuYW1lID0gZW50cnkuc291cmNlLFxuICAgICAgICAgICAgaW5wdXRJbmRleCA9IGksXG4gICAgICAgICAgICBkaXJlY3RJbnB1dEluZGV4ID0gYmFzZUVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaW5wdXRJbmRleCk7XG4gICAgICAgIHByb2dyYW0uX291dHB1dEluZm9bbmFtZV0gPSB7dHlwZTogZW50cnkudHlwZX07XG4gICAgICAgIGlmKCBiYXNlRW50cnkuaXNUcmFuc2ZlcklucHV0KGlucHV0SW5kZXgpIHx8XG4gICAgICAgICAgICBvcGVyYXRvckxpc3QuaXNJbnB1dEl0ZXJhdGUoZGlyZWN0SW5wdXRJbmRleCkpXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByb2dyYW0uX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID0gQy5JVEVSQVRJT05fVFlQRS5NQU5ZO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYob3BlcmF0b3JMaXN0LmlzSW5wdXRVbmlmb3JtKGRpcmVjdElucHV0SW5kZXgpKXtcbiAgICAgICAgICAgIHByb2dyYW0uX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID0gQy5JVEVSQVRJT05fVFlQRS5PTkU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIHByb2dyYW0uX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID0gQy5JVEVSQVRJT05fVFlQRS5OVUxMO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RWUyh2cywgcHJvZ3JhbSwgdnNDb25maWcpe1xuICAgIHZhciBvcGVyYXRvckxpc3QgPSBwcm9ncmFtLmxpc3QsIGVudHJpZXMgPSBvcGVyYXRvckxpc3QuZW50cmllcztcblxuICAgIHZhciB1c2VkTmFtZXMgPSBbXSxcbiAgICAgICAgZGlyZWN0SW5wdXROYW1lcyA9IHt9LFxuICAgICAgICB0cmFuc2Zlck5hbWVzID0ge307XG5cbiAgICB2YXIgYmFzZUVudHJ5ID0gZW50cmllc1tlbnRyaWVzLmxlbmd0aCAtIDFdLCBhY2NlcHRlZEJhc2VTaGFkZXJJbnB1dCA9IFtdLCBiYXNlT3BlcmF0b3IgPSBiYXNlRW50cnkub3BlcmF0b3I7XG5cbiAgICBpZighdnNDb25maWcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIHZzQ29uZmlnISBBdHRlbXB0IHRvIGNyZWF0ZSB2ZXJ0ZXggc2hhZGVyIHByb2dyYW1tIHdpdGhvdXQgVlMgb3BlcmF0b3I/XCIpO1xuXG4gICAgVXRpbHMubmFtZXNldC5hZGQodXNlZE5hbWVzLCB2c0NvbmZpZy5nZXRCbG9ja2VkTmFtZXMoKSk7XG5cbiAgICB2YXIgY29kZSA9IFwiXCI7XG4gICAgY29kZSArPSBcIi8vIE9VVFBVVFxcblwiO1xuICAgIC8vIEZpcnN0OiBjb2xsZWN0IG91dHB1dCBuYW1lc1xuICAgIGZvcih2YXIgbmFtZSBpbiB2c0NvbmZpZy5fYWRkT3V0cHV0KXtcbiAgICAgICAgdmFyIGVudHJ5ID0gdnNDb25maWcuX2FkZE91dHB1dFtuYW1lXTtcbiAgICAgICAgY29kZSArPSBcInZhcnlpbmcgXCIgKyBnZXRHTFNMVHlwZShlbnRyeS50eXBlKSArIFwiIFwiICsgbmFtZSArIFwiO1xcblwiO1xuICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh1c2VkTmFtZXMsIG5hbWUpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRJbmRleCA9IDA7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiB2c0NvbmZpZy5fYXR0cmlidXRlcyl7XG4gICAgICAgIHZhciBjb25maWdBdHRyID0gdnNDb25maWcuX2F0dHJpYnV0ZXNbbmFtZV0sXG4gICAgICAgICAgICBkaXJlY3RJbnB1dEluZGV4ID0gYmFzZUVudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaW5wdXRJbmRleCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjb25maWdBdHRyLmNoYW5uZWxpbmcubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIGNoYW5uZWxpbmcgPSBjb25maWdBdHRyLmNoYW5uZWxpbmdbaV07XG4gICAgICAgICAgICB2YXIgb3V0cHV0SW5mbyA9IHt0eXBlOiBjb25maWdBdHRyLnR5cGUsIGl0ZXJhdGlvbjogMCwgaW5kZXg6IDAsIHNvdXJjZU5hbWU6IG5hbWV9LFxuICAgICAgICAgICAgICAgIG91dHB1dE5hbWUgPSBjaGFubmVsaW5nLm91dHB1dE5hbWU7XG4gICAgICAgICAgICBpZiggY2hhbm5lbGluZy5jb2RlIHx8XG4gICAgICAgICAgICAgICAgYmFzZUVudHJ5LmlzVHJhbnNmZXJJbnB1dChpbnB1dEluZGV4KSB8fFxuICAgICAgICAgICAgICAgIG9wZXJhdG9yTGlzdC5pc0lucHV0SXRlcmF0ZShkaXJlY3RJbnB1dEluZGV4KSlcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhY2NlcHRlZEJhc2VTaGFkZXJJbnB1dFtpbnB1dEluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgb3V0cHV0SW5mby5pdGVyYXRpb24gPSBDLklURVJBVElPTl9UWVBFLk1BTlk7XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBiYXNlT3BlcmF0b3Iub3V0cHV0c1tpbnB1dEluZGV4XS50eXBlO1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gXCJ2YXJ5aW5nIFwiICsgZ2V0R0xTTFR5cGUodHlwZSkgKyBcIiBcIiArIG91dHB1dE5hbWUgKyBcIjtcXG5cIjtcbiAgICAgICAgICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh1c2VkTmFtZXMsIG91dHB1dE5hbWUpO1xuICAgICAgICAgICAgICAgIHRyYW5zZmVyTmFtZXNbYmFzZUVudHJ5LmdldFRyYW5zZmVyT3V0cHV0SWQoaSldID0gb3V0cHV0TmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYob3BlcmF0b3JMaXN0LmlzSW5wdXRVbmlmb3JtKGRpcmVjdElucHV0SW5kZXgpKXtcbiAgICAgICAgICAgICAgICBvdXRwdXRJbmZvLml0ZXJhdGlvbiA9IEMuSVRFUkFUSU9OX1RZUEUuT05FO1xuICAgICAgICAgICAgICAgIG91dHB1dEluZm8uaW5kZXggPSBkaXJlY3RJbnB1dEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBvdXRwdXRJbmZvLml0ZXJhdGlvbiA9IEMuSVRFUkFUSU9OX1RZUEUuTlVMTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHZzLl9vdXRwdXROYW1lcywgb3V0cHV0TmFtZSk7XG4gICAgICAgICAgICB2cy5fb3V0cHV0SW5mb1tvdXRwdXROYW1lXSA9IG91dHB1dEluZm87XG4gICAgICAgIH1cbiAgICAgICAgaW5wdXRJbmRleCsrO1xuICAgIH1cbiAgICBjb2RlICs9IFwiXFxuXCI7XG4gICAgY29kZSArPSBcIi8vIElOUFVUXFxuXCI7XG4gICAgLy8gQWRkIGFkZGl0aW9uYWwgaW5wdXRcbiAgICBmb3IodmFyIG5hbWUgaW4gdnNDb25maWcuX2FkZElucHV0KXtcbiAgICAgICAgdmFyIGVudHJ5ID0gdnNDb25maWcuX2FkZElucHV0W25hbWVdO1xuICAgICAgICBjb2RlICs9IChlbnRyeS51bmlmb3JtID8gXCJ1bmlmb3JtIFwiIDogXCJhdHRyaWJ1dGUgXCIgKSArIGdldEdMU0xUeXBlKGVudHJ5LnR5cGUpICsgXCIgXCIgKyBuYW1lICsgXCI7XFxuXCI7XG4gICAgICAgIFV0aWxzLm5hbWVzZXQuYWRkKHVzZWROYW1lcywgbmFtZSk7XG4gICAgfVxuICAgIC8vIFNlY29uZDogY29sbGVjdCBpbnB1dCBuYW1lc1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXSwgb3BlcmF0b3IgPSBlbnRyeS5vcGVyYXRvcjtcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IG9wZXJhdG9yLm1hcHBpbmcubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgaWYoIChpIDwgZW50cmllcy5sZW5ndGggLSAxIHx8IGFjY2VwdGVkQmFzZVNoYWRlcklucHV0W2pdKSAmJlxuICAgICAgICAgICAgICAgICAgICAhZW50cnkuaXNUcmFuc2ZlcklucHV0KGopICYmICFkaXJlY3RJbnB1dE5hbWVzW2VudHJ5LmdldERpcmVjdElucHV0SW5kZXgoaildKVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBtYXBFbnRyeSA9IG9wZXJhdG9yLm1hcHBpbmdbal07XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRGcmVlTmFtZShtYXBFbnRyeS5uYW1lLCB1c2VkTmFtZXMpLCBpbnB1dEluZGV4ID0gZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChqKSxcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybSA9ICFvcGVyYXRvckxpc3QuaXNJbnB1dEl0ZXJhdGUoaW5wdXRJbmRleCk7XG4gICAgICAgICAgICAgICAgdnMuX2lucHV0SW5mb1tuYW1lXSA9IHsgaW5kZXg6IGlucHV0SW5kZXgsIHVuaWZvcm06IHVuaWZvcm0gfTtcbiAgICAgICAgICAgICAgICBVdGlscy5uYW1lc2V0LmFkZCh2cy5faW5wdXROYW1lcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgZGlyZWN0SW5wdXROYW1lc1tpbnB1dEluZGV4XSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgY29kZSArPSAodW5pZm9ybSA/IFwidW5pZm9ybSBcIiA6IFwiYXR0cmlidXRlIFwiKSArIGdldEdMU0xUeXBlKG1hcEVudHJ5LmludGVybmFsVHlwZSkgKyBcIiBcIiArIG5hbWU7XG4gICAgICAgICAgICAgICAgaWYobWFwRW50cnkuYXJyYXkpXG4gICAgICAgICAgICAgICAgICAgIGNvZGUgKz0gXCJbXCIgKyBvcGVyYXRvckxpc3QuZ2V0SW5wdXRTaXplKGlucHV0SW5kZXgpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgY29kZSArPSBcIjtcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXJ0IG1haW5cbiAgICBjb2RlICs9IFwiXFxuLy8gQ09ERVxcblwiO1xuICAgIGNvZGUgKz0gXCJ2b2lkIG1haW4odm9pZCl7XFxuXCI7XG5cbiAgICAvLyBDcmVhdGUgQ29kZVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbnRyaWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpXSwgb3BlcmF0b3IgPSBlbnRyeS5vcGVyYXRvcjtcbiAgICAgICAgLy8gRGVjbGFyZSB0cmFuc2ZlciBvdXRwdXQgbmFtZXNcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IG9wZXJhdG9yLm91dHB1dHMubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgaWYoIWVudHJ5LmlzRmluYWxPdXRwdXQoaikpe1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gZ2V0RnJlZU5hbWUob3BlcmF0b3Iub3V0cHV0c1tqXS5uYW1lLCB1c2VkTmFtZXMpO1xuICAgICAgICAgICAgICAgIHRyYW5zZmVyTmFtZXNbZW50cnkuZ2V0VHJhbnNmZXJPdXRwdXRJZChqKV0gPSBuYW1lO1xuICAgICAgICAgICAgICAgIGNvZGUgKz0gXCJcXHRcIiArIGdldEdMU0xUeXBlKG9wZXJhdG9yLm91dHB1dHNbal0udHlwZSkgKyBcIiBcIiArIG5hbWUgKyBcIjtcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUYWtlIENvZGUgRnJhZ21lbnRcbiAgICAgICAgdmFyIGNvZGVGcmFnbWVudCA9IGNvbnZlcnRDb2RlRnJhZ21lbnQob3BlcmF0b3IuZXZhbHVhdGVfZ2xzbCwgZW50cnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZmVyTmFtZXMsIGRpcmVjdElucHV0TmFtZXMsIHVzZWROYW1lcyk7XG4gICAgICAgIGNvZGUgKz0gY29kZUZyYWdtZW50ICsgXCJcXG5cIjtcbiAgICB9XG5cbiAgICAvLyBBZGQgYXR0cmlidXRlIGNoYW5uZWxpbmcgY29kZVxuICAgIHZhciBtYXBwaW5nSW5kZXggPSAwLCBjb252ZXJzaW9uQ29kZSA9IFwiXCI7XG4gICAgZm9yKCB2YXIgbmFtZSBpbiB2c0NvbmZpZy5fYXR0cmlidXRlcyl7XG4gICAgICAgIHZhciBlbnRyeSA9IHZzQ29uZmlnLl9hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZW50cnkuY2hhbm5lbGluZy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbGluZyA9IGVudHJ5LmNoYW5uZWxpbmdbaV0sIG91dHB1dE5hbWUgPSBjaGFubmVsaW5nLm91dHB1dE5hbWU7XG4gICAgICAgICAgICBpZih2cy5fb3V0cHV0SW5mb1tvdXRwdXROYW1lXS5pdGVyYXRpb24gPT0gQy5JVEVSQVRJT05fVFlQRS5NQU5ZKXtcbiAgICAgICAgICAgICAgICBpZihjaGFubmVsaW5nLmNvZGUpXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnNpb25Db2RlICs9IFwiXFx0XCIgKyBjaGFubmVsaW5nLmNvZGUgKyBcIlxcblwiO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udmVyc2lvbkNvZGUgKz0gXCJcXHRcIiArIG91dHB1dE5hbWUgKyBcIiA9ICNJe1wiICsgbmFtZSArIFwifTtcXG5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtYXBwaW5nSW5kZXgrKztcbiAgICB9XG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB2c0NvbmZpZy5fY29kZUZyYWdtZW50cy5sZW5ndGg7ICsraSl7XG4gICAgICAgIGNvbnZlcnNpb25Db2RlICs9IFwiXFx0XCIgKyB2c0NvbmZpZy5fY29kZUZyYWdtZW50c1tpXSArIFwiXFxuXCI7XG4gICAgfVxuICAgIGNvZGUgKz0gY29udmVydENvZGVGcmFnbWVudChjb252ZXJzaW9uQ29kZSwgYmFzZUVudHJ5LCB0cmFuc2Zlck5hbWVzLCBkaXJlY3RJbnB1dE5hbWVzLCB1c2VkTmFtZXMpICsgXCJcXG5cIjtcblxuICAgIGNvZGUgKz0gXCJ9XFxuXCI7XG4gICAgdnMuX2dsc2xDb2RlID0gY29kZTtcbn1cblxuZnVuY3Rpb24gY29udmVydENvZGVGcmFnbWVudChjb2RlRnJhZ21lbnQsIGVudHJ5LCB0cmFuc2Zlck5hbWVzLCBkaXJlY3RJbnB1dE5hbWVzLCB1c2VkTmFtZXMpe1xuICAgIHZhciBpbmRleCwgb3BlcmF0b3IgPSBlbnRyeS5vcGVyYXRvcjtcbiAgICB3aGlsZSgoaW5kZXggPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIiNJe1wiKSkgIT0gLTEpe1xuICAgICAgICB2YXIgZW5kID0gY29kZUZyYWdtZW50LmluZGV4T2YoXCJ9XCIsaW5kZXgpO1xuICAgICAgICB2YXIgbWFwcGluZ0luZGV4ID0gZ2V0TWFwcGluZ0luZGV4KG9wZXJhdG9yLCBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKGluZGV4KzMsZW5kKSk7XG4gICAgICAgIHZhciByZXBsYWNlTmFtZSA9IGVudHJ5LmlzVHJhbnNmZXJJbnB1dChtYXBwaW5nSW5kZXgpID9cbiAgICAgICAgICAgIHRyYW5zZmVyTmFtZXNbZW50cnkuZ2V0VHJhbnNmZXJJbnB1dElkKG1hcHBpbmdJbmRleCldIDpcbiAgICAgICAgICAgIGRpcmVjdElucHV0TmFtZXNbZW50cnkuZ2V0RGlyZWN0SW5wdXRJbmRleChtYXBwaW5nSW5kZXgpXTtcbiAgICAgICAgY29kZUZyYWdtZW50ID0gY29kZUZyYWdtZW50LnN1YnN0cmluZygwLCBpbmRleCkgKyByZXBsYWNlTmFtZSArIGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoZW5kKzEpO1xuICAgIH1cbiAgICB3aGlsZSgoaW5kZXggPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIiNPe1wiKSkgIT0gLTEpe1xuICAgICAgICB2YXIgZW5kID0gY29kZUZyYWdtZW50LmluZGV4T2YoXCJ9XCIsaW5kZXgpO1xuICAgICAgICB2YXIgb3V0cHV0SW5kZXggPSBnZXRPdXRwdXRJbmRleChvcGVyYXRvciwgY29kZUZyYWdtZW50LnN1YnN0cmluZyhpbmRleCszLGVuZCkpO1xuICAgICAgICB2YXIgcmVwbGFjZU5hbWUgPSB0cmFuc2Zlck5hbWVzW2VudHJ5LmdldFRyYW5zZmVyT3V0cHV0SWQob3V0cHV0SW5kZXgpXTtcbiAgICAgICAgY29kZUZyYWdtZW50ID0gY29kZUZyYWdtZW50LnN1YnN0cmluZygwLCBpbmRleCkgKyByZXBsYWNlTmFtZSArIGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoZW5kKzEpO1xuICAgIH1cbiAgICB2YXIgbG9jYWxOYW1lcyA9IFtdO1xuICAgIHdoaWxlKChpbmRleCA9IGNvZGVGcmFnbWVudC5pbmRleE9mKFwiI0x7XCIpKSAhPSAtMSl7XG4gICAgICAgIHZhciBlbmQgPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIn1cIixpbmRleCk7XG4gICAgICAgIHZhciBrZXkgPSBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKGluZGV4KzMsZW5kKTtcbiAgICAgICAgaWYoIWxvY2FsTmFtZXNba2V5XSl7XG4gICAgICAgICAgICBsb2NhbE5hbWVzW2tleV0gPSBnZXRGcmVlTmFtZShrZXksIHVzZWROYW1lcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcGxhY2VOYW1lID0gbG9jYWxOYW1lc1trZXldO1xuICAgICAgICBjb2RlRnJhZ21lbnQgPSBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKDAsIGluZGV4KSArIHJlcGxhY2VOYW1lICsgY29kZUZyYWdtZW50LnN1YnN0cmluZyhlbmQrMSk7XG4gICAgfVxuICAgIHdoaWxlKChpbmRleCA9IGNvZGVGcmFnbWVudC5pbmRleE9mKFwiI0d7XCIpKSAhPSAtMSl7XG4gICAgICAgIHZhciBlbmQgPSBjb2RlRnJhZ21lbnQuaW5kZXhPZihcIn1cIixpbmRleCk7XG4gICAgICAgIHZhciByZXBsYWNlTmFtZSA9IGNvZGVGcmFnbWVudC5zdWJzdHJpbmcoaW5kZXgrMyxlbmQpO1xuICAgICAgICBjb2RlRnJhZ21lbnQgPSBjb2RlRnJhZ21lbnQuc3Vic3RyaW5nKDAsIGluZGV4KSArIHJlcGxhY2VOYW1lICsgY29kZUZyYWdtZW50LnN1YnN0cmluZyhlbmQrMSk7XG4gICAgfVxuICAgIHJldHVybiBjb2RlRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIGdldEZyZWVOYW1lKG5hbWUsIHVzZWROYW1lcyl7XG4gICAgdmFyIHJlc3VsdCA9IG5hbWUsIGkgPSAxO1xuICAgIHdoaWxlKHVzZWROYW1lcy5pbmRleE9mKHJlc3VsdCkgIT0gLTEpe1xuICAgICAgICByZXN1bHQgPSBuYW1lICsgXCJfXCIgKyAoKytpKTtcbiAgICB9XG4gICAgVXRpbHMubmFtZXNldC5hZGQodXNlZE5hbWVzLCByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hcHBpbmdJbmRleChvcGVyYXRvciwgbmFtZSl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9wZXJhdG9yLm1hcHBpbmcubGVuZ3RoOyArK2kpe1xuICAgICAgICBpZihvcGVyYXRvci5tYXBwaW5nW2ldLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IG5hbWUgJ1wiICsgbmFtZSAgKyBcIicgaW5zaWRlIG9mIGNvZGUgZnJhZ21lbnRcIiApO1xufVxuXG5mdW5jdGlvbiBnZXRPdXRwdXRJbmRleChvcGVyYXRvciwgbmFtZSl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG9wZXJhdG9yLm91dHB1dHMubGVuZ3RoOyArK2kpe1xuICAgICAgICBpZihvcGVyYXRvci5vdXRwdXRzW2ldLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0R0xTTFR5cGUoeGZsb3dUeXBlKXtcbiAgICBzd2l0Y2goeGZsb3dUeXBlKXtcbiAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5CT09MIDogcmV0dXJuICdib29sJztcbiAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5CWVRFIDogcmV0dXJuICd1aW50JztcbiAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVCA6IHJldHVybiAnZmxvYXQnO1xuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUMiA6IHJldHVybiAndmVjMic7XG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuRkxPQVQzIDogcmV0dXJuICd2ZWMzJztcbiAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDQgOiByZXR1cm4gJ3ZlYzQnO1xuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLkZMT0FUM1gzIDogcmV0dXJuICdtYXQzJztcbiAgICAgICAgY2FzZSBDLkRBVEFfVFlQRS5GTE9BVDRYNCA6IHJldHVybiAnbWF0NCc7XG4gICAgICAgIGNhc2UgQy5EQVRBX1RZUEUuSU5UIDogcmV0dXJuICdpbnQnO1xuICAgICAgICBjYXNlIEMuREFUQV9UWVBFLklOVDQgOiByZXR1cm4gJ2l2ZWM0JztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVHlwZSBub3Qgc3VwcG9ydGVkIGZvciBHTFNMIFwiICsgQy5nZXRUeXBlTmFtZSh4Zmxvd1R5cGUpICk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gVlNQcm9ncmFtO1xuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcbnZhciBDID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG52YXIgQ2hhbm5lbHMgPSByZXF1aXJlKFwiLi9jaGFubmVsLmpzXCIpO1xudmFyIFJlcXVlc3ROb2RlID0gcmVxdWlyZShcIi4vcHJvY2Vzcy1ub2RlLmpzXCIpLlJlcXVlc3ROb2RlO1xudmFyIFByb2Nlc3NOb2RlID0gcmVxdWlyZShcIi4vcHJvY2Vzcy1ub2RlLmpzXCIpLlByb2Nlc3NOb2RlO1xudmFyIERhdGFTbG90ID0gcmVxdWlyZShcIi4vZGF0YS1zbG90LmpzXCIpO1xudmFyIE9wZXJhdG9yID0gcmVxdWlyZShcIi4uL29wZXJhdG9yL29wZXJhdG9yLmpzXCIpO1xuXG52YXIgQ2hhbm5lbE1hcCA9IENoYW5uZWxzLkNoYW5uZWxNYXA7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ2hhbm5lbE5vZGVcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIElzIGNyZWF0ZWQgZm9yIGVhY2ggc3Vic3RpdHV0aW9uICh2aWEgZGF0YWZsb3cpIG9mIGEgRGF0YU5vZGUuXG4gKiBTdG9yZXMgYW4gb3B0aW1pemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBkYXRhIHdpdGggQ2hhbm5lbE1hcHMgYW5kIENoYW5uZWxzXG4gKiBPbiBjb25zdHJ1Y3Rpb24gYSBDaGFubmVsTm9kZSBpcyBtYXJrZWQgb3V0T2ZTeW5jIGFuZCBzeW5jaHJvbml6ZWQgb25seSBvbmNlIGRhdGEgaXMgcmVxdWVzdGVkLlxuICogV2hlbiB0aGUgc3RydWN0dXJlIG9mIGEgRGF0YU5vZGUgaXMgY2hhbmdlZCBpbiBhbnkgd2F5IChlLmcuIHJlbmFtZSBJbnB1dE5vZGUsIGFkZC9yZW1vdmUgY2hpbGRyZW4pIGEgY2hhbm5lbE5vZGVcbiAqIGlzIG1hcmtlZCBvdXRPZlN5bmMuXG4gKiBAcGFyYW0ge0RhdGFOb2RlfSBkYXRhTm9kZVxuICogQHBhcmFtIHtTdWJzdGl0dXRpb259IHN1YnN0aXR1dGlvblxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDaGFubmVsTm9kZSA9IGZ1bmN0aW9uKGRhdGFOb2RlLCBzdWJzdGl0dXRpb24pe1xuICAgIHRoaXMub3duZXIgPSBkYXRhTm9kZTtcbiAgICB0aGlzLnBsYXRmb3JtID0gQy5QTEFURk9STS5KQVZBU0NSSVBUO1xuICAgIHRoaXMuc3Vic3RpdHV0aW9uID0gc3Vic3RpdHV0aW9uOyAgIC8vIFN1YnN0aXR1dGlvbiBpcyBkZWZpbmVkIGJ5IHRoZSBkYXRhZmxvdyBpbnN0YW5jZVxuICAgIHRoaXMubG9hZGluZyA9IGZhbHNlOyAgIC8vIGlzIHRydWUgaWYgYW55IHZhbHVlIGluIHRoZSBzdWIgdHJlZSBpcyBsb2FkaW5nIGFuZCB0aGUgcmVzdWx0IGNhbid0IGJlIGNhbGN1bGF0ZWRcbiAgICB0aGlzLmlucHV0U2xvdHMgPSB7fTsgICAvLyBEYXRhRW50cmllcyBmcm9tIGRpcmVjdCBJbnB1dE5vZGUgY2hpbGRyZW4gb2YgdGhlIERhdGFOb2RlXG4gICAgdGhpcy5pbnB1dENoYW5uZWxzID0gbmV3IENoYW5uZWxNYXAoKTsgICAgLy8gY2hhbm5lbCBtYXAgZm9yIGlucHV0IGRhdGEgcHJpbyB0byBvcGVyYXRvciBleGVjdXRpb25cbiAgICB0aGlzLmNvbXB1dGVkQ2hhbm5lbHMgPSBuZXcgQ2hhbm5lbE1hcCgpOyAvLyBjaGFubmVsIG1hcCBleHRlbmQgYnkgb3BlcmF0b3Igb3V0cHV0XG4gICAgdGhpcy5vdXRwdXRDaGFubmVscyA9IG5ldyBDaGFubmVsTWFwKCk7ICAgLy8gY2hhbm5lbCBtYXAgd2l0aCBhcHBsaWVkIGZpbHRlciA9PiBmaW5hbCBvdXRwdXRcblxuICAgIC8qKlxuICAgICAqIE9wZXJhdG9yIGF0dGFjaGVkIHRvIERhdGFOb2RlIChndWFyYW50ZWVkIHRvIGJlIHJlc29sdmVkKVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgdGhpcy5vcGVyYXRvciA9IG51bGw7XG4gICAgLyoqXG4gICAgICogQ2hhbm5lbCBub2RlIG9mIHRoZSBkYXRhZmxvd05vZGUgKGFuYWxvZ3VlIHRvIGRhdGFmbG93Tm9kZSBvZiBEYXRhTm9kZSlcbiAgICAgKiBAdHlwZSB7Q2hhbm5lbE5vZGV9XG4gICAgICovXG4gICAgdGhpcy5kYXRhZmxvd0NoYW5uZWxOb2RlID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIG5vZGUgLSBvbmx5IGNvbnN0cnVjdGVkIGlmIGFuIG9wZXJhdG9yL2RhdGFmbG93IGlzIGRlZmluZWRcbiAgICAgKiBAdHlwZSB7UHJvY2Vzc05vZGV9XG4gICAgICovXG4gICAgdGhpcy5wcm9jZXNzTm9kZSA9IG51bGw7XG4gICAgLyoqXG4gICAgICogUmVxdWVzdCBOb2RlcyBjcmVhdGVkIGZvciBlYWNoIHJlc3VsdCByZXF1ZXN0IG9uIHRoaXMgZGF0YU5vZGUuXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLFJlcXVlc3ROb2RlPn1cbiAgICAgKi9cbiAgICB0aGlzLnJlcXVlc3ROb2RlcyA9IHt9O1xuICAgIC8qKlxuICAgICAqIE51bWJlciBvZiB1c2VzIG9mIGNoYW5uZWwgbm9kZS4gVGhpcyBpcyBvbmx5IHJlbGV2YW50IGZvciBjaGFubmVsIG5vZGVzIGNyZWF0ZWQgd2l0aCBzdWJzdGl0dXRpb24uXG4gICAgICogVGhlc2Ugbm9kZXMgYXJlIGNhY2hlZCBhbmQgdGhlIHVzZUNvdW50IGlzIHVzZWQgdG8gY2xlYW4gdGhpcyBjYWNoZS5cbiAgICAgKiBUT0RPOiBVc2Ugd2Vha21hcCBoZXJlIHRvIGF2b2lkIGV4cGxpY2l0IHJlZmVyZW5jZSBjb3VudFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy51c2VDb3VudCA9IDE7XG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgY2hhbm5lbCBub2RlIGlzIG91dCBvZiBzeW5jIGFuZCBpbnRlcm5hbCBjaGFubmVsIG1hcHMgbmVlZCB0byBiZSByZWNvbnN0cnVjdGVkXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdXRPZlN5bmMgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBJZiBub2RlIGlzIG91dCBvZiBzeW5jLCByZWNvbnN0cnVjdCBhbGwgY2hhbm5lbHNcbiAqL1xuQ2hhbm5lbE5vZGUucHJvdG90eXBlLnN5bmNocm9uaXplID0gZnVuY3Rpb24oKXtcblxuICAgIGlmKHRoaXMub3V0T2ZTeW5jKXtcbiAgICAgICAgdXBkYXRlUGxhdGZvcm0odGhpcyk7XG4gICAgICAgIHN5bmNocm9uaXplQ2hpbGRyZW4odGhpcyk7XG4gICAgICAgIHVwZGF0ZUlucHV0Q2hhbm5lbHModGhpcyk7XG4gICAgICAgIHVwZGF0ZUNvbXB1dGVkQ2hhbm5lbHModGhpcyk7XG4gICAgICAgIHVwZGF0ZU91dHB1dENoYW5uZWxzKHRoaXMpO1xuICAgICAgICB0aGlzLm91dE9mU3luYyA9IGZhbHNlO1xuICAgIH1cbn07XG5cbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy51c2VDb3VudCA9IDA7XG4gICAgIHRoaXMuaW5wdXRDaGFubmVscy5jbGVhcigpO1xuICAgICB0aGlzLm91dHB1dENoYW5uZWxzLmNsZWFyKCk7XG4gICAgIC8vIFRPRE86IE1ha2Ugc3VyZSBldmVyeXRoaW5nIGlzIGNsZWFuZWQgdXAgdGhlcmUhXG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5DaGFubmVsTm9kZS5wcm90b3R5cGUuaW5jcmVhc2VSZWYgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMudXNlQ291bnQrKztcbn07XG5cbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5kZWNyZWFzZVJlZiA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy51c2VDb3VudC0tO1xuICAgIGlmKHRoaXMudXNlQ291bnQgPT0gMCl7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5nZXRPdXRwdXROYW1lcyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zeW5jaHJvbml6ZSgpO1xuICAgIHJldHVybiB0aGlzLm91dHB1dENoYW5uZWxzLmdldE5hbWVzKCk7XG59O1xuXG5DaGFubmVsTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGREYXRhSW5kZXggPSBmdW5jdGlvbihmaWx0ZXIpe1xuICAgIHRoaXMuc3luY2hyb25pemUoKTtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXRDaGFubmVscy5nZXRDaGlsZERhdGFJbmRleEZvckZpbHRlcihmaWx0ZXIpO1xufTtcblxuQ2hhbm5lbE5vZGUucHJvdG90eXBlLnNldFN0cnVjdHVyZU91dE9mU3luYyA9IGZ1bmN0aW9uKClcbntcbiAgICBpZighdGhpcy5vdXRPZlN5bmMpe1xuICAgICAgICB0aGlzLm91dE9mU3luYyA9IHRydWU7XG4gICAgICAgIHRoaXMuaW5wdXRDaGFubmVscy5jbGVhcigpO1xuICAgICAgICB0aGlzLmNvbXB1dGVkQ2hhbm5lbHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vdXRwdXRDaGFubmVscy5jbGVhcigpO1xuICAgICAgICB0aGlzLnByb2Nlc3NOb2RlICYmIHRoaXMucHJvY2Vzc05vZGUuY2xlYXIoKTtcbiAgICAgICAgZm9yKHZhciBrZXkgaW4gdGhpcy5yZXF1ZXN0Tm9kZXMpe1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Tm9kZXNba2V5XS5zZXRTdHJ1Y3R1cmVPdXRPZlN5bmMoKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbkNoYW5uZWxOb2RlLnByb3RvdHlwZS5ub3RpZnlEYXRhQ2hhbmdlID0gZnVuY3Rpb24oaW5wdXROb2RlLCBjaGFuZ2VUeXBlKXtcbiAgICB2YXIga2V5ID0gaW5wdXROb2RlLl9uYW1lICsgXCI7XCIgKyBpbnB1dE5vZGUuX2tleTtcbiAgICBpZih0aGlzLmlucHV0U2xvdHNba2V5XSlcbiAgICAgICAgdGhpcy5pbnB1dFNsb3RzW2tleV0uc2V0RGF0YUVudHJ5KGlucHV0Tm9kZS5fZGF0YSwgY2hhbmdlVHlwZSk7XG59O1xuXG5DaGFubmVsTm9kZS5wcm90b3R5cGUuZ2V0UmVzdWx0ID0gZnVuY3Rpb24odHlwZSwgZmlsdGVyKSB7XG4gICAgdGhpcy5zeW5jaHJvbml6ZSgpO1xuXG4gICAgdmFyIGtleSA9IGZpbHRlciA/IGZpbHRlci5qb2luKFwiO1wiKSA6IFwiW251bGxdXCI7XG4gICAgaWYoIXRoaXMucmVxdWVzdE5vZGVzW2tleV0pe1xuICAgICAgICB0aGlzLnJlcXVlc3ROb2Rlc1trZXldID0gbmV3IFJlcXVlc3ROb2RlKHRoaXMsIGZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlcXVlc3ROb2Rlc1trZXldLmdldFJlc3VsdCh0eXBlKTtcbn07XG5cblxuQ2hhbm5lbE5vZGUucHJvdG90eXBlLmdldE91dHB1dENoYW5uZWxJbmZvID0gZnVuY3Rpb24obmFtZSl7XG4gICAgdGhpcy5zeW5jaHJvbml6ZSgpO1xuXG4gICAgdmFyIGNoYW5uZWwgPSB0aGlzLm91dHB1dENoYW5uZWxzLmdldENoYW5uZWwobmFtZSk7XG4gICAgaWYoIWNoYW5uZWwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IGNoYW5uZWwuZ2V0VHlwZSgpLFxuICAgICAgICBzZXFMZW5ndGg6IGNoYW5uZWwuZ2V0U2VxdWVuY2VMZW5ndGgoKSxcbiAgICAgICAgc2VxTWluS2V5OiBjaGFubmVsLmdldFNlcXVlbmNlTWluS2V5KCksXG4gICAgICAgIHNlcU1heEtleTogY2hhbm5lbC5nZXRTZXF1ZW5jZU1heEtleSgpLFxuICAgICAgICBvcmlnaW46IDAsXG4gICAgICAgIG9yaWdpbmFsTmFtZTogXCJcIlxuICAgIH07XG4gICAgdmFyIHByZUZpbHRlck5hbWUgPSB0aGlzLm93bmVyLl9maWx0ZXJNYXBwaW5nID8gdGhpcy5vd25lci5fZmlsdGVyTWFwcGluZy5nZXRSZW5hbWVTcmNOYW1lKG5hbWUpIDogbmFtZTtcbiAgICB2YXIgZGF0YUVudHJ5ID0gY2hhbm5lbC5nZXREYXRhRW50cnkoKTtcbiAgICBpZih0aGlzLmRhdGFmbG93Q2hhbm5lbE5vZGUpe1xuICAgICAgICB2YXIgcHJvdG9JbnB1dENoYW5uZWwgPSB0aGlzLmlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChwcmVGaWx0ZXJOYW1lKTtcbiAgICAgICAgaWYoIXByb3RvSW5wdXRDaGFubmVsIHx8IGRhdGFFbnRyeSAhPSBwcm90b0lucHV0Q2hhbm5lbC5nZXREYXRhRW50cnkoKSl7XG4gICAgICAgICAgICByZXN1bHQub3JpZ2luID0gQy5PUklHSU4uUFJPVE87XG4gICAgICAgICAgICByZXN1bHQub3JpZ2luYWxOYW1lID0gcHJlRmlsdGVyTmFtZTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYodGhpcy5vcGVyYXRvcil7XG4gICAgICAgIHZhciBpbnB1dENoYW5uZWwgPSB0aGlzLmlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChwcmVGaWx0ZXJOYW1lKTtcbiAgICAgICAgaWYoIWlucHV0Q2hhbm5lbCB8fCBkYXRhRW50cnkgIT0gaW5wdXRDaGFubmVsLmdldERhdGFFbnRyeSgpKXtcbiAgICAgICAgICAgIHJlc3VsdC5vcmlnaW4gPSBDLk9SSUdJTi5DT01QVVRFO1xuICAgICAgICAgICAgcmVzdWx0Lm9yaWdpbmFsTmFtZSA9IHRoaXMub3duZXIuX2NvbXB1dGVPdXRwdXRNYXBwaW5nLmdldFNjcmlwdE91dHB1dE5hbWVJbnYocHJlRmlsdGVyTmFtZSwgdGhpcy5vcGVyYXRvci5vdXRwdXRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0Lm9yaWdpbiA9IEMuT1JJR0lOLkNISUxEO1xuICAgIHJlc3VsdC5vcmlnaW5hbE5hbWUgPSBwcmVGaWx0ZXJOYW1lO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIFNlbGVjdCB0aGUgcGxhdGZvcm0gdG8gY29tcHV0ZSB0aGUgYXR0YWNoZWQgcGxhdGZvcm1cbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBsYXRmb3JtKGNoYW5uZWxOb2RlKSB7XG4gICAgdmFyIHBsYXRmb3JtO1xuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xuICAgIHZhciBncmFwaCA9IG93bmVyLl9ncmFwaDtcblxuICAgIC8vIFBsYXRmb3JtcyBvdGhlciB0aGFuIEphdmFTY3JpcHQgYXJlIGF2YWlsYWJsZSBvbmx5IGZvciBjb21wdXRpbmcgb3BlcmF0b3JzXG4gICAgaWYoIWNoYW5uZWxOb2RlLm93bmVyLl9jb21wdXRlT3BlcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vVE9ETzogSW1wcm92ZSBwbGF0Zm9ybSBzZWxlY3Rpb24gbG9naWMuXG4gICAgLy8gQ3VycmVudGx5IHdlIHVzZSBmb3JjZWQgcGxhdGZvcm0gaWYgZ3JhcGggcGxhdGZvcm0gaXMgc29tZXRoaW5nIG90aGVyIHRoYW4gSmF2YVNjcmlwdFxuICAgIC8vIGFuZCBmb3JjZWQgcGxhdGZvcm0gKG93bmVyLl9wbGF0Zm9ybSkgaXMgZGVmaW5lZFxuICAgIHBsYXRmb3JtID0gb3duZXIuX3BsYXRmb3JtICE9PSBudWxsID8gb3duZXIuX3BsYXRmb3JtIDogQy5QTEFURk9STS5KQVZBU0NSSVBUO1xuXG4gICAgY2hhbm5lbE5vZGUucGxhdGZvcm0gPSBwbGF0Zm9ybTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcbiAqL1xuZnVuY3Rpb24gc3luY2hyb25pemVDaGlsZHJlbihjaGFubmVsTm9kZSl7XG4gICAgdmFyIGRhdGFOb2RlID0gY2hhbm5lbE5vZGUub3duZXI7XG4gICAgY2hhbm5lbE5vZGUubG9hZGluZyA9IGRhdGFOb2RlLmlzU3VidHJlZUxvYWRpbmcoKTtcblxuICAgIC8qKlxuICAgICAqIElmIHRoZSBjaGFubmVsIG5vZGUgcmVwcmVzZW50cyBhIHN1YnN0aXR1dGlvbiwgd2UgYWxzbyBuZWVkIHRvXG4gICAgICogc3luY2hyb25pemUgdGhlIG1haW4gQ2hhbm5lbE5vZGUgb2YgdGhlIERhdGFOb2RlXG4gICAgICovXG4gICAgaWYoY2hhbm5lbE5vZGUuc3Vic3RpdHV0aW9uKSB7XG4gICAgICAgIGRhdGFOb2RlLl9jaGFubmVsTm9kZS5zeW5jaHJvbml6ZSgpO1xuICAgIH1cblxuICAgIC8vIE5vdyBzeW5jaHJvbml6ZSBhbGwgY2hpbGRyZW4gKGVpdGhlciByZWZlcmVuY2VkIGRhdGEgbm9kZSwgb3IgcmVhbCBjaGlsZHJlbilcbiAgICAvLyBUT0RPOiBDaGFuZ2UgaGVyZSBpZiB3ZSBjaGFuZ2UgYmVoYXZpb3VyIG9mIHNyYyBhdHRyaWJ1dGVcbiAgICBpZihkYXRhTm9kZS5fc291cmNlTm9kZSl7XG4gICAgICAgIGRhdGFOb2RlLl9zb3VyY2VOb2RlLl9nZXRPckNyZWF0ZUNoYW5uZWxOb2RlKGNoYW5uZWxOb2RlLnN1YnN0aXR1dGlvbikuc3luY2hyb25pemUoKTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGRhdGFOb2RlLl9jaGlsZHJlbi5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBpZihkYXRhTm9kZS5fY2hpbGRyZW5baV0uX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUpe1xuICAgICAgICAgICAgICAgIGRhdGFOb2RlLl9jaGlsZHJlbltpXS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZShjaGFubmVsTm9kZS5zdWJzdGl0dXRpb24pLnN5bmNocm9uaXplKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUlucHV0Q2hhbm5lbHMoY2hhbm5lbE5vZGUpe1xuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xuICAgIC8vIFRPRE86IENoYW5nZSBoZXJlIGlmIHdlIGNoYW5nZSBiZWhhdmlvdXIgb2Ygc3JjIGF0dHJpYnV0ZVxuICAgIGlmKG93bmVyLl9zb3VyY2VOb2RlKXtcbiAgICAgICAgY2hhbm5lbE5vZGUuaW5wdXRDaGFubmVscy5tZXJnZShvd25lci5fc291cmNlTm9kZS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZShjaGFubmVsTm9kZS5zdWJzdGl0dXRpb24pLm91dHB1dENoYW5uZWxzLCAwKTtcbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb3duZXIuX2NoaWxkcmVuO1xuICAgICAgICAvLyBGaXJzdCB0aGUgRGF0YU5vZGVzIHRoYW4gdGhlIGlucHV0IG5vZGVzIGluIG9yZGVyIHRvIG92ZXJyaWRlIHRoZSBEYXRhTm9kZSBjaGFubmVsc1xuICAgICAgICBtZXJnZUlucHV0Q2hhbm5lbERhdGFOb2RlcyhjaGFubmVsTm9kZSwgY2hpbGRyZW4pO1xuICAgICAgICBtZXJnZUlucHV0Q2hhbm5lbElucHV0Tm9kZXMoY2hhbm5lbE5vZGUsIGNoaWxkcmVuKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcbiAqIEBwYXJhbSB7QXJyYXkuPEdyYXBoTm9kZT59IGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW5wdXRDaGFubmVsSW5wdXROb2RlcyhjaGFubmVsTm9kZSwgY2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghY2hpbGRyZW5baV0uX2dldE9yQ3JlYXRlQ2hhbm5lbE5vZGUpIHsgIC8vIENoaWxkIGlzIGFuIElucHV0Tm9kZVxuICAgICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICB2YXIga2V5ID0gY2hpbGQuX25hbWUgKyBcIjtcIiArIGNoaWxkLl9rZXk7XG4gICAgICAgICAgICBpZiAoIWNoYW5uZWxOb2RlLnN1YnN0aXR1dGlvbikgeyAgLy8gTm8gZGF0YWZsb3dcbiAgICAgICAgICAgICAgICB2YXIgc2xvdCA9IG5ldyBEYXRhU2xvdChjaGlsZC5fZGF0YSwgY2hpbGQuX2tleSk7XG4gICAgICAgICAgICAgICAgY2hhbm5lbE5vZGUuaW5wdXRTbG90c1trZXldID0gc2xvdDtcbiAgICAgICAgICAgICAgICBjaGFubmVsTm9kZS5pbnB1dENoYW5uZWxzLmFkZERhdGFFbnRyeShjaGlsZC5fbmFtZSwgc2xvdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5fcGFyYW1OYW1lICYmIGNoYW5uZWxOb2RlLnN1YnN0aXR1dGlvbi5oYXNDaGFubmVsKGNoaWxkLl9wYXJhbU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuYWRkQ2hhbm5lbChjaGlsZC5fbmFtZSwgY2hhbm5lbE5vZGUuc3Vic3RpdHV0aW9uLmdldENoYW5uZWwoY2hpbGQuX3BhcmFtTmFtZSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuYWRkRGF0YUVudHJ5KGNoaWxkLl9uYW1lLCBjaGFubmVsTm9kZS5vd25lci5fY2hhbm5lbE5vZGUuaW5wdXRTbG90c1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcbiAqIEBwYXJhbSB7QXJyYXkuPEdyYXBoTm9kZT59IGNoaWxkcmVuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW5wdXRDaGFubmVsRGF0YU5vZGVzKGNoYW5uZWxOb2RlLCBjaGlsZHJlbikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuW2ldLl9nZXRPckNyZWF0ZUNoYW5uZWxOb2RlKSB7ICAvLyBDaGlsZCBpcyBhIERhdGFOb2RlXG4gICAgICAgICAgICBjaGFubmVsTm9kZS5pbnB1dENoYW5uZWxzLm1lcmdlKGNoaWxkcmVuW2ldLl9nZXRPckNyZWF0ZUNoYW5uZWxOb2RlKGNoYW5uZWxOb2RlLnN1YnN0aXR1dGlvbikub3V0cHV0Q2hhbm5lbHMsIGkpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wdXRlZENoYW5uZWxzKGNoYW5uZWxOb2RlKXtcbiAgICB2YXIgb3duZXIgPSBjaGFubmVsTm9kZS5vd25lcjtcbiAgICBjaGFubmVsTm9kZS5jb21wdXRlZENoYW5uZWxzLm1lcmdlKGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMpO1xuXG4gICAgdmFyIG9sZERhdGFmbG93Q2hhbm5lbE5vZGUgPSBjaGFubmVsTm9kZS5kYXRhZmxvd0NoYW5uZWxOb2RlO1xuXG4gICAgaWYoIG93bmVyLl9jb21wdXRlVXNlc0RhdGFmbG93ICYmIG93bmVyLl9kYXRhZmxvd05vZGUpe1xuICAgICAgICBjaGFubmVsTm9kZS5vcGVyYXRvciA9IG51bGw7XG4gICAgICAgIHVwZGF0ZURhdGFmbG93Q2hhbm5lbE5vZGUoY2hhbm5lbE5vZGUpO1xuICAgICAgICB1cGRhdGVDb21wdXRlZENoYW5uZWxzRnJvbURhdGFmbG93KGNoYW5uZWxOb2RlKTtcbiAgICB9XG4gICAgZWxzZSBpZighb3duZXIuX2NvbXB1dGVVc2VzRGF0YWZsb3cgJiYgb3duZXIuX2NvbXB1dGVPcGVyYXRvcil7XG4gICAgICAgIGNoYW5uZWxOb2RlLmRhdGFmbG93Q2hhbm5lbE5vZGUgPSBudWxsO1xuICAgICAgICB1cGRhdGVPcGVyYXRvcihjaGFubmVsTm9kZSk7XG4gICAgICAgIHVwZGF0ZUNvbXB1dGVkQ2hhbm5lbHNGcm9tT3BlcmF0b3IoY2hhbm5lbE5vZGUpO1xuICAgIH1cblxuICAgIGlmKG9sZERhdGFmbG93Q2hhbm5lbE5vZGUgJiYgb2xkRGF0YWZsb3dDaGFubmVsTm9kZSAhPSBjaGFubmVsTm9kZS5kYXRhZmxvd0NoYW5uZWxOb2RlKXtcbiAgICAgICAgb2xkRGF0YWZsb3dDaGFubmVsTm9kZS5vd25lci5fcmVtb3ZlU3Vic3RpdHV0aW9uTm9kZShvbGREYXRhZmxvd0NoYW5uZWxOb2RlKTtcbiAgICB9XG59XG5cbi8qKlxuICogRmluZCBhbmQgc2V0IHRoZSBvcGVyYXRvciBmb3IgdGhlIGdpdmVuIENoYW5uZWxOb2RlXG4gKiBAcGFyYW0gY2hhbm5lbE5vZGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3BlcmF0b3IoY2hhbm5lbE5vZGUpe1xuICAgIHZhciBvcGVyYXRvck5hbWUsIG9wZXJhdG9yO1xuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xuXG4gICAgaWYoY2hhbm5lbE5vZGUubG9hZGluZyl7XG4gICAgICAgIGNoYW5uZWxOb2RlLm9wZXJhdG9yID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZih0eXBlb2Ygb3duZXIuX2NvbXB1dGVPcGVyYXRvciA9PSBcInN0cmluZ1wiKXtcbiAgICAgICAgb3BlcmF0b3JOYW1lID0gb3duZXIuX2NvbXB1dGVPcGVyYXRvcjtcbiAgICAgICAgb3BlcmF0b3IgPSBudWxsO1xuXG4gICAgICAgIC8vIEdldHRpbmcgYSBjb3JyZWN0IG9wZXJhdG9yIGZvciB0aGUgc2VsZWN0ZWQgcGxhdGZvcm0uIElmIG9wZXJhdG9yIGlzIG5vdCBhdmFpbGFibGUsIHdlJ2xsIHRyeSB0byBnZXRcbiAgICAgICAgLy8gdGhlIGRlZmF1bHQgSmF2YVNjcmlwdCBwbGF0Zm9ybSBvcGVyYXRvclxuICAgICAgICBpZihvcGVyYXRvck5hbWUpe1xuICAgICAgICAgICAgb3BlcmF0b3IgPSBmaW5kT3BlcmF0b3JCeU5hbWUoY2hhbm5lbE5vZGUsIG93bmVyKTtcbiAgICAgICAgICAgIGlmKG9wZXJhdG9yKSB7IC8vIFRPRE86IElzIHRoaXMgZ29vZD8gV2UgY2FsY3VsYXRlZCB0aGUgcGxhdGZvcm0gYmVmb3JlLCBub3cgaXQganVzdCBnZXRzIG92ZXJyaWRlblxuICAgICAgICAgICAgICAgIGNoYW5uZWxOb2RlLnBsYXRmb3JtID0gb3BlcmF0b3IucGxhdGZvcm07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hhbm5lbE5vZGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICB9ZWxzZXtcbiAgICAgICAgY2hhbm5lbE5vZGUub3BlcmF0b3IgPSBvd25lci5fY29tcHV0ZU9wZXJhdG9yO1xuICAgIH1cbn1cblxudmFyIGNfdHlwZUNvbXBhcmlzb25zID0gW107XG5cbi8qKlxuICogRmluZCBvcGVyYXRvciBiYXNlZCBvbiBuYW1lIGluIGRhdGFOb2RlLCBwbGF0Zm9ybSBhbmQgaW5wdXQgbWFwcGluZyAoc2lnbmF0dXJlKVxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcbiAqIEBwYXJhbSB7RGF0YU5vZGV9IGRhdGFOb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fG51bGx9XG4gKi9cbmZ1bmN0aW9uIGZpbmRPcGVyYXRvckJ5TmFtZShjaGFubmVsTm9kZSwgZGF0YU5vZGUpe1xuICAgIHZhciBvcGVyYXRvck5hbWUgPSBkYXRhTm9kZS5fY29tcHV0ZU9wZXJhdG9yLFxuICAgICAgICBpbnB1dE1hcHBpbmcgPSBkYXRhTm9kZS5fY29tcHV0ZUlucHV0TWFwcGluZyxcbiAgICAgICAgaW5wdXRDaGFubmVscyA9IGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHM7XG5cbiAgICB2YXIgb3BlcmF0b3JzID0gT3BlcmF0b3IuZ2V0T3BlcmF0b3JzKG9wZXJhdG9yTmFtZSwgY2hhbm5lbE5vZGUucGxhdGZvcm0pIHx8XG4gICAgICAgICAgICAgICAgT3BlcmF0b3IuZ2V0T3BlcmF0b3JzKG9wZXJhdG9yTmFtZSwgQy5QTEFURk9STS5KQVZBU0NSSVBUKTtcbiAgICBpZighb3BlcmF0b3JzKXtcbiAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIk5vIG9wZXJhdG9yIHdpdGggbmFtZSAnXCIgKyBvcGVyYXRvck5hbWUrXCInIGZvdW5kXCIsIGNoYW5uZWxOb2RlLm93bmVyKTtcbiAgICB9XG5cbiAgICB2YXIgaSA9IG9wZXJhdG9ycy5sZW5ndGg7XG4gICAgd2hpbGUoaS0tKXtcbiAgICAgICAgaWYoY2hlY2tPcGVyYXRvcihvcGVyYXRvcnNbaV0sIGlucHV0TWFwcGluZywgaW5wdXRDaGFubmVscykpe1xuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yc1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjX3R5cGVDb21wYXJpc29ucy5sZW5ndGggPSAwO1xuICAgIGkgPSBvcGVyYXRvcnMubGVuZ3RoO1xuICAgIHdoaWxlKGktLSl7XG4gICAgICAgIGNoZWNrT3BlcmF0b3Iob3BlcmF0b3JzW2ldLCBpbnB1dE1hcHBpbmcsIGlucHV0Q2hhbm5lbHMsIGNfdHlwZUNvbXBhcmlzb25zKTtcbiAgICB9XG4gICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiTm8gb3BlcmF0b3IgJ1wiICsgb3BlcmF0b3JOYW1lK1wiJyB3aXRoIG1hdGNoaW5nIHR5cGUgc2lnbmF0dXJlIGZvdW5kOlxcblxcblwiXG4gICAgICAgICAgICAgICAgICAgICAgICArIGNfdHlwZUNvbXBhcmlzb25zLmpvaW4oXCJcXG5cIik7XG4gICAgQmFzZS5ub3RpZnlFcnJvcihlcnJvck1lc3NhZ2UsIGNoYW5uZWxOb2RlLm93bmVyKTtcbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIG9wZXJhdG9yXG4gKiBAcGFyYW0gaW5wdXRNYXBwaW5nXG4gKiBAcGFyYW0gaW5wdXRDaGFubmVsc1xuICogQHBhcmFtIHtBcnJheT99IHR5cGVDb21wYXJpc29uc091dHB1dCBJZiBhcnJheSBpcyBnaXZlLCBzYXZlIGVycm9yIGluZm9ybWF0aW9uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tPcGVyYXRvcihvcGVyYXRvciwgaW5wdXRNYXBwaW5nLCBpbnB1dENoYW5uZWxzLCB0eXBlQ29tcGFyaXNvbnNPdXRwdXQpe1xuICAgIHZhciBpbnB1dHMsIGVycm9ycztcbiAgICBpZih0eXBlQ29tcGFyaXNvbnNPdXRwdXQpe1xuICAgICAgICBpbnB1dHMgPSBbXTsgZXJyb3JzID0gW107XG4gICAgfVxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvcGVyYXRvci5wYXJhbXMubGVuZ3RoOyArK2kpe1xuICAgICAgICB2YXIgaW5wdXRFbnRyeSA9IG9wZXJhdG9yLnBhcmFtc1tpXSwgc291cmNlTmFtZSA9IGlucHV0RW50cnkuc291cmNlO1xuICAgICAgICB2YXIgZGF0YU5hbWUgPSBpbnB1dE1hcHBpbmcgPyBpbnB1dE1hcHBpbmcuZ2V0U2NyaXB0SW5wdXROYW1lKGksIHNvdXJjZU5hbWUpIDogc291cmNlTmFtZTtcbiAgICAgICAgdmFyIGVycm9ySGVhZGVyO1xuICAgICAgICBpZih0eXBlQ29tcGFyaXNvbnNPdXRwdXQpe1xuICAgICAgICAgICAgZXJyb3JIZWFkZXIgPSBcIkZvciBcIiArIChpKzEpICsgXCIuIGFyZ3VtZW50ICdcIiArIHNvdXJjZU5hbWUgKyBcIic6IFwiO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2goIEMuZ2V0VHlwZU5hbWUoaW5wdXRFbnRyeS50eXBlKSArIFwiIFwiICsgc291cmNlTmFtZSArIChpbnB1dEVudHJ5Lm9wdGlvbmFsID8gXCIgW29wdGlvbmFsXVwiIDogXCJcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmKGRhdGFOYW1lKXtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gaW5wdXRDaGFubmVscy5nZXRDaGFubmVsKGRhdGFOYW1lKTtcbiAgICAgICAgICAgIGlmKCFjaGFubmVsICYmICFpbnB1dEVudHJ5Lm9wdGlvbmFsKXtcbiAgICAgICAgICAgICAgICBpZighdHlwZUNvbXBhcmlzb25zT3V0cHV0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZXJyb3JIZWFkZXIgKyBcIkRhdGFFbnRyeSAnXCIgKyBkYXRhTmFtZSArIFwiJyBkb2VzIG5vdCBleGlzdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihjaGFubmVsICYmIGNoYW5uZWwuZ2V0VHlwZSgpICE9IGlucHV0RW50cnkudHlwZSl7XG4gICAgICAgICAgICAgICAgaWYoIXR5cGVDb21wYXJpc29uc091dHB1dClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycm9ySGVhZGVyICsgXCJEYXRhRW50cnkgJ1wiICsgZGF0YU5hbWUgKyBcIicgaGFzIHdyb25nIHR5cGUgJ1wiICsgQy5nZXRUeXBlTmFtZShjaGFubmVsLmdldFR5cGUoKSkgKyBcIidcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmKHR5cGVDb21wYXJpc29uc091dHB1dCl7XG4gICAgICAgIHR5cGVDb21wYXJpc29uc091dHB1dC5wdXNoKG9wZXJhdG9yLm5hbWUgKyBcIihcIiArIGlucHV0cy5qb2luKFwiLCBcIikgKyBcIilcXG5cXHQgKiBcIiArIGVycm9ycy5qb2luKFwiXFxuXFx0ICogXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBjaGFubmVsTm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVDb21wdXRlZENoYW5uZWxzRnJvbU9wZXJhdG9yKGNoYW5uZWxOb2RlKXtcbiAgICB2YXIgb3duZXIgPSBjaGFubmVsTm9kZS5vd25lcjtcbiAgICBpZihjaGFubmVsTm9kZS5vcGVyYXRvcil7XG4gICAgICAgIHZhciBwcm9jTm9kZSA9IGNoYW5uZWxOb2RlLnByb2Nlc3NOb2RlID0gbmV3IFByb2Nlc3NOb2RlKGNoYW5uZWxOb2RlKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgZm9yKHZhciBuYW1lIGluIHByb2NOb2RlLm91dHB1dERhdGFTbG90cyl7XG4gICAgICAgICAgICB2YXIgZGVzdE5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaWYob3duZXIuX2NvbXB1dGVPdXRwdXRNYXBwaW5nKSBkZXN0TmFtZSA9IG93bmVyLl9jb21wdXRlT3V0cHV0TWFwcGluZy5nZXRTY3JpcHRPdXRwdXROYW1lKGluZGV4LCBuYW1lKTtcbiAgICAgICAgICAgIGlmKGRlc3ROYW1lKXtcbiAgICAgICAgICAgICAgICBjaGFubmVsTm9kZS5jb21wdXRlZENoYW5uZWxzLmFkZE91dHB1dERhdGFTbG90KGRlc3ROYW1lLCBwcm9jTm9kZS5vdXRwdXREYXRhU2xvdHNbbmFtZV0sIHByb2NOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZURhdGFmbG93Q2hhbm5lbE5vZGUoY2hhbm5lbE5vZGUpe1xuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xuICAgIHZhciBzdWJTdWJzdGl0dXRpb24gPSBuZXcgU3Vic3RpdHV0aW9uKG93bmVyLl9kYXRhZmxvd05vZGUsIGNoYW5uZWxOb2RlKTtcbiAgICBjaGFubmVsTm9kZS5kYXRhZmxvd0NoYW5uZWxOb2RlID0gb3duZXIuX2RhdGFmbG93Tm9kZS5fZ2V0T3JDcmVhdGVDaGFubmVsTm9kZShzdWJTdWJzdGl0dXRpb24pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7Q2hhbm5lbE5vZGV9IGNoYW5uZWxOb2RlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNvbXB1dGVkQ2hhbm5lbHNGcm9tRGF0YWZsb3coY2hhbm5lbE5vZGUpe1xuICAgIHZhciBvd25lciA9IGNoYW5uZWxOb2RlLm93bmVyO1xuICAgIGlmKGNoYW5uZWxOb2RlLmRhdGFmbG93Q2hhbm5lbE5vZGUpe1xuICAgICAgICB2YXIgZGF0YWZsb3dDTm9kZSA9IGNoYW5uZWxOb2RlLmRhdGFmbG93Q2hhbm5lbE5vZGU7XG4gICAgICAgIGRhdGFmbG93Q05vZGUuc3luY2hyb25pemUoKTtcbiAgICAgICAgLy8gVE9ETzogV2UgaGF2ZSB0byBtYWtlIHN1cmUgdG8gZ2V0IG91dHB1dE5hbWVzIGluIHRoZSByaWdodCBvcmRlciB0byBhcHBseSBvdXRwdXQgbWFwcGluZyBjb3JyZWN0bHlcbiAgICAgICAgdmFyIG91dHB1dE5hbWVzID0gZGF0YWZsb3dDTm9kZS5vdXRwdXRDaGFubmVscy5nZXROYW1lcygpO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3V0cHV0TmFtZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHNyY05hbWUgPSBvdXRwdXROYW1lc1tpXSwgZGVzdE5hbWUgPSBzcmNOYW1lO1xuICAgICAgICAgICAgaWYob3duZXIuX2NvbXB1dGVPdXRwdXRNYXBwaW5nKVxuICAgICAgICAgICAgICAgIGRlc3ROYW1lID0gb3duZXIuX2NvbXB1dGVPdXRwdXRNYXBwaW5nLmdldFNjcmlwdE91dHB1dE5hbWUoaSwgc3JjTmFtZSk7XG4gICAgICAgICAgICBpZihkZXN0TmFtZSlcbiAgICAgICAgICAgICAgICBjaGFubmVsTm9kZS5jb21wdXRlZENoYW5uZWxzLmFkZENoYW5uZWwoZGVzdE5hbWUsIGRhdGFmbG93Q05vZGUub3V0cHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChzcmNOYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU91dHB1dENoYW5uZWxzKGNoYW5uZWxOb2RlKXtcbiAgICB2YXIgZGF0YU5vZGUgPSBjaGFubmVsTm9kZS5vd25lcjtcbiAgICBpZihkYXRhTm9kZS5fZmlsdGVyTWFwcGluZykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGlzIHRoZSBvbmx5IGxvY2F0aW9uIHdoZXJlIGFwcGx5RmlsdGVyT25DaGFubmVsTWFwIGlzIHVzZWQuIENhbiBiZSBzaW1wbGlmaWVkIChlLmcuIHdpdGhvdXQgY2FsbGJhY2spXG4gICAgICAgIGRhdGFOb2RlLl9maWx0ZXJNYXBwaW5nLmFwcGx5RmlsdGVyT25DaGFubmVsTWFwKGNoYW5uZWxOb2RlLm91dHB1dENoYW5uZWxzLCBjaGFubmVsTm9kZS5jb21wdXRlZENoYW5uZWxzLCBkYXRhTm9kZS5fZmlsdGVyVHlwZSwgc2V0Q2hhbm5lbEZpbHRlckNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBjaGFubmVsTm9kZS5vdXRwdXRDaGFubmVscy5tZXJnZShjaGFubmVsTm9kZS5jb21wdXRlZENoYW5uZWxzKTtcbn1cblxuZnVuY3Rpb24gc2V0Q2hhbm5lbEZpbHRlckNhbGxiYWNrKGRlc3RNYXAsIGRlc3ROYW1lLCBzcmNNYXAsIHNyY05hbWUpe1xuICAgIHZhciBjaGFubmVsID0gc3JjTWFwLmdldENoYW5uZWwoc3JjTmFtZSk7XG4gICAgZGVzdE1hcC5hZGRDaGFubmVsKGRlc3ROYW1lLCBjaGFubmVsLCBzcmNNYXAuZ2V0Q2hpbGREYXRhSW5kZXgoc3JjTmFtZSkpO1xufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFN1YnN0aXR1dGlvblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVE9ETzogVGhpbmsgb2YgcmVwbGFjaW5nIHRoaXMgd2l0aCBhIGNoYW5uZWwgbWFwXG4gKiBAcGFyYW0gZGF0YWZsb3dOb2RlXG4gKiBAcGFyYW0gdXNlckNoYW5uZWxOb2RlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFN1YnN0aXR1dGlvbiA9IGZ1bmN0aW9uKGRhdGFmbG93Tm9kZSwgdXNlckNoYW5uZWxOb2RlKXtcbiAgICB0aGlzLm1hcCA9IHt9O1xuXG4gICAgY3JlYXRlU3Vic3RpdHV0aW9uKHRoaXMsIGRhdGFmbG93Tm9kZSwgdXNlckNoYW5uZWxOb2RlKTtcbn07XG5cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuaGFzQ2hhbm5lbCA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiAhIXRoaXMubWFwW25hbWVdO1xufTtcblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0Q2hhbm5lbCA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB0aGlzLm1hcFtuYW1lXTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgaGFzaGFibGUga2V5IGZvciB0aGUgc3Vic3RpdXRpb25cbiAqIEBwYXJhbSBzdWJEYXRhZmxvd05vZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblN1YnN0aXR1dGlvbi5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24oc3ViRGF0YWZsb3dOb2RlKXtcbiAgICB2YXIga2V5ID0gXCJcIjtcbiAgICB2YXIgZ2xvYmFsUGFyYW1OYW1lcyA9IHN1YkRhdGFmbG93Tm9kZS5fZ2V0R2xvYmFsUGFyYW1OYW1lcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBnbG9iYWxQYXJhbU5hbWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLm1hcFtnbG9iYWxQYXJhbU5hbWVzW2ldXTtcbiAgICAgICAga2V5Kz0gKGNoYW5uZWwgJiYgY2hhbm5lbC5pZCB8fCBcIi1cIikgKyBcIiFcIjtcbiAgICB9XG4gICAgdmFyIHBhcmFtTmFtZXMgPSBzdWJEYXRhZmxvd05vZGUuX2dldFBhcmFtTmFtZXMoKTtcbiAgICBmb3IoaSA9IDA7IGkgPCBwYXJhbU5hbWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgY2hhbm5lbCA9IHRoaXMubWFwW3BhcmFtTmFtZXNbaV1dO1xuICAgICAgICBrZXkrPSAoY2hhbm5lbCAmJiBjaGFubmVsLmlkIHx8IFwiLVwiKSArIFwiLlwiO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTdWJzdGl0dXRpb259IHN1YnN0aXR1dGlvblxuICogQHBhcmFtIHtEYXRhTm9kZX0gZGF0YWZsb3dOb2RlXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSB1c2VyQ2hhbm5lbE5vZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlU3Vic3RpdHV0aW9uKHN1YnN0aXR1dGlvbiwgZGF0YWZsb3dOb2RlLCB1c2VyQ2hhbm5lbE5vZGUpe1xuICAgIHZhciB1c2VyT3duZXIgPSB1c2VyQ2hhbm5lbE5vZGUub3duZXI7XG5cbiAgICAvLyBGaW5kIGNoYW5uZWxzIGZvciBnbG9iYWwgcGFyYW1ldGVyc1xuICAgIHZhciBnbG9iYWxQYXJhbU5hbWVzID0gZGF0YWZsb3dOb2RlLl9nZXRHbG9iYWxQYXJhbU5hbWVzKCk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGdsb2JhbFBhcmFtTmFtZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICBzdWJzdGl0dXRpb24ubWFwW2dsb2JhbFBhcmFtTmFtZXNbaV1dID0gdXNlckNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChnbG9iYWxQYXJhbU5hbWVzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBGaW5kIGNoYW5uZWxzIGZvciBsb2NhbCBwYXJhbWV0ZXJzLiBUaGVzZSB3aWxsIG92ZXJyaWRlIGV4aXN0aW5nIGdsb2JhbCBwYXJhbWV0ZXJzXG4gICAgdmFyIHBhcmFtTmFtZXMgPSBkYXRhZmxvd05vZGUuX2dldFBhcmFtTmFtZXMoKTtcbiAgICBmb3IoaSA9IDA7IGkgPCBwYXJhbU5hbWVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdmFyIGRlc3ROYW1lID0gcGFyYW1OYW1lc1tpXSwgc3JjTmFtZSA9IGRlc3ROYW1lO1xuICAgICAgICBpZih1c2VyT3duZXIuX2NvbXB1dGVJbnB1dE1hcHBpbmcpe1xuICAgICAgICAgICAgc3JjTmFtZSA9IHVzZXJPd25lci5fY29tcHV0ZUlucHV0TWFwcGluZy5nZXRTY3JpcHRJbnB1dE5hbWUoaSwgZGVzdE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnN0aXR1dGlvbi5tYXBbZGVzdE5hbWVdID0gdXNlckNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChzcmNOYW1lKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIENoYW5uZWxOb2RlOiAgQ2hhbm5lbE5vZGUsXG4gICAgU3Vic3RpdHV0aW9uOiBTdWJzdGl0dXRpb25cbn07XG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xudmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcbnZhciBCdWZmZXJFbnRyeSA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvZGF0YS5qc1wiKS5CdWZmZXJFbnRyeTtcblxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIERhdGFTbG90XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENoYW5uZWxNYXBcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEEgbWFwIHdpdGggY2hhbm5lbHMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENoYW5uZWxNYXAgPSBmdW5jdGlvbigpe1xuICAgIC8qKlxuICAgICAqIEEgbWFwIG9mIGNoYW5uZWxzLlxuICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywge2NoYW5uZWw6IENoYW5uZWwsIGNoaWxkRGF0YUluZGV4OiBOdW1iZXJ9Pn1cbiAgICAgKi9cbiAgICB0aGlzLm1hcCA9IHt9O1xufTtcblxuXG4vKipcbiAqIFJldHVybiBhIGxpc3Qgb2YgYWxsIGtleXMuXG4gKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59XG4gKi9cbkNoYW5uZWxNYXAucHJvdG90eXBlLmdldE5hbWVzID0gZnVuY3Rpb24oKVxue1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm1hcCk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gbmFtZVxuICogQHJldHVybnMge0NoYW5uZWx9XG4gKi9cbkNoYW5uZWxNYXAucHJvdG90eXBlLmdldENoYW5uZWwgPSBmdW5jdGlvbihuYW1lKVxue1xuICAgIGlmKCF0aGlzLm1hcFtuYW1lXSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHRoaXMubWFwW25hbWVdLmNoYW5uZWw7XG59O1xuXG5DaGFubmVsTWFwLnByb3RvdHlwZS5nZXRDaGlsZERhdGFJbmRleCA9IGZ1bmN0aW9uKG5hbWUpXG57XG4gICAgaWYoIXRoaXMubWFwW25hbWVdKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiB0aGlzLm1hcFtuYW1lXS5jaGlsZERhdGFJbmRleDtcbn07XG5DaGFubmVsTWFwLnByb3RvdHlwZS5nZXRDaGlsZERhdGFJbmRleEZvckZpbHRlciA9IGZ1bmN0aW9uKGZpbHRlcil7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBmaWx0ZXIgPSBmaWx0ZXIgfHwgdGhpcy5nZXROYW1lcygpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmaWx0ZXIubGVuZ3RoOyArK2kpe1xuICAgICAgICB2YXIgaWR4ID0gdGhpcy5nZXRDaGlsZERhdGFJbmRleChmaWx0ZXJbaV0pO1xuICAgICAgICBpZihpZHggPT0gdW5kZWZpbmVkKSBjb250aW51ZTtcbiAgICAgICAgaWYocmVzdWx0ICE9IHVuZGVmaW5lZCAmJiByZXN1bHQgIT0gaWR4KVxuICAgICAgICAgICAgcmVzdWx0ID0gLTE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJlc3VsdCA9IGlkeDtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogVE9ETzogQWRkIGEgbWVyZ2VXaXRoQ2hpbGRJbmRleCBtZXRob2Q/XG4gKiBAcGFyYW0ge0NoYW5uZWxNYXB9IG90aGVyQ2hhbm5lbE1hcFxuICogQHBhcmFtIHtudW1iZXI/fSBjaGlsZERhdGFJbmRleCBJbmRleCByZWxhdGl2ZSB0byBEYXRhTm9kZS4gVXNlZCB0byBtYXJrIGlmIGNoYW5uZWwgY29tZXNcbiAqIGZyb20gYSBzcGVjaWZpYyBjaGlsZCBEYXRhTm9kZSwgdW5kZWZpbmVkIGlmIENoYW5uZWxNYXAgc2hvdWxkIHRha2Ugb3ZlciBjaGlsZCBpbmRleCBmcm9tIG90aGVyQ2hhbm5lbE1hcFxuICovXG5DaGFubmVsTWFwLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKG90aGVyQ2hhbm5lbE1hcCwgY2hpbGREYXRhSW5kZXgpe1xuICAgIGZvcih2YXIgbmFtZSBpbiBvdGhlckNoYW5uZWxNYXAubWFwKXtcbiAgICAgICAgLy8gRWl0aGVyIHVzZSBwcm92aWRlZCBjaGlsZCBpbmRleCwgb3RoZXJ3aXNlIHVzZSBjaGlsZCBpbmRleCBmcm9tIENoYW5uZWxNYXAgdG8gbWVyZ2VcbiAgICAgICAgLy8gRm9yIGlucHV0IGNoYW5uZWwgbWFwIHdlIGRlZmluZSB0aGUgY2hpbGREYXRhSW5kZXggZGlyZWN0bHksIGZvciBhcHBsaWVkIGZpbHRlcnMgd2UgdXNlIHRoZVxuICAgICAgICAvLyBjaGlsZERhdGFJbmRleCBvZiB0aGUgcHJvdmlkZWQgQ2hhbm5lbE1hcCAoaXQncyBqdXN0IGEgcmVuYW1pbmcpXG4gICAgICAgIHZhciBpbmRleCA9IGNoaWxkRGF0YUluZGV4ID09IHVuZGVmaW5lZCA/IG90aGVyQ2hhbm5lbE1hcC5nZXRDaGlsZERhdGFJbmRleChuYW1lKSA6IGNoaWxkRGF0YUluZGV4O1xuICAgICAgICB0aGlzLmFkZENoYW5uZWwobmFtZSwgb3RoZXJDaGFubmVsTWFwLmdldENoYW5uZWwobmFtZSksIGluZGV4KTtcbiAgICB9XG59O1xuLyoqXG4gKiBBZGQgYSBjaGFubmVsIHdpdGggYSBjaGlsZERhdGFJbmRleFxuICogVGhlIGNoaWxkRGF0YUluZGV4IGRlZmluZXMgdGhlIG9yaWdpbiBvZiB0aGUgY2hhbm5lbC5cbiAqIElmIGNoaWxkRGF0YUluZGV4IGlzIHVuZGVmaW5lZCB0aGUgdmFsdWUgb2YgdGhlIGNoYW5uZWwgY2FuJ3QgYmUgZGV0ZXJtaW5lZCBmcm9tIG9uZSBzaW5nbGUgRGF0YU5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0NoYW5uZWx9IGNoYW5uZWxcbiAqIEBwYXJhbSB7TnVtYmVyP30gY2hpbGREYXRhSW5kZXhcbiAqL1xuQ2hhbm5lbE1hcC5wcm90b3R5cGUuYWRkQ2hhbm5lbCA9IGZ1bmN0aW9uKG5hbWUsIGNoYW5uZWwsIGNoaWxkRGF0YUluZGV4KXtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIGlzIGV2ZXIgY2FsbGVkIHdpdGggYSBwcm9wZXIgY2hpbGREYXRhSW5kZXggdmFsdWVcbiAgICBpZighY2hhbm5lbCkgcmV0dXJuO1xuICAgIGlmKGNoaWxkRGF0YUluZGV4ID09IHVuZGVmaW5lZCkgY2hpbGREYXRhSW5kZXggPSAtMTtcbiAgICBtZXJnZUNoYW5uZWxJbnRvQ2hhbm5lbCh0aGlzLCBuYW1lLCBjaGFubmVsLCBjaGlsZERhdGFJbmRleCk7XG59O1xuXG4vKipcbiAqIEFkZCBEYXRhU2xvdCB0byB0aGUgQ2hhbm5lbFxuICogQHBhcmFtIG5hbWVcbiAqIEBwYXJhbSBkYXRhU2xvdFxuICovXG5DaGFubmVsTWFwLnByb3RvdHlwZS5hZGREYXRhRW50cnkgPSBmdW5jdGlvbihuYW1lLCBkYXRhU2xvdClcbntcbiAgICBtZXJnZURhdGFTbG90SW50b0NoYW5uZWwodGhpcywgbmFtZSwgZGF0YVNsb3QsIC0xKTtcbn07XG4vKipcbiAqIEFkZCBhbiBvdXRwdXQgRGF0YVNsb3QgdGhhdCBvcmlnaW5hdGVzIGZyb20gYW4gb3BlcmF0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0RhdGFTbG90fSBkYXRhU2xvdFxuICogQHBhcmFtIHtQcm9jZXNzTm9kZX0gY3JlYXRvck5vZGVcbiAqL1xuQ2hhbm5lbE1hcC5wcm90b3R5cGUuYWRkT3V0cHV0RGF0YVNsb3QgPSBmdW5jdGlvbihuYW1lLCBkYXRhU2xvdCwgY3JlYXRvck5vZGUpe1xuICAgIHZhciBmaW5hbENoYW5uZWwgPSBtZXJnZURhdGFTbG90SW50b0NoYW5uZWwodGhpcywgbmFtZSwgZGF0YVNsb3QsIC0xKTtcbiAgICBmaW5hbENoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlID0gY3JlYXRvck5vZGU7XG59O1xuXG4vKipcbiAqIEVtcHR5IHRoZSBjaGFubmVsIG1hcC5cbiAqL1xuQ2hhbm5lbE1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIGZvcih2YXIgbmFtZSBpbiB0aGlzLm1hcCl7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5tYXBbbmFtZV07XG4gICAgICAgIGlmKGNoYW5uZWwgJiYgY2hhbm5lbC5tYXAgPT0gdGhpcylcbiAgICAgICAgICAgIGNoYW5uZWwuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5tYXAgPSB7fTtcbn07XG5cbmZ1bmN0aW9uIGluaXRDaGFubmVsU2xvdChjaGFubmVsTWFwLCBuYW1lKXtcbiAgICBpZighY2hhbm5lbE1hcC5tYXBbbmFtZV0pe1xuICAgICAgICBjaGFubmVsTWFwLm1hcFtuYW1lXSA9IHtcbiAgICAgICAgICAgIGNoYW5uZWw6IG51bGwsXG4gICAgICAgICAgICBjaGlsZERhdGFJbmRleDogdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2hhbm5lbEludG9DaGFubmVsKGNoYW5uZWxNYXAsIG5hbWUsIG5ld0NoYW5uZWwsIGNoaWxkRGF0YUluZGV4KXtcbiAgICBpbml0Q2hhbm5lbFNsb3QoY2hhbm5lbE1hcCwgbmFtZSk7XG4gICAgdmFyIGN1cnJlbnRDaGFubmVsID0gY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hhbm5lbDtcbiAgICBpZighY3VycmVudENoYW5uZWwgfHwgIWN1cnJlbnRDaGFubmVsLndpbGxNZXJnZVdpdGhDaGFubmVsKG5ld0NoYW5uZWwpKSB7XG4gICAgICAgIGNoYW5uZWxNYXAubWFwW25hbWVdLmNoYW5uZWwgPSBuZXdDaGFubmVsO1xuICAgICAgICBjaGFubmVsTWFwLm1hcFtuYW1lXS5jaGlsZERhdGFJbmRleCA9IGNoaWxkRGF0YUluZGV4O1xuICAgICAgICByZXR1cm4gbmV3Q2hhbm5lbDtcbiAgICB9XG4gICAgY3VycmVudENoYW5uZWwgPSBnZXRNYXBPd25lZENoYW5uZWwoY2hhbm5lbE1hcCwgY3VycmVudENoYW5uZWwpO1xuICAgIGN1cnJlbnRDaGFubmVsLmFkZENoYW5uZWxFbnRyaWVzKG5ld0NoYW5uZWwpO1xuICAgIGNoYW5uZWxNYXAubWFwW25hbWVdLmNoYW5uZWwgPSBjdXJyZW50Q2hhbm5lbDtcbiAgICBjaGFubmVsTWFwLm1hcFtuYW1lXS5jaGlsZERhdGFJbmRleCA9IC0xO1xuICAgIHJldHVybiBjdXJyZW50Q2hhbm5lbDtcbn1cblxuZnVuY3Rpb24gbWVyZ2VEYXRhU2xvdEludG9DaGFubmVsKGNoYW5uZWxNYXAsIG5hbWUsIGRhdGFTbG90LCBjaGlsZERhdGFJbmRleCl7XG4gICAgaW5pdENoYW5uZWxTbG90KGNoYW5uZWxNYXAsIG5hbWUpO1xuICAgIHZhciBjdXJyZW50Q2hhbm5lbCA9IGNoYW5uZWxNYXAubWFwW25hbWVdLmNoYW5uZWw7XG4gICAgaWYoIWN1cnJlbnRDaGFubmVsIHx8ICFjdXJyZW50Q2hhbm5lbC53aWxsTWVyZ2VXaXRoRGF0YVNsb3QoZGF0YVNsb3QpKXtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgQ2hhbm5lbChjaGFubmVsTWFwLCBkYXRhU2xvdCk7XG4gICAgICAgIGNoYW5uZWxNYXAubWFwW25hbWVdLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICBjaGFubmVsTWFwLm1hcFtuYW1lXS5jaGlsZERhdGFJbmRleCA9IGNoaWxkRGF0YUluZGV4O1xuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9XG4gICAgY3VycmVudENoYW5uZWwgPSBnZXRNYXBPd25lZENoYW5uZWwoY2hhbm5lbE1hcCwgY3VycmVudENoYW5uZWwpO1xuICAgIGN1cnJlbnRDaGFubmVsLmFkZERhdGFTbG90KGRhdGFTbG90KTtcbiAgICBjaGFubmVsTWFwLm1hcFtuYW1lXS5jaGFubmVsID0gY3VycmVudENoYW5uZWw7XG4gICAgY2hhbm5lbE1hcC5tYXBbbmFtZV0uY2hpbGREYXRhSW5kZXggPSAtMTtcbiAgICByZXR1cm4gY3VycmVudENoYW5uZWw7XG59XG5cblxuZnVuY3Rpb24gZ2V0TWFwT3duZWRDaGFubmVsKG1hcCwgY2hhbm5lbCl7XG4gICAgaWYoY2hhbm5lbC5tYXAgIT0gbWFwKXtcbiAgICAgICAgdmFyIG5ld0NoYW5uZWwgPSBuZXcgQ2hhbm5lbChtYXApO1xuICAgICAgICBuZXdDaGFubmVsLmFkZENoYW5uZWxFbnRyaWVzKGNoYW5uZWwpO1xuICAgICAgICBuZXdDaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSA9IGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlO1xuICAgICAgICByZXR1cm4gbmV3Q2hhbm5lbFxuICAgIH1cbiAgICByZXR1cm4gY2hhbm5lbDtcbn1cblxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENoYW5uZWxcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG5cbi8qKlxuICogQSBjaGFubmVsIG1heSBpbmNsdWUgc2V2ZXJhbCBEYXRhU2xvdHMvRGF0YUVudHJpZXNcbiAqIEEgZGVjbGFyZWQgU2VxdWVuY2Ugd2lsbCByZXN1bHQgaW4gb24gY2hhbm5lbCB3aXRoIG11bHRpcGxlIERhdGFFbnRyaWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0NoYW5uZWxNYXB9IG1hcCBPd25lciBvZiB0aGUgY2hhbm5lbFxuICogQHBhcmFtIHtEYXRhU2xvdD19IGRhdGFTbG90IE9wdGlvbmFsIERhdGFTbG90IGFkZGVkIHRvIHRoZSBjaGFubmVsXG4gKi9cbnZhciBDaGFubmVsID0gZnVuY3Rpb24obWFwLCBkYXRhU2xvdCl7XG4gICAgLyoqXG4gICAgICogRGF0YVNsb3QgZW50cmllcyBzb3J0ZWQgYnkga2V5IHZhbHVlXG4gICAgICogQHR5cGUge0FycmF5LjxEYXRhU2xvdD59XG4gICAgICovXG4gICAgdGhpcy5lbnRyaWVzID0gW107XG4gICAgLyoqXG4gICAgICogT3duZXIgQ2hhbm5lbE1hcCB0aGF0IGNyZWF0ZWQgd2l0aCBjaGFubmVsLlxuICAgICAqIE5vdGU6IGEgY2hhbm5lbCBjYW4gc3RpbGwgZXhpc3QgaW4gc2V2ZXJhbCBDaGFubmVsTWFwc1xuICAgICAqIEB0eXBlIHtDaGFubmVsTWFwfVxuICAgICAqL1xuICAgIHRoaXMubWFwID0gbWFwO1xuICAgIC8qKlxuICAgICAqIFVuaXF1ZSBJRCBmb3IgdGhpcyBjaGFubmVsLiBJcyB1c2VkIGZvciBzZXZlcmFsIG9wdGltaXphdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5pZCA9IGdlbmVyYXRlQ2hhbm5lbElkKCk7XG4gICAgLyoqXG4gICAgICogTGlzdGVuZXJzIG9mIHRoaXMgY2hhbm5lbHMgKHVzdWFsbHkgUHJvY2Vzc05vZGVzIGFuZCBSZXF1ZXN0Tm9kZXMpXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgLyoqXG4gICAgICogVGhlIFByb2Nlc3NOb2RlIHRoYXQgY3JlYXRlZC9leHRlbmRlZCB0aGUgY29udGVudCBvZiB0aGlzIGNoYW5uZWxcbiAgICAgKiBUaGVyZSBjYW4gYmUgb25seSBvbmUgY3JlYXRvclByb2Nlc3NOb2RlIHBlciBjaGFubmVsIGJlY2F1c2VcbiAgICAgKiB0aGVuIG91cHV0IERhdGFTbG90cyBvZiBhbiBvcGVyYXRvciB3aWxsIGFsd2F5cyBoYXZlIGtleSBcIjBcIlxuICAgICAqIElmIHR3byBvcGVyYXRvcnMgaW5mbHVlbmNlIHRoZSBzYW1lIHNlcXVlbmNlLCB0aGUgc2Vjb25kIG9wZXJhdG9yJ1xuICAgICAqIG91dHB1dCB3aWxsIHJlcGxhY2UgdGhlIGZpcnN0IG9wZXJhdG9yJ3Mgb3V0cHV0LCBlZmZlY3RpdmVseSByZW1vdmluZyB0aGUgZGVwZW5kZW5jeS5cbiAgICAgKiBAdHlwZSB7bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0b3JQcm9jZXNzTm9kZSA9IG51bGw7XG5cbiAgICBpZihkYXRhU2xvdCl7XG4gICAgICAgIHRoaXMuYWRkRGF0YVNsb3QoZGF0YVNsb3QpO1xuICAgIH1cbn07XG5cbi8qKlxuICogQWRkIGEgZGF0YVNsb3QgdG8gdGhlIGNoYW5uZWwsIGFkZGluZyBkZXBlbmRlbmNpZXMuXG4gKiBObyBub3RpZmljYXRpb25zIHNlbmQgZXRjLlxuICogTWFrZXMgc3VyZSB0aGF0IHJlc3VsdGluZyBjaGFubmVsIGhhcyBkYXRhU2xvdHMgb3JkZXJlZCBieSBrZXlcbiAqIEBwYXJhbSBkYXRhU2xvdFxuICovXG5DaGFubmVsLnByb3RvdHlwZS5hZGREYXRhU2xvdCA9IGZ1bmN0aW9uKGRhdGFTbG90KXtcbiAgICBkYXRhU2xvdC5hZGRDaGFubmVsKHRoaXMpO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmVudHJpZXNbaV07XG4gICAgICAgIC8vIFdlIHVzZSBlcHNpbG9uIGhlcmUgdG8gZGV0ZWN0IGRhdGEgZW50cmllcyB3aXRoIFwiZXF1YWxcIiBrZXlcbiAgICAgICAgaWYoZW50cnkua2V5ID49IGRhdGFTbG90LmtleSAtIEMuRVBTSUxPTiApe1xuICAgICAgICAgICAgaWYoTWF0aC5hYnMoZW50cnkua2V5IC0gZGF0YVNsb3Qua2V5KSA8PSBDLkVQU0lMT04pe1xuICAgICAgICAgICAgICAgIGVudHJ5LnJlbW92ZUNoYW5uZWwodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnRyaWVzLnNwbGljZShpLCAxLCBkYXRhU2xvdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHRoaXMuZW50cmllcy5zcGxpY2UoaSwgMCwgZGF0YVNsb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbnRyaWVzLnB1c2goZGF0YVNsb3QpO1xufTtcblxuQ2hhbm5lbC5wcm90b3R5cGUuZ2V0U2VxdWVuY2VMZW5ndGggPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB0aGlzLmVudHJpZXMubGVuZ3RoO1xufTtcbkNoYW5uZWwucHJvdG90eXBlLmdldFNlcXVlbmNlTWluS2V5ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzWzBdLmtleTtcbn07XG5DaGFubmVsLnByb3RvdHlwZS5nZXRTZXF1ZW5jZU1heEtleSA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllc1t0aGlzLmVudHJpZXMubGVuZ3RoIC0gMV0ua2V5O1xufTtcbi8qKlxuICogVGhlIERhdGFUeXBlIG9mIHRoZSBjaGFubmVsLlxuICogU2luY2UgYWxsIERhdGFFbnRyaWVzIHdpdGhpbiBhIGNoYW5uZWwgaGF2ZSB0aGUgc2FtZSB0eXBlLCB3ZSBjYW4gc2ltcGx5IHJldHVybiB0aGUgdHlwZSBvZiB0aGUgZmlyc3QgZW50cnkuXG4gKiBAcmV0dXJucyB7REFUQV9UWVBFfVxuICovXG5DaGFubmVsLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmVudHJpZXMubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBDLkRBVEFfVFlQRS5VTktOT1dOO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1swXS5kYXRhRW50cnkuX3R5cGU7XG59O1xuLyoqXG4gKiBNZXJnZSBhbm90aGVyIGNoYW5uZWwgaW50byB0aGlzIGNoYW5uZWwuXG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLmFkZENoYW5uZWxFbnRyaWVzID0gZnVuY3Rpb24ob3RoZXJDaGFubmVsKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3RoZXJDaGFubmVsLmVudHJpZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICB2YXIgc2xvdCA9IG90aGVyQ2hhbm5lbC5lbnRyaWVzW2ldO1xuICAgICAgICB0aGlzLmFkZERhdGFTbG90KHNsb3QpO1xuICAgIH1cbiAgICAvLyBGSVhNRTogb3RoZXJDaGFubmVsIG1pZ2h0IGJlIHdpdGhvdXQgY3JlYXRvclByb2Nlc3NOb2RlIGJ1dCBzdGlsbCBkZWZpbmUgYSBEYXRhU2xvdCB3aXRoIGtleSAwXG4gICAgLy8gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gc2V0IGNyZWF0b3JQcm9jZXNzTm9kZSB0byBudWxsXG4gICAgaWYob3RoZXJDaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSlcbiAgICAgICAgdGhpcy5jcmVhdG9yUHJvY2Vzc05vZGUgPSBvdGhlckNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlO1xuICAgIC8vZWxzZVxuICAgIC8vICAgIHRoaXMuY3JlYXRvclByb2Nlc3NOb2RlID0gbnVsbDtcbn07XG4vKipcbiAqIFJldHVybiBhIERhdGFFbnRyeSBmcm9tIHRoaXMgY2hhbm5lbCBkZXBlbmRpbmcgb24gc2VxdWVuY2VLZXkuXG4gKiBAcGFyYW0ge0MuU0VRVUVOQ0U/fSBzZXF1ZW5jZUFjY2Vzc1R5cGVcbiAqIEBwYXJhbSB7bnVtYmVyP30gc2VxdWVuY2VLZXlcbiAqIEByZXR1cm5zIHtEYXRhRW50cnl9XG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLmdldERhdGFFbnRyeSA9IGZ1bmN0aW9uKHNlcXVlbmNlQWNjZXNzVHlwZSwgc2VxdWVuY2VLZXkpe1xuICAgIGlmKHRoaXMuZW50cmllcy5sZW5ndGggPT0gMClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYoIXNlcXVlbmNlQWNjZXNzVHlwZSl7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNbMF0uZGF0YUVudHJ5O1xuICAgIH1cblxuXG4gICAgdmFyIGkgPSAwLCBtYXggPSB0aGlzLmVudHJpZXMubGVuZ3RoO1xuICAgIC8vIFRPRE86IERvIGJpbmFyeSBzZWFyY2ggaGVyZT9cbiAgICB3aGlsZShpIDwgbWF4ICYmIHRoaXMuZW50cmllc1tpXS5rZXkgPCBzZXF1ZW5jZUtleSkgKytpO1xuICAgIGlmKHNlcXVlbmNlQWNjZXNzVHlwZSA9PSBDLlNFUVVFTkNFLlBSRVZfQlVGRkVSKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc1tpID8gaSAtMSA6IDBdLmRhdGFFbnRyeTtcbiAgICB9XG4gICAgZWxzZSBpZihzZXF1ZW5jZUFjY2Vzc1R5cGUgPT0gQy5TRVFVRU5DRS5ORVhUX0JVRkZFUil7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNbaSA8IG1heCA/IGkgOiBtYXggLSAxXS5kYXRhRW50cnk7XG4gICAgfVxuICAgIGVsc2UgaWYoc2VxdWVuY2VBY2Nlc3NUeXBlID09IEMuU0VRVUVOQ0UuTElORUFSX1dFSUdIVCl7XG4gICAgICAgIHZhciB3ZWlnaHQxID0gdGhpcy5lbnRyaWVzW2kgPyBpIC0gMSA6IDBdLmtleTtcbiAgICAgICAgdmFyIHdlaWdodDIgPSB0aGlzLmVudHJpZXNbaSA8IG1heCA/IGkgOiBtYXggLSAxXS5rZXk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMSk7XG4gICAgICAgIHZhbHVlWzBdID0gd2VpZ2h0MiA9PSB3ZWlnaHQxID8gMCA6IChzZXF1ZW5jZUtleSAtIHdlaWdodDEpIC8gKHdlaWdodDIgLSB3ZWlnaHQxKTtcbiAgICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgcmVwZWF0ZWQgQnVmZmVyRW50cnkgYW5kIEZsb2F0MzJBcnJheSBhbGxvY2F0aW9uIGlzIGEgc2VyaW91cyBib3R0bGVuZWNrXG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyRW50cnkoQy5EQVRBX1RZUEUuRkxPQVQsIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIG9mIHRoZSB0d28gY2hhbm5lbHMgbmVlZCB0byBiZSBtZXJnZWQgKGluc3RlYWQgb2YgcmVwbGFjaW5nIHRoaXMgY2hhbm5lbCB3aXRoIG90aGVyQ2hhbm5lbClcbiAqIEBwYXJhbSBvdGhlckNoYW5uZWxcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5DaGFubmVsLnByb3RvdHlwZS53aWxsTWVyZ2VXaXRoQ2hhbm5lbCA9IGZ1bmN0aW9uKG90aGVyQ2hhbm5lbCl7XG4gICAgaWYodGhpcy5lbnRyaWVzLmxlbmd0aCAhPSBvdGhlckNoYW5uZWwuZW50cmllcy5sZW5ndGgpIHJldHVybiB0cnVlO1xuICAgIGlmKHRoaXMuZ2V0VHlwZSgpICE9IG90aGVyQ2hhbm5lbC5nZXRUeXBlKCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5lbnRyaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYoTWF0aC5hYnModGhpcy5lbnRyaWVzW2ldLmtleSAtIG90aGVyQ2hhbm5lbC5lbnRyaWVzW2ldLmtleSkgPiBDLkVQU0lMT04pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgd2UgbmVlZCB0byBtZXJnZSB0aGUgY2hhbm5lbCB3aXRoIHRoaXMgZGF0YVNsb3RcbiAqIChpbnN0ZWFkIG9mIGNyZWF0aW5nIGEgbmV3IGNoYW5uZWwgZnJvbXRoaXMgZGF0YVNsb3QpXG4gKiBAcGFyYW0gZGF0YVNsb3RcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5DaGFubmVsLnByb3RvdHlwZS53aWxsTWVyZ2VXaXRoRGF0YVNsb3QgPSBmdW5jdGlvbihkYXRhU2xvdCl7XG4gICAgaWYodGhpcy5lbnRyaWVzLmxlbmd0aCA+IDEpIHJldHVybiB0cnVlO1xuICAgIGlmKHRoaXMuZ2V0VHlwZSgpICE9IGRhdGFTbG90LmRhdGFFbnRyeS5fdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAoTWF0aC5hYnModGhpcy5lbnRyaWVzWzBdLmtleSAtIGRhdGFTbG90LmtleSkgPiBDLkVQU0lMT04pO1xufTtcblxuQ2hhbm5lbC5wcm90b3R5cGUubm90aWZ5T25DaGFuZ2UgPSBmdW5jdGlvbihzdGF0ZSl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGlzdGVuZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbaV0ub25YZmxvd0NoYW5uZWxDaGFuZ2UodGhpcywgc3RhdGUpO1xuICAgIH1cbn07XG5cbkNoYW5uZWwucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24ocHJvY2Vzc05vZGUpe1xuICAgIHRoaXMubGlzdGVuZXJzLnB1c2gocHJvY2Vzc05vZGUpO1xufTtcbkNoYW5uZWwucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24ocHJvY2Vzc05vZGUpe1xuICAgIHZhciBpZHggPSB0aGlzLmxpc3RlbmVycy5pbmRleE9mKHByb2Nlc3NOb2RlKTtcbiAgICBpZihpZHggIT0gLTEpIHRoaXMubGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xufTtcblxuQ2hhbm5lbC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmVudHJpZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICB0aGlzLmVudHJpZXNbaV0ucmVtb3ZlQ2hhbm5lbCh0aGlzKTtcbiAgICB9XG59O1xuXG52YXIgY19jaGFubmVsS2V5SWR4ID0gMDtcbmZ1bmN0aW9uIGdlbmVyYXRlQ2hhbm5lbElkKCl7XG4gICAgcmV0dXJuICsrY19jaGFubmVsS2V5SWR4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBDaGFubmVsOiBDaGFubmVsLFxuICAgIENoYW5uZWxNYXA6IENoYW5uZWxNYXBcbn07XG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xudmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcblxuLyoqXG4gKiBBIERhdGFTbG90IHdyYXBzIGEgZGF0YUVudHJ5IGFuZCBhZGRzIGEga2V5IHZhbHVlIGZvciBzZXF1ZW5jZXMuXG4gKiBUaGlzIHN0cnVjdHVyZSBpcyB1c2VkIGludGVybmFsbHkgd2l0aGluIGNoYW5uZWxzIGFuZCBwcm9jZXNzIG5vZGVzXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RGF0YUVudHJ5fSBkYXRhRW50cnlcbiAqIEBwYXJhbSB7bnVtYmVyPX0ga2V5XG4gKi9cbnZhciBEYXRhU2xvdCA9IGZ1bmN0aW9uKGRhdGFFbnRyeSwga2V5KXtcbiAgICB0aGlzLmtleSA9IGtleSB8fCAwOyAgICAgICAgICAgIC8vIHNlcXVlbmNlIGtleVxuICAgIHRoaXMuZGF0YUVudHJ5ID0gZGF0YUVudHJ5OyAgICAgLy8gZGF0YUVudHJ5IG9mIHRoZSBzbG90XG4gICAgLyoqXG4gICAgICogYWx0ZXJuYXRpdmUgZGF0YUVudHJ5IGZvciBhc3luY2hyb25vdXMgcHJvY2Vzc2luZ1xuICAgICAqIG9ubHkgdXNlZCBmb3Igb3V0cHV0IERhdGFTbG90cyBvZiBhc3luY2hyb25vdXMgb3BlcmF0b3JzXG4gICAgICogQHR5cGUge0RhdGFFbnRyeX1cbiAgICAgKi9cbiAgICB0aGlzLmFzeW5jRGF0YUVudHJ5ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIGFsbCBjaGFubmVscyB0aGF0IGNvbnRhaW4gdGhpcyBEYXRhU2xvdFxuICAgICAqIEB0eXBlIHtBcnJheS48Q2hhbm5lbD59XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnRDaGFubmVscyA9IFtdO1xuXG59O1xuRGF0YVNsb3QucHJvdG90eXBlLmFkZENoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsKXtcbiAgICB0aGlzLnBhcmVudENoYW5uZWxzLnB1c2goY2hhbm5lbCk7XG59O1xuRGF0YVNsb3QucHJvdG90eXBlLnJlbW92ZUNoYW5uZWwgPSBmdW5jdGlvbihjaGFubmVsKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5wYXJlbnRDaGFubmVscy5pbmRleE9mKGNoYW5uZWwpO1xuICAgIGlmKGlkeCAhPSAtMSkgdGhpcy5wYXJlbnRDaGFubmVscy5zcGxpY2UoaWR4LCAxKTtcbn07XG5EYXRhU2xvdC5wcm90b3R5cGUuc3dhcEFzeW5jID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgdG1wID0gdGhpcy5kYXRhRW50cnk7XG4gICAgdGhpcy5kYXRhRW50cnkgPSB0aGlzLmFzeW5jRGF0YUVudHJ5O1xuICAgIHRoaXMuYXN5bmNEYXRhRW50cnkgPSB0bXA7XG59O1xuXG5EYXRhU2xvdC5wcm90b3R5cGUuc2V0RGF0YUVudHJ5ID0gZnVuY3Rpb24oZGF0YUVudHJ5LCBjaGFuZ2VUeXBlKXtcbiAgICB0aGlzLmRhdGFFbnRyeSA9IGRhdGFFbnRyeTtcbiAgICB2YXIgc3RhdGUgPSBjaGFuZ2VUeXBlID09IEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfREFUQV9WQUxVRSA/IEMuREFUQV9FTlRSWV9TVEFURS5DSEFOR0VEX1ZBTFVFIDpcbiAgICAgICAgQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfU0laRTtcbiAgICB0aGlzLm5vdGlmeU9uQ2hhbmdlKHN0YXRlKTtcbn07XG5cbkRhdGFTbG90LnByb3RvdHlwZS5ub3RpZnlPbkNoYW5nZSA9IGZ1bmN0aW9uKHN0YXRlKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXJlbnRDaGFubmVscy5sZW5ndGg7ICsraSl7XG4gICAgICAgIHRoaXMucGFyZW50Q2hhbm5lbHNbaV0ubm90aWZ5T25DaGFuZ2Uoc3RhdGUpO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YVNsb3Q7XG4iLCJ2YXIgQmFzZSA9IHJlcXVpcmUoXCIuLi9iYXNlLmpzXCIpO1xudmFyIEMgPSByZXF1aXJlKFwiLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcbnZhciBPcGVyYXRvckxpc3QgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3Ivb3BlcmF0b3ItbGlzdC5qc1wiKTtcbnZhciBVdGlscyA9IHJlcXVpcmUoXCIuLi91dGlscy91dGlscy5qc1wiKTtcbnZhciBPcGVyYXRvciA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvci9vcGVyYXRvci5qc1wiKTtcbnZhciBPcGVyYXRvckVudHJ5ID0gcmVxdWlyZShcIi4uL29wZXJhdG9yL29wZXJhdG9yLWVudHJ5LmpzXCIpO1xudmFyIFByb2dyYW0gPSByZXF1aXJlKFwiLi4vb3BlcmF0b3IvcHJvZ3JhbS5qc1wiKTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBFeGVjdXRvclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogVHJpZXMgdG8gY29tYmluZSBtdWx0aXBsZSBQcm9jZXNzTm9kZXMgaW50byBhIFByb2dyYW0uIEN1cnJlbnRseSBvbmx5IHVzZWQgZm9yIHZlcnRleCBzaGFkZXJzLlxuICpcbiAqIEBwYXJhbSB7UmVxdWVzdE5vZGV8UHJvY2Vzc05vZGV9IG93bmVyTm9kZVxuICogQHBhcmFtIHtDLlBMQVRGT1JNfSBwbGF0Zm9ybVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBFeGVjdXRvciA9IGZ1bmN0aW9uKG93bmVyTm9kZSwgcGxhdGZvcm0pe1xuICAgIHRoaXMucGxhdGZvcm0gPSBwbGF0Zm9ybTtcblxuICAgIC8qKlxuICAgICAqIE5vZGVzIHRoYXQgYXJlIG1lcmdlZCBieSB0aGlzIGV4ZWN1dG9yXG4gICAgICogQHR5cGUge0FycmF5LjxQcm9jZXNzTm9kZXxSZXF1ZXN0Tm9kZT59XG4gICAgICovXG4gICAgdGhpcy5tZXJnZWROb2RlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogU3Vic2V0IG9mIHRoaXMubWVyZ2VkTm9kZXMgdGhhdCBkaXJlY3RseSBwcm92aWRlIHJlc3VsdHMgb2YgdGhlIGV4ZWN1dG9yXG4gICAgICogQHR5cGUge0FycmF5LjxQcm9jZXNzTm9kZT59XG4gICAgICovXG4gICAgdGhpcy5tZXJnZWRPdXRwdXROb2RlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogUHJvY2Vzc05vZGVzIHRvIGJlIGV4ZWN1dGVkIGJlZm9yZSB0aGlzIGV4ZWN1dG9yIGNhbiBiZVxuICAgICAqIGV4ZWN1dGVkXG4gICAgICogQHR5cGUge0FycmF5LjxQcm9jZXNzTm9kZT59XG4gICAgICovXG4gICAgdGhpcy5zdWJOb2RlcyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVE9ETzogVW51c2VkLiBSZW1vdmU/XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudW5wcm9jZXNzZWREYXRhTmFtZXMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqICBUT0RPOiBNYXliZSB3ZSBzaG91bGQganVzdCBzdG9yZSB0aGUgY2wtcGxhdGZvcm0gb2JqZWN0cyBpbiBnbG9iYWwgb2JqZWN0IHNvIHRoZXkgYXJlIG1vcmUgZWFzaWx5IGF2YWlsYWJsZSBhbmRcbiAgICAgKiAgdG8gYXZvaWQgbG9uZyBwcm90b3R5cGUgY2hhaW5zLiBPciB3ZSBjb3VsZCBwYXNzIHRoZSBncmFwaCBjb250ZXh0IHRvIGVhY2ggbm9kZSBvZiB0aGUgZ3JhcGguXG4gICAgICogIEhvd2V2ZXIsIGl0IHdvdWxkIGJlIGdvb2QgdG8gYWxsb3cgZWFjaCBHcmFwaCBvYmplY3QgdG8gaGF2ZSBhdCBsZWFzdCBvd24gY29udGV4dCwgY21kUXVldWUgYW5kIGtlcm5lbE1hbmFnZXIuXG4gICAgICogIGUuZy4gcGFzc2luZyBncmFwaCBpbmZvcm1hdGlvbiBoZXJlIHJlcXVpcmVzIGEgbG9uZyBwcm90b3R5cGUgY2hhaW5cbiAgICAgKi9cbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9ICBuZXcgT3BlcmF0b3JMaXN0KHBsYXRmb3JtKTtcbiAgICB0aGlzLnByb2dyYW1EYXRhID0gIG5ldyBQcm9ncmFtLlByb2dyYW1EYXRhKCk7XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtQcm9ncmFtfVxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG5cbiAgICBjb25zdHJ1Y3RFeGVjdXRvcih0aGlzLCBvd25lck5vZGUpO1xufTtcblxuICAgIEV4ZWN1dG9yLnByb3RvdHlwZS5pc1Byb2Nlc3NlZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBpID0gdGhpcy5tZXJnZWRPdXRwdXROb2Rlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlKGktLSl7XG4gICAgICAgICAgICBpZih0aGlzLm1lcmdlZE91dHB1dE5vZGVzW2ldLnN0YXR1cyAhPSBDLlBST0NFU1NfU1RBVEUuUFJPQ0VTU0VEKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG5cbiAgICBFeGVjdXRvci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24oYXN5bmNDYWxsYmFjayl7XG4gICAgICAgIHJ1blN1Yk5vZGVzKHRoaXMpO1xuICAgICAgICB1cGRhdGVJdGVyYXRlU3RhdGUodGhpcyk7IC8vIFRPRE8gY2hlY2sgaWYgaXRlcmF0ZSBTdGF0ZSBoYXMgY2hhbmdlcyBpbiBhbnkgd2F5IGFuZCBvbmx5IHJlZmV0Y2ggcHJvZ3JhbSBpbiB0aGF0IGNhc2VcblxuICAgICAgICB0aGlzLnByb2dyYW0gPSBQcm9ncmFtLmNyZWF0ZVByb2dyYW0odGhpcy5vcGVyYXRvckxpc3QpO1xuXG4gICAgICAgIGlmKHRoaXMucHJvZ3JhbSl7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdG9yTGlzdC5hbGxvY2F0ZU91dHB1dCh0aGlzLnByb2dyYW1EYXRhLCAhIWFzeW5jQ2FsbGJhY2spO1xuICAgICAgICAgICAgdGhpcy5wcm9ncmFtLnJ1bih0aGlzLnByb2dyYW1EYXRhLCBhc3luY0NhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLnBsYXRmb3JtICE9IEMuUExBVEZPUk0uQVNZTkMpe1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLm1lcmdlZE91dHB1dE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlKGktLSl7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXJnZWRPdXRwdXROb2Rlc1tpXS5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuUFJPQ0VTU0VEO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgIH07XG5cbiAgICBFeGVjdXRvci5wcm90b3R5cGUuZ2V0VmVydGV4U2hhZGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcnVuU3ViTm9kZXModGhpcyk7XG4gICAgICAgIHVwZGF0ZUl0ZXJhdGVTdGF0ZSh0aGlzKTtcblxuICAgICAgICB0aGlzLnByb2dyYW0gPSBQcm9ncmFtLmNyZWF0ZVByb2dyYW0odGhpcy5vcGVyYXRvckxpc3QpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLnByb2dyYW07XG4gICAgfTtcblxuLyoqXG4gKiBDb25zdHJ1Y3QgRXhlY3V0b3JcbiAqIEBwYXJhbSBleGVjdXRlclxuICogQHBhcmFtIG93bmVyTm9kZVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RFeGVjdXRvcihleGVjdXRlciwgb3duZXJOb2RlKXtcbiAgICB2YXIgY0RhdGEgPSB7XG4gICAgICAgIGJsb2NrZWROb2RlczogW10sICAgLy8gQmFkIE5vZGVzIHRoYXQgY2Fubm90IGJlIG1lcmdlLiBGaWxsZWQgZHVyaW5nIHByZSBzY2FuXG4gICAgICAgIGRvbmVOb2RlczogW10sICAgICAgLy8gTm9kZXMgdGhhdCBoYXZlIGJlZW4gc2lnbmVkIHVwIGZvciBtZXJnaW5nLiBUT0RPOiBSZWR1bmRhbnQgd2l0aCBjb25zdHJ1Y3Rpb25PcmRlciBhbmQgc3ViTm9kZXM/IC0gbWF5YmUgeWVzIVxuICAgICAgICBjb25zdHJ1Y3Rpb25PcmRlcjogW10sIC8vIFN0b3JlIG5vZGVzIGluIG9yZGVyIG9mIGNvbnN0cnVjdGlvbiBvZiBPcGVyYXRvckVudHJpZXMuXG4gICAgICAgIGlucHV0U2xvdHM6IHt9LCAgICAgLy8gQ29sbGVjdGVkIGlucHV0IGNoYW5uZWxzIG9mIGFsbCBtZXJnZWQgbm9kZXMuIFVzZWQgdG8gYXZvaWQgYXNzaWduaW5nIHNhbWUgaW5wdXQgYnVmZmVyIHR3aWNlXG4gICAgICAgIGZpbmFsT3V0cHV0OiBudWxsLCAgLy8gZmluYWxPdXRwdXQgY2hhbm5lcyBpbiBjYXNlIHdlIGhhdmUgYSBSZXF1ZXN0Tm9kZVxuICAgICAgICBmaXJzdE9wZXJhdG9yOiBudWxsIC8vIFNldCB0byBmaXJzdCBvcGVyYXRvciB0aGF0IGhhcyBiZWVuIG1lcmdlZCAod2lsbCBiZSBleGVjdXRlZCBsYXN0KVxuICAgIH07XG4gICAgdmFyIHJlcXVlc3ROb2RlID0gaW5pdFJlcXVlc3ROb2RlKGNEYXRhLCBleGVjdXRlciwgb3duZXJOb2RlKTtcblxuICAgIHZhciBub09wZXJhdG9ycyA9IGZhbHNlOyAvLyBUT0RPOiBSZW1vdmUgdGhpcz9cbiAgICBjb25zdHJ1Y3RQcmVTY2FuKGNEYXRhLCBvd25lck5vZGUsIGV4ZWN1dGVyLnBsYXRmb3JtLCBub09wZXJhdG9ycyk7XG5cbiAgICBzZXRDb25zdHJ1Y3Rpb25PcmRlckFuZFN1Yk5vZGVzKGNEYXRhLCBleGVjdXRlciwgb3duZXJOb2RlKTtcblxuICAgIGNvbnN0cnVjdEZyb21EYXRhKGV4ZWN1dGVyLCBjRGF0YSk7XG59XG4vKipcbiAqIE9ubHkgcmVsZXZhbnQgaWYgb3duZXJOb2RlcyBpcyBhIFJlcXVlc3ROb2RlXG4gKiBTZXRzIGZpbmFsT3V0cHV0IG9mIGNvbnN0cnVjdGlvbiBkYXRhIGFuZCB1bnByb2Nlc3NlZERhdGFOYW1lc1xuICogQHBhcmFtIGNEYXRhXG4gKiBAcGFyYW0gZXhlY3V0ZXJcbiAqIEBwYXJhbSBvd25lck5vZGVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpbml0UmVxdWVzdE5vZGUoY0RhdGEsIGV4ZWN1dGVyLCBvd25lck5vZGUpe1xuICAgIGlmKHRydWUpIHsgLy8gRklYTUU6IG93bmVyTm9kZSBpbnN0YW5jZW9mIFJlcXVlc3ROb2RlKXtcbiAgICAgICAgY0RhdGEuZmluYWxPdXRwdXQgPSB7fTtcbiAgICAgICAgdmFyIGZpbHRlciA9IG93bmVyTm9kZS5maWx0ZXIgfHwgb3duZXJOb2RlLm93bmVyLm91dHB1dENoYW5uZWxzLmdldE5hbWVzKCk7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBmaWx0ZXIubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWx0ZXJbaV07XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IG93bmVyTm9kZS5vd25lci5vdXRwdXRDaGFubmVscy5nZXRDaGFubmVsKG5hbWUpO1xuICAgICAgICAgICAgaWYoY2hhbm5lbCAmJiBjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSlcbiAgICAgICAgICAgICAgICBjRGF0YS5maW5hbE91dHB1dFtuYW1lXSA9IGNoYW5uZWwuZ2V0RGF0YUVudHJ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgVXRpbHMubmFtZXNldC5hZGQoZXhlY3V0ZXIudW5wcm9jZXNzZWREYXRhTmFtZXMsIGZpbHRlcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEdvZXMgdG8gcHJvY2Vzc2luZyBzdWJ0cmVlIGF0IGZpbGxlZCBibG9ja2VkTm9kZXMgYXJyYXkgaW4gY29uc3RydWN0aW9uIGRhdGEuXG4gKiBBbGwgbm9kZXMgdGhhdCBjYW5ub3QgYmUgbWVyZ2VkIG9yIGhhdmUgcGFyZW50cyB0aGF0IGNhbid0IGJlIG1lcmdlZCB3aWxsIGJlIGJsb2NrZWRcbiAqIEBwYXJhbSBjRGF0YVxuICogQHBhcmFtIG5vZGVcbiAqIEBwYXJhbSBwbGF0Zm9ybVxuICogQHBhcmFtIG5vT3BlcmF0b3JzXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFByZVNjYW4oY0RhdGEsIG5vZGUsIHBsYXRmb3JtLCBub09wZXJhdG9ycyl7XG4gICAgaWYoY0RhdGEuYmxvY2tlZE5vZGVzLmluZGV4T2Yobm9kZSkgIT0gLTEpXG4gICAgICAgIHJldHVybjtcblxuICAgIGlmKG5vZGUub3BlcmF0b3Ipe1xuICAgICAgICBpZihub09wZXJhdG9ycyB8fCAhY2FuT3BlcmF0b3JNZXJnZShjRGF0YSwgbm9kZS5vcGVyYXRvciwgcGxhdGZvcm0pKXtcbiAgICAgICAgICAgIGJsb2NrU3VidHJlZShjRGF0YSwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZXtcbiAgICAgICAgICAgIGlmKCFjRGF0YS5maXJzdE9wZXJhdG9yKSBjRGF0YS5maXJzdE9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcbiAgICAgICAgICAgIHZhciBtYXBwaW5nID0gbm9kZS5vcGVyYXRvci5tYXBwaW5nO1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcHBpbmcubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIGlmKG1hcHBpbmdbaV0uc2VxdWVuY2Upe1xuICAgICAgICAgICAgICAgICAgICBibG9ja0lucHV0KGNEYXRhLCBub2RlLCBtYXBwaW5nW2ldLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSW5wdXQoY0RhdGEsIG5vZGUsIG1hcHBpbmdbaV0ua2V5U291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZihtYXBwaW5nW2ldLmFycmF5KXtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogUmVuYW1lIC5hcnJheSB0byAucmFuZG9tQWNjZXNzXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrSW5wdXQoY0RhdGEsIG5vZGUsIG1hcHBpbmdbaV0uc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICBjb25zdHJ1Y3RQcmVTY2FuKGNEYXRhLCBub2RlLmNoaWxkcmVuW2ldLCBwbGF0Zm9ybSwgbm9PcGVyYXRvcnMpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2FuT3BlcmF0b3JNZXJnZShjRGF0YSwgb3BlcmF0b3IsIHBsYXRmb3JtKXtcbiAgICAvLyBUT0RPOiBEZXRlY3QgbWVyZ2Ugc3VwcG9ydFxuICAgIHJldHVybiAocGxhdGZvcm0gPT0gQy5QTEFURk9STS5BU1lOQyB8fCAhT3BlcmF0b3IuaXNPcGVyYXRvckFzeW5jKG9wZXJhdG9yKSkgJiZcbiAgICAgICAgKCFjRGF0YS5maXJzdE9wZXJhdG9yIHx8XG4gICAgICAgIChwbGF0Zm9ybSA9PSBDLlBMQVRGT1JNLkdMU0wgJiYgY0RhdGEuZmlyc3RPcGVyYXRvci5ldmFsdWF0ZV9nbHNsICYmIG9wZXJhdG9yLmV2YWx1YXRlX2dsc2wpKTtcbn1cblxuZnVuY3Rpb24gYmxvY2tTdWJ0cmVlKGNEYXRhLCBub2RlKXtcbiAgICBpZihjRGF0YS5ibG9ja2VkTm9kZXMuaW5kZXhPZihub2RlKSAhPSAtMSlcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgY0RhdGEuYmxvY2tlZE5vZGVzLnB1c2gobm9kZSk7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICBibG9ja1N1YnRyZWUoY0RhdGEsIG5vZGUuY2hpbGRyZW5baV0pO1xuICAgIH1cbn1cbi8qKlxuICogQmxvY2sgYWxsIHByb2Nlc3NOb2RlcyBhc3NpZ25lZCB0byBhbiBpbnB1dCBjaGFubmVsXG4gKiBAcGFyYW0gY0RhdGFcbiAqIEBwYXJhbSBub2RlXG4gKiBAcGFyYW0gaW5wdXROYW1lXG4gKi9cbiAgICBmdW5jdGlvbiBibG9ja0lucHV0KGNEYXRhLCBub2RlLCBpbnB1dE5hbWUpe1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5vZGUuaW5wdXRDaGFubmVsc1tpbnB1dE5hbWVdO1xuICAgICAgICBpZihjaGFubmVsICYmIGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKXtcbiAgICAgICAgICAgIGJsb2NrU3VidHJlZShjRGF0YSwgY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUpO1xuICAgICAgICB9XG4gICAgfVxuLyoqXG4gKiBGaWxsIGRvbmVOb2RlcyBhbmQgY29uc3RydWN0aW9uT3JkZXIgYXJyYXlzIG9mIGNvbnN0cnVjdGlvbiBkYXRhLlxuICogSXQgYWxzbyBmaWxscyB0aGUgc3ViTm9kZXMgYXJyYXkgb2YgdGhlIGV4ZWN1dGVyXG4gKiBAcGFyYW0gY0RhdGEgY29uc3RydWN0aW9uIGRhdGFcbiAqIEBwYXJhbSBleGVjdXRlclxuICogQHBhcmFtIG5vZGVcbiAqL1xuICAgIGZ1bmN0aW9uIHNldENvbnN0cnVjdGlvbk9yZGVyQW5kU3ViTm9kZXMoY0RhdGEsIGV4ZWN1dGVyLCBub2RlKXtcbiAgICAgICAgaWYoY0RhdGEuZG9uZU5vZGVzLmluZGV4T2Yobm9kZSkgIT0gLTEpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY0RhdGEuZG9uZU5vZGVzLnB1c2gobm9kZSk7XG5cbiAgICAgICAgaWYoY0RhdGEuYmxvY2tlZE5vZGVzLmluZGV4T2Yobm9kZSkgIT0gLTEpe1xuICAgICAgICAgICAgZXhlY3V0ZXIuc3ViTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIHNldENvbnN0cnVjdGlvbk9yZGVyQW5kU3ViTm9kZXMoY0RhdGEsIGV4ZWN1dGVyLCBub2RlLmNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYobm9kZS5vcGVyYXRvcil7IC8vIFJlcXVlc3ROb2RlcyBkb24ndCBoYXZlIGFuIG9wZXJhdG9yLiBDb25zaWRlciB0aGlzIGNhc2UuXG4gICAgICAgICAgICAgICAgY0RhdGEuY29uc3RydWN0aW9uT3JkZXIucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbi8qKlxuICogTGFzdCBzdGVwIG9mIGNvbnN0cnVjdGlvbjogY3JlYXRlIE9wZXJhdG9yTGlzdCBmcm9tIGNvbnN0cnVjdGlvbk9yZGVyIGFycmF5XG4gKiBBbHNvIGZpbGwgbWVyZ2VkTm9kZXMgYW5kIHByb2dyYW1EYXRhXG4gKiBAcGFyYW0gZXhlY3V0ZXJcbiAqIEBwYXJhbSBjRGF0YVxuICovXG4gICAgZnVuY3Rpb24gY29uc3RydWN0RnJvbURhdGEoZXhlY3V0ZXIsIGNEYXRhKXtcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY0RhdGEuY29uc3RydWN0aW9uT3JkZXIubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBjRGF0YS5jb25zdHJ1Y3Rpb25PcmRlcltpXTtcblxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbmV3IE9wZXJhdG9yRW50cnkobm9kZS5vcGVyYXRvcik7XG5cbiAgICAgICAgICAgIGNvbnN0cnVjdElucHV0Q29ubmVjdGlvbihleGVjdXRlciwgZW50cnksIGNEYXRhLCBub2RlKTtcblxuICAgICAgICAgICAgdmFyIGlzT3V0cHV0Tm9kZSA9IGNvbnN0cnVjdE91dHB1dENvbm5lY3Rpb24oZXhlY3V0ZXIsIGVudHJ5LCBjRGF0YSwgbm9kZSk7XG5cbiAgICAgICAgICAgIGV4ZWN1dGVyLnByb2dyYW1EYXRhLm9wZXJhdG9yRGF0YS5wdXNoKHt9KTtcbiAgICAgICAgICAgIGV4ZWN1dGVyLm9wZXJhdG9yTGlzdC5hZGRFbnRyeShlbnRyeSk7XG4gICAgICAgICAgICBleGVjdXRlci5tZXJnZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgaWYoaXNPdXRwdXROb2RlIHx8IChpID09IGNEYXRhLmNvbnN0cnVjdGlvbk9yZGVyLmxlbmd0aC0xKSlcbiAgICAgICAgICAgICAgICBleGVjdXRlci5tZXJnZWRPdXRwdXROb2Rlcy5wdXNoKG5vZGUpXG5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0cnVjdExvc3RPdXRwdXQoZXhlY3V0ZXIsIGNEYXRhKTtcbiAgICB9XG4vKipcbiAqIENvbnN0cnVjdCBpbnB1dCBpbmZvIGZvciBPcGVyYXRvckVudHJ5LlxuICogV2lsbCBpbXBsaWNpdGx5IGNyZWF0ZSBQcm9ncmFtSW5wdXRDb25uZWN0aW9ucyBmb3IgUHJvZ3JhbURhdGFcbiAqIEBwYXJhbSB7RXhlY3V0b3J9IGV4ZWN1dGVyXG4gKiBAcGFyYW0ge09wZXJhdG9yRW50cnl9IGVudHJ5XG4gKiBAcGFyYW0ge3t9fSBjRGF0YVxuICogQHBhcmFtIHtQcm9jZXNzTm9kZX0gbm9kZVxuICovXG4gICAgZnVuY3Rpb24gY29uc3RydWN0SW5wdXRDb25uZWN0aW9uKGV4ZWN1dGVyLCBlbnRyeSwgY0RhdGEsIG5vZGUpe1xuICAgICAgICB2YXIgbWFwcGluZyA9IG5vZGUub3BlcmF0b3IubWFwcGluZztcbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IG1hcHBpbmcubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSBub2RlLmlucHV0Q2hhbm5lbHNbbWFwcGluZ1tqXS5zb3VyY2VdO1xuICAgICAgICAgICAgdmFyIG9wZXJhdG9ySW5kZXg7XG4gICAgICAgICAgICBpZihjaGFubmVsICYmIGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlICYmIChvcGVyYXRvckluZGV4ID1cbiAgICAgICAgICAgICAgICBleGVjdXRlci5tZXJnZWROb2Rlcy5pbmRleE9mKGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKSApICE9IC0xIClcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBpdCdzIHRyYW5zZmVyIGlucHV0XG4gICAgICAgICAgICAgICAgdmFyIG91dHB1dEluZGV4ID0gZ2V0T3BlcmF0b3JPdXRwdXRJbmRleChjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgZW50cnkuc2V0VHJhbnNmZXJJbnB1dChqLCBvcGVyYXRvckluZGV4LCBvdXRwdXRJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFyIHByZXZPcGVyYXRvciA9IGV4ZWN1dGVyLm9wZXJhdG9yTGlzdC5lbnRyaWVzW29wZXJhdG9ySW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmKCFwcmV2T3BlcmF0b3IuaXNGaW5hbE91dHB1dChvdXRwdXRJbmRleCkpe1xuICAgICAgICAgICAgICAgICAgICBwcmV2T3BlcmF0b3Iuc2V0VHJhbnNmZXJPdXRwdXQob3V0cHV0SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBkaXJlY3QgaW5wdXRcblxuICAgICAgICAgICAgdmFyIG1hcHBlZElucHV0TmFtZSA9IG1hcHBpbmdbal0uc291cmNlO1xuICAgICAgICAgICAgaWYobm9kZS5vd25lci5vd25lci5fY29tcHV0ZUlucHV0TWFwcGluZylcbiAgICAgICAgICAgICAgICBtYXBwZWRJbnB1dE5hbWUgPSBub2RlLm93bmVyLm93bmVyLl9jb21wdXRlSW5wdXRNYXBwaW5nLmdldFNjcmlwdElucHV0TmFtZShtYXBwaW5nW2pdLnBhcmFtSWR4LCBtYXBwaW5nW2pdLnNvdXJjZSk7XG5cbiAgICAgICAgICAgIHZhciBjb25uZWN0aW9uID0gbmV3IFByb2dyYW0uUHJvZ3JhbUlucHV0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgY29ubmVjdGlvbi5jaGFubmVsID0gY2hhbm5lbDtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24uYXJyYXlBY2Nlc3MgPSBtYXBwaW5nW2pdLmFycmF5IHx8IGZhbHNlOyAvLyBUT0RPOiByZW5hbWUgdG8gcmFuZG9tQWNjZXNzXG4gICAgICAgICAgICBjb25uZWN0aW9uLnNlcXVlbmNlQWNjZXNzVHlwZSA9IG1hcHBpbmdbal0uc2VxdWVuY2UgfHwgMDtcbiAgICAgICAgICAgIGlmKGNvbm5lY3Rpb24uc2VxdWVuY2VBY2Nlc3NUeXBlKVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24uc2VxdWVuY2VLZXlTb3VyY2VDaGFubmVsID0gbm9kZS5pbnB1dENoYW5uZWxzW21hcHBpbmdbal0ua2V5U291cmNlXTtcblxuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uLmdldEtleSgpO1xuICAgICAgICAgICAgdmFyIGlucHV0U2xvdElkeCA9IGNEYXRhLmlucHV0U2xvdHNbY29ubmVjdGlvbktleV07XG4gICAgICAgICAgICBpZihjaGFubmVsICYmIGlucHV0U2xvdElkeCAhPSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgICAgIC8vIERpcmVjdCBpbnB1dCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgIGVudHJ5LnNldERpcmVjdElucHV0KGosIGlucHV0U2xvdElkeCwgbWFwcGVkSW5wdXROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgLy8gbmV3IGRpcmVjdCBpbnB1dFxuICAgICAgICAgICAgICAgIGlucHV0U2xvdElkeCA9IGV4ZWN1dGVyLnByb2dyYW1EYXRhLmlucHV0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY0RhdGEuaW5wdXRTbG90c1tjb25uZWN0aW9uS2V5XSA9IGlucHV0U2xvdElkeDtcbiAgICAgICAgICAgICAgICBleGVjdXRlci5wcm9ncmFtRGF0YS5pbnB1dHMucHVzaChjb25uZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBlbnRyeS5zZXREaXJlY3RJbnB1dChqLCBpbnB1dFNsb3RJZHgsIG1hcHBlZElucHV0TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbi8qKlxuICogQ29uc3RydWN0IG91dHB1dCBpbmZvIG9mIE9wZXJhdG9yRW50cnlcbiAqIEBwYXJhbSB7RXhlY3V0b3J9IGV4ZWN1dGVyXG4gKiBAcGFyYW0ge09wZXJhdG9yRW50cnl9IGVudHJ5XG4gKiBAcGFyYW0ge3t9fSBjRGF0YVxuICogQHBhcmFtIHtQcm9jZXNzTm9kZX0gbm9kZVxuICovXG4gICAgZnVuY3Rpb24gY29uc3RydWN0T3V0cHV0Q29ubmVjdGlvbihleGVjdXRlciwgZW50cnksIGNEYXRhLCBub2RlKXtcbiAgICAgICAgdmFyIG91dHB1dHMgPSBub2RlLm9wZXJhdG9yLm91dHB1dHM7XG4gICAgICAgIHZhciBpc091dHB1dE5vZGUgPSB0cnVlO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgc2xvdCA9IG5vZGUub3V0cHV0RGF0YVNsb3RzW291dHB1dHNbaV0ubmFtZV07XG4gICAgICAgICAgICB2YXIgZmluYWxPdXRwdXROYW1lID0gZ2V0RmluYWxPdXRwdXROYW1lKHNsb3QsIGNEYXRhKTtcbiAgICAgICAgICAgIGlmKGZpbmFsT3V0cHV0TmFtZSl7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gIGV4ZWN1dGVyLnByb2dyYW1EYXRhLm91dHB1dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVyLnByb2dyYW1EYXRhLm91dHB1dHMucHVzaChzbG90KTtcbiAgICAgICAgICAgICAgICBlbnRyeS5zZXRGaW5hbE91dHB1dChpLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYoZmluYWxPdXRwdXROYW1lICE9PSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgVXRpbHMubmFtZXNldC5yZW1vdmUoZXhlY3V0ZXIudW5wcm9jZXNzZWREYXRhTmFtZXMsIGZpbmFsT3V0cHV0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICBpc091dHB1dE5vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNPdXRwdXROb2RlOyAvLyBUT0RPOiBDaGVjayBpZiBjb21wdXRhdGlvbiBvZiBpc091dHB1dE5vZGUgaXMgcmVhbGx5IGNvcnJlY3Q/XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBnZXRPcGVyYXRvck91dHB1dEluZGV4KHByb2Nlc3NOb2RlLCBjaGFubmVsKXtcbiAgICAgICAgdmFyIG91dHB1dHMgPSBwcm9jZXNzTm9kZS5vcGVyYXRvci5vdXRwdXRzO1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3V0cHV0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBpZihjaGFubmVsLmdldERhdGFFbnRyeSgpID09IHByb2Nlc3NOb2RlLm91dHB1dERhdGFTbG90c1tvdXRwdXRzW2ldLm5hbWVdLmRhdGFFbnRyeSl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0RmluYWxPdXRwdXROYW1lKGRhdGFTbG90LCBjRGF0YSl7XG4gICAgICAgIGlmKCFjRGF0YS5maW5hbE91dHB1dCkgLy8gSWYgcm9vdCBvZiBFeGVjdXRvciBpcyBhIFByb2Nlc3NOb2RlIHdlIGRvbid0IGhhdmUgZmluYWxPdXRwdXQgZGVmaW5lZCBhbmQgYWxsIG91dHB1dHMgYXJlIGZpbmFsLlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGZvcih2YXIgbmFtZSBpbiBjRGF0YS5maW5hbE91dHB1dCl7XG4gICAgICAgICAgICBpZihjRGF0YS5maW5hbE91dHB1dFtuYW1lXSA9PSBkYXRhU2xvdC5kYXRhRW50cnkpe1xuICAgICAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb25zdHJ1Y3RMb3N0T3V0cHV0KGV4ZWN1dGVyLCBjRGF0YSl7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBjRGF0YS5jb25zdHJ1Y3Rpb25PcmRlci5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNEYXRhLmNvbnN0cnVjdGlvbk9yZGVyW2ldO1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZXhlY3V0ZXIub3BlcmF0b3JMaXN0LmVudHJpZXNbaV07XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXRzID0gbm9kZS5vcGVyYXRvci5vdXRwdXRzO1xuICAgICAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IG91dHB1dHMubGVuZ3RoOyArK2ope1xuICAgICAgICAgICAgICAgIGlmKCFlbnRyeS5pc0ZpbmFsT3V0cHV0KGopICYmICEgZW50cnkuaXNUcmFuc2Zlck91dHB1dChqKSl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGV4ZWN1dGVyLnByb2dyYW1EYXRhLm91dHB1dHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBleGVjdXRlci5wcm9ncmFtRGF0YS5vdXRwdXRzLnB1c2gobm9kZS5vdXRwdXREYXRhU2xvdHNbb3V0cHV0c1tqXS5uYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnNldExvc3RPdXRwdXQoaiwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gdXBkYXRlSXRlcmF0ZVN0YXRlKGV4ZWN1dGVyKXtcbiAgICAgICAgdmFyIGlucHV0cyA9IGV4ZWN1dGVyLnByb2dyYW1EYXRhLmlucHV0cztcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGV4ZWN1dGVyLnByb2dyYW1EYXRhLmlucHV0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBleGVjdXRlci5wcm9ncmFtRGF0YS5nZXREYXRhRW50cnkoaSk7XG4gICAgICAgICAgICB2YXIgaXRlcmF0ZUNvdW50ID0gZW50cnkgPyBlbnRyeS5nZXRJdGVyYXRlQ291bnQgPyBlbnRyeS5nZXRJdGVyYXRlQ291bnQoKSA6IDEgOiAwO1xuICAgICAgICAgICAgaWYoIWl0ZXJhdGVDb3VudClcbiAgICAgICAgICAgICAgICBleGVjdXRlci5vcGVyYXRvckxpc3Quc2V0SW5wdXRJdGVyYXRlVHlwZShpLCBDLklURVJBVElPTl9UWVBFLk5VTEwpO1xuICAgICAgICAgICAgZWxzZSBpZighaW5wdXRzW2ldLmFycmF5QWNjZXNzICYmIGl0ZXJhdGVDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgZXhlY3V0ZXIub3BlcmF0b3JMaXN0LnNldElucHV0SXRlcmF0ZVR5cGUoaSwgQy5JVEVSQVRJT05fVFlQRS5NQU5ZKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBleGVjdXRlci5vcGVyYXRvckxpc3Quc2V0SW5wdXRJdGVyYXRlVHlwZShpLCBDLklURVJBVElPTl9UWVBFLk9ORSk7XG5cbiAgICAgICAgICAgIGlmKGlucHV0c1tpXS5hcnJheUFjY2VzcyAmJiBwbGF0Zm9ybVJlcXVpcmVzQXJyYXlTaXplKGV4ZWN1dGVyLiBwbGF0Zm9ybSkpe1xuICAgICAgICAgICAgICAgIGV4ZWN1dGVyLm9wZXJhdG9yTGlzdC5zZXRJbnB1dFNpemUoaSwgaXRlcmF0ZUNvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBwbGF0Zm9ybSBuZWVkcyB0byBkZWNsYXJlIHVuaWZvcm0gYXJyYXkgc2l6ZXMgaW4gdGhlIHNvdXJjZSBjb2RlLlxuICogQHBhcmFtIHBsYXRmb3JtXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuICAgIGZ1bmN0aW9uIHBsYXRmb3JtUmVxdWlyZXNBcnJheVNpemUocGxhdGZvcm0pe1xuICAgICAgICByZXR1cm4gcGxhdGZvcm0gPT0gQy5QTEFURk9STS5HTFNMO1xuICAgIH1cblxuXG4gICAgZnVuY3Rpb24gcnVuU3ViTm9kZXMoZXhlY3V0ZXIpe1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZXhlY3V0ZXIuc3ViTm9kZXMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgZXhlY3V0ZXIuc3ViTm9kZXNbaV0ucHJvY2VzcygpO1xuICAgICAgICB9XG4gICAgfVxuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dG9yO1xuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcbnZhciBDID0gcmVxdWlyZShcIi4vLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcblxuXG52YXIgb3JkZXJNYXBwaW5nUGFyc2VyID0gL14oW146LHt9XSspKCxbXjp7fSxdKykqJC87XG52YXIgbmFtZU1hcHBpbmdQYXJzZXIgPSAvXlxceygoW146LHt9XSs6W146e30sXSspKCxbXjp7fSxdKzpbXjp9LF0rKSopfSQvO1xuXG4vKipcbiAqIEEgbWFwcGluZyB1c2VkIGZvciBhIGZpbHRlciBvciBhIGNvbXB1dGUgcHJvcGVydGllcyBvZiBhIERhdGFOb2RlXG4gKiBAYWJzdHJhY3RcbiAqL1xudmFyIE1hcHBpbmcgPSBmdW5jdGlvbigpe1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxEYXRhTm9kZT59XG4gICAgICovXG4gICAgdGhpcy5fb3duZXJzID0gW107XG59O1xuXG4vKipcbiAqIFBhcnNlIGEgTWFwcGluZyAoYm90aCBDLk9yZGVyTWFwcGluZyBvciBDLkNvbXB1dGVNYXBwaW5nKSBmcm9tIGEgc3ludGF4IHN0cmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN5bnRheCBzdHJpbmcuXG4gKiBAcGFyYW0ge0MuRGF0YU5vZGV9IGRhdGFOb2RlIERhdGFOb2RlIG9mIHRoZSBNYXBwaW5nXG4gKiBAcmV0dXJucyB7P0MuTWFwcGluZ31cbiAqL1xuTWFwcGluZy5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZywgZGF0YU5vZGUpe1xuICAgIHN0cmluZyA9IHN0cmluZy50cmltKCk7XG4gICAgdmFyIHJlc3VsdHMgPSBzdHJpbmcudHJpbSgpLm1hdGNoKG9yZGVyTWFwcGluZ1BhcnNlcik7XG4gICAgaWYocmVzdWx0cylcbiAgICAgICAgcmV0dXJuIE9yZGVyTWFwcGluZy5wYXJzZShzdHJpbmcsIGRhdGFOb2RlKTtcbiAgICByZXN1bHRzID0gc3RyaW5nLnRyaW0oKS5tYXRjaChuYW1lTWFwcGluZ1BhcnNlcik7XG4gICAgaWYocmVzdWx0cylcbiAgICAgICAgcmV0dXJuIE5hbWVNYXBwaW5nLnBhcnNlKHJlc3VsdHNbMV0sIGRhdGFOb2RlKTtcbiAgICBCYXNlLm5vdGlmeUVycm9yKFwiQ2Fubm90IHBhcnNlIG5hbWUgbWFwcGluZyAnXCIgKyBzdHJpbmcgKyBcIidcIiwgZGF0YU5vZGUpO1xuICAgIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtEYXRhTm9kZX0gb3duZXJcbiAqIEBwcml2YXRlXG4gKi9cbk1hcHBpbmcucHJvdG90eXBlLl9hZGRPd25lciA9IGZ1bmN0aW9uKG93bmVyKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5fb3duZXJzLmluZGV4T2Yob3duZXIpO1xuICAgIGlmKGlkeCA9PSAtMSlcbiAgICAgICAgdGhpcy5fb3duZXJzLnB1c2gob3duZXIpO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtEYXRhTm9kZX0gb3duZXJcbiAqIEBwcml2YXRlXG4gKi9cbk1hcHBpbmcucHJvdG90eXBlLl9yZW1vdmVPd25lciA9IGZ1bmN0aW9uKG93bmVyKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5fb3duZXJzLmluZGV4T2Yob3duZXIpO1xuICAgIGlmKGlkeCAhPSAtMSlcbiAgICAgICAgdGhpcy5fb3duZXJzLnNwbGljZShpZHgsIC0xKTtcbn07XG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBPcmRlck1hcHBpbmdcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFuIE9yZGVyTWFwcGluZyB1c2VkIGZvciBhIGZpbHRlciBvciBjb21wdXRlIHByb3BlcnRpZXMgb2YgYSBEYXRhTm9kZVxuICogSXQgZGVzY3JpYmVzIGEgbWFwcGluZyBvZiBuYW1lcyByZWZlcnJpbmcgdG8gdGhlIG9yZGVyIG9mIGFyZ3VtZW50cyAvIG91dHB1dCB2YWx1ZXMuXG4gKiBPcmRlck1hcHBpbmcgc3ludGF4IGV4YW1wbGVzIGluIGNvbXB1dGU6XG4gKiBwb3NpdGlvbiA9IEMubW9ycGgocG9zaXRpb24sIHBvc0FkZCwgd2VpZ2h0KVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7TWFwcGluZ31cbiAqL1xudmFyIE9yZGVyTWFwcGluZyA9IGZ1bmN0aW9uKCl7XG4gICAgTWFwcGluZy5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX25hbWVzID0gW107XG59O1xuQmFzZS5jcmVhdGVDbGFzcyhPcmRlck1hcHBpbmcsIE1hcHBpbmcpO1xuXG5PcmRlck1hcHBpbmcucGFyc2UgPSBmdW5jdGlvbihzdHJpbmcsIGRhdGFOb2RlKXtcbiAgICB2YXIgbWFwcGluZyA9IG5ldyBPcmRlck1hcHBpbmcoZGF0YU5vZGUpO1xuICAgIHZhciB0b2tlbiA9IHN0cmluZy5zcGxpdChcIixcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgbWFwcGluZy5fbmFtZXMucHVzaCh0b2tlbltpXS50cmltKCkpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGluZztcbn07XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE9yZGVyTWFwcGluZy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7IHRocm93IG5ldyBFcnJvcihcImxlbmd0aCBpcyByZWFkLW9ubHlcIik7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9uYW1lcy5sZW5ndGg7IH1cbn0pO1xuXG5PcmRlck1hcHBpbmcucHJvdG90eXBlLmdldE5hbWUgPSBmdW5jdGlvbihpZHgpe1xuICAgIHJldHVybiB0aGlzLl9uYW1lc1tpZHhdO1xufTtcblxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5fbmFtZXMgPSBbXTtcbiAgICBtYXBwaW5nTm90aWZ5T3duZXIodGhpcyk7XG59O1xuXG5PcmRlck1hcHBpbmcucHJvdG90eXBlLnNldE5hbWUgPSBmdW5jdGlvbihpbmRleCwgbmFtZSl7XG4gICAgdGhpcy5fbmFtZXNbaW5kZXhdID0gbmFtZTtcbiAgICBtYXBwaW5nTm90aWZ5T3duZXIodGhpcyk7XG59O1xuXG5cbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5yZW1vdmVOYW1lID0gZnVuY3Rpb24oaW5kZXgpe1xuICAgIHRoaXMuX25hbWVzLnNwbGljZShpbmRleCk7XG4gICAgbWFwcGluZ05vdGlmeU93bmVyKHRoaXMpO1xufTtcblxuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fbmFtZXMubGVuZ3RoID09IDA7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0NoYW5uZWxNYXB9IGRlc3RNYXBcbiAqIEBwYXJhbSB7Q2hhbm5lbE1hcH0gc291cmNlTWFwXG4gKiBAcGFyYW0ge2V4cG9ydHMuQy5EQVRBX0ZJTFRFUl9UWVBFfSBmaWx0ZXJUeXBlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKENoYW5uZWxNYXAsIHN0cmluZywgQ2hhbm5lbE1hcCwgc3RyaW5nKX0gY2FsbGJhY2tcbiAqL1xuT3JkZXJNYXBwaW5nLnByb3RvdHlwZS5hcHBseUZpbHRlck9uQ2hhbm5lbE1hcCA9IGZ1bmN0aW9uKGRlc3RNYXAsIHNvdXJjZU1hcCwgZmlsdGVyVHlwZSwgY2FsbGJhY2spe1xuICAgIHZhciBpO1xuICAgIGlmKGZpbHRlclR5cGUgPT0gQy5EQVRBX0ZJTFRFUl9UWVBFLktFRVApe1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCB0aGlzLl9uYW1lcy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IHRoaXMuX25hbWVzW2ldO1xuICAgICAgICAgICAgaWYoc291cmNlTWFwLm1hcFtuYW1lXSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRlc3RNYXAsIG5hbWUsIHNvdXJjZU1hcCwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZXtcbiAgICAgICAgZm9yKGkgaW4gc291cmNlTWFwLm1hcCl7XG4gICAgICAgICAgICB2YXIgaWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihpKTtcbiAgICAgICAgICAgIGlmKGZpbHRlclR5cGUgPT0gQy5EQVRBX0ZJTFRFUl9UWVBFLlJFTkFNRSB8fFxuICAgICAgICAgICAgICAgIChmaWx0ZXJUeXBlID09IEMuREFUQV9GSUxURVJfVFlQRS5SRU1PVkUgJiYgaWR4ID09IC0xKSlcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhkZXN0TWFwLCBpLCBzb3VyY2VNYXAsIGkpO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGlucHV0IHZhbHVlIGFzc2lnbmVkIHRvIG9wZXJhdG9yIGFyZ3VtZW50LlxuICogUmV0dXJucyBudWxsLCBpZiBubyBtYXBwaW5nIGlzIGRlZmluZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggUG9zaXRpb24gb2YgdGhlIG9wZXJhdG9yIGFyZ3VtZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gKi9cbk9yZGVyTWFwcGluZy5wcm90b3R5cGUuZ2V0U2NyaXB0SW5wdXROYW1lID0gZnVuY3Rpb24oaW5kZXggLyosIGRlc3ROYW1lICovKXtcbiAgICBpZih0aGlzLl9uYW1lc1tpbmRleF0pXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lc1tpbmRleF07XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgb3V0cHV0IHBhcmFtZXRlciBhcyBpdCBzaG91bGQgYmUgdXNlZCBmb3IgdGhlXG4gKiBmb2xsb3dpbmcgZGF0YWZsb3cuIFJldHVybnMgbnVsbCwgaWYgbm8gbWFwcGluZyBpcyBkZWZpbmVkLlxuICogQHBhcmFtIGluZGV4XG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gKi9cbk9yZGVyTWFwcGluZy5wcm90b3R5cGUuZ2V0U2NyaXB0T3V0cHV0TmFtZSA9IGZ1bmN0aW9uKGluZGV4IC8qLCBzcmNOYW1lICovKXtcbiAgICBpZih0aGlzLl9uYW1lc1tpbmRleF0pXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lc1tpbmRleF07XG4gICAgZWxzZVxuICAgICAgICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBuYW1lIG9mIHRoZSBvdXRwdXQgcGFyYW1ldGVyIGFzIGl0IHNob3VsZCBiZSB1c2VkIGZvciB0aGVcbiAqIGZvbGxvd2luZyBkYXRhZmxvdy4gUmV0dXJucyBudWxsLCBpZiBubyBtYXBwaW5nIGlzIGRlZmluZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdE5hbWVcbiAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gb3BlcmF0b3JPdXRwdXRzXG4gKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG4gKi9cbk9yZGVyTWFwcGluZy5wcm90b3R5cGUuZ2V0U2NyaXB0T3V0cHV0TmFtZUludiA9IGZ1bmN0aW9uKGRlc3ROYW1lLCBvcGVyYXRvck91dHB1dHMpe1xuICAgIHZhciBpbmRleCA9IHRoaXMuX25hbWVzLmluZGV4T2YoZGVzdE5hbWUpO1xuICAgIGlmKGluZGV4ID09IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gb3BlcmF0b3JPdXRwdXRzW2luZGV4XS5uYW1lO1xufTtcblxuLyoqXG4gKiBJZGVudGl0eSBmdW5jdGlvbi4gVXNlZCB0byBpbXBsZW1lbnQgaW50ZXJmYWNlLiBVc3VhbGx5IHlvdSBkb24ndCByZW5hbWUgd2l0aCBvcmRlclxuICogbWFwcGluZy5cbiAqIEBwYXJhbSBuYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcmRlck1hcHBpbmcucHJvdG90eXBlLmdldFJlbmFtZVNyY05hbWUgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gbmFtZTtcbn07XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gTmFtZU1hcHBpbmdcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFuIE5hbWVNYXBwaW5nIHVzZWQgZm9yIGEgZmlsdGVyIG9yIGNvbXB1dGUgcHJvcGVydGllcyBvZiBhIERhdGFOb2RlXG4gKiBJdCBkZXNjcmliZXMgYSBtYXBwaW5nIG9mIG5hbWVzIHJlZmVycmluZyB0byB0aGUgb3JpZ2luYWwgbmFtZXMgb2YgdGhlIGFyZ3VtZW50cyAvIG91dHB1dCB2YWx1ZXMuXG4gKiBOYW1lTWFwcGluZyBzeW50YXggZXhhbXBsZXMgaW4gY29tcHV0ZTpcbiAqIHtwb3NpdGlvbjogcmVzdWx0fSA9IEMubW9ycGgoe3ZhbHVlOiBwb3NpdGlvbiwgdmFsdWVBZGQ6IHBvc0FkZCwgd2VpZ2h0OiB3ZWlnaHR9KVxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7TWFwcGluZ31cbiAqL1xudmFyIE5hbWVNYXBwaW5nID0gZnVuY3Rpb24oKXtcbiAgICBNYXBwaW5nLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fZGVzdE5hbWVzID0gW107XG4gICAgdGhpcy5fc3JjTmFtZXMgPSBbXTtcblxufTtcbkJhc2UuY3JlYXRlQ2xhc3MoTmFtZU1hcHBpbmcsIE1hcHBpbmcpO1xuXG5OYW1lTWFwcGluZy5wYXJzZSA9IGZ1bmN0aW9uKHN0cmluZywgZGF0YU5vZGUpICB7XG4gICAgdmFyIG1hcHBpbmcgPSBuZXcgTmFtZU1hcHBpbmcoZGF0YU5vZGUpO1xuICAgIHZhciB0b2tlbiA9IHN0cmluZy5zcGxpdChcIixcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IHRva2VuLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgdmFyIHBhaXIgPSB0b2tlbltpXS5zcGxpdChcIjpcIik7XG4gICAgICAgIHZhciBkZXN0ID0gcGFpclswXS50cmltKCk7IHZhciBzcmMgPSBwYWlyWzFdLnRyaW0oKTtcbiAgICAgICAgbWFwcGluZy5zZXROYW1lUGFpcihkZXN0LCBzcmMpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwcGluZztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShOYW1lTWFwcGluZy5wcm90b3R5cGUsIFwibGVuZ3RoXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKCl7IHRocm93IG5ldyBFcnJvcihcImxlbmd0aCBpcyByZWFkLW9ubHlcIik7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9zcmNOYW1lcy5sZW5ndGg7IH1cbn0pO1xuXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0RGVzdE5hbWUgPSBmdW5jdGlvbihpZHgpe1xuICAgIHJldHVybiB0aGlzLl9kZXN0TmFtZXNbaWR4XTtcbn07XG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0U3JjTmFtZSA9IGZ1bmN0aW9uKGlkeCl7XG4gICAgcmV0dXJuIHRoaXMuX3NyY05hbWVzW2lkeF07XG59O1xuXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0U3JjTmFtZUZyb21EZXN0TmFtZSA9IGZ1bmN0aW9uKGRlc3ROYW1lKXtcbiAgICB2YXIgaWR4ID0gdGhpcy5fZGVzdE5hbWVzLmluZGV4T2YoZGVzdE5hbWUpO1xuICAgIHJldHVybiBpZHggPT0gLTEgPyBudWxsIDogdGhpcy5fc3JjTmFtZXNbaWR4XTtcbn07XG5OYW1lTWFwcGluZy5wcm90b3R5cGUuZ2V0RGVzdE5hbWVGcm9tU3JjTmFtZSA9IGZ1bmN0aW9uKHNyY05hbWUpe1xuICAgIHZhciBpZHggPSB0aGlzLl9zcmNOYW1lcy5pbmRleE9mKHNyY05hbWUpO1xuICAgIHJldHVybiBpZHggPT0gLTEgPyBudWxsIDogdGhpcy5fZGVzdE5hbWVzW2lkeF07XG59O1xuXG5OYW1lTWFwcGluZy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpe1xuICAgIHRoaXMuX3NyY05hbWVzID0gW107XG4gICAgdGhpcy5fZGVzdE5hbWVzID0gW107XG4gICAgbWFwcGluZ05vdGlmeU93bmVyKHRoaXMpO1xufTtcblxuTmFtZU1hcHBpbmcucHJvdG90eXBlLnNldE5hbWVQYWlyID0gZnVuY3Rpb24oZGVzdE5hbWUsIHNyY05hbWUpe1xuICAgIHZhciBpZHggPSB0aGlzLl9kZXN0TmFtZXMuaW5kZXhPZihkZXN0TmFtZSk7XG4gICAgaWYoaWR4ICE9IC0xKXtcbiAgICAgICAgdGhpcy5fZGVzdE5hbWVzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIHRoaXMuX3NyY05hbWVzLnNwbGljZShpZHgsMSk7XG4gICAgfVxuICAgIHRoaXMuX2Rlc3ROYW1lcy5wdXNoKGRlc3ROYW1lKTtcbiAgICB0aGlzLl9zcmNOYW1lcy5wdXNoKHNyY05hbWUpO1xuICAgIG1hcHBpbmdOb3RpZnlPd25lcih0aGlzKTtcbn07XG5cbi8vbm9pbnNwZWN0aW9uIEpTVW51c2VkR2xvYmFsU3ltYm9sc1xuTmFtZU1hcHBpbmcucHJvdG90eXBlLnJlbW92ZU5hbWVQYWlyID0gZnVuY3Rpb24oZGVzdE5hbWUpe1xuICAgIHZhciBpZHggPSB0aGlzLl9kZXN0TmFtZXMuaW5kZXhPZihkZXN0TmFtZSk7XG4gICAgaWYoaWR4ICE9IC0xKXtcbiAgICAgICAgdGhpcy5fZGVzdE5hbWVzLnNwbGljZShpZHgsMSk7XG4gICAgICAgIHRoaXMuX3NyY05hbWVzLnNwbGljZShpZHgsMSk7XG4gICAgfVxuICAgIG1hcHBpbmdOb3RpZnlPd25lcih0aGlzKTtcbn07XG5cbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fZGVzdE5hbWVzLmxlbmd0aCA9PSAwO1xufTtcblxuLyoqXG4gKiBAc2VlIE9yZGVyTWFwcGluZy5hcHBseUZpbHRlck9uQ2hhbm5lbE1hcFxuICogQHBhcmFtIHtDaGFubmVsTWFwfSBkZXN0TWFwXG4gKiBAcGFyYW0ge0NoYW5uZWxNYXB9IHNvdXJjZU1hcFxuICogQHBhcmFtIHtDLkRBVEFfRklMVEVSX1RZUEV9IGZpbHRlclR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5hcHBseUZpbHRlck9uQ2hhbm5lbE1hcCA9IGZ1bmN0aW9uKGRlc3RNYXAsIHNvdXJjZU1hcCwgZmlsdGVyVHlwZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgaTtcbiAgICBpZihmaWx0ZXJUeXBlID09IEMuREFUQV9GSUxURVJfVFlQRS5SRU1PVkUpe1xuICAgICAgICBmb3IoaSBpbiBzb3VyY2VNYXAubWFwKVxuICAgICAgICAgICAgaWYodGhpcy5fc3JjTmFtZXMuaW5kZXhPZihpKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhkZXN0TWFwLCBpLCBzb3VyY2VNYXAsIGkpO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBpZihmaWx0ZXJUeXBlID09IEMuREFUQV9GSUxURVJfVFlQRS5SRU5BTUUpe1xuICAgICAgICAgICAgZm9yKGkgaW4gc291cmNlTWFwLm1hcClcbiAgICAgICAgICAgICAgICBpZih0aGlzLl9zcmNOYW1lcy5pbmRleE9mKGkpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhkZXN0TWFwLCBpLCBzb3VyY2VNYXAsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpIGluIHRoaXMuX2Rlc3ROYW1lcyl7XG4gICAgICAgICAgICBjYWxsYmFjayhkZXN0TWFwLCB0aGlzLl9kZXN0TmFtZXNbaV0sIHNvdXJjZU1hcCwgdGhpcy5fc3JjTmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW5hbWVzOiBMb29rLXVwIHRoZSBkZXN0aW5hdGlvbiBuYW1lIGFuZCByZXR1cm4gdGhlIHNvdXJjZSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuTmFtZU1hcHBpbmcucHJvdG90eXBlLmdldFJlbmFtZVNyY05hbWUgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gdGhpcy5nZXRTcmNOYW1lRnJvbURlc3ROYW1lKG5hbWUpIHx8IG5hbWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgaW5wdXQgdmFsdWUgYXNzaWduZWQgdG8gb3BlcmF0b3IgYXJndW1lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBQb3NpdGlvbiBvZiB0aGUgb3BlcmF0b3IgYXJndW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBkZXN0aW5hdGlvbk5hbWUgTmFtZSBvZiB0aGUgb3BlcmF0b3IgYXJndW1lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd8bnVsbH1cbiAqL1xuTmFtZU1hcHBpbmcucHJvdG90eXBlLmdldFNjcmlwdElucHV0TmFtZT0gZnVuY3Rpb24oaW5kZXgsIGRlc3RpbmF0aW9uTmFtZSl7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3JjTmFtZUZyb21EZXN0TmFtZShkZXN0aW5hdGlvbk5hbWUpO1xufTtcblxuLyoqXG4gKiBAc2VlIE9yZGVyTWFwcGluZy5nZXRTY3JpcHRPdXRwdXROYW1lXG4gKi9cbk5hbWVNYXBwaW5nLnByb3RvdHlwZS5nZXRTY3JpcHRPdXRwdXROYW1lID0gZnVuY3Rpb24oaW5kZXgsIHNyY05hbWUpe1xuICAgIHJldHVybiB0aGlzLmdldERlc3ROYW1lRnJvbVNyY05hbWUoc3JjTmFtZSk7XG59O1xuXG4vKipcbiAqIEBzZWUgT3JkZXJNYXBwaW5nLmdldFNjcmlwdE91dHB1dE5hbWVJbnZcbiAqL1xuTmFtZU1hcHBpbmcucHJvdG90eXBlLmdldFNjcmlwdE91dHB1dE5hbWVJbnYgPSBmdW5jdGlvbihkZXN0TmFtZSAvKiwgb3BlcmF0b3JPdXRwdXRzICovKXtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9kZXN0TmFtZXMuaW5kZXhPZihkZXN0TmFtZSk7XG4gICAgaWYoaW5kZXggPT0gLTEpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiB0aGlzLl9zcmNOYW1lc1tpbmRleF07XG59O1xuXG4vKipcbiAqIE5vdGlmeSBhbGwgRGF0YU5vZGVzIHRoYXQgdXNlIHRoZSBtYXBwaW5nIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cbiAqIEBwYXJhbSB7TWFwcGluZ30gbWFwcGluZ1xuICovXG5mdW5jdGlvbiBtYXBwaW5nTm90aWZ5T3duZXIobWFwcGluZyl7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IG1hcHBpbmcuX293bmVycy5sZW5ndGg7ICsraSkge1xuICAgICAgICBtYXBwaW5nLl9vd25lcnNbaV0ubm90aWZ5KEMuUkVTVUxUX1NUQVRFLkNIQU5HRURfU1RSVUNUVVJFKTtcbiAgICB9XG4gICAgQmFzZS5fZmx1c2hSZXN1bHRDYWxsYmFja3MoKTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIE5hbWVNYXBwaW5nOiBOYW1lTWFwcGluZyxcbiAgICBPcmRlck1hcHBpbmc6IE9yZGVyTWFwcGluZyxcbiAgICBNYXBwaW5nOiBNYXBwaW5nXG59O1xuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcbnZhciBDID0gcmVxdWlyZShcIi4uL2ludGVyZmFjZS9jb25zdGFudHMuanNcIik7XG52YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vdXRpbHMvdXRpbHMuanNcIik7XG52YXIgRXhlY3V0b3IgPSByZXF1aXJlKFwiLi9leGVjdXRvci5qc1wiKTtcbnZhciBSZXN1bHQgPSByZXF1aXJlKFwiLi9yZXN1bHQuanNcIik7XG52YXIgT3BlcmF0b3IgPSByZXF1aXJlKFwiLi4vb3BlcmF0b3Ivb3BlcmF0b3IuanNcIik7XG52YXIgRGF0YSA9IHJlcXVpcmUoXCIuLi9pbnRlcmZhY2UvZGF0YS5qc1wiKTtcbnZhciBEYXRhU2xvdCA9IHJlcXVpcmUoXCIuLi9wcm9jZXNzaW5nL2RhdGEtc2xvdC5qc1wiKTtcblxudmFyIEJ1ZmZlckVudHJ5ID0gRGF0YS5CdWZmZXJFbnRyeTtcbnZhciBUZXh0dXJlRW50cnkgPSBEYXRhLlRleHR1cmVFbnRyeTtcbnZhciBJbWFnZURhdGFUZXh0dXJlRW50cnkgPSBEYXRhLkltYWdlRGF0YVRleHR1cmVFbnRyeTtcblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBDLlByb2Nlc3NOb2RlXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIEFTWU5DX1BST0NFU1NfU1RBVEUgPSB7XG4gICAgSURMRSA6IDAsXG4gICAgUlVOTklORyA6IDEsXG4gICAgUkVTQ0hFRFVMRUQgOiAyLFxuICAgIElOSVQ6IDNcbn07XG5cblxuLyoqXG4gKiBPcHRpbWl6ZWQgcmVwcmVzZW50YXRpb24gZm9yIHRoZSBwcm9jZXNzaW5nIGdyYXBoLiBPbmx5IGNyZWF0ZWQgZm9yIENoYW5uZWxOb2RlcyB3aXRoIG9wZXJhdG9ycy5cbiAqIElzIGNvbm5lY3RlZCBkaXJlY3RseSB0byBvdGhlciBQcm9jZXNzTm9kZXMsIGlnbm9yaW5nIGNoYW5uZWxzIHRoYXQgYXJlIG5vdCByZWxldmFudCBmb3IgcHJvY2Vzc2luZ1xuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0dyYXBoTm9kZX1cbiAqL1xudmFyIFByb2Nlc3NOb2RlID0gZnVuY3Rpb24oY2hhbm5lbE5vZGUpe1xuICAgIHRoaXMub3duZXIgPSBjaGFubmVsTm9kZTtcbiAgICB0aGlzLm9wZXJhdG9yID0gY2hhbm5lbE5vZGUub3BlcmF0b3I7XG5cbiAgICAvKipcbiAgICAgKiBJbnB1dCBjaGFubmVscyBmb3IgdGhlIG9wZXJhdG9yXG4gICAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBDaGFubmVsPn1cbiAgICAgKi9cbiAgICB0aGlzLmlucHV0Q2hhbm5lbHMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIE91dHB1dHMgb2Ygb3BlcmF0b3JcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIERhdGFTbG90Pn1cbiAgICAgKi9cbiAgICB0aGlzLm91dHB1dERhdGFTbG90cyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge2V4cG9ydHMuQy5QUk9DRVNTX1NUQVRFfVxuICAgICAqL1xuICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLk1PRElGSUVEO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FTWU5DX1BST0NFU1NfU1RBVEV9XG4gICAgICovXG4gICAgdGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSA9IEFTWU5DX1BST0NFU1NfU1RBVEUuSU5JVDtcblxuICAgIC8qKlxuICAgICAqIERpcmVjdCBDaGlsZHJlbiB3aXRob3V0IHRyYW5zaXRpdmUgY2hpbGRyZW4gb2YgY2hpbGRyZW5cbiAgICAgKiBUT0RPOiBVc2UgU2V0KCk/XG4gICAgICogQHR5cGUge0FycmF5LjxQcm9jZXNzTm9kZT59XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQ2hpbGRyZW4gd2l0aCB0cmFuc2l0aXZlIGRlcGVuZGVuY2llc1xuICAgICAqIFRPRE86IFVzZSBTZXQoKT9cbiAgICAgKiBAdHlwZSB7QXJyYXkuPFByb2Nlc3NOb2RlPn1cbiAgICAgKi9cbiAgICB0aGlzLmRlc2NlbmRhbnRzID0gW107XG5cbiAgICAvKipcbiAgICAgKiBDYWxsYmFjaywgdGhlIGV4ZWN1dG9yIG5lZWRzIHRvIGNhbGwgd2hlbiB0aGUgY29tcHV0YXRpb24gaXMgcmVhZHlcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9iaW5kZWRBc3luY0NhbGxiYWNrID0gbnVsbDtcblxuICAgIC8qKlxuICAgICAqIEluZGV4IG9mIGFycmF5IG1hdGNoZXMgcGxhdGZvcm0gaWQgKEMuUExBVEZPUk0pXG4gICAgICogQHR5cGUge0FycmF5LjxFeGVjdXRvcj59XG4gICAgICovXG4gICAgdGhpcy5leGVjdXRlcnMgPSBbXTtcblxuICAgIGNvbnN0cnVjdFByb2Nlc3NOb2RlKHRoaXMsIGNoYW5uZWxOb2RlKTtcblxuICAgIGlmKE9wZXJhdG9yLmlzT3BlcmF0b3JBc3luYyh0aGlzLm9wZXJhdG9yKSl7XG4gICAgICAgIHRoaXMuX2JpbmRlZEFzeW5jQ2FsbGJhY2sgPSB0aGlzLnJlY2VpdmVBc3luY1Byb2Nlc3NpbmcuYmluZCh0aGlzKTtcbiAgICB9XG59O1xuXG5Qcm9jZXNzTm9kZS5wcm90b3R5cGUub25YZmxvd0NoYW5uZWxDaGFuZ2UgPSBmdW5jdGlvbihjaGFubmVsLCBzdGF0ZSl7XG4gICAgaWYgKE9wZXJhdG9yLmlzT3BlcmF0b3JBc3luYyh0aGlzLm9wZXJhdG9yKSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gQy5QUk9DRVNTX1NUQVRFLkxPQURJTkcgfHwgdGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSAhPSBBU1lOQ19QUk9DRVNTX1NUQVRFLklOSVQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLk1PRElGSUVEO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuXG4gICAgICAgIGlmIChzdGF0ZSA9PSBDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9WQUxVRSAmJiB0aGlzLnN0YXR1cyA+IEMuUFJPQ0VTU19TVEFURS5VTlBST0NFU1NFRCkge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuVU5QUk9DRVNTRUQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5NT0RJRklFRDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeU91dHB1dENoYW5nZWQoc3RhdGUpO1xuICAgIH1cbn07XG5cblByb2Nlc3NOb2RlLnByb3RvdHlwZS5zdGFydEFzeW5jUHJvY2Vzc2luZyA9IGZ1bmN0aW9uKCl7XG4gICAgaWYodGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSA9PSBBU1lOQ19QUk9DRVNTX1NUQVRFLklETEUgfHwgdGhpcy5hc3luY1Byb2Nlc3NTdGF0ZSA9PSBBU1lOQ19QUk9DRVNTX1NUQVRFLklOSVQpe1xuICAgICAgICB0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID0gQVNZTkNfUFJPQ0VTU19TVEFURS5SVU5OSU5HO1xuICAgICAgICB2YXIgZXhlY3V0ZXIgPSBnZXRPckNyZWF0ZUV4ZWN1dGVyKHRoaXMsIEMuUExBVEZPUk0uQVNZTkMpO1xuICAgICAgICBleGVjdXRlci5ydW4odGhpcy5fYmluZGVkQXN5bmNDYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIHRoaXMuYXN5bmNQcm9jZXNzU3RhdGUgPSBBU1lOQ19QUk9DRVNTX1NUQVRFLlJFU0NIRURVTEVEO1xuICAgIH1cbn07XG5Qcm9jZXNzTm9kZS5wcm90b3R5cGUucmVjZWl2ZUFzeW5jUHJvY2Vzc2luZyA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuUFJPQ0VTU0VEO1xuICAgIHRoaXMubm90aWZ5T3V0cHV0Q2hhbmdlZChDLkRBVEFfRU5UUllfU1RBVEUuQ0hBTkdFRF9TSVpFX1RZUEUpO1xuICAgIGlmKHRoaXMuYXN5bmNQcm9jZXNzU3RhdGUgPT0gQVNZTkNfUFJPQ0VTU19TVEFURS5SRVNDSEVEVUxFRCl7XG4gICAgICAgIHRoaXMuYXN5bmNQcm9jZXNzU3RhdGUgPSBBU1lOQ19QUk9DRVNTX1NUQVRFLklETEU7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLk1PRElGSUVEO1xuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgfVxuICAgIGVsc2V7XG4gICAgICAgIHRoaXMuYXN5bmNQcm9jZXNzU3RhdGUgPSBBU1lOQ19QUk9DRVNTX1NUQVRFLklETEU7XG4gICAgfVxuICAgIEJhc2UuX2ZsdXNoUmVzdWx0Q2FsbGJhY2tzKCk7XG59O1xuXG5cblxuUHJvY2Vzc05vZGUucHJvdG90eXBlLm5vdGlmeU91dHB1dENoYW5nZWQgPSBmdW5jdGlvbihzdGF0ZSl7XG4gICAgZm9yKHZhciBuYW1lIGluIHRoaXMub3V0cHV0RGF0YVNsb3RzKXtcbiAgICAgICAgdGhpcy5vdXRwdXREYXRhU2xvdHNbbmFtZV0ubm90aWZ5T25DaGFuZ2Uoc3RhdGUpO1xuICAgIH1cbn07XG5cblxuUHJvY2Vzc05vZGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKXtcbiAgICBmb3IodmFyIG5hbWUgaW4gdGhpcy5pbnB1dENoYW5uZWxzKXtcbiAgICAgICAgdGhpcy5pbnB1dENoYW5uZWxzW25hbWVdICYmIHRoaXMuaW5wdXRDaGFubmVsc1tuYW1lXS5yZW1vdmVMaXN0ZW5lcih0aGlzKTtcbiAgICB9XG59O1xuXG5Qcm9jZXNzTm9kZS5wcm90b3R5cGUudXBkYXRlU3RhdGUgPSBmdW5jdGlvbigpe1xuICAgIGlmKHRoaXMuc3RhdHVzID09IEMuUFJPQ0VTU19TVEFURS5NT0RJRklFRCl7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLlVOUFJPQ0VTU0VEO1xuXG4gICAgICAgIFhNTDNELmRlYnVnLmFzc2VydCghdGhpcy5vd25lci5sb2FkaW5nLCBcIlRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlblwiKTtcblxuICAgICAgICBpZih0aGlzLm93bmVyLmxvYWRpbmcpXG4gICAgICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5MT0FESU5HO1xuICAgICAgICBlbHNle1xuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID0gTWF0aC5taW4odGhpcy5zdGF0dXMsIHRoaXMuY2hpbGRyZW5baV0udXBkYXRlU3RhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZih0aGlzLnN0YXR1cyA+IEMuUFJPQ0VTU19TVEFURS5MT0FESU5HICYmIGlzSW5wdXRMb2FkaW5nKHRoaXMub3BlcmF0b3IsIHRoaXMuaW5wdXRDaGFubmVscykpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTE9BRElORztcblxuICAgICAgICAgICAgaWYodGhpcy5zdGF0dXMgPiBDLlBST0NFU1NfU1RBVEUuSU5WQUxJRCAmJlxuICAgICAgICAgICAgICAgICFjaGVja0lucHV0KHRoaXMsIHRoaXMub3BlcmF0b3IsIHRoaXMub3duZXIub3duZXIuX2NvbXB1dGVJbnB1dE1hcHBpbmcsIHRoaXMuaW5wdXRDaGFubmVscykpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuSU5WQUxJRDtcblxuICAgICAgICAgICAgaWYodGhpcy5zdGF0dXMgPT0gQy5QUk9DRVNTX1NUQVRFLlVOUFJPQ0VTU0VEICYmIE9wZXJhdG9yLmlzT3BlcmF0b3JBc3luYyh0aGlzLm9wZXJhdG9yKSl7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSB0aGlzLmFzeW5jUHJvY2Vzc1N0YXRlID09IEFTWU5DX1BST0NFU1NfU1RBVEUuSU5JVCA/IEMuUFJPQ0VTU19TVEFURS5MT0FESU5HXG4gICAgICAgICAgICAgICAgICAgIDogQy5QUk9DRVNTX1NUQVRFLlBST0NFU1NFRDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QXN5bmNQcm9jZXNzaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zdGF0dXM7XG59O1xuXG5Qcm9jZXNzTm9kZS5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uKCl7XG5cbiAgICBpZih0aGlzLnN0YXR1cyA9PSBDLlBST0NFU1NfU1RBVEUuVU5QUk9DRVNTRUQpe1xuICAgICAgICB2YXIgZXhlY3V0ZXIgPSBnZXRPckNyZWF0ZUV4ZWN1dGVyKHRoaXMsIHRoaXMub3duZXIucGxhdGZvcm0pO1xuICAgICAgICBleGVjdXRlci5ydW4oKTtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuUFJPQ0VTU0VEO1xuICAgIH1cbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7UHJvY2Vzc05vZGV9IHByb2Nlc3NOb2RlXG4gKiBAcGFyYW0ge0NoYW5uZWxOb2RlfSBjaGFubmVsTm9kZVxuICovXG5mdW5jdGlvbiBjb25zdHJ1Y3RQcm9jZXNzTm9kZShwcm9jZXNzTm9kZSwgY2hhbm5lbE5vZGUpe1xuICAgIHZhciBkYXRhTm9kZSA9IGNoYW5uZWxOb2RlLm93bmVyO1xuICAgIHN5bmNocm9uaXplSW5wdXRDaGFubmVscyhwcm9jZXNzTm9kZSwgY2hhbm5lbE5vZGUsIGRhdGFOb2RlKTtcbiAgICBzeW5jaHJvbml6ZUNoaWxkcmVuQW5kRGVzY2VuZGFudHMocHJvY2Vzc05vZGUuY2hpbGRyZW4sIHByb2Nlc3NOb2RlLmRlc2NlbmRhbnRzLCBwcm9jZXNzTm9kZS5pbnB1dENoYW5uZWxzKTtcbiAgICBzeW5jaHJvbml6ZU91dHB1dChwcm9jZXNzTm9kZS5vcGVyYXRvciwgcHJvY2Vzc05vZGUub3V0cHV0RGF0YVNsb3RzKTtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHByb2Nlc3NOb2RlXG4gKiBAcGFyYW0gY2hhbm5lbE5vZGVcbiAqIEBwYXJhbSBkYXRhTm9kZVxuICovXG5mdW5jdGlvbiBzeW5jaHJvbml6ZUlucHV0Q2hhbm5lbHMocHJvY2Vzc05vZGUsIGNoYW5uZWxOb2RlLCBkYXRhTm9kZSl7XG4gICAgdmFyIG9wZXJhdG9yID0gcHJvY2Vzc05vZGUub3BlcmF0b3IsIGlucHV0TWFwcGluZyA9IGRhdGFOb2RlLl9jb21wdXRlSW5wdXRNYXBwaW5nO1xuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBvcGVyYXRvci5wYXJhbXMubGVuZ3RoOyArK2kpe1xuICAgICAgICB2YXIgc291cmNlTmFtZSA9IG9wZXJhdG9yLnBhcmFtc1tpXS5zb3VyY2U7XG4gICAgICAgIHZhciBkYXRhTmFtZSA9IGlucHV0TWFwcGluZyA/IGlucHV0TWFwcGluZy5nZXRTY3JpcHRJbnB1dE5hbWUoaSwgc291cmNlTmFtZSkgOiBzb3VyY2VOYW1lO1xuICAgICAgICBpZihkYXRhTmFtZSl7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IGNoYW5uZWxOb2RlLmlucHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChkYXRhTmFtZSk7XG4gICAgICAgICAgICBpZihjaGFubmVsKSBjaGFubmVsLmFkZExpc3RlbmVyKHByb2Nlc3NOb2RlKTtcbiAgICAgICAgICAgIHByb2Nlc3NOb2RlLmlucHV0Q2hhbm5lbHNbc291cmNlTmFtZV0gPSBjaGFubmVsO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc0lucHV0TG9hZGluZyhvcGVyYXRvciwgaW5wdXRDaGFubmVscyl7XG4gICAgZm9yKHZhciBpIGluIG9wZXJhdG9yLnBhcmFtcyl7XG4gICAgICAgIHZhciBlbnRyeSA9IG9wZXJhdG9yLnBhcmFtc1tpXTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBpbnB1dENoYW5uZWxzW2VudHJ5LnNvdXJjZV07XG4gICAgICAgIGlmKCFjaGFubmVsKSBjb250aW51ZTtcbiAgICAgICAgdmFyIGRhdGFFbnRyeSA9IGNoYW5uZWwuZ2V0RGF0YUVudHJ5KCk7XG4gICAgICAgIGlmKCFkYXRhRW50cnkpIGNvbnRpbnVlO1xuICAgICAgICBpZihkYXRhRW50cnkuaXNMb2FkaW5nICYmIGRhdGFFbnRyeS5pc0xvYWRpbmcoKSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnB1dChwcm9jZXNzTm9kZSwgb3BlcmF0b3IsIGlucHV0TWFwcGluZywgaW5wdXRDaGFubmVscyl7XG4gICAgdmFyIGRhdGFOb2RlID0gcHJvY2Vzc05vZGUub3duZXIub3duZXI7XG4gICAgZm9yKHZhciBpIGluIG9wZXJhdG9yLnBhcmFtcyl7XG4gICAgICAgIHZhciBlbnRyeSA9IG9wZXJhdG9yLnBhcmFtc1tpXTtcbiAgICAgICAgdmFyIGRhdGFOYW1lID0gaW5wdXRNYXBwaW5nID8gaW5wdXRNYXBwaW5nLmdldFNjcmlwdElucHV0TmFtZShpLCBlbnRyeS5zb3VyY2UpIDogZW50cnkuc291cmNlO1xuICAgICAgICBpZighZW50cnkub3B0aW9uYWwgJiYgIWRhdGFOYW1lKXtcbiAgICAgICAgICAgIEJhc2Uubm90aWZ5RXJyb3IoXCJYZmxvdzogb3BlcmF0b3IgXCIgKyBvcGVyYXRvci5uYW1lICsgXCI6IE1pc3NpbmcgaW5wdXQgYXJndW1lbnQgZm9yIFwiXG4gICAgICAgICAgICAgICAgKyBlbnRyeS5zb3VyY2UsIGRhdGFOb2RlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZihkYXRhTmFtZSl7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IGlucHV0Q2hhbm5lbHNbZW50cnkuc291cmNlXTtcbiAgICAgICAgICAgIGlmKCFjaGFubmVsKXtcbiAgICAgICAgICAgICAgICBpZighaW5wdXRNYXBwaW5nKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBCYXNlLm5vdGlmeUVycm9yKFwiWGZsb3c6IG9wZXJhdG9yIFwiICsgb3BlcmF0b3IubmFtZSArIFwiOiBJbnB1dCBvZiBuYW1lICdcIiArIGRhdGFOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgXCInIG5vdCBmb3VuZC4gVXNlZCBmb3IgcGFyYW1ldGVyIFwiICsgZW50cnkuc291cmNlLCBkYXRhTm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGFFbnRyeSA9IGNoYW5uZWwuZ2V0RGF0YUVudHJ5KCk7XG5cbiAgICAgICAgICAgIGlmKCFjaGFubmVsLmNyZWF0b3JQcm9jZXNzTm9kZSl7XG4gICAgICAgICAgICAgICAgaWYoIWVudHJ5Lm9wdGlvbmFsICYmICghZGF0YUVudHJ5IHx8IGRhdGFFbnRyeS5pc0VtcHR5KCkpKXtcbiAgICAgICAgICAgICAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIlhmbG93OiBvcGVyYXRvciBcIiArIG9wZXJhdG9yLm5hbWUgKyBcIjogSW5wdXQgZm9yIFwiICsgZW50cnkuc291cmNlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgY29udGFpbnMgbm8gZGF0YS4nLCBkYXRhTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihkYXRhRW50cnkgJiYgZGF0YUVudHJ5LnR5cGUgIT0gZW50cnkudHlwZSl7XG4gICAgICAgICAgICAgICAgQmFzZS5ub3RpZnlFcnJvcihcIlhmbG93OiBvcGVyYXRvciBcIiArIG9wZXJhdG9yLm5hbWUgKyBcIjogSW5wdXQgZm9yIFwiICsgZW50cnkuc291cmNlICtcbiAgICAgICAgICAgICAgICAgICAgXCIgaGFzIHdyb25nIHR5cGUuIEV4cGVjdGVkOiBcIiArIEMuZ2V0VHlwZU5hbWUoZW50cnkudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgKyBcIiwgYnV0IGdvdDogXCIgKyAgQy5nZXRUeXBlTmFtZShkYXRhRW50cnkudHlwZSksIGRhdGFOb2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHN5bmNocm9uaXplQ2hpbGRyZW5BbmREZXNjZW5kYW50cyhjaGlsZHJlbiwgZGVzY2VuZGFudHMsIGlucHV0Q2hhbm5lbHMpe1xuICAgIHZhciBjaGFubmVsO1xuICAgIGZvcih2YXIgbmFtZSBpbiBpbnB1dENoYW5uZWxzKXtcbiAgICAgICAgY2hhbm5lbCA9IGlucHV0Q2hhbm5lbHNbbmFtZV07XG4gICAgICAgIGlmKGNoYW5uZWwgJiYgY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUpe1xuICAgICAgICAgICAgdXRpbHMuc2V0LmFkZChjaGlsZHJlbiwgY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUpO1xuICAgICAgICAgICAgdXRpbHMuc2V0LmFkZChkZXNjZW5kYW50cywgY2hhbm5lbC5jcmVhdG9yUHJvY2Vzc05vZGUuZGVzY2VuZGFudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHV0aWxzLnNldC5yZW1vdmUoY2hpbGRyZW4sIGRlc2NlbmRhbnRzKTtcbiAgICB1dGlscy5zZXQuYWRkKGRlc2NlbmRhbnRzLCBjaGlsZHJlbik7XG59XG5cbmZ1bmN0aW9uIHN5bmNocm9uaXplT3V0cHV0KG9wZXJhdG9yLCBvdXRwdXRzKXtcbiAgICB2YXIgYXN5bmMgPSBPcGVyYXRvci5pc09wZXJhdG9yQXN5bmMob3BlcmF0b3IpO1xuICAgIGZvcih2YXIgaSBpbiBvcGVyYXRvci5vdXRwdXRzKXtcbiAgICAgICAgdmFyIGRhdGFFbnRyeSA9IG9wZXJhdG9yLm91dHB1dHNbaV07XG5cbiAgICAgICAgdmFyIGVudHJ5LCBhc3luY0VudHJ5O1xuICAgICAgICB2YXIgdHlwZSA9IGRhdGFFbnRyeS50eXBlO1xuICAgICAgICBpZih0eXBlICE9IEMuREFUQV9UWVBFLlRFWFRVUkUpe1xuICAgICAgICAgICAgZW50cnkgPSBuZXcgQnVmZmVyRW50cnkodHlwZSwgbnVsbCk7XG4gICAgICAgICAgICBpZihhc3luYykgYXN5bmNFbnRyeSA9IG5ldyBCdWZmZXJFbnRyeSh0eXBlLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNle1xuICAgICAgICAgICAgZW50cnkgPSB3aW5kb3cuZG9jdW1lbnQgPyBuZXcgVGV4dHVyZUVudHJ5KG51bGwpIDogbmV3IEltYWdlRGF0YVRleHR1cmVFbnRyeShudWxsKTtcbiAgICAgICAgICAgIGlmKGFzeW5jKSBhc3luY0VudHJ5ID0gd2luZG93LmRvY3VtZW50ID8gbmV3IFRleHR1cmVFbnRyeShudWxsKSA6IG5ldyBJbWFnZURhdGFUZXh0dXJlRW50cnkobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0c1tkYXRhRW50cnkubmFtZV0gPSBuZXcgRGF0YVNsb3QoZW50cnksIDApO1xuICAgICAgICBpZihhc3luYykgb3V0cHV0c1tkYXRhRW50cnkubmFtZV0uYXN5bmNEYXRhRW50cnkgPSBhc3luY0VudHJ5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0T3JDcmVhdGVFeGVjdXRlcihub2RlLCBwbGF0Zm9ybSl7XG4gICAgaWYoIW5vZGUuZXhlY3V0ZXJzW3BsYXRmb3JtXSl7XG4gICAgICAgIG5vZGUuZXhlY3V0ZXJzW3BsYXRmb3JtXSA9IG5ldyBFeGVjdXRvcihub2RlLCBwbGF0Zm9ybSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlLmV4ZWN1dGVyc1twbGF0Zm9ybV07XG59XG5cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXF1ZXN0Tm9kZVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vKipcbiAqXG4gKiBGSVhNRTogUmVxdWVzdE5vZGVzIGFyZSBuZXZlciBkZWxldGVkLlxuICogQHBhcmFtIHtDaGFubmVsTm9kZX0gY2hhbm5lbE5vZGVcbiAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IGZpbHRlclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSZXF1ZXN0Tm9kZSA9IGZ1bmN0aW9uKGNoYW5uZWxOb2RlLCBmaWx0ZXIpe1xuICAgIHRoaXMub3duZXIgPSBjaGFubmVsTm9kZTtcbiAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxDLlBMQVRGT1JNLCBleHBvcnRzLlJlc3VsdD59XG4gICAgICovXG4gICAgdGhpcy5yZXN1bHRzID0ge307XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7ZXhwb3J0cy5DLlBST0NFU1NfU1RBVEV9XG4gICAgICovXG4gICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTU9ESUZJRUQ7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIENoYW5uZWw+fVxuICAgICAqL1xuICAgIHRoaXMuY2hhbm5lbHMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEBzZWUgUHJvY2Vzc05vZGUuY2hpbGRyZW5cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5jaGlsZHJlbiA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHNlZSBQcm9jZXNzTm9kZS5leGVjdXRlcnNcbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5leGVjdXRlcnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBzZWUgUHJvY2Vzc05vZGUub3V0T2ZTeW5jXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5vdXRPZlN5bmMgPSB0cnVlO1xufTtcblxuUmVxdWVzdE5vZGUucHJvdG90eXBlLnN5bmNocm9uaXplID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLm91dE9mU3luYyl7XG4gICAgICAgIHRoaXMub3V0T2ZTeW5jID0gZmFsc2U7XG4gICAgICAgIHN5bmNocm9uaXplUmVxdWVzdENoYW5uZWxzKHRoaXMsIHRoaXMub3duZXIpO1xuICAgICAgICBzeW5jaHJvbml6ZUNoaWxkcmVuQW5kRGVzY2VuZGFudHModGhpcy5jaGlsZHJlbiwgW10sIHRoaXMuY2hhbm5lbHMpO1xuICAgIH1cbn07XG5cblJlcXVlc3ROb2RlLnByb3RvdHlwZS51cGRhdGVTdGF0ZSA9IGZ1bmN0aW9uKCl7XG4gICAgdGhpcy5zeW5jaHJvbml6ZSgpO1xuICAgIGlmKHRoaXMuc3RhdHVzID09IEMuUFJPQ0VTU19TVEFURS5NT0RJRklFRCl7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLlVOUFJPQ0VTU0VEO1xuXG4gICAgICAgIGlmKHRoaXMub3duZXIubG9hZGluZykge1xuICAgICAgICAgICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTE9BRElORztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9IE1hdGgubWluKHRoaXMuc3RhdHVzLCB0aGlzLmNoaWxkcmVuW2ldLnVwZGF0ZVN0YXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0YXR1cztcbn07XG5cblJlcXVlc3ROb2RlLnByb3RvdHlwZS5nZXRSZXN1bHQgPSBmdW5jdGlvbihyZXN1bHRUeXBlKXtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG5cbiAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIGJlIGluIGdldFJlcXVlc3RDb21wdXRlUmVzdWx0XG4gICAgaWYodGhpcy5zdGF0dXMgPT0gQy5QUk9DRVNTX1NUQVRFLlVOUFJPQ0VTU0VEKXtcbiAgICAgICAgaWYocmVzdWx0VHlwZSA9PSBDLlJFU1VMVF9UWVBFLkNPTVBVVEUpe1xuICAgICAgICAgICAgdmFyIGV4ZWN1dGVyID0gZ2V0T3JDcmVhdGVFeGVjdXRlcih0aGlzLCB0aGlzLm93bmVyLnBsYXRmb3JtKTtcbiAgICAgICAgICAgIGlmKCFleGVjdXRlci5pc1Byb2Nlc3NlZCgpKVxuICAgICAgICAgICAgICAgIGV4ZWN1dGVyLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdHVzID0gQy5QUk9DRVNTX1NUQVRFLlBST0NFU1NFRDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdFR5cGUgPT0gQy5SRVNVTFRfVFlQRS5DT01QVVRFKSB7XG4gICAgICAgIHJlc3VsdCA9IGdldFJlcXVlc3RDb21wdXRlUmVzdWx0KHRoaXMpO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0VHlwZSA9PSBDLlJFU1VMVF9UWVBFLlZTKSB7XG4gICAgICAgIHJlc3VsdCA9IGdldFJlcXVlc3RWU1Jlc3VsdCh0aGlzKTtcbiAgICB9XG4gICAgcmVzdWx0LmxvYWRpbmcgPSAodGhpcy5zdGF0dXMgPT0gQy5QUk9DRVNTX1NUQVRFLkxPQURJTkcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5SZXF1ZXN0Tm9kZS5wcm90b3R5cGUuc2V0U3RydWN0dXJlT3V0T2ZTeW5jID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLm91dE9mU3luYyA9IHRydWU7XG4gICAgdGhpcy5zdGF0dXMgPSBDLlBST0NFU1NfU1RBVEUuTU9ESUZJRUQ7XG4gICAgZm9yKHZhciB0eXBlIGluIHRoaXMucmVzdWx0cyl7XG4gICAgICAgIHRoaXMucmVzdWx0c1t0eXBlXS5fbm90aWZ5Q2hhbmdlZChDLlJFU1VMVF9TVEFURS5DSEFOR0VEX1NUUlVDVFVSRSk7XG4gICAgfVxuICAgIGZvcih2YXIgbmFtZSBpbiB0aGlzLmNoYW5uZWxzKXtcbiAgICAgICAgdGhpcy5jaGFubmVsc1tuYW1lXS5yZW1vdmVMaXN0ZW5lcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5jaGFubmVscyA9IFtdO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB0aGlzLmV4ZWN1dGVycyA9IFtdO1xufTtcblxuUmVxdWVzdE5vZGUucHJvdG90eXBlLm9uWGZsb3dDaGFubmVsQ2hhbmdlID0gZnVuY3Rpb24oY2hhbm5lbCwgc3RhdGUpe1xuICAgIGlmKGNoYW5uZWwuY3JlYXRvclByb2Nlc3NOb2RlKVxuICAgICAgICB0aGlzLnN0YXR1cyA9IEMuUFJPQ0VTU19TVEFURS5NT0RJRklFRDtcbiAgICB2YXIgbm90aWZ5U3RhdGUgPSAoc3RhdGUgPT0gQy5EQVRBX0VOVFJZX1NUQVRFLkNIQU5HRURfVkFMVUUgPyBDLlJFU1VMVF9TVEFURS5DSEFOR0VEX0RBVEFfVkFMVUVcbiAgICAgICAgICAgIDogQy5SRVNVTFRfU1RBVEUuQ0hBTkdFRF9EQVRBX1NJWkUpO1xuXG4gICAgZm9yKHZhciB0eXBlIGluIHRoaXMucmVzdWx0cyl7XG4gICAgICAgIHRoaXMucmVzdWx0c1t0eXBlXS5fbm90aWZ5Q2hhbmdlZChub3RpZnlTdGF0ZSk7XG4gICAgfVxufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHJlcXVlc3ROb2RlXG4gKiBAcGFyYW0gY2hhbm5lbE5vZGVcbiAqL1xuZnVuY3Rpb24gc3luY2hyb25pemVSZXF1ZXN0Q2hhbm5lbHMocmVxdWVzdE5vZGUsIGNoYW5uZWxOb2RlKXtcbiAgICB2YXIgbmFtZXMgPSByZXF1ZXN0Tm9kZS5maWx0ZXI7XG4gICAgaWYoIW5hbWVzKXtcbiAgICAgICAgbmFtZXMgPSBjaGFubmVsTm9kZS5vdXRwdXRDaGFubmVscy5nZXROYW1lcygpO1xuICAgIH1cblxuICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSl7XG4gICAgICAgIHZhciBuYW1lID0gbmFtZXNbaV07XG4gICAgICAgIHZhciBjaGFubmVsID0gY2hhbm5lbE5vZGUub3V0cHV0Q2hhbm5lbHMuZ2V0Q2hhbm5lbChuYW1lKTtcbiAgICAgICAgaWYoY2hhbm5lbCl7XG4gICAgICAgICAgICByZXF1ZXN0Tm9kZS5jaGFubmVsc1tuYW1lXSA9IGNoYW5uZWw7XG4gICAgICAgICAgICBjaGFubmVsLmFkZExpc3RlbmVyKHJlcXVlc3ROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtSZXF1ZXN0Tm9kZX0gcmVxdWVzdE5vZGVcbiAqIEByZXR1cm5zIHtSZXN1bHR9XG4gKi9cbmZ1bmN0aW9uIGdldFJlcXVlc3RDb21wdXRlUmVzdWx0KHJlcXVlc3ROb2RlKVxue1xuICAgIGlmKCFyZXF1ZXN0Tm9kZS5yZXN1bHRzW0MuUkVTVUxUX1RZUEUuQ09NUFVURV0pXG4gICAgICAgIHJlcXVlc3ROb2RlLnJlc3VsdHNbQy5SRVNVTFRfVFlQRS5DT01QVVRFXSA9IG5ldyBSZXN1bHQuQ29tcHV0ZVJlc3VsdCgpO1xuXG4gICAgdmFyIHJlc3VsdCA9IHJlcXVlc3ROb2RlLnJlc3VsdHNbQy5SRVNVTFRfVFlQRS5DT01QVVRFXTtcbiAgICByZXN1bHQuX2RhdGFFbnRyaWVzID0ge307IHJlc3VsdC5fb3V0cHV0TmFtZXMgPSBbXTtcblxuICAgIGZvcih2YXIgbmFtZSBpbiByZXF1ZXN0Tm9kZS5jaGFubmVscyl7XG4gICAgICAgIHZhciBlbnRyeSA9IHJlcXVlc3ROb2RlLmNoYW5uZWxzW25hbWVdLmdldERhdGFFbnRyeSgpO1xuICAgICAgICByZXN1bHQuX2RhdGFFbnRyaWVzW25hbWVdID0gZW50cnkgJiYgIWVudHJ5LmlzRW1wdHkoKSA/IGVudHJ5IDogbnVsbDtcbiAgICAgICAgcmVzdWx0Ll9vdXRwdXROYW1lcy5wdXNoKG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqXG4gKiBAcGFyYW0gcmVxdWVzdE5vZGVcbiAqIEByZXR1cm5zIHtleHBvcnRzLlZTRGF0YVJlc3VsdH1cbiAqL1xuZnVuY3Rpb24gZ2V0UmVxdWVzdFZTUmVzdWx0KHJlcXVlc3ROb2RlKVxue1xuICAgIHZhciBleGVjdXRlciA9IGdldE9yQ3JlYXRlRXhlY3V0ZXIocmVxdWVzdE5vZGUsIEMuUExBVEZPUk0uR0xTTCk7XG4gICAgaWYoIXJlcXVlc3ROb2RlLnJlc3VsdHNbQy5SRVNVTFRfVFlQRS5WU10pXG4gICAgICAgIHJlcXVlc3ROb2RlLnJlc3VsdHNbQy5SRVNVTFRfVFlQRS5WU10gPSBuZXcgUmVzdWx0LlZTRGF0YVJlc3VsdCgpO1xuICAgIHZhciByZXN1bHQgPSByZXF1ZXN0Tm9kZS5yZXN1bHRzW0MuUkVTVUxUX1RZUEUuVlNdO1xuXG4gICAgdmFyIHByb2dyYW0gPSBleGVjdXRlci5nZXRWZXJ0ZXhTaGFkZXIoKTtcbiAgICByZXN1bHQuX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgIHJlc3VsdC5fcHJvZ3JhbURhdGEgPSBleGVjdXRlci5wcm9ncmFtRGF0YTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIFJlcXVlc3ROb2RlOiBSZXF1ZXN0Tm9kZSxcbiAgICBQcm9jZXNzTm9kZTogUHJvY2Vzc05vZGVcbn07XG5cbiIsInZhciBCYXNlID0gcmVxdWlyZShcIi4uL2Jhc2UuanNcIik7XG5yZXF1aXJlKFwiLi4vLi4vdXRpbHMvYXJyYXkuanNcIik7XG5cbnZhciBxdWV1ZVJlc3VsdENhbGxiYWNrID0gQmFzZS5fcXVldWVSZXN1bHRDYWxsYmFjaztcblxuLyoqXG4gKiBDb250ZW50IG9mIHRoaXMgZmlsZTpcbiAqIFJlc3VsdCBjbGFzc2VzIG9mIGFuIFhmbG93IGdyYXBoIHdoaWNoIGFyZSByZWNlaXZlZCB0aHJvdWdoIFJlcXVlc3RzLlxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgUmVzdWx0IHN0cnVjdHVyZSBjb250YWluaW5nIGEgKHByb2Nlc3NlZCkgcmVzdWx0IG9mIHRoZSBYZmxvdyBncmFwaC5cbiAqIEBhYnN0cmFjdFxuICovXG52YXIgUmVzdWx0ID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAvKiogVmFsaWQgaXMgZmFsc2UgaWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIHRoZSBwcm9jZXNzaW5nIG9mIHRoZSByZXN1bHQgKi9cbiAgICB0aGlzLnZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihSZXN1bHQsIEMuUkVTVUxUX1NUQVRFKX0gY2FsbGJhY2tcbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKGNhbGxiYWNrKXtcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUmVzdWx0LCBDLlJFU1VMVF9TVEFURSl9IGNhbGxiYWNrXG4gKi9cblJlc3VsdC5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihjYWxsYmFjayl7XG4gICAgQXJyYXkuZXJhc2UodGhpcy5fbGlzdGVuZXJzLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUmVzdWx0LCBDLlJFU1VMVF9TVEFURSl9IGNhbGxiYWNrXG4gKi9cblJlc3VsdC5wcm90b3R5cGUuX2FkZFJlcXVlc3QgPSBmdW5jdGlvbihyZXF1ZXN0KXtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFJlc3VsdCwgQy5SRVNVTFRfU1RBVEUpfSBjYWxsYmFja1xuICovXG5SZXN1bHQucHJvdG90eXBlLl9yZW1vdmVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdCl7XG4gICAgQXJyYXkuZXJhc2UodGhpcy5fcmVxdWVzdHMsIHJlcXVlc3QpO1xufTtcblxuXG5SZXN1bHQucHJvdG90eXBlLl9ub3RpZnlDaGFuZ2VkID0gZnVuY3Rpb24oc3RhdGUpe1xuICAgIHRoaXMudmFsaWQgPSBmYWxzZTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fcmVxdWVzdHMubGVuZ3RoOyArK2kpe1xuICAgICAgICB0aGlzLl9yZXF1ZXN0c1tpXS5fb25SZXN1bHRDaGFuZ2VkKHN0YXRlKTtcbiAgICB9XG4gICAgcXVldWVSZXN1bHRDYWxsYmFjayh0aGlzLCBzdGF0ZSk7XG59XG5cblJlc3VsdC5wcm90b3R5cGUuX29uUG9zdHBvbmVkUmVzdWx0Q2hhbmdlZCA9IGZ1bmN0aW9uKHN0YXRlKXtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdGVuZXJzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2ldKHRoaXMsIHN0YXRlKTtcbiAgICB9XG59XG5cblxuXG4vKipcbiAqIENvbXB1dGVSZXN1bHQgY29udGFpbnMgYSBuYW1lZCBtYXAgb2YgdHlwZWQgdmFsdWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7UmVzdWx0fVxuICovXG52YXIgQ29tcHV0ZVJlc3VsdCA9IGZ1bmN0aW9uKCl7XG4gICAgUmVzdWx0LmNhbGwodGhpcyk7XG4gICAgdGhpcy5fb3V0cHV0TmFtZXMgPSBbXTtcbiAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLERhdGFFbnRyeT59ICovXG4gICAgdGhpcy5fZGF0YUVudHJpZXMgPSB7fTtcbn07XG5CYXNlLmNyZWF0ZUNsYXNzKENvbXB1dGVSZXN1bHQsIFJlc3VsdCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wdXRlUmVzdWx0LnByb3RvdHlwZSwgXCJvdXRwdXROYW1lc1wiLCB7XG4gICAgc2V0OiBmdW5jdGlvbih2KXtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0cHV0TmFtZXMgaXMgcmVhZG9ubHlcIik7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLl9vdXRwdXROYW1lczsgfVxufSk7XG5cbkNvbXB1dGVSZXN1bHQucHJvdG90eXBlLmdldE91dHB1dERhdGEgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gdGhpcy5fZGF0YUVudHJpZXNbbmFtZV07XG59O1xuXG4vKipcbiAqIEByZXR1cm5zIHtPYmplY3QuPHN0cmluZyxEYXRhRW50cnk+fVxuICovXG5Db21wdXRlUmVzdWx0LnByb3RvdHlwZS5nZXRPdXRwdXRNYXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YUVudHJpZXM7XG59O1xuXG5cblxuLyoqXG4gKiBWU0RhdGFSZXN1bHQgaXMgdXNlZCB0byBhbmFseXNlIHRoZSBvdXRwdXQgb2YgYSBWZXJ0ZXhTaGFkZXJcbiAqIE5vdGUgdGhhdCB0aGUgVlNEYXRhUmVzdWx0IGlzIG5vdCB1c2VkIHRvIGdlbmVyYXRlIHRoZSBWZXJ0ZXhTaGFkZXIgZGlyZWN0bHkuXG4gKiBGb3IgdGhhdCwgdGhlIFZlcnRleFNoYWRlciBzdHJ1Y3R1cmUgbXVzdCBiZSBjcmVhdGVkIGZyb20gVmVydGV4U2hhZGVyUmVxdWVzdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7UmVzdWx0fVxuICovXG52YXIgVlNEYXRhUmVzdWx0ID0gZnVuY3Rpb24oKXtcbiAgICBSZXN1bHQuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9wcm9ncmFtID0gbnVsbDtcbiAgICB0aGlzLl9wcm9ncmFtRGF0YSA9IG51bGw7XG59O1xuQmFzZS5jcmVhdGVDbGFzcyhWU0RhdGFSZXN1bHQsIFJlc3VsdCk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWU0RhdGFSZXN1bHQucHJvdG90eXBlLCBcIm91dHB1dE5hbWVzXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaGFkZXJPdXRwdXROYW1lcyBpcyByZWFkb25seVwiKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX3Byb2dyYW0uZ2V0T3V0cHV0TmFtZXMoKTsgfVxufSk7XG5cblZTRGF0YVJlc3VsdC5wcm90b3R5cGUuaXNPdXRwdXRVbmlmb3JtID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyYW0uaXNPdXRwdXRVbmlmb3JtKG5hbWUpO1xufVxuVlNEYXRhUmVzdWx0LnByb3RvdHlwZS5pc091dHB1dE51bGwgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbS5pc091dHB1dE51bGwobmFtZSk7XG59XG5WU0RhdGFSZXN1bHQucHJvdG90eXBlLmdldE91dHB1dFR5cGUgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbS5nZXRPdXRwdXRUeXBlKG5hbWUpO1xufVxuVlNEYXRhUmVzdWx0LnByb3RvdHlwZS5nZXRWZXJ0ZXhTaGFkZXIgPSBmdW5jdGlvbih2c0NvbmZpZyl7XG4gICAgcmV0dXJuIHRoaXMuX3Byb2dyYW0uY3JlYXRlVmVydGV4U2hhZGVyKHRoaXMuX3Byb2dyYW1EYXRhLCB2c0NvbmZpZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIENvbXB1dGVSZXN1bHQ6ICBDb21wdXRlUmVzdWx0LFxuICAgIFZTRGF0YVJlc3VsdDogVlNEYXRhUmVzdWx0XG59O1xuIiwidmFyIEJhc2UgPSByZXF1aXJlKFwiLi4vYmFzZS5qc1wiKTtcbnZhciBDID0gcmVxdWlyZShcIi4vLi4vaW50ZXJmYWNlL2NvbnN0YW50cy5qc1wiKTtcblxudmFyIGluaXRBbm9ueW1vdXNPcGVyYXRvciA9IHJlcXVpcmUoXCIuLi9vcGVyYXRvci9vcGVyYXRvci5qc1wiKS5pbml0QW5vbnltb3VzT3BlcmF0b3I7XG5cbnZhciBzaGFkZXJDb25zdGFudCA9IHt9O1xuc2hhZGVyQ29uc3RhbnRbQy5TSEFERVJfQ09OU1RBTlRfS0VZLk9CSkVDVF9JRF0gPSBcIm9iamVjdElEXCI7XG5zaGFkZXJDb25zdGFudFtDLlNIQURFUl9DT05TVEFOVF9LRVkuU0NSRUVOX1RSQU5TRk9STV0gPSBcInNjcmVlblRyYW5zZm9ybVwiO1xuc2hhZGVyQ29uc3RhbnRbQy5TSEFERVJfQ09OU1RBTlRfS0VZLlNDUkVFTl9UUkFOU0ZPUk1fTk9STUFMXSA9IFwic2NyZWVuVHJhbnNmb3JtTm9ybWFsXCI7XG5zaGFkZXJDb25zdGFudFtDLlNIQURFUl9DT05TVEFOVF9LRVkuVklFV19UUkFOU0ZPUk1dID0gXCJ2aWV3VHJhbnNmb3JtXCI7XG5zaGFkZXJDb25zdGFudFtDLlNIQURFUl9DT05TVEFOVF9LRVkuVklFV19UUkFOU0ZPUk1fTk9STUFMXSA9IFwidmlld1RyYW5zZm9ybU5vcm1hbFwiO1xuc2hhZGVyQ29uc3RhbnRbQy5TSEFERVJfQ09OU1RBTlRfS0VZLldPUkxEX1RSQU5TRk9STV0gPSBcIndvcmxkVHJhbnNmb3JtXCI7XG5zaGFkZXJDb25zdGFudFtDLlNIQURFUl9DT05TVEFOVF9LRVkuV09STERfVFJBTlNGT1JNX05PUk1BTF0gPSBcIndvcmxkVHJhbnNmb3JtTm9ybWFsXCI7XG5cbnZhciBzZXRTaGFkZXJDb25zdGFudCA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUpe1xuICAgIHNoYWRlckNvbnN0YW50W3R5cGVdID0gbmFtZTtcbn07XG5cblxuLyoqXG4gKiBUaGUgb3V0cHV0IGNvbmZpZ3VyYXRpb24gb2YgYSBWZXJ0ZXhTaGFkZXIgZ2VuZXJhdGVkIGJ5IFhmbG93XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFZTQ29uZmlnID0gZnVuY3Rpb24oKXtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0ge307XG4gICAgdGhpcy5fYmxvY2tlZE5hbWVzID0gW107XG4gICAgdGhpcy5fYWRkSW5wdXQgPSB7fTtcbiAgICB0aGlzLl9hZGRPdXRwdXQgPSB7fTtcbiAgICB0aGlzLl9jb2RlRnJhZ21lbnRzID0gW107XG4gICAgdGhpcy5fb3V0cHV0Q2hhbm5lbGluZyA9IHt9O1xufTtcblxuVlNDb25maWcucHJvdG90eXBlLmFkZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUsIG9wdGlvbmFsKXtcbiAgICBpZih0aGlzLl9hdHRyaWJ1dGVzW25hbWVdKXtcbiAgICAgICAgaWYodGhpcy5fYXR0cmlidXRlc1tuYW1lXS50eXBlICE9IHR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmllcyB0byBhZGQgdHdvIGF0dHJpYnV0ZXMgd2l0aCBkaWZmZXJlbnQgdHlwZXMgb2YgbmFtZSAnXCIgKyBuYW1lICsgJ1wiJyk7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0ub3B0aW9uYWwgPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdLm9wdGlvbmFsICYmIG9wdGlvbmFsO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gPSB7dHlwZTogdHlwZSwgb3B0aW9uYWw6IG9wdGlvbmFsLCBjaGFubmVsaW5nOiBbXX07XG59O1xuXG5WU0NvbmZpZy5wcm90b3R5cGUuY2hhbm5lbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKGlucHV0TmFtZSwgb3V0cHV0TmFtZSwgY29kZSl7XG4gICAgdGhpcy5fYXR0cmlidXRlc1tpbnB1dE5hbWVdLmNoYW5uZWxpbmcucHVzaCggeyBvdXRwdXROYW1lIDogb3V0cHV0TmFtZSwgY29kZSA6IGNvZGUgfSk7XG59O1xuXG5WU0NvbmZpZy5wcm90b3R5cGUuYWRkSW5wdXRQYXJhbWV0ZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCB1bmlmb3JtKXtcbiAgICBpZih0aGlzLl9hZGRJbnB1dFtuYW1lXSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2FkZElucHV0W25hbWVdID0geyB0eXBlOiB0eXBlLCB1bmlmb3JtOiB1bmlmb3JtIH07XG4gICAgdGhpcy5fYmxvY2tlZE5hbWVzLnB1c2gobmFtZSk7XG59O1xuVlNDb25maWcucHJvdG90eXBlLmFkZE91dHB1dFBhcmFtZXRlciA9IGZ1bmN0aW9uKHR5cGUsIG5hbWUpe1xuICAgIGlmKHRoaXMuX2FkZE91dHB1dFtuYW1lXSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHRoaXMuX2FkZE91dHB1dFtuYW1lXSA9IHsgdHlwZTogdHlwZSB9O1xuICAgIHRoaXMuX2Jsb2NrZWROYW1lcy5wdXNoKG5hbWUpO1xufTtcblZTQ29uZmlnLnByb3RvdHlwZS5hZGRDb2RlRnJhZ21lbnQgPSBmdW5jdGlvbihjb2RlRnJhZ21lbnQpe1xuICAgIHRoaXMuX2NvZGVGcmFnbWVudHMucHVzaChjb2RlRnJhZ21lbnQpO1xufTtcblxuVlNDb25maWcucHJvdG90eXBlLmFkZEJsb2NrZWROYW1lID0gZnVuY3Rpb24obmFtZSl7XG4gICAgdGhpcy5fYmxvY2tlZE5hbWVzLnB1c2gobmFtZSk7XG59O1xuXG5WU0NvbmZpZy5wcm90b3R5cGUuZ2V0QmxvY2tlZE5hbWVzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fYmxvY2tlZE5hbWVzO1xufTtcblxuVlNDb25maWcucHJvdG90eXBlLmdldEZpbHRlciA9IGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2F0dHJpYnV0ZXMpO1xufTtcblZTQ29uZmlnLnByb3RvdHlwZS5nZXRLZXkgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrZXkgPSBcIlwiO1xuICAgIGZvcih2YXIgbmFtZSBpbiB0aGlzLl9hdHRyaWJ1dGVzKXtcbiAgICAgICAgdmFyIGF0dHIgPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICBrZXkgKz0gXCI7XCIgKyBhdHRyLnR5cGUgKyBcIixcIiArIG5hbWUgKyBcIixcIiArIGF0dHIub3B0aW9uYWw7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG59O1xuXG52YXIgY192c19vcGVyYXRvcl9jYWNoZSA9IHt9O1xuXG5WU0NvbmZpZy5wcm90b3R5cGUuZ2V0T3BlcmF0b3IgPSBmdW5jdGlvbigpe1xuICAgIHZhciBrZXkgPSB0aGlzLmdldEtleSgpO1xuICAgIGlmKGNfdnNfb3BlcmF0b3JfY2FjaGVba2V5XSlcbiAgICAgICAgcmV0dXJuIGNfdnNfb3BlcmF0b3JfY2FjaGVba2V5XTtcblxuICAgIHZhciBvdXRwdXRzID0gW10sIHBhcmFtcyA9IFtdLCBnbHNsQ29kZSA9IFwiXFx0Ly8gVlMgQ29ubmVjdG9yXFxuXCI7XG4gICAgbmFtZSA9IFwiVlNDb25uZWN0XCI7XG4gICAgZm9yKHZhciBuYW1lIGluIHRoaXMuX2F0dHJpYnV0ZXMpe1xuICAgICAgICB2YXIgYXR0ciA9IHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV07XG4gICAgICAgIHZhciB0eXBlID0gQy5nZXRUeXBlTmFtZShhdHRyLnR5cGUpO1xuICAgICAgICBvdXRwdXRzLnB1c2goIHsgdHlwZTogdHlwZSwgbmFtZTogbmFtZX0gKTtcbiAgICAgICAgcGFyYW1zLnB1c2goIHsgdHlwZTogdHlwZSwgc291cmNlOiBuYW1lLCBvcHRpb25hbDogYXR0ci5vcHRpb25hbH0gKTtcbiAgICAgICAgbmFtZSArPSBcIlRcIiArIHR5cGUgKyBcIk5cIiArIG5hbWUgKyBcIk9cIiArIGF0dHIub3B0aW9uYWwgKyBcIi5cIjtcbiAgICB9XG4gICAgdmFyIG9wZXJhdG9yID0gaW5pdEFub255bW91c09wZXJhdG9yKG5hbWUsXG4gICAge1xuICAgICAgICBvdXRwdXRzOiBvdXRwdXRzLFxuICAgICAgICBwYXJhbXM6ICBwYXJhbXMsXG4gICAgICAgIGV2YWx1YXRlX2dsc2w6IGdsc2xDb2RlXG4gICAgfSk7XG4gICAgY192c19vcGVyYXRvcl9jYWNoZVtrZXldID0gb3BlcmF0b3I7XG4gICAgcmV0dXJuIG9wZXJhdG9yO1xufTtcblxudmFyIFZlcnRleFNoYWRlciA9IGZ1bmN0aW9uKHByb2dyYW1EYXRhKXtcbiAgICB0aGlzLl9wcm9ncmFtRGF0YSA9IHByb2dyYW1EYXRhO1xuICAgIHRoaXMuX2dsc2xDb2RlID0gbnVsbDtcbiAgICB0aGlzLl9pbnB1dE5hbWVzID0gW107XG4gICAgdGhpcy5fb3V0cHV0TmFtZXMgPSBbXTtcbiAgICB0aGlzLl9pbnB1dEluZm8gPSB7fTtcbiAgICB0aGlzLl9vdXRwdXRJbmZvID0ge307XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVmVydGV4U2hhZGVyLnByb3RvdHlwZSwgXCJpbnB1dE5hbWVzXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dE5hbWVzIGlzIHJlYWRvbmx5XCIpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5faW5wdXROYW1lczsgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWZXJ0ZXhTaGFkZXIucHJvdG90eXBlLCBcIm91dHB1dE5hbWVzXCIsIHtcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpe1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXRwdXROYW1lcyBpcyByZWFkb25seVwiKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuX291dHB1dE5hbWVzOyB9XG59KTtcblxuVmVydGV4U2hhZGVyLnByb3RvdHlwZS5pc0lucHV0VW5pZm9ybSA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB0aGlzLl9pbnB1dEluZm9bbmFtZV0udW5pZm9ybTtcbn07XG5WZXJ0ZXhTaGFkZXIucHJvdG90eXBlLmdldElucHV0RGF0YSA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0YS5nZXREYXRhRW50cnkodGhpcy5faW5wdXRJbmZvW25hbWVdLmluZGV4KTtcbn07XG5cblZlcnRleFNoYWRlci5wcm90b3R5cGUuaXNPdXRwdXROdWxsID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID09IEMuSVRFUkFUSU9OX1RZUEUuTlVMTDtcbn07XG5WZXJ0ZXhTaGFkZXIucHJvdG90eXBlLmlzT3V0cHV0RnJhZ21lbnRVbmlmb3JtID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEluZm9bbmFtZV0uaXRlcmF0aW9uID09IEMuSVRFUkFUSU9OX1RZUEUuT05FO1xufTtcblZlcnRleFNoYWRlci5wcm90b3R5cGUuZ2V0VW5pZm9ybU91dHB1dERhdGEgPSBmdW5jdGlvbihuYW1lKXtcbiAgICByZXR1cm4gdGhpcy5fcHJvZ3JhbURhdGEuZ2V0RGF0YUVudHJ5KHRoaXMuX291dHB1dEluZm9bbmFtZV0uaW5kZXgpO1xufTtcblZlcnRleFNoYWRlci5wcm90b3R5cGUuZ2V0T3V0cHV0VHlwZSA9IGZ1bmN0aW9uKG5hbWUpe1xuICAgIHJldHVybiB0aGlzLl9vdXRwdXRJbmZvW25hbWVdLnR5cGU7XG59O1xuVmVydGV4U2hhZGVyLnByb3RvdHlwZS5nZXRPdXRwdXRTb3VyY2VOYW1lID0gZnVuY3Rpb24obmFtZSl7XG4gICAgcmV0dXJuIHRoaXMuX291dHB1dEluZm9bbmFtZV0uc291cmNlTmFtZTtcbn07XG5WZXJ0ZXhTaGFkZXIucHJvdG90eXBlLmdldEdMU0xDb2RlID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5fZ2xzbENvZGU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzaGFkZXJDb25zdGFudDogc2hhZGVyQ29uc3RhbnQsXG4gICAgc2V0U2hhZGVyQ29uc3RhbnQ6IHNldFNoYWRlckNvbnN0YW50LFxuICAgIFZTQ29uZmlnOiBWU0NvbmZpZyxcbiAgICBWZXJ0ZXhTaGFkZXI6IFZlcnRleFNoYWRlclxufTtcbiIsInZhciBzZXQgPSB7fTtcblxuXG5zZXQuYWRkID0gZnVuY3Rpb24oc2V0QXJyYXksIHNldFRvQWRkKXtcbiAgICBpZihBcnJheS5pc0FycmF5KHNldFRvQWRkKSl7XG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzZXRUb0FkZC5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBpZihzZXRBcnJheS5pbmRleE9mKHNldFRvQWRkW2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBzZXRBcnJheS5wdXNoKHNldFRvQWRkW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBpZihzZXRBcnJheS5pbmRleE9mKHNldFRvQWRkKSA9PSAtMSlcbiAgICAgICAgICAgIHNldEFycmF5LnB1c2goc2V0VG9BZGQpO1xuICAgIH1cbn1cbnNldC5yZW1vdmUgPSBmdW5jdGlvbihzZXRBcnJheSwgc2V0VG9SZW1vdmUpe1xuICAgIHZhciBpZHg7XG4gICAgaWYoQXJyYXkuaXNBcnJheShzZXRUb1JlbW92ZSkpe1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2V0VG9SZW1vdmUubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaWYoIChpZHggPSBzZXRBcnJheS5pbmRleE9mKHNldFRvUmVtb3ZlW2ldKSkgIT0gLTEpXG4gICAgICAgICAgICAgICAgc2V0QXJyYXkuc3BsaWNlKGlkeCwxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBpZiggKGlkeCA9IHNldEFycmF5LmluZGV4T2Yoc2V0VG9SZW1vdmUpKSAhPSAtMSlcbiAgICAgICAgICAgIHNldEFycmF5LnNwbGljZShpZHgsMSk7XG4gICAgfVxufVxuXG5zZXQuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oZGVzdCwgc2V0QSwgc2V0Qil7XG4gICAgdmFyIHNpemUgPSBzZXRBLmxlbmd0aDtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKXtcbiAgICAgICAgaWYoc2V0Qi5pbmRleE9mKHNldEFbaV0pICE9IC0xKVxuICAgICAgICAgICAgZGVzdC5wdXNoKHNldEFbaV0pO1xuICAgIH1cbn1cblxuc2V0LmlzSW50ZXJzZWN0aW5nID0gZnVuY3Rpb24oc2V0QSwgc2V0Qil7XG4gICAgdmFyIGkgPSBzZXRBLmxlbmd0aDtcbiAgICB3aGlsZShpLS0pe1xuICAgICAgICBpZihzZXRCLmluZGV4T2Yoc2V0QVtpXSkgIT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5zZXQuaXNTdWJzZXQgPSBmdW5jdGlvbihzbWFsbGVyU2V0LCBsYXJnZXJTZXQpe1xuICAgIHZhciBpID0gc21hbGxlclNldC5sZW5ndGg7XG4gICAgd2hpbGUoaS0tKXtcbiAgICAgICAgaWYobGFyZ2VyU2V0LmluZGV4T2Yoc21hbGxlclNldFtpXSkgPT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIE5hbWVzZXQgVXRpbGl0aWVzIGZvciBYZmxvd1xuICovXG52YXIgbmFtZXNldCA9IHt9O1xuXG5uYW1lc2V0LmFkZCA9IGZ1bmN0aW9uKG5hbWVTZXQsIHRvQWRkKXtcbiAgICBpZighdG9BZGQpIHJldHVybjtcbiAgICBpZih0eXBlb2YgdG9BZGQgPT0gXCJzdHJpbmdcIil7XG4gICAgICAgIGlmKG5hbWVTZXQuaW5kZXhPZih0b0FkZCkgPT0gLTEpXG4gICAgICAgICAgICBuYW1lU2V0LnB1c2godG9BZGQpO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG9BZGQubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgaWYobmFtZVNldC5pbmRleE9mKHRvQWRkW2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBuYW1lU2V0LnB1c2godG9BZGRbaV0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5uYW1lc2V0LnJlbW92ZSA9IGZ1bmN0aW9uKG5hbWVTZXQsIHRvUmVtb3ZlKXtcbiAgICBpZighdG9SZW1vdmUpIHJldHVybjtcbiAgICBpZih0eXBlb2YgdG9SZW1vdmUgPT0gXCJzdHJpbmdcIil7XG4gICAgICAgIHZhciByZW1vdmVJZHggPSBuYW1lU2V0LmluZGV4T2YodG9SZW1vdmUpO1xuICAgICAgICBpZihyZW1vdmVJZHggIT0gLTEpXG4gICAgICAgICAgICBuYW1lU2V0LnNwbGljZShyZW1vdmVJZHgsIDEpO1xuICAgIH1cbiAgICBlbHNle1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgdmFyIHJlbW92ZUlkeCA9IG5hbWVTZXQuaW5kZXhPZih0b1JlbW92ZVtpXSk7XG4gICAgICAgICAgICBpZihyZW1vdmVJZHggIT0gLTEpXG4gICAgICAgICAgICAgICAgbmFtZVNldC5zcGxpY2UocmVtb3ZlSWR4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubmFtZXNldC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihuYW1lU2V0QSwgbmFtZVNldEIpe1xuICAgIHZhciBpID0gbmFtZVNldEEubGVuZ3RoO1xuICAgIHdoaWxlKGktLSl7XG4gICAgICAgIGlmKG5hbWVTZXRCLmluZGV4T2YobmFtZVNldEFbaV0pID09IC0xKXtcbiAgICAgICAgICAgIG5hbWVTZXRBLnNwbGljZShpLDEpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5cbnZhciBiaW5hcnlTZWFyY2ggPSBmdW5jdGlvbihrZXlzLCBrZXksIG1heEluZGV4KXtcbiAgICB2YXIgbWluID0gMCwgbWF4ID0gbWF4SW5kZXggLSAxO1xuICAgIHdoaWxlKG1pbiA8PSBtYXgpe1xuICAgICAgICB2YXIgaSA9IE1hdGguZmxvb3IoKG1pbiArIG1heCkgLyAyKTtcbiAgICAgICAgaWYoa2V5c1tpXSA9PSBrZXkpe1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZihrZXlzW2ldIDwga2V5KVxuICAgICAgICAgICAgbWluID0gaSArIDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heCA9IGkgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gbWF4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzZXQ6IHNldCxcbiAgICBuYW1lc2V0OiBuYW1lc2V0LFxuICAgIGJpbmFyeVNlYXJjaDogYmluYXJ5U2VhcmNoXG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vaW5pdC5qc1wiKTsiXX0=
